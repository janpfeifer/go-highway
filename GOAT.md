# GoAT

Go assembly transpiler for C programming languages. It help to utilize optimization from C compiler in Go projects. For example, generate SIMD vectorized functions for Go (refer to [How to Use AVX512 in Golang](https://gorse.io/posts/avx512-in-golang.html)).

# Example

Suppose you have a C function that adds two arrays of floats in `src/add.c`:

```c
void add(float *a, float *b, float *result, long n) {
    for (long i = 0; i < n; i++) {
        result[i] = a[i] + b[i];
    }
}
```

You can use GoAT to transpile this C function to Go assembly code.

Finally, the add function can be used by:

```go
func Add(a, b, c []float32) {
	if len(a) ! = len(b) || len(a) ! = len(c) {
		panic("floats: slice lengths do not match")
	}
	add(unsafe.Pointer(&a[0]), unsafe.Pointer(&b[0]), unsafe.Pointer(&c[0]), int64(len(a)))
}
````

# Limitations

- No call statements except for inline functions.
- Arguments must be int64_t, long, float, double, _Bool or pointer.
- Potentially BUGGY code generation.
- C functions must have void return types
- `uint64_t` from the header <stdint.h> is not supported
- C source file names should not begin with `_`.
- **`else` clauses in conditionals are not supported** - The parser fails with "expected `}`" errors when encountering `else`. Rewrite code to avoid `else` by using multiple `if` statements or initializing values before conditionally updating them.
- **No `__builtin_*` functions** - Calls to `__builtin_expf`, `__builtin_sqrtf`, etc. generate `bl` (branch-link) instructions to C library functions (`expf`, `sqrtf`, etc.) which don't exist in Go assembly context. Use polynomial approximations or other manual implementations instead.
- **No `static inline` helper functions** - The parser fails on `static inline` function definitions. Inline all helper code directly where needed.
- **No `union` type punning** - Union types for float/int bit reinterpretation cause parsing errors. Use alternative approaches like loop-based 2^k computation.
- **No array initializers with variables** - `int arr[4] = {m0, m1, m2, m3}` causes parsing errors. Use explicit stores instead.
- **Scalar loops may be optimized to `memset`** - Simple loops like `for (i = 0; i < n; i++) result[i] = 0;` may be optimized by the compiler into `memset` calls, which don't exist in Go assembly. Break the pattern by using NEON stores for the scalar remainder or add complexity to prevent the optimization.
- **Double constants in scalar loops cause parser panic** - When using `double` constants that can't be represented with `fmov` immediate (like `0.6931471805599453`), clang stores them in `.rodata` and loads them with `adrp` + `ldr d_reg, [x_reg, :lo12:.LCPI...]`. GOAT's ARM64 parser panics with "index out of range [-1]" when parsing the `:lo12:` addressing mode. **Workarounds:**
  - Use SIMD-only code without scalar remainder loops for F64 (process only multiples of 2 elements)
  - Use `vreinterpretq_f64_s64(vdupq_n_s64(0x3FE62E42FEFA39EFLL))` to construct double constants from integer bit patterns in SIMD code
  - Float constants work fine because clang uses `mov w_reg, #imm` + `fmov s_reg, w_reg` which GOAT can parse

# ARM SME/SVE Support

GoAT can generate ARM SVE (Scalable Vector Extension) code when using `-march=armv9-a+sme`. However, there are important considerations:

## Streaming Mode Requirement

SVE instructions require ARM SME streaming mode to be enabled. You must manually add `smstart sm` and `smstop sm` instructions to the generated assembly:

```assembly
TEXT ·my_function(SB), $0-48
    // Load parameters
    MOVD a+0(FP), R0
    MOVD b+8(FP), R1

    WORD $0xd503477f  // smstart sm - enter SME streaming mode

    // ... generated code with SVE instructions ...

    WORD $0xd503467f  // smstop sm - exit SME streaming mode
    RET
```

**Important:** Add `smstop sm` before ALL function exit points, including early returns and tail calls.

## macOS Compatibility Issues

On macOS (Apple Silicon M4+), certain NEON instructions are not allowed in streaming mode:

- **`movi d0, #0` causes SIGILL** in streaming mode
- **Solution:** Use `fmov s0, wzr` instead (encoding: `0x1e2703e0`)

When editing GoAT-generated assembly, replace:
```assembly
WORD $0x2f00e400  // movi d0, #0 - FAILS in streaming mode on macOS
```

With:
```assembly
WORD $0x1e2703e0  // fmov s0, wzr - works in streaming mode
```

## Tips for SME Code

1. **Keep C code simple** - Complex loops with nested conditions generate harder-to-maintain assembly
2. **Let compiler auto-vectorize** - Don't use SVE intrinsics (`#include <arm_sve.h>`) unless necessary; simple loops often vectorize well
3. **Test on macOS first** - macOS has stricter restrictions on streaming mode instructions
4. **Mark modified assembly** - Add a comment header when manually editing generated files:
   ```assembly
   // Code generated by GoAT. DO NOT EDIT.
   // Modified by [your name] to add SME streaming mode entry/exit instructions.
   ```

See `c/matmul_sme_arm64.c` and `asm/matmul_sme_arm64.s` for a complete example.

## Why GoAT-Generated SME Code is Slower Than Hand-Written

**Problem**: GoAT-generated SME code is significantly slower than:
- Hand-written SME assembly (7-18x slower)
- Even pure Go and NEON implementations

**Root Causes**:

1. **SVE Instructions Outside Streaming Mode**
   - GoAT generates SVE instructions (like `cnth`, `ptrue`) for runtime vector length detection
   - These instructions appear *before* streaming mode entry
   - On macOS, ALL SVE instructions require streaming mode → SIGILL
   - Cannot fix by moving `smstart` earlier without breaking scalar fallback paths

2. **Compiler-Generated Instructions Not Compatible**
   - Compiler generates `fadda` (floating-point add strictly-ordered) for horizontal reduction
   - `fadda` causes SIGILL in streaming mode on macOS
   - Replacing with `fadd` + `faddv` requires extensive manual surgery
   - Even `-O2` vs `-O3` doesn't avoid these incompatible instructions

3. **Multiple Streaming Mode Entries**
   - GoAT approach calls SME function per-row via Go wrapper
   - For 1024x1024 matrix: 1,024 `smstart`/`smstop` pairs
   - Friend's hand-written code: 1 `smstart`/`smstop` pair total
   - Streaming mode transitions are expensive

4. **Poor Vectorization**
   - GoAT generates scalar NEON code (`fmadd`) instead of SVE vectors
   - Complex control flow prevents effective auto-vectorization
   - Friend's code uses true SVE: `ld1w`, `fmla z.s`, `faddv`

**Attempted Solutions**:

1. **Simplify C code with `restrict` keyword** - Still generates incompatible SVE setup instructions
2. **Manual assembly surgery** - Too complex, breaks easily, not maintainable
3. **Different optimization levels** (-O2, -O3) - Same fundamental issues

**Conclusion**: For high-performance SME code on macOS:
- Write assembly by hand (like `vdot_sme_friend.s`)
- Carefully manage streaming mode entry/exit
- Use only macOS-compatible SVE instructions
- GoAT is excellent for NEON, but not suitable for macOS SME

**Performance Comparison** (4096x4096 matrix-vector multiplication):
- Pure Go: 3.8ms
- NEON (GoAT): 2.9ms (1.3x faster than Go)
- SME (GoAT): 23ms (8x slower than NEON!)
- SME (Hand-written): 2.5ms (1.14x faster than NEON, **1.5x faster than Go**)
