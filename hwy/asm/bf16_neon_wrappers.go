//go:build !noasm && arm64

// BFloat16 NEON operations for ARM64 with BF16 extension (ARMv8.6-A+)
package asm

import "unsafe"

// -march=armv8.6-a+bf16 enables BFDOT and BFMMLA instructions
//go:generate go tool goat ../c/ops_bf16_neon_arm64.c -O3 --target arm64 -e="-march=armv8.6-a+bf16"

// ============================================================================
// BFloat16 Conversions
// ============================================================================

// PromoteBF16ToF32NEON converts bfloat16 to float32 using NEON bit shifts.
// BF16 is simply F32 with the lower 16 bits truncated, so conversion is
// just shifting the 16-bit value left by 16 to form the upper bits of F32.
func PromoteBF16ToF32NEON(a []uint16, result []float32) {
	if len(a) == 0 {
		return
	}
	n := int64(min(len(a), len(result)))
	promote_bf16_to_f32_neon(unsafe.Pointer(&a[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
}

// DemoteF32ToBF16NEON converts float32 to bfloat16 using round-to-nearest-even.
// This properly rounds the F32 value before truncating to 16 bits.
func DemoteF32ToBF16NEON(a []float32, result []uint16) {
	if len(a) == 0 {
		return
	}
	n := int64(min(len(a), len(result)))
	demote_f32_to_bf16_neon(unsafe.Pointer(&a[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
}

// ============================================================================
// BFloat16 Dot Product (ARMv8.6-A BFDOT instruction)
// ============================================================================

// DotBF16NEON computes the dot product of two BF16 vectors, accumulating to F32.
// Uses the BFDOT instruction for optimal performance on ARMv8.6-A+.
// The result is added to the existing value in acc: acc += sum(a[i] * b[i])
func DotBF16NEON(a, b []uint16, acc *float32, n int) {
	if n == 0 || len(a) == 0 || len(b) == 0 {
		return
	}
	count := int64(min(n, min(len(a), len(b))))
	dot_bf16_neon(unsafe.Pointer(&a[0]), unsafe.Pointer(&b[0]), unsafe.Pointer(acc), unsafe.Pointer(&count))
}

// ============================================================================
// BFloat16 Matrix Multiply (ARMv8.6-A BFMMLA instruction)
// ============================================================================

// MatMulBF16NEON performs tiled matrix multiplication: C += A * B
// A is MxK (row-major), B is KxN (row-major), C is MxN (row-major)
// Uses BFMMLA instruction for 2x2 tiled accumulation when possible.
//
// Parameters:
//   - a: M x K matrix of BF16 values (row-major, leading dimension lda)
//   - b: K x N matrix of BF16 values (row-major, leading dimension ldb)
//   - c: M x N matrix of F32 values (row-major, leading dimension ldc)
//   - m, n, k: matrix dimensions
//   - lda, ldb, ldc: leading dimensions (number of elements between row starts)
func MatMulBF16NEON(a, b []uint16, c []float32, m, n, k, lda, ldb, ldc int) {
	if m == 0 || n == 0 || k == 0 {
		return
	}
	if len(a) == 0 || len(b) == 0 || len(c) == 0 {
		return
	}
	mVal := int64(m)
	nVal := int64(n)
	kVal := int64(k)
	ldaVal := int64(lda)
	ldbVal := int64(ldb)
	ldcVal := int64(ldc)
	matmul_bf16_neon(
		unsafe.Pointer(&a[0]), unsafe.Pointer(&b[0]), unsafe.Pointer(&c[0]),
		unsafe.Pointer(&mVal), unsafe.Pointer(&nVal), unsafe.Pointer(&kVal),
		unsafe.Pointer(&ldaVal), unsafe.Pointer(&ldbVal), unsafe.Pointer(&ldcVal),
	)
}

// Assembly function declarations are in ops_bf16_neon_arm64.go (generated by GoAT)
