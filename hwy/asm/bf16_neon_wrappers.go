// Copyright 2025 go-highway Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//go:build !noasm && arm64

// BFloat16 NEON operations for ARM64 with BF16 extension (ARMv8.6-A+)
package asm

import "unsafe"

// -march=armv8.6-a+bf16 enables BFDOT and BFMMLA instructions
//go:generate go tool goat ../c/ops_bf16_neon_arm64.c -O3 --target arm64 -e="-march=armv8.6-a+bf16"

// ============================================================================
// BFloat16 Conversions
// ============================================================================

// PromoteBF16ToF32NEON converts bfloat16 to float32 using NEON bit shifts.
// BF16 is simply F32 with the lower 16 bits truncated, so conversion is
// just shifting the 16-bit value left by 16 to form the upper bits of F32.
func PromoteBF16ToF32NEON(a []uint16, result []float32) {
	if len(a) == 0 {
		return
	}
	n := int64(min(len(a), len(result)))
	promote_bf16_to_f32_neon(unsafe.Pointer(&a[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
}

// DemoteF32ToBF16NEON converts float32 to bfloat16 using round-to-nearest-even.
// This properly rounds the F32 value before truncating to 16 bits.
func DemoteF32ToBF16NEON(a []float32, result []uint16) {
	if len(a) == 0 {
		return
	}
	n := int64(min(len(a), len(result)))
	demote_f32_to_bf16_neon(unsafe.Pointer(&a[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
}

// ============================================================================
// BFloat16 Dot Product (ARMv8.6-A BFDOT instruction)
// ============================================================================

// DotBF16NEON computes the dot product of two BF16 vectors, accumulating to F32.
// Uses the BFDOT instruction for optimal performance on ARMv8.6-A+.
// The result is added to the existing value in acc: acc += sum(a[i] * b[i])
func DotBF16NEON(a, b []uint16, acc *float32, n int) {
	if n == 0 || len(a) == 0 || len(b) == 0 {
		return
	}
	count := int64(min(n, min(len(a), len(b))))
	dot_bf16_neon(unsafe.Pointer(&a[0]), unsafe.Pointer(&b[0]), unsafe.Pointer(acc), unsafe.Pointer(&count))
}

// ============================================================================
// BFloat16 Matrix Multiply (ARMv8.6-A BFMMLA instruction)
// ============================================================================

// MatMulBF16NEON performs tiled matrix multiplication: C += A * B
// A is MxK (row-major), B is KxN (row-major), C is MxN (row-major)
// Uses BFMMLA instruction for 2x2 tiled accumulation when possible.
//
// Parameters:
//   - a: M x K matrix of BF16 values (row-major, leading dimension lda)
//   - b: K x N matrix of BF16 values (row-major, leading dimension ldb)
//   - c: M x N matrix of F32 values (row-major, leading dimension ldc)
//   - m, n, k: matrix dimensions
//   - lda, ldb, ldc: leading dimensions (number of elements between row starts)
func MatMulBF16NEON(a, b []uint16, c []float32, m, n, k, lda, ldb, ldc int) {
	if m == 0 || n == 0 || k == 0 {
		return
	}
	if len(a) == 0 || len(b) == 0 || len(c) == 0 {
		return
	}
	mVal := int64(m)
	nVal := int64(n)
	kVal := int64(k)
	ldaVal := int64(lda)
	ldbVal := int64(ldb)
	ldcVal := int64(ldc)
	matmul_bf16_neon(
		unsafe.Pointer(&a[0]), unsafe.Pointer(&b[0]), unsafe.Pointer(&c[0]),
		unsafe.Pointer(&mVal), unsafe.Pointer(&nVal), unsafe.Pointer(&kVal),
		unsafe.Pointer(&ldaVal), unsafe.Pointer(&ldbVal), unsafe.Pointer(&ldcVal),
	)
}

// ============================================================================
// BFloat16 Vector Load/Store Operations
// ============================================================================

// Load4BF16x8NEON loads 4 consecutive bfloat16x8 vectors (32 bfloat16 values = 64 bytes).
// Uses vld1q_bf16_x4 which loads 64 bytes in a single instruction.
// Returns 4 vectors as [16]byte (each holding 8 bfloat16 values).
func Load4BF16x8NEON(ptr []uint16) (v0, v1, v2, v3 [16]byte) {
	if len(ptr) < 32 {
		return
	}
	load4_bf16x8(unsafe.Pointer(&ptr[0]),
		unsafe.Pointer(&v0[0]), unsafe.Pointer(&v1[0]),
		unsafe.Pointer(&v2[0]), unsafe.Pointer(&v3[0]))
	return
}

// Store4BF16x8NEON stores 4 consecutive bfloat16x8 vectors (32 bfloat16 values = 64 bytes).
// Uses vst1q_bf16_x4 which stores 64 bytes in a single instruction.
func Store4BF16x8NEON(ptr []uint16, v0, v1, v2, v3 [16]byte) {
	if len(ptr) < 32 {
		return
	}
	store4_bf16x8(unsafe.Pointer(&ptr[0]), v0, v1, v2, v3)
}

// Assembly function declarations are in ops_bf16_neon_arm64.go (generated by GoAT)
