// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

package image

import (
	"github.com/ajroetker/go-highway/hwy"
)

func BaseForwardRCT_fallback_Int32(r *Image[int32], g *Image[int32], b *Image[int32], outY *Image[int32], outCb *Image[int32], outCr *Image[int32]) {
	if r == nil || g == nil || b == nil || outY == nil || outCb == nil || outCr == nil {
		return
	}
	if r.data == nil || g.data == nil || b.data == nil || outY.data == nil || outCb.data == nil || outCr.data == nil {
		return
	}
	twoVec := hwy.Set(int32(2))
	lanes := hwy.MaxLanes[int32]()
	height := r.height
	width := r.width
	for y := range height {
		rRow := r.Row(y)
		gRow := g.Row(y)
		bRow := b.Row(y)
		yRow := outY.Row(y)
		cbRow := outCb.Row(y)
		crRow := outCr.Row(y)
		i := 0
		for ; i+lanes <= width; i += lanes {
			vr := hwy.Load(rRow[i:])
			vg := hwy.Load(gRow[i:])
			vb := hwy.Load(bRow[i:])
			twoG := hwy.Mul(vg, twoVec)
			sum := hwy.Add(hwy.Add(vr, twoG), vb)
			vy := hwy.ShiftRight(sum, 2)
			vcb := hwy.Sub(vb, vg)
			vcr := hwy.Sub(vr, vg)
			hwy.Store(vy, yRow[i:])
			hwy.Store(vcb, cbRow[i:])
			hwy.Store(vcr, crRow[i:])
		}
		if remaining := width - i; remaining > 0 {
			bufR := make([]int32, lanes)
			bufG := make([]int32, lanes)
			bufB := make([]int32, lanes)
			bufY := make([]int32, lanes)
			bufCb := make([]int32, lanes)
			bufCr := make([]int32, lanes)
			copy(bufR, rRow[i:i+remaining])
			copy(bufG, gRow[i:i+remaining])
			copy(bufB, bRow[i:i+remaining])
			vr := hwy.Load(bufR)
			vg := hwy.Load(bufG)
			vb := hwy.Load(bufB)
			twoG := hwy.Mul(vg, twoVec)
			sum := hwy.Add(hwy.Add(vr, twoG), vb)
			vy := hwy.ShiftRight(sum, 2)
			vcb := hwy.Sub(vb, vg)
			vcr := hwy.Sub(vr, vg)
			hwy.Store(vy, bufY)
			hwy.Store(vcb, bufCb)
			hwy.Store(vcr, bufCr)
			copy(yRow[i:i+remaining], bufY[:remaining])
			copy(cbRow[i:i+remaining], bufCb[:remaining])
			copy(crRow[i:i+remaining], bufCr[:remaining])
		}
	}
}

func BaseForwardRCT_fallback_Int64(r *Image[int64], g *Image[int64], b *Image[int64], outY *Image[int64], outCb *Image[int64], outCr *Image[int64]) {
	if r == nil || g == nil || b == nil || outY == nil || outCb == nil || outCr == nil {
		return
	}
	if r.data == nil || g.data == nil || b.data == nil || outY.data == nil || outCb.data == nil || outCr.data == nil {
		return
	}
	twoVec := hwy.Set(int64(2))
	lanes := hwy.MaxLanes[int64]()
	height := r.height
	width := r.width
	for y := range height {
		rRow := r.Row(y)
		gRow := g.Row(y)
		bRow := b.Row(y)
		yRow := outY.Row(y)
		cbRow := outCb.Row(y)
		crRow := outCr.Row(y)
		i := 0
		for ; i+lanes <= width; i += lanes {
			vr := hwy.Load(rRow[i:])
			vg := hwy.Load(gRow[i:])
			vb := hwy.Load(bRow[i:])
			twoG := hwy.Mul(vg, twoVec)
			sum := hwy.Add(hwy.Add(vr, twoG), vb)
			vy := hwy.ShiftRight(sum, 2)
			vcb := hwy.Sub(vb, vg)
			vcr := hwy.Sub(vr, vg)
			hwy.Store(vy, yRow[i:])
			hwy.Store(vcb, cbRow[i:])
			hwy.Store(vcr, crRow[i:])
		}
		if remaining := width - i; remaining > 0 {
			bufR := make([]int64, lanes)
			bufG := make([]int64, lanes)
			bufB := make([]int64, lanes)
			bufY := make([]int64, lanes)
			bufCb := make([]int64, lanes)
			bufCr := make([]int64, lanes)
			copy(bufR, rRow[i:i+remaining])
			copy(bufG, gRow[i:i+remaining])
			copy(bufB, bRow[i:i+remaining])
			vr := hwy.Load(bufR)
			vg := hwy.Load(bufG)
			vb := hwy.Load(bufB)
			twoG := hwy.Mul(vg, twoVec)
			sum := hwy.Add(hwy.Add(vr, twoG), vb)
			vy := hwy.ShiftRight(sum, 2)
			vcb := hwy.Sub(vb, vg)
			vcr := hwy.Sub(vr, vg)
			hwy.Store(vy, bufY)
			hwy.Store(vcb, bufCb)
			hwy.Store(vcr, bufCr)
			copy(yRow[i:i+remaining], bufY[:remaining])
			copy(cbRow[i:i+remaining], bufCb[:remaining])
			copy(crRow[i:i+remaining], bufCr[:remaining])
		}
	}
}

func BaseInverseRCT_fallback_Int32(y *Image[int32], cb *Image[int32], cr *Image[int32], outR *Image[int32], outG *Image[int32], outB *Image[int32]) {
	if y == nil || cb == nil || cr == nil || outR == nil || outG == nil || outB == nil {
		return
	}
	if y.data == nil || cb.data == nil || cr.data == nil || outR.data == nil || outG.data == nil || outB.data == nil {
		return
	}
	lanes := hwy.MaxLanes[int32]()
	height := y.height
	width := y.width
	for row := range height {
		yRow := y.Row(row)
		cbRow := cb.Row(row)
		crRow := cr.Row(row)
		rRow := outR.Row(row)
		gRow := outG.Row(row)
		bRow := outB.Row(row)
		i := 0
		for ; i+lanes <= width; i += lanes {
			vy := hwy.Load(yRow[i:])
			vcb := hwy.Load(cbRow[i:])
			vcr := hwy.Load(crRow[i:])
			cbPlusCr := hwy.Add(vcb, vcr)
			shift := hwy.ShiftRight(cbPlusCr, 2)
			vg := hwy.Sub(vy, shift)
			vr := hwy.Add(vcr, vg)
			vb := hwy.Add(vcb, vg)
			hwy.Store(vr, rRow[i:])
			hwy.Store(vg, gRow[i:])
			hwy.Store(vb, bRow[i:])
		}
		if remaining := width - i; remaining > 0 {
			bufY := make([]int32, lanes)
			bufCb := make([]int32, lanes)
			bufCr := make([]int32, lanes)
			bufR := make([]int32, lanes)
			bufG := make([]int32, lanes)
			bufB := make([]int32, lanes)
			copy(bufY, yRow[i:i+remaining])
			copy(bufCb, cbRow[i:i+remaining])
			copy(bufCr, crRow[i:i+remaining])
			vy := hwy.Load(bufY)
			vcb := hwy.Load(bufCb)
			vcr := hwy.Load(bufCr)
			cbPlusCr := hwy.Add(vcb, vcr)
			shift := hwy.ShiftRight(cbPlusCr, 2)
			vg := hwy.Sub(vy, shift)
			vr := hwy.Add(vcr, vg)
			vb := hwy.Add(vcb, vg)
			hwy.Store(vr, bufR)
			hwy.Store(vg, bufG)
			hwy.Store(vb, bufB)
			copy(rRow[i:i+remaining], bufR[:remaining])
			copy(gRow[i:i+remaining], bufG[:remaining])
			copy(bRow[i:i+remaining], bufB[:remaining])
		}
	}
}

func BaseInverseRCT_fallback_Int64(y *Image[int64], cb *Image[int64], cr *Image[int64], outR *Image[int64], outG *Image[int64], outB *Image[int64]) {
	if y == nil || cb == nil || cr == nil || outR == nil || outG == nil || outB == nil {
		return
	}
	if y.data == nil || cb.data == nil || cr.data == nil || outR.data == nil || outG.data == nil || outB.data == nil {
		return
	}
	lanes := hwy.MaxLanes[int64]()
	height := y.height
	width := y.width
	for row := range height {
		yRow := y.Row(row)
		cbRow := cb.Row(row)
		crRow := cr.Row(row)
		rRow := outR.Row(row)
		gRow := outG.Row(row)
		bRow := outB.Row(row)
		i := 0
		for ; i+lanes <= width; i += lanes {
			vy := hwy.Load(yRow[i:])
			vcb := hwy.Load(cbRow[i:])
			vcr := hwy.Load(crRow[i:])
			cbPlusCr := hwy.Add(vcb, vcr)
			shift := hwy.ShiftRight(cbPlusCr, 2)
			vg := hwy.Sub(vy, shift)
			vr := hwy.Add(vcr, vg)
			vb := hwy.Add(vcb, vg)
			hwy.Store(vr, rRow[i:])
			hwy.Store(vg, gRow[i:])
			hwy.Store(vb, bRow[i:])
		}
		if remaining := width - i; remaining > 0 {
			bufY := make([]int64, lanes)
			bufCb := make([]int64, lanes)
			bufCr := make([]int64, lanes)
			bufR := make([]int64, lanes)
			bufG := make([]int64, lanes)
			bufB := make([]int64, lanes)
			copy(bufY, yRow[i:i+remaining])
			copy(bufCb, cbRow[i:i+remaining])
			copy(bufCr, crRow[i:i+remaining])
			vy := hwy.Load(bufY)
			vcb := hwy.Load(bufCb)
			vcr := hwy.Load(bufCr)
			cbPlusCr := hwy.Add(vcb, vcr)
			shift := hwy.ShiftRight(cbPlusCr, 2)
			vg := hwy.Sub(vy, shift)
			vr := hwy.Add(vcr, vg)
			vb := hwy.Add(vcb, vg)
			hwy.Store(vr, bufR)
			hwy.Store(vg, bufG)
			hwy.Store(vb, bufB)
			copy(rRow[i:i+remaining], bufR[:remaining])
			copy(gRow[i:i+remaining], bufG[:remaining])
			copy(bRow[i:i+remaining], bufB[:remaining])
		}
	}
}

func BaseForwardICT_fallback_Float16(r *Image[hwy.Float16], g *Image[hwy.Float16], b *Image[hwy.Float16], outY *Image[hwy.Float16], outCb *Image[hwy.Float16], outCr *Image[hwy.Float16]) {
	if r == nil || g == nil || b == nil || outY == nil || outCb == nil || outCr == nil {
		return
	}
	if r.data == nil || g.data == nil || b.data == nil || outY.data == nil || outCb.data == nil || outCr.data == nil {
		return
	}
	rToY, gToY, bToY, rToCb, gToCb, bToCb, rToCr, gToCr, bToCr, _, _, _, _ := ictCoeffs[hwy.Float16]()
	rToYVec := hwy.Set(rToY)
	gToYVec := hwy.Set(gToY)
	bToYVec := hwy.Set(bToY)
	rToCbVec := hwy.Set(rToCb)
	gToCbVec := hwy.Set(gToCb)
	bToCbVec := hwy.Set(bToCb)
	rToCrVec := hwy.Set(rToCr)
	gToCrVec := hwy.Set(gToCr)
	bToCrVec := hwy.Set(bToCr)
	lanes := hwy.MaxLanes[hwy.Float16]()
	height := r.height
	width := r.width
	for row := range height {
		rRow := r.Row(row)
		gRow := g.Row(row)
		bRow := b.Row(row)
		yRow := outY.Row(row)
		cbRow := outCb.Row(row)
		crRow := outCr.Row(row)
		i := 0
		for ; i+lanes <= width; i += lanes {
			vr := hwy.Load(rRow[i:])
			vg := hwy.Load(gRow[i:])
			vb := hwy.Load(bRow[i:])
			vy := hwy.FMA(vr, rToYVec, hwy.FMA(vg, gToYVec, hwy.Mul(vb, bToYVec)))
			vcb := hwy.FMA(vr, rToCbVec, hwy.FMA(vg, gToCbVec, hwy.Mul(vb, bToCbVec)))
			vcr := hwy.FMA(vr, rToCrVec, hwy.FMA(vg, gToCrVec, hwy.Mul(vb, bToCrVec)))
			hwy.Store(vy, yRow[i:])
			hwy.Store(vcb, cbRow[i:])
			hwy.Store(vcr, crRow[i:])
		}
		if remaining := width - i; remaining > 0 {
			bufR := make([]hwy.Float16, lanes)
			bufG := make([]hwy.Float16, lanes)
			bufB := make([]hwy.Float16, lanes)
			bufY := make([]hwy.Float16, lanes)
			bufCb := make([]hwy.Float16, lanes)
			bufCr := make([]hwy.Float16, lanes)
			copy(bufR, rRow[i:i+remaining])
			copy(bufG, gRow[i:i+remaining])
			copy(bufB, bRow[i:i+remaining])
			vr := hwy.Load(bufR)
			vg := hwy.Load(bufG)
			vb := hwy.Load(bufB)
			vy := hwy.FMA(vr, rToYVec, hwy.FMA(vg, gToYVec, hwy.Mul(vb, bToYVec)))
			vcb := hwy.FMA(vr, rToCbVec, hwy.FMA(vg, gToCbVec, hwy.Mul(vb, bToCbVec)))
			vcr := hwy.FMA(vr, rToCrVec, hwy.FMA(vg, gToCrVec, hwy.Mul(vb, bToCrVec)))
			hwy.Store(vy, bufY)
			hwy.Store(vcb, bufCb)
			hwy.Store(vcr, bufCr)
			copy(yRow[i:i+remaining], bufY[:remaining])
			copy(cbRow[i:i+remaining], bufCb[:remaining])
			copy(crRow[i:i+remaining], bufCr[:remaining])
		}
	}
}

func BaseForwardICT_fallback_BFloat16(r *Image[hwy.BFloat16], g *Image[hwy.BFloat16], b *Image[hwy.BFloat16], outY *Image[hwy.BFloat16], outCb *Image[hwy.BFloat16], outCr *Image[hwy.BFloat16]) {
	if r == nil || g == nil || b == nil || outY == nil || outCb == nil || outCr == nil {
		return
	}
	if r.data == nil || g.data == nil || b.data == nil || outY.data == nil || outCb.data == nil || outCr.data == nil {
		return
	}
	rToY, gToY, bToY, rToCb, gToCb, bToCb, rToCr, gToCr, bToCr, _, _, _, _ := ictCoeffs[hwy.BFloat16]()
	rToYVec := hwy.Set(rToY)
	gToYVec := hwy.Set(gToY)
	bToYVec := hwy.Set(bToY)
	rToCbVec := hwy.Set(rToCb)
	gToCbVec := hwy.Set(gToCb)
	bToCbVec := hwy.Set(bToCb)
	rToCrVec := hwy.Set(rToCr)
	gToCrVec := hwy.Set(gToCr)
	bToCrVec := hwy.Set(bToCr)
	lanes := hwy.MaxLanes[hwy.BFloat16]()
	height := r.height
	width := r.width
	for row := range height {
		rRow := r.Row(row)
		gRow := g.Row(row)
		bRow := b.Row(row)
		yRow := outY.Row(row)
		cbRow := outCb.Row(row)
		crRow := outCr.Row(row)
		i := 0
		for ; i+lanes <= width; i += lanes {
			vr := hwy.Load(rRow[i:])
			vg := hwy.Load(gRow[i:])
			vb := hwy.Load(bRow[i:])
			vy := hwy.FMA(vr, rToYVec, hwy.FMA(vg, gToYVec, hwy.Mul(vb, bToYVec)))
			vcb := hwy.FMA(vr, rToCbVec, hwy.FMA(vg, gToCbVec, hwy.Mul(vb, bToCbVec)))
			vcr := hwy.FMA(vr, rToCrVec, hwy.FMA(vg, gToCrVec, hwy.Mul(vb, bToCrVec)))
			hwy.Store(vy, yRow[i:])
			hwy.Store(vcb, cbRow[i:])
			hwy.Store(vcr, crRow[i:])
		}
		if remaining := width - i; remaining > 0 {
			bufR := make([]hwy.BFloat16, lanes)
			bufG := make([]hwy.BFloat16, lanes)
			bufB := make([]hwy.BFloat16, lanes)
			bufY := make([]hwy.BFloat16, lanes)
			bufCb := make([]hwy.BFloat16, lanes)
			bufCr := make([]hwy.BFloat16, lanes)
			copy(bufR, rRow[i:i+remaining])
			copy(bufG, gRow[i:i+remaining])
			copy(bufB, bRow[i:i+remaining])
			vr := hwy.Load(bufR)
			vg := hwy.Load(bufG)
			vb := hwy.Load(bufB)
			vy := hwy.FMA(vr, rToYVec, hwy.FMA(vg, gToYVec, hwy.Mul(vb, bToYVec)))
			vcb := hwy.FMA(vr, rToCbVec, hwy.FMA(vg, gToCbVec, hwy.Mul(vb, bToCbVec)))
			vcr := hwy.FMA(vr, rToCrVec, hwy.FMA(vg, gToCrVec, hwy.Mul(vb, bToCrVec)))
			hwy.Store(vy, bufY)
			hwy.Store(vcb, bufCb)
			hwy.Store(vcr, bufCr)
			copy(yRow[i:i+remaining], bufY[:remaining])
			copy(cbRow[i:i+remaining], bufCb[:remaining])
			copy(crRow[i:i+remaining], bufCr[:remaining])
		}
	}
}

func BaseForwardICT_fallback(r *Image[float32], g *Image[float32], b *Image[float32], outY *Image[float32], outCb *Image[float32], outCr *Image[float32]) {
	if r == nil || g == nil || b == nil || outY == nil || outCb == nil || outCr == nil {
		return
	}
	if r.data == nil || g.data == nil || b.data == nil || outY.data == nil || outCb.data == nil || outCr.data == nil {
		return
	}
	rToY, gToY, bToY, rToCb, gToCb, bToCb, rToCr, gToCr, bToCr, _, _, _, _ := ictCoeffs[float32]()
	rToYVec := float32(rToY)
	gToYVec := float32(gToY)
	bToYVec := float32(bToY)
	rToCbVec := float32(rToCb)
	gToCbVec := float32(gToCb)
	bToCbVec := float32(bToCb)
	rToCrVec := float32(rToCr)
	gToCrVec := float32(gToCr)
	bToCrVec := float32(bToCr)
	height := r.height
	width := r.width
	for row := range height {
		rRow := r.Row(row)
		gRow := g.Row(row)
		bRow := b.Row(row)
		yRow := outY.Row(row)
		cbRow := outCb.Row(row)
		crRow := outCr.Row(row)
		i := 0
		for ; i < width; i++ {
			vr := rRow[i]
			vg := gRow[i]
			vb := bRow[i]
			vy := vr*rToYVec + (vg*gToYVec + vb*bToYVec)
			vcb := vr*rToCbVec + (vg*gToCbVec + vb*bToCbVec)
			vcr := vr*rToCrVec + (vg*gToCrVec + vb*bToCrVec)
			yRow[i] = vy
			cbRow[i] = vcb
			crRow[i] = vcr
		}
		if remaining := width - i; remaining > 0 {
			bufR := make([]float32, 1)
			bufG := make([]float32, 1)
			bufB := make([]float32, 1)
			bufY := make([]float32, 1)
			bufCb := make([]float32, 1)
			bufCr := make([]float32, 1)
			copy(bufR, rRow[i:i+remaining])
			copy(bufG, gRow[i:i+remaining])
			copy(bufB, bRow[i:i+remaining])
			vr := bufR[0]
			vg := bufG[0]
			vb := bufB[0]
			vy := vr*rToYVec + (vg*gToYVec + vb*bToYVec)
			vcb := vr*rToCbVec + (vg*gToCbVec + vb*bToCbVec)
			vcr := vr*rToCrVec + (vg*gToCrVec + vb*bToCrVec)
			bufY[0] = vy
			bufCb[0] = vcb
			bufCr[0] = vcr
			copy(yRow[i:i+remaining], bufY[:remaining])
			copy(cbRow[i:i+remaining], bufCb[:remaining])
			copy(crRow[i:i+remaining], bufCr[:remaining])
		}
	}
}

func BaseForwardICT_fallback_Float64(r *Image[float64], g *Image[float64], b *Image[float64], outY *Image[float64], outCb *Image[float64], outCr *Image[float64]) {
	if r == nil || g == nil || b == nil || outY == nil || outCb == nil || outCr == nil {
		return
	}
	if r.data == nil || g.data == nil || b.data == nil || outY.data == nil || outCb.data == nil || outCr.data == nil {
		return
	}
	rToY, gToY, bToY, rToCb, gToCb, bToCb, rToCr, gToCr, bToCr, _, _, _, _ := ictCoeffs[float64]()
	rToYVec := float64(rToY)
	gToYVec := float64(gToY)
	bToYVec := float64(bToY)
	rToCbVec := float64(rToCb)
	gToCbVec := float64(gToCb)
	bToCbVec := float64(bToCb)
	rToCrVec := float64(rToCr)
	gToCrVec := float64(gToCr)
	bToCrVec := float64(bToCr)
	height := r.height
	width := r.width
	for row := range height {
		rRow := r.Row(row)
		gRow := g.Row(row)
		bRow := b.Row(row)
		yRow := outY.Row(row)
		cbRow := outCb.Row(row)
		crRow := outCr.Row(row)
		i := 0
		for ; i < width; i++ {
			vr := rRow[i]
			vg := gRow[i]
			vb := bRow[i]
			vy := vr*rToYVec + (vg*gToYVec + vb*bToYVec)
			vcb := vr*rToCbVec + (vg*gToCbVec + vb*bToCbVec)
			vcr := vr*rToCrVec + (vg*gToCrVec + vb*bToCrVec)
			yRow[i] = vy
			cbRow[i] = vcb
			crRow[i] = vcr
		}
		if remaining := width - i; remaining > 0 {
			bufR := make([]float64, 1)
			bufG := make([]float64, 1)
			bufB := make([]float64, 1)
			bufY := make([]float64, 1)
			bufCb := make([]float64, 1)
			bufCr := make([]float64, 1)
			copy(bufR, rRow[i:i+remaining])
			copy(bufG, gRow[i:i+remaining])
			copy(bufB, bRow[i:i+remaining])
			vr := bufR[0]
			vg := bufG[0]
			vb := bufB[0]
			vy := vr*rToYVec + (vg*gToYVec + vb*bToYVec)
			vcb := vr*rToCbVec + (vg*gToCbVec + vb*bToCbVec)
			vcr := vr*rToCrVec + (vg*gToCrVec + vb*bToCrVec)
			bufY[0] = vy
			bufCb[0] = vcb
			bufCr[0] = vcr
			copy(yRow[i:i+remaining], bufY[:remaining])
			copy(cbRow[i:i+remaining], bufCb[:remaining])
			copy(crRow[i:i+remaining], bufCr[:remaining])
		}
	}
}

func BaseInverseICT_fallback_Float16(y *Image[hwy.Float16], cb *Image[hwy.Float16], cr *Image[hwy.Float16], outR *Image[hwy.Float16], outG *Image[hwy.Float16], outB *Image[hwy.Float16]) {
	if y == nil || cb == nil || cr == nil || outR == nil || outG == nil || outB == nil {
		return
	}
	if y.data == nil || cb.data == nil || cr.data == nil || outR.data == nil || outG.data == nil || outB.data == nil {
		return
	}
	_, _, _, _, _, _, _, _, _, crToR, cbToG, crToG, cbToB := ictCoeffs[hwy.Float16]()
	crToRVec := hwy.Set(crToR)
	cbToGVec := hwy.Set(cbToG)
	crToGVec := hwy.Set(crToG)
	cbToBVec := hwy.Set(cbToB)
	lanes := hwy.MaxLanes[hwy.Float16]()
	height := y.height
	width := y.width
	for row := range height {
		yRow := y.Row(row)
		cbRow := cb.Row(row)
		crRow := cr.Row(row)
		rRow := outR.Row(row)
		gRow := outG.Row(row)
		bRow := outB.Row(row)
		i := 0
		for ; i+lanes <= width; i += lanes {
			vy := hwy.Load(yRow[i:])
			vcb := hwy.Load(cbRow[i:])
			vcr := hwy.Load(crRow[i:])
			vr := hwy.FMA(vcr, crToRVec, vy)
			vg := hwy.FMA(vcb, cbToGVec, hwy.FMA(vcr, crToGVec, vy))
			vb := hwy.FMA(vcb, cbToBVec, vy)
			hwy.Store(vr, rRow[i:])
			hwy.Store(vg, gRow[i:])
			hwy.Store(vb, bRow[i:])
		}
		if remaining := width - i; remaining > 0 {
			bufY := make([]hwy.Float16, lanes)
			bufCb := make([]hwy.Float16, lanes)
			bufCr := make([]hwy.Float16, lanes)
			bufR := make([]hwy.Float16, lanes)
			bufG := make([]hwy.Float16, lanes)
			bufB := make([]hwy.Float16, lanes)
			copy(bufY, yRow[i:i+remaining])
			copy(bufCb, cbRow[i:i+remaining])
			copy(bufCr, crRow[i:i+remaining])
			vy := hwy.Load(bufY)
			vcb := hwy.Load(bufCb)
			vcr := hwy.Load(bufCr)
			vr := hwy.FMA(vcr, crToRVec, vy)
			vg := hwy.FMA(vcb, cbToGVec, hwy.FMA(vcr, crToGVec, vy))
			vb := hwy.FMA(vcb, cbToBVec, vy)
			hwy.Store(vr, bufR)
			hwy.Store(vg, bufG)
			hwy.Store(vb, bufB)
			copy(rRow[i:i+remaining], bufR[:remaining])
			copy(gRow[i:i+remaining], bufG[:remaining])
			copy(bRow[i:i+remaining], bufB[:remaining])
		}
	}
}

func BaseInverseICT_fallback_BFloat16(y *Image[hwy.BFloat16], cb *Image[hwy.BFloat16], cr *Image[hwy.BFloat16], outR *Image[hwy.BFloat16], outG *Image[hwy.BFloat16], outB *Image[hwy.BFloat16]) {
	if y == nil || cb == nil || cr == nil || outR == nil || outG == nil || outB == nil {
		return
	}
	if y.data == nil || cb.data == nil || cr.data == nil || outR.data == nil || outG.data == nil || outB.data == nil {
		return
	}
	_, _, _, _, _, _, _, _, _, crToR, cbToG, crToG, cbToB := ictCoeffs[hwy.BFloat16]()
	crToRVec := hwy.Set(crToR)
	cbToGVec := hwy.Set(cbToG)
	crToGVec := hwy.Set(crToG)
	cbToBVec := hwy.Set(cbToB)
	lanes := hwy.MaxLanes[hwy.BFloat16]()
	height := y.height
	width := y.width
	for row := range height {
		yRow := y.Row(row)
		cbRow := cb.Row(row)
		crRow := cr.Row(row)
		rRow := outR.Row(row)
		gRow := outG.Row(row)
		bRow := outB.Row(row)
		i := 0
		for ; i+lanes <= width; i += lanes {
			vy := hwy.Load(yRow[i:])
			vcb := hwy.Load(cbRow[i:])
			vcr := hwy.Load(crRow[i:])
			vr := hwy.FMA(vcr, crToRVec, vy)
			vg := hwy.FMA(vcb, cbToGVec, hwy.FMA(vcr, crToGVec, vy))
			vb := hwy.FMA(vcb, cbToBVec, vy)
			hwy.Store(vr, rRow[i:])
			hwy.Store(vg, gRow[i:])
			hwy.Store(vb, bRow[i:])
		}
		if remaining := width - i; remaining > 0 {
			bufY := make([]hwy.BFloat16, lanes)
			bufCb := make([]hwy.BFloat16, lanes)
			bufCr := make([]hwy.BFloat16, lanes)
			bufR := make([]hwy.BFloat16, lanes)
			bufG := make([]hwy.BFloat16, lanes)
			bufB := make([]hwy.BFloat16, lanes)
			copy(bufY, yRow[i:i+remaining])
			copy(bufCb, cbRow[i:i+remaining])
			copy(bufCr, crRow[i:i+remaining])
			vy := hwy.Load(bufY)
			vcb := hwy.Load(bufCb)
			vcr := hwy.Load(bufCr)
			vr := hwy.FMA(vcr, crToRVec, vy)
			vg := hwy.FMA(vcb, cbToGVec, hwy.FMA(vcr, crToGVec, vy))
			vb := hwy.FMA(vcb, cbToBVec, vy)
			hwy.Store(vr, bufR)
			hwy.Store(vg, bufG)
			hwy.Store(vb, bufB)
			copy(rRow[i:i+remaining], bufR[:remaining])
			copy(gRow[i:i+remaining], bufG[:remaining])
			copy(bRow[i:i+remaining], bufB[:remaining])
		}
	}
}

func BaseInverseICT_fallback(y *Image[float32], cb *Image[float32], cr *Image[float32], outR *Image[float32], outG *Image[float32], outB *Image[float32]) {
	if y == nil || cb == nil || cr == nil || outR == nil || outG == nil || outB == nil {
		return
	}
	if y.data == nil || cb.data == nil || cr.data == nil || outR.data == nil || outG.data == nil || outB.data == nil {
		return
	}
	_, _, _, _, _, _, _, _, _, crToR, cbToG, crToG, cbToB := ictCoeffs[float32]()
	crToRVec := float32(crToR)
	cbToGVec := float32(cbToG)
	crToGVec := float32(crToG)
	cbToBVec := float32(cbToB)
	height := y.height
	width := y.width
	for row := range height {
		yRow := y.Row(row)
		cbRow := cb.Row(row)
		crRow := cr.Row(row)
		rRow := outR.Row(row)
		gRow := outG.Row(row)
		bRow := outB.Row(row)
		i := 0
		for ; i < width; i++ {
			vy := yRow[i]
			vcb := cbRow[i]
			vcr := crRow[i]
			vr := vcr*crToRVec + vy
			vg := vcb*cbToGVec + (vcr*crToGVec + vy)
			vb := vcb*cbToBVec + vy
			rRow[i] = vr
			gRow[i] = vg
			bRow[i] = vb
		}
		if remaining := width - i; remaining > 0 {
			bufY := make([]float32, 1)
			bufCb := make([]float32, 1)
			bufCr := make([]float32, 1)
			bufR := make([]float32, 1)
			bufG := make([]float32, 1)
			bufB := make([]float32, 1)
			copy(bufY, yRow[i:i+remaining])
			copy(bufCb, cbRow[i:i+remaining])
			copy(bufCr, crRow[i:i+remaining])
			vy := bufY[0]
			vcb := bufCb[0]
			vcr := bufCr[0]
			vr := vcr*crToRVec + vy
			vg := vcb*cbToGVec + (vcr*crToGVec + vy)
			vb := vcb*cbToBVec + vy
			bufR[0] = vr
			bufG[0] = vg
			bufB[0] = vb
			copy(rRow[i:i+remaining], bufR[:remaining])
			copy(gRow[i:i+remaining], bufG[:remaining])
			copy(bRow[i:i+remaining], bufB[:remaining])
		}
	}
}

func BaseInverseICT_fallback_Float64(y *Image[float64], cb *Image[float64], cr *Image[float64], outR *Image[float64], outG *Image[float64], outB *Image[float64]) {
	if y == nil || cb == nil || cr == nil || outR == nil || outG == nil || outB == nil {
		return
	}
	if y.data == nil || cb.data == nil || cr.data == nil || outR.data == nil || outG.data == nil || outB.data == nil {
		return
	}
	_, _, _, _, _, _, _, _, _, crToR, cbToG, crToG, cbToB := ictCoeffs[float64]()
	crToRVec := float64(crToR)
	cbToGVec := float64(cbToG)
	crToGVec := float64(crToG)
	cbToBVec := float64(cbToB)
	height := y.height
	width := y.width
	for row := range height {
		yRow := y.Row(row)
		cbRow := cb.Row(row)
		crRow := cr.Row(row)
		rRow := outR.Row(row)
		gRow := outG.Row(row)
		bRow := outB.Row(row)
		i := 0
		for ; i < width; i++ {
			vy := yRow[i]
			vcb := cbRow[i]
			vcr := crRow[i]
			vr := vcr*crToRVec + vy
			vg := vcb*cbToGVec + (vcr*crToGVec + vy)
			vb := vcb*cbToBVec + vy
			rRow[i] = vr
			gRow[i] = vg
			bRow[i] = vb
		}
		if remaining := width - i; remaining > 0 {
			bufY := make([]float64, 1)
			bufCb := make([]float64, 1)
			bufCr := make([]float64, 1)
			bufR := make([]float64, 1)
			bufG := make([]float64, 1)
			bufB := make([]float64, 1)
			copy(bufY, yRow[i:i+remaining])
			copy(bufCb, cbRow[i:i+remaining])
			copy(bufCr, crRow[i:i+remaining])
			vy := bufY[0]
			vcb := bufCb[0]
			vcr := bufCr[0]
			vr := vcr*crToRVec + vy
			vg := vcb*cbToGVec + (vcr*crToGVec + vy)
			vb := vcb*cbToBVec + vy
			bufR[0] = vr
			bufG[0] = vg
			bufB[0] = vb
			copy(rRow[i:i+remaining], bufR[:remaining])
			copy(gRow[i:i+remaining], bufG[:remaining])
			copy(bRow[i:i+remaining], bufB[:remaining])
		}
	}
}
