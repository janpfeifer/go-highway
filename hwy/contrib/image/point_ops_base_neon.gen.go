// Code generated by hwygen. DO NOT EDIT.
//go:build arm64

package image

import (
	"github.com/ajroetker/go-highway/hwy/asm"
)

func BaseBrightnessContrast_neon(img *Image[float32], out *Image[float32], scale float32, offset float32) {
	if img == nil || out == nil || img.data == nil || out.data == nil {
		return
	}
	scaleVec := asm.BroadcastFloat32x4(scale)
	offsetVec := asm.BroadcastFloat32x4(offset)
	lanes := 4
	for y := 0; y < img.height; y++ {
		inRow := img.Row(y)
		outRow := out.Row(y)
		width := img.width
		i := 0
		for ; i+lanes <= width; i += lanes {
			v := asm.LoadFloat32x4Slice(inRow[i:])
			result := v.MulAdd(scaleVec, offsetVec)
			result.StoreSlice(outRow[i:])
		}
		if remaining := width - i; remaining > 0 {
			buf := [4]float32{}
			copy(buf[:], inRow[i:i+remaining])
			v := asm.LoadFloat32x4Slice(buf[:])
			result := v.MulAdd(scaleVec, offsetVec)
			result.StoreSlice(buf[:])
			copy(outRow[i:i+remaining], buf[:remaining])
		}
	}
}

func BaseBrightnessContrast_neon_Float64(img *Image[float64], out *Image[float64], scale float64, offset float64) {
	if img == nil || out == nil || img.data == nil || out.data == nil {
		return
	}
	scaleVec := asm.BroadcastFloat64x2(scale)
	offsetVec := asm.BroadcastFloat64x2(offset)
	lanes := 2
	for y := 0; y < img.height; y++ {
		inRow := img.Row(y)
		outRow := out.Row(y)
		width := img.width
		i := 0
		for ; i+lanes <= width; i += lanes {
			v := asm.LoadFloat64x2Slice(inRow[i:])
			result := v.MulAdd(scaleVec, offsetVec)
			result.StoreSlice(outRow[i:])
		}
		if remaining := width - i; remaining > 0 {
			buf := [2]float64{}
			copy(buf[:], inRow[i:i+remaining])
			v := asm.LoadFloat64x2Slice(buf[:])
			result := v.MulAdd(scaleVec, offsetVec)
			result.StoreSlice(buf[:])
			copy(outRow[i:i+remaining], buf[:remaining])
		}
	}
}

func BaseClampImage_neon(img *Image[float32], out *Image[float32], minVal float32, maxVal float32) {
	if img == nil || out == nil || img.data == nil || out.data == nil {
		return
	}
	minVec := asm.BroadcastFloat32x4(minVal)
	maxVec := asm.BroadcastFloat32x4(maxVal)
	lanes := 4
	for y := 0; y < img.height; y++ {
		inRow := img.Row(y)
		outRow := out.Row(y)
		width := img.width
		i := 0
		for ; i+lanes <= width; i += lanes {
			v := asm.LoadFloat32x4Slice(inRow[i:])
			result := v.Min(maxVec).Max(minVec)
			result.StoreSlice(outRow[i:])
		}
		if remaining := width - i; remaining > 0 {
			buf := [4]float32{}
			copy(buf[:], inRow[i:i+remaining])
			v := asm.LoadFloat32x4Slice(buf[:])
			result := v.Min(maxVec).Max(minVec)
			result.StoreSlice(buf[:])
			copy(outRow[i:i+remaining], buf[:remaining])
		}
	}
}

func BaseClampImage_neon_Float64(img *Image[float64], out *Image[float64], minVal float64, maxVal float64) {
	if img == nil || out == nil || img.data == nil || out.data == nil {
		return
	}
	minVec := asm.BroadcastFloat64x2(minVal)
	maxVec := asm.BroadcastFloat64x2(maxVal)
	lanes := 2
	for y := 0; y < img.height; y++ {
		inRow := img.Row(y)
		outRow := out.Row(y)
		width := img.width
		i := 0
		for ; i+lanes <= width; i += lanes {
			v := asm.LoadFloat64x2Slice(inRow[i:])
			result := v.Min(maxVec).Max(minVec)
			result.StoreSlice(outRow[i:])
		}
		if remaining := width - i; remaining > 0 {
			buf := [2]float64{}
			copy(buf[:], inRow[i:i+remaining])
			v := asm.LoadFloat64x2Slice(buf[:])
			result := v.Min(maxVec).Max(minVec)
			result.StoreSlice(buf[:])
			copy(outRow[i:i+remaining], buf[:remaining])
		}
	}
}

func BaseThreshold_neon(img *Image[float32], out *Image[float32], threshold float32, below float32, above float32) {
	if img == nil || out == nil || img.data == nil || out.data == nil {
		return
	}
	threshVec := asm.BroadcastFloat32x4(threshold)
	belowVec := asm.BroadcastFloat32x4(below)
	aboveVec := asm.BroadcastFloat32x4(above)
	lanes := 4
	for y := 0; y < img.height; y++ {
		inRow := img.Row(y)
		outRow := out.Row(y)
		width := img.width
		i := 0
		for ; i+lanes <= width; i += lanes {
			v := asm.LoadFloat32x4Slice(inRow[i:])
			mask := v.GreaterEqual(threshVec)
			result := asm.IfThenElse(mask, aboveVec, belowVec)
			result.StoreSlice(outRow[i:])
		}
		if remaining := width - i; remaining > 0 {
			buf := [4]float32{}
			copy(buf[:], inRow[i:i+remaining])
			v := asm.LoadFloat32x4Slice(buf[:])
			mask := v.GreaterEqual(threshVec)
			result := asm.IfThenElse(mask, aboveVec, belowVec)
			result.StoreSlice(buf[:])
			copy(outRow[i:i+remaining], buf[:remaining])
		}
	}
}

func BaseThreshold_neon_Float64(img *Image[float64], out *Image[float64], threshold float64, below float64, above float64) {
	if img == nil || out == nil || img.data == nil || out.data == nil {
		return
	}
	threshVec := asm.BroadcastFloat64x2(threshold)
	belowVec := asm.BroadcastFloat64x2(below)
	aboveVec := asm.BroadcastFloat64x2(above)
	lanes := 2
	for y := 0; y < img.height; y++ {
		inRow := img.Row(y)
		outRow := out.Row(y)
		width := img.width
		i := 0
		for ; i+lanes <= width; i += lanes {
			v := asm.LoadFloat64x2Slice(inRow[i:])
			mask := v.GreaterEqual(threshVec)
			result := asm.IfThenElseFloat64(mask, aboveVec, belowVec)
			result.StoreSlice(outRow[i:])
		}
		if remaining := width - i; remaining > 0 {
			buf := [2]float64{}
			copy(buf[:], inRow[i:i+remaining])
			v := asm.LoadFloat64x2Slice(buf[:])
			mask := v.GreaterEqual(threshVec)
			result := asm.IfThenElseFloat64(mask, aboveVec, belowVec)
			result.StoreSlice(buf[:])
			copy(outRow[i:i+remaining], buf[:remaining])
		}
	}
}

func BaseInvert_neon(img *Image[float32], out *Image[float32], maxVal float32) {
	if img == nil || out == nil || img.data == nil || out.data == nil {
		return
	}
	maxVec := asm.BroadcastFloat32x4(maxVal)
	lanes := 4
	for y := 0; y < img.height; y++ {
		inRow := img.Row(y)
		outRow := out.Row(y)
		width := img.width
		i := 0
		for ; i+lanes <= width; i += lanes {
			v := asm.LoadFloat32x4Slice(inRow[i:])
			result := maxVec.Sub(v)
			result.StoreSlice(outRow[i:])
		}
		if remaining := width - i; remaining > 0 {
			buf := [4]float32{}
			copy(buf[:], inRow[i:i+remaining])
			v := asm.LoadFloat32x4Slice(buf[:])
			result := maxVec.Sub(v)
			result.StoreSlice(buf[:])
			copy(outRow[i:i+remaining], buf[:remaining])
		}
	}
}

func BaseInvert_neon_Float64(img *Image[float64], out *Image[float64], maxVal float64) {
	if img == nil || out == nil || img.data == nil || out.data == nil {
		return
	}
	maxVec := asm.BroadcastFloat64x2(maxVal)
	lanes := 2
	for y := 0; y < img.height; y++ {
		inRow := img.Row(y)
		outRow := out.Row(y)
		width := img.width
		i := 0
		for ; i+lanes <= width; i += lanes {
			v := asm.LoadFloat64x2Slice(inRow[i:])
			result := maxVec.Sub(v)
			result.StoreSlice(outRow[i:])
		}
		if remaining := width - i; remaining > 0 {
			buf := [2]float64{}
			copy(buf[:], inRow[i:i+remaining])
			v := asm.LoadFloat64x2Slice(buf[:])
			result := maxVec.Sub(v)
			result.StoreSlice(buf[:])
			copy(outRow[i:i+remaining], buf[:remaining])
		}
	}
}

func BaseAbs_neon(img *Image[float32], out *Image[float32]) {
	if img == nil || out == nil || img.data == nil || out.data == nil {
		return
	}
	lanes := 4
	for y := 0; y < img.height; y++ {
		inRow := img.Row(y)
		outRow := out.Row(y)
		width := img.width
		i := 0
		for ; i+lanes <= width; i += lanes {
			v := asm.LoadFloat32x4Slice(inRow[i:])
			result := v.Abs()
			result.StoreSlice(outRow[i:])
		}
		if remaining := width - i; remaining > 0 {
			buf := [4]float32{}
			copy(buf[:], inRow[i:i+remaining])
			v := asm.LoadFloat32x4Slice(buf[:])
			result := v.Abs()
			result.StoreSlice(buf[:])
			copy(outRow[i:i+remaining], buf[:remaining])
		}
	}
}

func BaseAbs_neon_Float64(img *Image[float64], out *Image[float64]) {
	if img == nil || out == nil || img.data == nil || out.data == nil {
		return
	}
	lanes := 2
	for y := 0; y < img.height; y++ {
		inRow := img.Row(y)
		outRow := out.Row(y)
		width := img.width
		i := 0
		for ; i+lanes <= width; i += lanes {
			v := asm.LoadFloat64x2Slice(inRow[i:])
			result := v.Abs()
			result.StoreSlice(outRow[i:])
		}
		if remaining := width - i; remaining > 0 {
			buf := [2]float64{}
			copy(buf[:], inRow[i:i+remaining])
			v := asm.LoadFloat64x2Slice(buf[:])
			result := v.Abs()
			result.StoreSlice(buf[:])
			copy(outRow[i:i+remaining], buf[:remaining])
		}
	}
}

func BaseScale_neon(img *Image[float32], out *Image[float32], scale float32) {
	if img == nil || out == nil || img.data == nil || out.data == nil {
		return
	}
	scaleVec := asm.BroadcastFloat32x4(scale)
	lanes := 4
	for y := 0; y < img.height; y++ {
		inRow := img.Row(y)
		outRow := out.Row(y)
		width := img.width
		i := 0
		for ; i+lanes <= width; i += lanes {
			v := asm.LoadFloat32x4Slice(inRow[i:])
			result := v.Mul(scaleVec)
			result.StoreSlice(outRow[i:])
		}
		if remaining := width - i; remaining > 0 {
			buf := [4]float32{}
			copy(buf[:], inRow[i:i+remaining])
			v := asm.LoadFloat32x4Slice(buf[:])
			result := v.Mul(scaleVec)
			result.StoreSlice(buf[:])
			copy(outRow[i:i+remaining], buf[:remaining])
		}
	}
}

func BaseScale_neon_Float64(img *Image[float64], out *Image[float64], scale float64) {
	if img == nil || out == nil || img.data == nil || out.data == nil {
		return
	}
	scaleVec := asm.BroadcastFloat64x2(scale)
	lanes := 2
	for y := 0; y < img.height; y++ {
		inRow := img.Row(y)
		outRow := out.Row(y)
		width := img.width
		i := 0
		for ; i+lanes <= width; i += lanes {
			v := asm.LoadFloat64x2Slice(inRow[i:])
			result := v.Mul(scaleVec)
			result.StoreSlice(outRow[i:])
		}
		if remaining := width - i; remaining > 0 {
			buf := [2]float64{}
			copy(buf[:], inRow[i:i+remaining])
			v := asm.LoadFloat64x2Slice(buf[:])
			result := v.Mul(scaleVec)
			result.StoreSlice(buf[:])
			copy(outRow[i:i+remaining], buf[:remaining])
		}
	}
}

func BaseOffset_neon(img *Image[float32], out *Image[float32], offset float32) {
	if img == nil || out == nil || img.data == nil || out.data == nil {
		return
	}
	offsetVec := asm.BroadcastFloat32x4(offset)
	lanes := 4
	for y := 0; y < img.height; y++ {
		inRow := img.Row(y)
		outRow := out.Row(y)
		width := img.width
		i := 0
		for ; i+lanes <= width; i += lanes {
			v := asm.LoadFloat32x4Slice(inRow[i:])
			result := v.Add(offsetVec)
			result.StoreSlice(outRow[i:])
		}
		if remaining := width - i; remaining > 0 {
			buf := [4]float32{}
			copy(buf[:], inRow[i:i+remaining])
			v := asm.LoadFloat32x4Slice(buf[:])
			result := v.Add(offsetVec)
			result.StoreSlice(buf[:])
			copy(outRow[i:i+remaining], buf[:remaining])
		}
	}
}

func BaseOffset_neon_Float64(img *Image[float64], out *Image[float64], offset float64) {
	if img == nil || out == nil || img.data == nil || out.data == nil {
		return
	}
	offsetVec := asm.BroadcastFloat64x2(offset)
	lanes := 2
	for y := 0; y < img.height; y++ {
		inRow := img.Row(y)
		outRow := out.Row(y)
		width := img.width
		i := 0
		for ; i+lanes <= width; i += lanes {
			v := asm.LoadFloat64x2Slice(inRow[i:])
			result := v.Add(offsetVec)
			result.StoreSlice(outRow[i:])
		}
		if remaining := width - i; remaining > 0 {
			buf := [2]float64{}
			copy(buf[:], inRow[i:i+remaining])
			v := asm.LoadFloat64x2Slice(buf[:])
			result := v.Add(offsetVec)
			result.StoreSlice(buf[:])
			copy(outRow[i:i+remaining], buf[:remaining])
		}
	}
}

func BaseGamma_neon(img *Image[float32], out *Image[float32], gamma float32) {
	if img == nil || out == nil || img.data == nil || out.data == nil {
		return
	}
	gammaVec := asm.BroadcastFloat32x4(gamma)
	lanes := 4
	for y := 0; y < img.height; y++ {
		inRow := img.Row(y)
		outRow := out.Row(y)
		width := img.width
		i := 0
		for ; i+lanes <= width; i += lanes {
			v := asm.LoadFloat32x4Slice(inRow[i:])
			result := v.Pow(gammaVec)
			result.StoreSlice(outRow[i:])
		}
		if remaining := width - i; remaining > 0 {
			buf := [4]float32{}
			copy(buf[:], inRow[i:i+remaining])
			v := asm.LoadFloat32x4Slice(buf[:])
			result := v.Pow(gammaVec)
			result.StoreSlice(buf[:])
			copy(outRow[i:i+remaining], buf[:remaining])
		}
	}
}

func BaseGamma_neon_Float64(img *Image[float64], out *Image[float64], gamma float64) {
	if img == nil || out == nil || img.data == nil || out.data == nil {
		return
	}
	gammaVec := asm.BroadcastFloat64x2(gamma)
	lanes := 2
	for y := 0; y < img.height; y++ {
		inRow := img.Row(y)
		outRow := out.Row(y)
		width := img.width
		i := 0
		for ; i+lanes <= width; i += lanes {
			v := asm.LoadFloat64x2Slice(inRow[i:])
			result := v.Pow(gammaVec)
			result.StoreSlice(outRow[i:])
		}
		if remaining := width - i; remaining > 0 {
			buf := [2]float64{}
			copy(buf[:], inRow[i:i+remaining])
			v := asm.LoadFloat64x2Slice(buf[:])
			result := v.Pow(gammaVec)
			result.StoreSlice(buf[:])
			copy(outRow[i:i+remaining], buf[:remaining])
		}
	}
}

func BaseMinImage_neon(a *Image[float32], b *Image[float32], out *Image[float32]) {
	if a == nil || b == nil || out == nil || a.data == nil || b.data == nil || out.data == nil {
		return
	}
	lanes := 4
	height := min(a.height, b.height)
	for y := 0; y < height; y++ {
		aRow := a.Row(y)
		bRow := b.Row(y)
		outRow := out.Row(y)
		width := min(a.width, b.width)
		i := 0
		for ; i+lanes <= width; i += lanes {
			va := asm.LoadFloat32x4Slice(aRow[i:])
			vb := asm.LoadFloat32x4Slice(bRow[i:])
			result := va.Min(vb)
			result.StoreSlice(outRow[i:])
		}
		if remaining := width - i; remaining > 0 {
			bufA := [4]float32{}
			bufB := [4]float32{}
			bufOut := [4]float32{}
			copy(bufA[:], aRow[i:i+remaining])
			copy(bufB[:], bRow[i:i+remaining])
			va := asm.LoadFloat32x4Slice(bufA[:])
			vb := asm.LoadFloat32x4Slice(bufB[:])
			result := va.Min(vb)
			result.StoreSlice(bufOut[:])
			copy(outRow[i:i+remaining], bufOut[:remaining])
		}
	}
}

func BaseMinImage_neon_Float64(a *Image[float64], b *Image[float64], out *Image[float64]) {
	if a == nil || b == nil || out == nil || a.data == nil || b.data == nil || out.data == nil {
		return
	}
	lanes := 2
	height := min(a.height, b.height)
	for y := 0; y < height; y++ {
		aRow := a.Row(y)
		bRow := b.Row(y)
		outRow := out.Row(y)
		width := min(a.width, b.width)
		i := 0
		for ; i+lanes <= width; i += lanes {
			va := asm.LoadFloat64x2Slice(aRow[i:])
			vb := asm.LoadFloat64x2Slice(bRow[i:])
			result := va.Min(vb)
			result.StoreSlice(outRow[i:])
		}
		if remaining := width - i; remaining > 0 {
			bufA := [2]float64{}
			bufB := [2]float64{}
			bufOut := [2]float64{}
			copy(bufA[:], aRow[i:i+remaining])
			copy(bufB[:], bRow[i:i+remaining])
			va := asm.LoadFloat64x2Slice(bufA[:])
			vb := asm.LoadFloat64x2Slice(bufB[:])
			result := va.Min(vb)
			result.StoreSlice(bufOut[:])
			copy(outRow[i:i+remaining], bufOut[:remaining])
		}
	}
}

func BaseMaxImage_neon(a *Image[float32], b *Image[float32], out *Image[float32]) {
	if a == nil || b == nil || out == nil || a.data == nil || b.data == nil || out.data == nil {
		return
	}
	lanes := 4
	height := min(a.height, b.height)
	for y := 0; y < height; y++ {
		aRow := a.Row(y)
		bRow := b.Row(y)
		outRow := out.Row(y)
		width := min(a.width, b.width)
		i := 0
		for ; i+lanes <= width; i += lanes {
			va := asm.LoadFloat32x4Slice(aRow[i:])
			vb := asm.LoadFloat32x4Slice(bRow[i:])
			result := va.Max(vb)
			result.StoreSlice(outRow[i:])
		}
		if remaining := width - i; remaining > 0 {
			bufA := [4]float32{}
			bufB := [4]float32{}
			bufOut := [4]float32{}
			copy(bufA[:], aRow[i:i+remaining])
			copy(bufB[:], bRow[i:i+remaining])
			va := asm.LoadFloat32x4Slice(bufA[:])
			vb := asm.LoadFloat32x4Slice(bufB[:])
			result := va.Max(vb)
			result.StoreSlice(bufOut[:])
			copy(outRow[i:i+remaining], bufOut[:remaining])
		}
	}
}

func BaseMaxImage_neon_Float64(a *Image[float64], b *Image[float64], out *Image[float64]) {
	if a == nil || b == nil || out == nil || a.data == nil || b.data == nil || out.data == nil {
		return
	}
	lanes := 2
	height := min(a.height, b.height)
	for y := 0; y < height; y++ {
		aRow := a.Row(y)
		bRow := b.Row(y)
		outRow := out.Row(y)
		width := min(a.width, b.width)
		i := 0
		for ; i+lanes <= width; i += lanes {
			va := asm.LoadFloat64x2Slice(aRow[i:])
			vb := asm.LoadFloat64x2Slice(bRow[i:])
			result := va.Max(vb)
			result.StoreSlice(outRow[i:])
		}
		if remaining := width - i; remaining > 0 {
			bufA := [2]float64{}
			bufB := [2]float64{}
			bufOut := [2]float64{}
			copy(bufA[:], aRow[i:i+remaining])
			copy(bufB[:], bRow[i:i+remaining])
			va := asm.LoadFloat64x2Slice(bufA[:])
			vb := asm.LoadFloat64x2Slice(bufB[:])
			result := va.Max(vb)
			result.StoreSlice(bufOut[:])
			copy(outRow[i:i+remaining], bufOut[:remaining])
		}
	}
}
