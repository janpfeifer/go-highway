// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

//go:build arm64

package image

import (
	"github.com/ajroetker/go-highway/hwy"
)

var BrightnessContrastFloat16 func(img *Image[hwy.Float16], out *Image[hwy.Float16], scale hwy.Float16, offset hwy.Float16)
var BrightnessContrastBFloat16 func(img *Image[hwy.BFloat16], out *Image[hwy.BFloat16], scale hwy.BFloat16, offset hwy.BFloat16)
var BrightnessContrastFloat32 func(img *Image[float32], out *Image[float32], scale float32, offset float32)
var BrightnessContrastFloat64 func(img *Image[float64], out *Image[float64], scale float64, offset float64)
var ClampImageFloat16 func(img *Image[hwy.Float16], out *Image[hwy.Float16], minVal hwy.Float16, maxVal hwy.Float16)
var ClampImageBFloat16 func(img *Image[hwy.BFloat16], out *Image[hwy.BFloat16], minVal hwy.BFloat16, maxVal hwy.BFloat16)
var ClampImageFloat32 func(img *Image[float32], out *Image[float32], minVal float32, maxVal float32)
var ClampImageFloat64 func(img *Image[float64], out *Image[float64], minVal float64, maxVal float64)
var ThresholdFloat16 func(img *Image[hwy.Float16], out *Image[hwy.Float16], threshold hwy.Float16, below hwy.Float16, above hwy.Float16)
var ThresholdBFloat16 func(img *Image[hwy.BFloat16], out *Image[hwy.BFloat16], threshold hwy.BFloat16, below hwy.BFloat16, above hwy.BFloat16)
var ThresholdFloat32 func(img *Image[float32], out *Image[float32], threshold float32, below float32, above float32)
var ThresholdFloat64 func(img *Image[float64], out *Image[float64], threshold float64, below float64, above float64)
var InvertFloat16 func(img *Image[hwy.Float16], out *Image[hwy.Float16], maxVal hwy.Float16)
var InvertBFloat16 func(img *Image[hwy.BFloat16], out *Image[hwy.BFloat16], maxVal hwy.BFloat16)
var InvertFloat32 func(img *Image[float32], out *Image[float32], maxVal float32)
var InvertFloat64 func(img *Image[float64], out *Image[float64], maxVal float64)
var AbsFloat16 func(img *Image[hwy.Float16], out *Image[hwy.Float16])
var AbsBFloat16 func(img *Image[hwy.BFloat16], out *Image[hwy.BFloat16])
var AbsFloat32 func(img *Image[float32], out *Image[float32])
var AbsFloat64 func(img *Image[float64], out *Image[float64])
var ScaleFloat16 func(img *Image[hwy.Float16], out *Image[hwy.Float16], scale hwy.Float16)
var ScaleBFloat16 func(img *Image[hwy.BFloat16], out *Image[hwy.BFloat16], scale hwy.BFloat16)
var ScaleFloat32 func(img *Image[float32], out *Image[float32], scale float32)
var ScaleFloat64 func(img *Image[float64], out *Image[float64], scale float64)
var OffsetFloat16 func(img *Image[hwy.Float16], out *Image[hwy.Float16], offset hwy.Float16)
var OffsetBFloat16 func(img *Image[hwy.BFloat16], out *Image[hwy.BFloat16], offset hwy.BFloat16)
var OffsetFloat32 func(img *Image[float32], out *Image[float32], offset float32)
var OffsetFloat64 func(img *Image[float64], out *Image[float64], offset float64)
var GammaFloat16 func(img *Image[hwy.Float16], out *Image[hwy.Float16], gamma hwy.Float16)
var GammaBFloat16 func(img *Image[hwy.BFloat16], out *Image[hwy.BFloat16], gamma hwy.BFloat16)
var GammaFloat32 func(img *Image[float32], out *Image[float32], gamma float32)
var GammaFloat64 func(img *Image[float64], out *Image[float64], gamma float64)
var MinImageFloat16 func(a *Image[hwy.Float16], b *Image[hwy.Float16], out *Image[hwy.Float16])
var MinImageBFloat16 func(a *Image[hwy.BFloat16], b *Image[hwy.BFloat16], out *Image[hwy.BFloat16])
var MinImageFloat32 func(a *Image[float32], b *Image[float32], out *Image[float32])
var MinImageFloat64 func(a *Image[float64], b *Image[float64], out *Image[float64])
var MaxImageFloat16 func(a *Image[hwy.Float16], b *Image[hwy.Float16], out *Image[hwy.Float16])
var MaxImageBFloat16 func(a *Image[hwy.BFloat16], b *Image[hwy.BFloat16], out *Image[hwy.BFloat16])
var MaxImageFloat32 func(a *Image[float32], b *Image[float32], out *Image[float32])
var MaxImageFloat64 func(a *Image[float64], b *Image[float64], out *Image[float64])

// BrightnessContrast applies linear transformation: out = in * scale + offset.
// This is the fundamental point operation for adjusting image brightness and contrast.
//
// This function dispatches to the appropriate SIMD implementation at runtime.
func BrightnessContrast[T hwy.Floats](img *Image[T], out *Image[T], scale T, offset T) {
	switch any(img).(type) {
	case *Image[hwy.Float16]:
		BrightnessContrastFloat16(any(img).(*Image[hwy.Float16]), any(out).(*Image[hwy.Float16]), any(scale).(hwy.Float16), any(offset).(hwy.Float16))
	case *Image[hwy.BFloat16]:
		BrightnessContrastBFloat16(any(img).(*Image[hwy.BFloat16]), any(out).(*Image[hwy.BFloat16]), any(scale).(hwy.BFloat16), any(offset).(hwy.BFloat16))
	case *Image[float32]:
		BrightnessContrastFloat32(any(img).(*Image[float32]), any(out).(*Image[float32]), any(scale).(float32), any(offset).(float32))
	case *Image[float64]:
		BrightnessContrastFloat64(any(img).(*Image[float64]), any(out).(*Image[float64]), any(scale).(float64), any(offset).(float64))
	}
}

// ClampImage clamps pixel values to [minVal, maxVal].
//
// This function dispatches to the appropriate SIMD implementation at runtime.
func ClampImage[T hwy.Floats](img *Image[T], out *Image[T], minVal T, maxVal T) {
	switch any(img).(type) {
	case *Image[hwy.Float16]:
		ClampImageFloat16(any(img).(*Image[hwy.Float16]), any(out).(*Image[hwy.Float16]), any(minVal).(hwy.Float16), any(maxVal).(hwy.Float16))
	case *Image[hwy.BFloat16]:
		ClampImageBFloat16(any(img).(*Image[hwy.BFloat16]), any(out).(*Image[hwy.BFloat16]), any(minVal).(hwy.BFloat16), any(maxVal).(hwy.BFloat16))
	case *Image[float32]:
		ClampImageFloat32(any(img).(*Image[float32]), any(out).(*Image[float32]), any(minVal).(float32), any(maxVal).(float32))
	case *Image[float64]:
		ClampImageFloat64(any(img).(*Image[float64]), any(out).(*Image[float64]), any(minVal).(float64), any(maxVal).(float64))
	}
}

// Threshold applies binary threshold: out = (in >= threshold) ? above : below.
//
// This function dispatches to the appropriate SIMD implementation at runtime.
func Threshold[T hwy.Floats](img *Image[T], out *Image[T], threshold T, below T, above T) {
	switch any(img).(type) {
	case *Image[hwy.Float16]:
		ThresholdFloat16(any(img).(*Image[hwy.Float16]), any(out).(*Image[hwy.Float16]), any(threshold).(hwy.Float16), any(below).(hwy.Float16), any(above).(hwy.Float16))
	case *Image[hwy.BFloat16]:
		ThresholdBFloat16(any(img).(*Image[hwy.BFloat16]), any(out).(*Image[hwy.BFloat16]), any(threshold).(hwy.BFloat16), any(below).(hwy.BFloat16), any(above).(hwy.BFloat16))
	case *Image[float32]:
		ThresholdFloat32(any(img).(*Image[float32]), any(out).(*Image[float32]), any(threshold).(float32), any(below).(float32), any(above).(float32))
	case *Image[float64]:
		ThresholdFloat64(any(img).(*Image[float64]), any(out).(*Image[float64]), any(threshold).(float64), any(below).(float64), any(above).(float64))
	}
}

// Invert inverts pixel values: out = maxVal - in.
// For normalized images [0,1], use maxVal=1.
//
// This function dispatches to the appropriate SIMD implementation at runtime.
func Invert[T hwy.Floats](img *Image[T], out *Image[T], maxVal T) {
	switch any(img).(type) {
	case *Image[hwy.Float16]:
		InvertFloat16(any(img).(*Image[hwy.Float16]), any(out).(*Image[hwy.Float16]), any(maxVal).(hwy.Float16))
	case *Image[hwy.BFloat16]:
		InvertBFloat16(any(img).(*Image[hwy.BFloat16]), any(out).(*Image[hwy.BFloat16]), any(maxVal).(hwy.BFloat16))
	case *Image[float32]:
		InvertFloat32(any(img).(*Image[float32]), any(out).(*Image[float32]), any(maxVal).(float32))
	case *Image[float64]:
		InvertFloat64(any(img).(*Image[float64]), any(out).(*Image[float64]), any(maxVal).(float64))
	}
}

// Abs computes absolute value of each pixel: out = |in|.
//
// This function dispatches to the appropriate SIMD implementation at runtime.
func Abs[T hwy.Floats](img *Image[T], out *Image[T]) {
	switch any(img).(type) {
	case *Image[hwy.Float16]:
		AbsFloat16(any(img).(*Image[hwy.Float16]), any(out).(*Image[hwy.Float16]))
	case *Image[hwy.BFloat16]:
		AbsBFloat16(any(img).(*Image[hwy.BFloat16]), any(out).(*Image[hwy.BFloat16]))
	case *Image[float32]:
		AbsFloat32(any(img).(*Image[float32]), any(out).(*Image[float32]))
	case *Image[float64]:
		AbsFloat64(any(img).(*Image[float64]), any(out).(*Image[float64]))
	}
}

// Scale multiplies all pixels by a constant: out = in * scale.
//
// This function dispatches to the appropriate SIMD implementation at runtime.
func Scale[T hwy.Floats](img *Image[T], out *Image[T], scale T) {
	switch any(img).(type) {
	case *Image[hwy.Float16]:
		ScaleFloat16(any(img).(*Image[hwy.Float16]), any(out).(*Image[hwy.Float16]), any(scale).(hwy.Float16))
	case *Image[hwy.BFloat16]:
		ScaleBFloat16(any(img).(*Image[hwy.BFloat16]), any(out).(*Image[hwy.BFloat16]), any(scale).(hwy.BFloat16))
	case *Image[float32]:
		ScaleFloat32(any(img).(*Image[float32]), any(out).(*Image[float32]), any(scale).(float32))
	case *Image[float64]:
		ScaleFloat64(any(img).(*Image[float64]), any(out).(*Image[float64]), any(scale).(float64))
	}
}

// Offset adds a constant to all pixels: out = in + offset.
//
// This function dispatches to the appropriate SIMD implementation at runtime.
func Offset[T hwy.Floats](img *Image[T], out *Image[T], offset T) {
	switch any(img).(type) {
	case *Image[hwy.Float16]:
		OffsetFloat16(any(img).(*Image[hwy.Float16]), any(out).(*Image[hwy.Float16]), any(offset).(hwy.Float16))
	case *Image[hwy.BFloat16]:
		OffsetBFloat16(any(img).(*Image[hwy.BFloat16]), any(out).(*Image[hwy.BFloat16]), any(offset).(hwy.BFloat16))
	case *Image[float32]:
		OffsetFloat32(any(img).(*Image[float32]), any(out).(*Image[float32]), any(offset).(float32))
	case *Image[float64]:
		OffsetFloat64(any(img).(*Image[float64]), any(out).(*Image[float64]), any(offset).(float64))
	}
}

// Gamma applies gamma correction: out = pow(in, gamma).
// Input should be in [0, 1] range for proper gamma correction.
// Uses SIMD pow for vectorized processing.
//
// This function dispatches to the appropriate SIMD implementation at runtime.
func Gamma[T hwy.Floats](img *Image[T], out *Image[T], gamma T) {
	switch any(img).(type) {
	case *Image[hwy.Float16]:
		GammaFloat16(any(img).(*Image[hwy.Float16]), any(out).(*Image[hwy.Float16]), any(gamma).(hwy.Float16))
	case *Image[hwy.BFloat16]:
		GammaBFloat16(any(img).(*Image[hwy.BFloat16]), any(out).(*Image[hwy.BFloat16]), any(gamma).(hwy.BFloat16))
	case *Image[float32]:
		GammaFloat32(any(img).(*Image[float32]), any(out).(*Image[float32]), any(gamma).(float32))
	case *Image[float64]:
		GammaFloat64(any(img).(*Image[float64]), any(out).(*Image[float64]), any(gamma).(float64))
	}
}

// MinImage computes element-wise minimum: out = min(a, b).
//
// This function dispatches to the appropriate SIMD implementation at runtime.
func MinImage[T hwy.Floats](a *Image[T], b *Image[T], out *Image[T]) {
	switch any(a).(type) {
	case *Image[hwy.Float16]:
		MinImageFloat16(any(a).(*Image[hwy.Float16]), any(b).(*Image[hwy.Float16]), any(out).(*Image[hwy.Float16]))
	case *Image[hwy.BFloat16]:
		MinImageBFloat16(any(a).(*Image[hwy.BFloat16]), any(b).(*Image[hwy.BFloat16]), any(out).(*Image[hwy.BFloat16]))
	case *Image[float32]:
		MinImageFloat32(any(a).(*Image[float32]), any(b).(*Image[float32]), any(out).(*Image[float32]))
	case *Image[float64]:
		MinImageFloat64(any(a).(*Image[float64]), any(b).(*Image[float64]), any(out).(*Image[float64]))
	}
}

// MaxImage computes element-wise maximum: out = max(a, b).
//
// This function dispatches to the appropriate SIMD implementation at runtime.
func MaxImage[T hwy.Floats](a *Image[T], b *Image[T], out *Image[T]) {
	switch any(a).(type) {
	case *Image[hwy.Float16]:
		MaxImageFloat16(any(a).(*Image[hwy.Float16]), any(b).(*Image[hwy.Float16]), any(out).(*Image[hwy.Float16]))
	case *Image[hwy.BFloat16]:
		MaxImageBFloat16(any(a).(*Image[hwy.BFloat16]), any(b).(*Image[hwy.BFloat16]), any(out).(*Image[hwy.BFloat16]))
	case *Image[float32]:
		MaxImageFloat32(any(a).(*Image[float32]), any(b).(*Image[float32]), any(out).(*Image[float32]))
	case *Image[float64]:
		MaxImageFloat64(any(a).(*Image[float64]), any(b).(*Image[float64]), any(out).(*Image[float64]))
	}
}

func init() {
	if hwy.NoSimdEnv() {
		initPointopsFallback()
		return
	}
	initPointopsNEON()
	return
}

func initPointopsNEON() {
	BrightnessContrastFloat16 = BaseBrightnessContrast_neon_Float16
	BrightnessContrastBFloat16 = BaseBrightnessContrast_neon_BFloat16
	BrightnessContrastFloat32 = BaseBrightnessContrast_neon
	BrightnessContrastFloat64 = BaseBrightnessContrast_neon_Float64
	ClampImageFloat16 = BaseClampImage_neon_Float16
	ClampImageBFloat16 = BaseClampImage_neon_BFloat16
	ClampImageFloat32 = BaseClampImage_neon
	ClampImageFloat64 = BaseClampImage_neon_Float64
	ThresholdFloat16 = BaseThreshold_neon_Float16
	ThresholdBFloat16 = BaseThreshold_neon_BFloat16
	ThresholdFloat32 = BaseThreshold_neon
	ThresholdFloat64 = BaseThreshold_neon_Float64
	InvertFloat16 = BaseInvert_neon_Float16
	InvertBFloat16 = BaseInvert_neon_BFloat16
	InvertFloat32 = BaseInvert_neon
	InvertFloat64 = BaseInvert_neon_Float64
	AbsFloat16 = BaseAbs_neon_Float16
	AbsBFloat16 = BaseAbs_neon_BFloat16
	AbsFloat32 = BaseAbs_neon
	AbsFloat64 = BaseAbs_neon_Float64
	ScaleFloat16 = BaseScale_neon_Float16
	ScaleBFloat16 = BaseScale_neon_BFloat16
	ScaleFloat32 = BaseScale_neon
	ScaleFloat64 = BaseScale_neon_Float64
	OffsetFloat16 = BaseOffset_neon_Float16
	OffsetBFloat16 = BaseOffset_neon_BFloat16
	OffsetFloat32 = BaseOffset_neon
	OffsetFloat64 = BaseOffset_neon_Float64
	GammaFloat16 = BaseGamma_neon_Float16
	GammaBFloat16 = BaseGamma_neon_BFloat16
	GammaFloat32 = BaseGamma_neon
	GammaFloat64 = BaseGamma_neon_Float64
	MinImageFloat16 = BaseMinImage_neon_Float16
	MinImageBFloat16 = BaseMinImage_neon_BFloat16
	MinImageFloat32 = BaseMinImage_neon
	MinImageFloat64 = BaseMinImage_neon_Float64
	MaxImageFloat16 = BaseMaxImage_neon_Float16
	MaxImageBFloat16 = BaseMaxImage_neon_BFloat16
	MaxImageFloat32 = BaseMaxImage_neon
	MaxImageFloat64 = BaseMaxImage_neon_Float64
}

func initPointopsFallback() {
	BrightnessContrastFloat16 = BaseBrightnessContrast_fallback_Float16
	BrightnessContrastBFloat16 = BaseBrightnessContrast_fallback_BFloat16
	BrightnessContrastFloat32 = BaseBrightnessContrast_fallback
	BrightnessContrastFloat64 = BaseBrightnessContrast_fallback_Float64
	ClampImageFloat16 = BaseClampImage_fallback_Float16
	ClampImageBFloat16 = BaseClampImage_fallback_BFloat16
	ClampImageFloat32 = BaseClampImage_fallback
	ClampImageFloat64 = BaseClampImage_fallback_Float64
	ThresholdFloat16 = BaseThreshold_fallback_Float16
	ThresholdBFloat16 = BaseThreshold_fallback_BFloat16
	ThresholdFloat32 = BaseThreshold_fallback
	ThresholdFloat64 = BaseThreshold_fallback_Float64
	InvertFloat16 = BaseInvert_fallback_Float16
	InvertBFloat16 = BaseInvert_fallback_BFloat16
	InvertFloat32 = BaseInvert_fallback
	InvertFloat64 = BaseInvert_fallback_Float64
	AbsFloat16 = BaseAbs_fallback_Float16
	AbsBFloat16 = BaseAbs_fallback_BFloat16
	AbsFloat32 = BaseAbs_fallback
	AbsFloat64 = BaseAbs_fallback_Float64
	ScaleFloat16 = BaseScale_fallback_Float16
	ScaleBFloat16 = BaseScale_fallback_BFloat16
	ScaleFloat32 = BaseScale_fallback
	ScaleFloat64 = BaseScale_fallback_Float64
	OffsetFloat16 = BaseOffset_fallback_Float16
	OffsetBFloat16 = BaseOffset_fallback_BFloat16
	OffsetFloat32 = BaseOffset_fallback
	OffsetFloat64 = BaseOffset_fallback_Float64
	GammaFloat16 = BaseGamma_fallback_Float16
	GammaBFloat16 = BaseGamma_fallback_BFloat16
	GammaFloat32 = BaseGamma_fallback
	GammaFloat64 = BaseGamma_fallback_Float64
	MinImageFloat16 = BaseMinImage_fallback_Float16
	MinImageBFloat16 = BaseMinImage_fallback_BFloat16
	MinImageFloat32 = BaseMinImage_fallback
	MinImageFloat64 = BaseMinImage_fallback_Float64
	MaxImageFloat16 = BaseMaxImage_fallback_Float16
	MaxImageBFloat16 = BaseMaxImage_fallback_BFloat16
	MaxImageFloat32 = BaseMaxImage_fallback
	MaxImageFloat64 = BaseMaxImage_fallback_Float64
}
