//go:build !noasm && amd64

// AVX2 Matrix-Vector Multiplication for AMD64
// Uses AVX2 SIMD instructions for efficient matvec.
package asm

import (
	"unsafe"

	"github.com/ajroetker/go-highway/hwy"
)

// AVX2 with F16C and FMA for f16/bf16 support
//go:generate go tool goat ../c/matvec_avx2_amd64.c -O3 --target amd64 -m avx2 -m fma -m f16c

// ============================================================================
// AVX2 Matrix-Vector Multiplication
// ============================================================================

// MatVecAVX2F16 performs matrix-vector multiplication using AVX2: result = M * v
// Uses F16C for f16<->f32 conversion, compute in f32.
// M is rows x cols (row-major), v is the input vector (cols elements),
// result is the output vector (rows elements).
//
// Parameters:
//   - m: rows x cols matrix (row-major)
//   - v: input vector (cols elements)
//   - result: output vector (rows elements)
//   - rows, cols: matrix dimensions
func MatVecAVX2F16(m []hwy.Float16, v []hwy.Float16, result []hwy.Float16, rows, cols int) {
	if rows == 0 || cols == 0 {
		return
	}
	if len(m) < rows*cols || len(v) < cols || len(result) < rows {
		return
	}
	rowsVal := int64(rows)
	colsVal := int64(cols)
	matvec_avx2_f16(
		unsafe.Pointer(&m[0]),
		unsafe.Pointer(&v[0]),
		unsafe.Pointer(&result[0]),
		unsafe.Pointer(&rowsVal),
		unsafe.Pointer(&colsVal),
	)
}

// MatVecAVX2BF16 performs matrix-vector multiplication using AVX2: result = M * v
// Emulates bf16 via f32 conversion (no native bf16 in AVX2).
// M is rows x cols (row-major), v is the input vector (cols elements),
// result is the output vector (rows elements).
//
// Parameters:
//   - m: rows x cols matrix (row-major)
//   - v: input vector (cols elements)
//   - result: output vector (rows elements)
//   - rows, cols: matrix dimensions
func MatVecAVX2BF16(m []hwy.BFloat16, v []hwy.BFloat16, result []hwy.BFloat16, rows, cols int) {
	if rows == 0 || cols == 0 {
		return
	}
	if len(m) < rows*cols || len(v) < cols || len(result) < rows {
		return
	}
	rowsVal := int64(rows)
	colsVal := int64(cols)
	matvec_avx2_bf16(
		unsafe.Pointer(&m[0]),
		unsafe.Pointer(&v[0]),
		unsafe.Pointer(&result[0]),
		unsafe.Pointer(&rowsVal),
		unsafe.Pointer(&colsVal),
	)
}

// MatVecAVX2F32 performs matrix-vector multiplication using AVX2: result = M * v
// M is rows x cols (row-major), v is the input vector (cols elements),
// result is the output vector (rows elements).
//
// Parameters:
//   - m: rows x cols matrix (row-major)
//   - v: input vector (cols elements)
//   - result: output vector (rows elements)
//   - rows, cols: matrix dimensions
func MatVecAVX2F32(m []float32, v []float32, result []float32, rows, cols int) {
	if rows == 0 || cols == 0 {
		return
	}
	if len(m) < rows*cols || len(v) < cols || len(result) < rows {
		return
	}
	rowsVal := int64(rows)
	colsVal := int64(cols)
	matvec_avx2_f32(
		unsafe.Pointer(&m[0]),
		unsafe.Pointer(&v[0]),
		unsafe.Pointer(&result[0]),
		unsafe.Pointer(&rowsVal),
		unsafe.Pointer(&colsVal),
	)
}

// MatVecAVX2F64 performs matrix-vector multiplication using AVX2: result = M * v
// M is rows x cols (row-major), v is the input vector (cols elements),
// result is the output vector (rows elements).
//
// Parameters:
//   - m: rows x cols matrix (row-major)
//   - v: input vector (cols elements)
//   - result: output vector (rows elements)
//   - rows, cols: matrix dimensions
func MatVecAVX2F64(m []float64, v []float64, result []float64, rows, cols int) {
	if rows == 0 || cols == 0 {
		return
	}
	if len(m) < rows*cols || len(v) < cols || len(result) < rows {
		return
	}
	rowsVal := int64(rows)
	colsVal := int64(cols)
	matvec_avx2_f64(
		unsafe.Pointer(&m[0]),
		unsafe.Pointer(&v[0]),
		unsafe.Pointer(&result[0]),
		unsafe.Pointer(&rowsVal),
		unsafe.Pointer(&colsVal),
	)
}

// Assembly function declarations are in matvec_avx2_amd64.go (generated by GoAT)
