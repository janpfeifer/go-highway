// Copyright 2025 go-highway Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//go:build !noasm && arm64

// NEON Matrix-Vector Multiplication for ARM64
// Uses NEON SIMD instructions for efficient matvec.
package asm

import (
	"unsafe"

	"github.com/ajroetker/go-highway/hwy"
)

// NEON f16/bf16 requires ARMv8.2-A FP16 and ARMv8.6-A BF16 extensions
//go:generate go tool goat ../c/matvec_neon_arm64.c -O3 --target arm64 -e="-march=armv8.6-a+fp16+bf16"

// ============================================================================
// NEON Matrix-Vector Multiplication
// ============================================================================

// MatVecNEONF16 performs matrix-vector multiplication using NEON: result = M * v
// M is rows x cols (row-major), v is the input vector (cols elements),
// result is the output vector (rows elements).
//
// Parameters:
//   - m: rows x cols matrix (row-major)
//   - v: input vector (cols elements)
//   - result: output vector (rows elements)
//   - rows, cols: matrix dimensions
func MatVecNEONF16(m []hwy.Float16, v []hwy.Float16, result []hwy.Float16, rows, cols int) {
	if rows == 0 || cols == 0 {
		return
	}
	if len(m) < rows*cols || len(v) < cols || len(result) < rows {
		return
	}
	rowsVal := int64(rows)
	colsVal := int64(cols)
	matvec_neon_f16(
		unsafe.Pointer(&m[0]),
		unsafe.Pointer(&v[0]),
		unsafe.Pointer(&result[0]),
		unsafe.Pointer(&rowsVal),
		unsafe.Pointer(&colsVal),
	)
}

// MatVecNEONBF16 performs matrix-vector multiplication using NEON: result = M * v
// Uses BFDOT for bf16 computation with f32 accumulation.
// M is rows x cols (row-major), v is the input vector (cols elements),
// result is the output vector (rows elements).
//
// Parameters:
//   - m: rows x cols matrix (row-major)
//   - v: input vector (cols elements)
//   - result: output vector (rows elements)
//   - rows, cols: matrix dimensions
func MatVecNEONBF16(m []hwy.BFloat16, v []hwy.BFloat16, result []hwy.BFloat16, rows, cols int) {
	if rows == 0 || cols == 0 {
		return
	}
	if len(m) < rows*cols || len(v) < cols || len(result) < rows {
		return
	}
	rowsVal := int64(rows)
	colsVal := int64(cols)
	matvec_neon_bf16(
		unsafe.Pointer(&m[0]),
		unsafe.Pointer(&v[0]),
		unsafe.Pointer(&result[0]),
		unsafe.Pointer(&rowsVal),
		unsafe.Pointer(&colsVal),
	)
}

// MatVecNEONF32 performs matrix-vector multiplication using NEON: result = M * v
// M is rows x cols (row-major), v is the input vector (cols elements),
// result is the output vector (rows elements).
//
// Parameters:
//   - m: rows x cols matrix (row-major)
//   - v: input vector (cols elements)
//   - result: output vector (rows elements)
//   - rows, cols: matrix dimensions
func MatVecNEONF32(m []float32, v []float32, result []float32, rows, cols int) {
	if rows == 0 || cols == 0 {
		return
	}
	if len(m) < rows*cols || len(v) < cols || len(result) < rows {
		return
	}
	rowsVal := int64(rows)
	colsVal := int64(cols)
	matvec_neon_f32(
		unsafe.Pointer(&m[0]),
		unsafe.Pointer(&v[0]),
		unsafe.Pointer(&result[0]),
		unsafe.Pointer(&rowsVal),
		unsafe.Pointer(&colsVal),
	)
}

// MatVecNEONF64 performs matrix-vector multiplication using NEON: result = M * v
// M is rows x cols (row-major), v is the input vector (cols elements),
// result is the output vector (rows elements).
//
// Parameters:
//   - m: rows x cols matrix (row-major)
//   - v: input vector (cols elements)
//   - result: output vector (rows elements)
//   - rows, cols: matrix dimensions
func MatVecNEONF64(m []float64, v []float64, result []float64, rows, cols int) {
	if rows == 0 || cols == 0 {
		return
	}
	if len(m) < rows*cols || len(v) < cols || len(result) < rows {
		return
	}
	rowsVal := int64(rows)
	colsVal := int64(cols)
	matvec_neon_f64(
		unsafe.Pointer(&m[0]),
		unsafe.Pointer(&v[0]),
		unsafe.Pointer(&result[0]),
		unsafe.Pointer(&rowsVal),
		unsafe.Pointer(&colsVal),
	)
}

// Assembly function declarations are in matvec_neon_arm64.go (generated by GoAT)
