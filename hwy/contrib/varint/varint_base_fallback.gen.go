// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

package varint

import (
	"github.com/ajroetker/go-highway/hwy"
)

func BaseFindVarintEnds_fallback(src []byte) uint32 {
	if len(src) == 0 {
		return 0
	}
	n := min(len(src), 32)
	if n == 32 {
		threshold := hwy.Set[uint8](0x80)
		v0 := hwy.LoadSlice[uint8](src[:16])
		isTerminator0 := hwy.LessThan(v0, threshold)
		mask0 := uint32(hwy.BitsFromMask(isTerminator0))
		v1 := hwy.LoadSlice[uint8](src[16:32])
		isTerminator1 := hwy.LessThan(v1, threshold)
		mask1 := uint32(hwy.BitsFromMask(isTerminator1))
		return mask0 | (mask1 << 16)
	}
	var mask uint32
	for i := 0; i < n; i++ {
		if src[i] < 0x80 {
			mask |= 1 << uint(i)
		}
	}
	return mask
}

func BaseDecodeUvarint64Batch_fallback(src []byte, dst []uint64, n int) (decoded int, consumed int) {
	if len(src) == 0 || n == 0 || len(dst) == 0 {
		return 0, 0
	}
	maxDecode := min(n, len(dst))
	pos := 0
	for decoded < maxDecode && pos < len(src) {
		val, bytesRead := decodeOneUvarint64(src[pos:])
		if bytesRead == 0 {
			break
		}
		dst[decoded] = val
		decoded++
		pos += bytesRead
	}
	return decoded, pos
}

func BaseDecode2Uvarint64_fallback(src []byte) (v1 uint64, v2 uint64, consumed int) {
	if len(src) == 0 {
		return 0, 0, 0
	}
	val1, n1 := decodeOneUvarint64(src)
	if n1 == 0 {
		return 0, 0, 0
	}
	if n1 >= len(src) {
		return 0, 0, 0
	}
	val2, n2 := decodeOneUvarint64(src[n1:])
	if n2 == 0 {
		return 0, 0, 0
	}
	return val1, val2, n1 + n2
}

func BaseDecode5Uvarint64_fallback(src []byte) (values [5]uint64, consumed int) {
	if len(src) == 0 {
		return [5]uint64{}, 0
	}
	pos := 0
	for i := 0; i < 5; i++ {
		if pos >= len(src) {
			return [5]uint64{}, 0
		}
		val, n := decodeOneUvarint64(src[pos:])
		if n == 0 {
			return [5]uint64{}, 0
		}
		values[i] = val
		pos += n
	}
	return values, pos
}

func BaseDecodeUvarint64BatchWithMask_fallback(src []byte, dst []uint64, mask uint32, n int) (decoded int, consumed int) {
	if mask == 0 || len(src) == 0 || n == 0 || len(dst) == 0 {
		return 0, 0
	}
	maxDecode := min(n, len(dst))
	pos := 0
	startPos := 0
	for mask != 0 && decoded < maxDecode {
		endPos := trailingZeros32(mask)
		if endPos >= len(src) {
			break
		}
		val, bytesRead := decodeOneUvarint64(src[startPos : endPos+1])
		if bytesRead == 0 || startPos+bytesRead-1 != endPos {
			break
		}
		dst[decoded] = val
		decoded++
		pos = endPos + 1
		startPos = pos
		mask &= mask - 1
	}
	return decoded, pos
}
