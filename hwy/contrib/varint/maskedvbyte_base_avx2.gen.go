// Code generated by hwygen. DO NOT EDIT.
//go:build amd64 && goexperiment.simd

package varint

import (
	"github.com/ajroetker/go-highway/hwy"
	"simd/archsimd"
)

// Hoisted constants - pre-broadcasted at package init time
var (
	BaseMaskedVByteDecodeGroup_AVX2_threshold_f32 = archsimd.BroadcastUint8x16(0x80)
)

func BaseMaskedVByteDecodeBatch32_avx2(src []byte, dst []uint32, n int) (decoded int, consumed int) {
	if len(src) == 0 || n == 0 || len(dst) == 0 {
		return 0, 0
	}
	maxDecode := min(n, len(dst))
	pos := 0
	for decoded+4 <= maxDecode && pos+16 <= len(src) {
		numDecoded, bytesUsed := BaseMaskedVByteDecodeGroup_avx2(src[pos:], dst[decoded:])
		if numDecoded == 0 {
			break
		}
		decoded += numDecoded
		pos += bytesUsed
	}
	for decoded < maxDecode && pos < len(src) {
		val, bytesRead := baseMaskedVByteDecodeOne32(src[pos:])
		if bytesRead == 0 {
			break
		}
		dst[decoded] = val
		decoded++
		pos += bytesRead
	}
	return decoded, pos
}

func BaseMaskedVByteDecodeGroup_avx2(src []byte, dst []uint32) (decoded int, consumed int) {
	if len(src) < 16 || len(dst) < 4 {
		return 0, 0
	}
	srcVec := archsimd.LoadUint8x16Slice(src[:16])
	threshold := BaseMaskedVByteDecodeGroup_AVX2_threshold_f32
	terminatorMask := srcVec.Less(threshold)
	pattern := uint16(hwy.BitsFromMask_AVX2_Uint8x16(terminatorMask)) & 0x0FFF
	if pattern == 0 {
		return 0, 0
	}
	lookup := &maskedVByte12LookupTable[pattern]
	if lookup.numValues == 0 {
		return 0, 0
	}
	shuffleMask := maskedVByte12ShuffleMasks[pattern][:]
	maskVec := archsimd.LoadUint8x16Slice(shuffleMask)
	shuffled := hwy.TableLookupBytes_AVX2_Uint8x16(srcVec, maskVec)
	var result [16]uint8
	shuffled.StoreSlice(result[:])
	dst[0] = uint32(result[0]&0x7f) | uint32(result[1]&0x7f)<<7 | uint32(result[2]&0x7f)<<14 | uint32(result[3])<<21
	dst[1] = uint32(result[4]&0x7f) | uint32(result[5]&0x7f)<<7 | uint32(result[6]&0x7f)<<14 | uint32(result[7])<<21
	dst[2] = uint32(result[8]&0x7f) | uint32(result[9]&0x7f)<<7 | uint32(result[10]&0x7f)<<14 | uint32(result[11])<<21
	dst[3] = uint32(result[12]&0x7f) | uint32(result[13]&0x7f)<<7 | uint32(result[14]&0x7f)<<14 | uint32(result[15])<<21
	return int(lookup.numValues), int(lookup.bytesConsumed)
}
