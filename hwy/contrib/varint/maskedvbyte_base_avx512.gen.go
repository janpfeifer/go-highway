// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

//go:build amd64 && goexperiment.simd

package varint

import (
	"simd/archsimd"
	"sync"

	"github.com/ajroetker/go-highway/hwy"
)

// Hoisted constants - lazily initialized on first use to avoid init-time crashes
var (
	BaseMaskedVByteDecodeGroup_AVX512_threshold_f32 archsimd.Uint8x16
	_maskedvbyteBaseHoistOnce                       sync.Once
)

func _maskedvbyteBaseInitHoistedConstants() {
	_maskedvbyteBaseHoistOnce.Do(func() {
		BaseMaskedVByteDecodeGroup_AVX512_threshold_f32 = archsimd.BroadcastUint8x16(0x80)
	})
}

func BaseMaskedVByteDecodeBatch32_avx512(src []byte, dst []uint32, n int) (decoded int, consumed int) {
	_maskedvbyteBaseInitHoistedConstants()
	if len(src) == 0 || n == 0 || len(dst) == 0 {
		return 0, 0
	}
	maxDecode := min(n, len(dst))
	pos := 0
	for decoded+4 <= maxDecode && pos+16 <= len(src) {
		numDecoded, bytesUsed := BaseMaskedVByteDecodeGroup_avx512(src[pos:], dst[decoded:])
		if numDecoded == 0 {
			break
		}
		decoded += numDecoded
		pos += bytesUsed
	}
	for decoded < maxDecode && pos < len(src) {
		val, bytesRead := baseMaskedVByteDecodeOne32(src[pos:])
		if bytesRead == 0 {
			break
		}
		dst[decoded] = val
		decoded++
		pos += bytesRead
	}
	return decoded, pos
}

func BaseMaskedVByteDecodeGroup_avx512(src []byte, dst []uint32) (decoded int, consumed int) {
	_maskedvbyteBaseInitHoistedConstants()
	if len(src) < 16 || len(dst) < 4 {
		return 0, 0
	}
	srcVec := archsimd.LoadUint8x16Slice(src[:16])
	threshold := BaseMaskedVByteDecodeGroup_AVX512_threshold_f32
	terminatorMask := srcVec.Less(threshold)
	pattern := uint16(hwy.BitsFromMask_AVX512_Uint8x16(terminatorMask)) & 0x0FFF
	if pattern == 0 {
		return 0, 0
	}
	lookup := &maskedVByte12LookupTable[pattern]
	if lookup.numValues == 0 {
		return 0, 0
	}
	shuffleMask := maskedVByte12ShuffleMasks[pattern][:]
	maskVec := archsimd.LoadUint8x16Slice(shuffleMask)
	shuffled := hwy.TableLookupBytes_AVX512_Uint8x16(srcVec, maskVec)
	var result [16]uint8
	shuffled.StoreSlice(result[:])
	dst[0] = uint32(result[0]&0x7f) | uint32(result[1]&0x7f)<<7 | uint32(result[2]&0x7f)<<14 | uint32(result[3])<<21
	dst[1] = uint32(result[4]&0x7f) | uint32(result[5]&0x7f)<<7 | uint32(result[6]&0x7f)<<14 | uint32(result[7])<<21
	dst[2] = uint32(result[8]&0x7f) | uint32(result[9]&0x7f)<<7 | uint32(result[10]&0x7f)<<14 | uint32(result[11])<<21
	dst[3] = uint32(result[12]&0x7f) | uint32(result[13]&0x7f)<<7 | uint32(result[14]&0x7f)<<14 | uint32(result[15])<<21
	return int(lookup.numValues), int(lookup.bytesConsumed)
}

func baseMaskedVByteDecodeOne32_avx512(src []byte) (uint32, int) {
	_maskedvbyteBaseInitHoistedConstants()
	var x uint32
	var s uint
	for i, b := range src {
		if i >= 5 {
			return 0, 0
		}
		if b < 0x80 {
			if i == 4 && b > 0x0f {
				return 0, 0
			}
			return x | uint32(b)<<s, i + 1
		}
		x |= uint32(b&0x7f) << s
		s += 7
	}
	return 0, 0
}

func BaseMaskedVByteDecodeBatch64_avx512(src []byte, dst []uint64, n int) (decoded int, consumed int) {
	_maskedvbyteBaseInitHoistedConstants()
	if len(src) == 0 || n == 0 || len(dst) == 0 {
		return 0, 0
	}
	maxDecode := min(n, len(dst))
	pos := 0
	for decoded < maxDecode && pos < len(src) {
		val, bytesRead := baseMaskedVByteDecodeOne64(src[pos:])
		if bytesRead == 0 {
			break
		}
		dst[decoded] = val
		decoded++
		pos += bytesRead
	}
	return decoded, pos
}

func baseMaskedVByteDecodeOne64_avx512(src []byte) (uint64, int) {
	_maskedvbyteBaseInitHoistedConstants()
	var x uint64
	var s uint
	for i, b := range src {
		if i >= 10 {
			return 0, 0
		}
		if b < 0x80 {
			if i == 9 && b > 1 {
				return 0, 0
			}
			return x | uint64(b)<<s, i + 1
		}
		x |= uint64(b&0x7f) << s
		s += 7
	}
	return 0, 0
}
