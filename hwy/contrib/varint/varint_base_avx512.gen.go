// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

//go:build amd64 && goexperiment.simd

package varint

import (
	"simd/archsimd"
	"sync"

	"github.com/ajroetker/go-highway/hwy"
)

// Hoisted constants - lazily initialized on first use to avoid init-time crashes
var (
	BaseFindVarintEnds_AVX512_threshold_f32 archsimd.Uint8x16
	_varintBaseHoistOnce                    sync.Once
)

func _varintBaseInitHoistedConstants() {
	_varintBaseHoistOnce.Do(func() {
		BaseFindVarintEnds_AVX512_threshold_f32 = archsimd.BroadcastUint8x16(0x80)
	})
}

func BaseFindVarintEnds_avx512(src []byte) uint32 {
	_varintBaseInitHoistedConstants()
	if len(src) == 0 {
		return 0
	}
	n := min(len(src), 32)
	if n == 32 {
		threshold := BaseFindVarintEnds_AVX512_threshold_f32
		v0 := archsimd.LoadUint8x16Slice(src[:16])
		isTerminator0 := v0.Less(threshold)
		mask0 := uint32(hwy.BitsFromMask_AVX512_Uint8x16(isTerminator0))
		v1 := archsimd.LoadUint8x16Slice(src[16:32])
		isTerminator1 := v1.Less(threshold)
		mask1 := uint32(hwy.BitsFromMask_AVX512_Uint8x16(isTerminator1))
		return mask0 | (mask1 << 16)
	}
	var mask uint32
	for i := 0; i < n; i++ {
		if src[i] < 0x80 {
			mask |= 1 << uint(i)
		}
	}
	return mask
}

func BaseDecodeUvarint64Batch_avx512(src []byte, dst []uint64, n int) (decoded int, consumed int) {
	_varintBaseInitHoistedConstants()
	if len(src) == 0 || n == 0 || len(dst) == 0 {
		return 0, 0
	}
	maxDecode := min(n, len(dst))
	pos := 0
	for decoded < maxDecode && pos < len(src) {
		val, bytesRead := decodeOneUvarint64(src[pos:])
		if bytesRead == 0 {
			break
		}
		dst[decoded] = val
		decoded++
		pos += bytesRead
	}
	return decoded, pos
}

func BaseDecode2Uvarint64_avx512(src []byte) (v1 uint64, v2 uint64, consumed int) {
	_varintBaseInitHoistedConstants()
	if len(src) == 0 {
		return 0, 0, 0
	}
	val1, n1 := decodeOneUvarint64(src)
	if n1 == 0 {
		return 0, 0, 0
	}
	if n1 >= len(src) {
		return 0, 0, 0
	}
	val2, n2 := decodeOneUvarint64(src[n1:])
	if n2 == 0 {
		return 0, 0, 0
	}
	return val1, val2, n1 + n2
}

func BaseDecode5Uvarint64_avx512(src []byte) (values [5]uint64, consumed int) {
	_varintBaseInitHoistedConstants()
	if len(src) == 0 {
		return [5]uint64{}, 0
	}
	pos := 0
	for i := 0; i < 5; i++ {
		if pos >= len(src) {
			return [5]uint64{}, 0
		}
		val, n := decodeOneUvarint64(src[pos:])
		if n == 0 {
			return [5]uint64{}, 0
		}
		values[i] = val
		pos += n
	}
	return values, pos
}

func BaseDecodeUvarint64BatchWithMask_avx512(src []byte, dst []uint64, mask uint32, n int) (decoded int, consumed int) {
	_varintBaseInitHoistedConstants()
	if mask == 0 || len(src) == 0 || n == 0 || len(dst) == 0 {
		return 0, 0
	}
	maxDecode := min(n, len(dst))
	pos := 0
	startPos := 0
	for mask != 0 && decoded < maxDecode {
		endPos := trailingZeros32(mask)
		if endPos >= len(src) {
			break
		}
		val, bytesRead := decodeOneUvarint64(src[startPos : endPos+1])
		if bytesRead == 0 || startPos+bytesRead-1 != endPos {
			break
		}
		dst[decoded] = val
		decoded++
		pos = endPos + 1
		startPos = pos
		mask &= mask - 1
	}
	return decoded, pos
}
