// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

//go:build arm64

package varint

import (
	"github.com/ajroetker/go-highway/hwy"
	"github.com/ajroetker/go-highway/hwy/asm"
)

// Hoisted constants - pre-broadcasted at package init time
var (
	BaseFindVarintEnds_NEON_threshold_f32 = asm.BroadcastUint8x16(0x80)
)

func BaseFindVarintEnds_neon(src []byte) uint32 {
	if len(src) == 0 {
		return 0
	}
	n := min(len(src), 32)
	if n == 32 {
		threshold := BaseFindVarintEnds_NEON_threshold_f32
		v0 := asm.LoadUint8x16Slice(src[:16])
		isTerminator0 := v0.LessThan(threshold)
		mask0 := uint32(hwy.BitsFromMask_NEON_Uint8x16(isTerminator0))
		v1 := asm.LoadUint8x16Slice(src[16:32])
		isTerminator1 := v1.LessThan(threshold)
		mask1 := uint32(hwy.BitsFromMask_NEON_Uint8x16(isTerminator1))
		return mask0 | (mask1 << 16)
	}
	var mask uint32
	for i := range n {
		if src[i] < 0x80 {
			mask |= 1 << uint(i)
		}
	}
	return mask
}

func BaseDecodeUvarint64Batch_neon(src []byte, dst []uint64, n int) (decoded int, consumed int) {
	if len(src) == 0 || n == 0 || len(dst) == 0 {
		return 0, 0
	}
	maxDecode := min(n, len(dst))
	pos := 0
	for decoded < maxDecode && pos < len(src) {
		val, bytesRead := decodeOneUvarint64(src[pos:])
		if bytesRead == 0 {
			break
		}
		dst[decoded] = val
		decoded++
		pos += bytesRead
	}
	return decoded, pos
}

func BaseDecode2Uvarint64_neon(src []byte) (v1 uint64, v2 uint64, consumed int) {
	if len(src) == 0 {
		return 0, 0, 0
	}
	val1, n1 := decodeOneUvarint64(src)
	if n1 == 0 {
		return 0, 0, 0
	}
	if n1 >= len(src) {
		return 0, 0, 0
	}
	val2, n2 := decodeOneUvarint64(src[n1:])
	if n2 == 0 {
		return 0, 0, 0
	}
	return val1, val2, n1 + n2
}

func BaseDecode5Uvarint64_neon(src []byte) (values [5]uint64, consumed int) {
	if len(src) == 0 {
		return [5]uint64{}, 0
	}
	pos := 0
	for i := range 5 {
		if pos >= len(src) {
			return [5]uint64{}, 0
		}
		val, n := decodeOneUvarint64(src[pos:])
		if n == 0 {
			return [5]uint64{}, 0
		}
		values[i] = val
		pos += n
	}
	return values, pos
}

func BaseDecodeUvarint64BatchWithMask_neon(src []byte, dst []uint64, mask uint32, n int) (decoded int, consumed int) {
	if mask == 0 || len(src) == 0 || n == 0 || len(dst) == 0 {
		return 0, 0
	}
	maxDecode := min(n, len(dst))
	pos := 0
	startPos := 0
	for mask != 0 && decoded < maxDecode {
		endPos := trailingZeros32(mask)
		if endPos >= len(src) {
			break
		}
		val, bytesRead := decodeOneUvarint64(src[startPos : endPos+1])
		if bytesRead == 0 || startPos+bytesRead-1 != endPos {
			break
		}
		dst[decoded] = val
		decoded++
		pos = endPos + 1
		startPos = pos
		mask &= mask - 1
	}
	return decoded, pos
}
