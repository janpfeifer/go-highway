// Copyright 2025 The Go Highway Authors
// SPDX-License-Identifier: Apache-2.0
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package varint

import (
	"math/bits"
	"unsafe"

	"github.com/ajroetker/go-highway/hwy"
)

//go:generate go run ../../../cmd/hwygen -input streamvbyte_base.go -output . -targets avx2,avx512,neon,fallback -dispatch streamvbyte

// Stream-VByte encode and decode functions with SIMD acceleration.
// These use hwy.* operations and get target-specific variants generated by hwygen.

// streamVByte32DataLen[control] = sum of 4 value lengths for this control byte.
// Each 2-bit field encodes (length - 1), so we add 1 to each.
var streamVByte32DataLen [256]uint8

func init() {
	for control := range 256 {
		len0 := ((control >> 0) & 0x3) + 1
		len1 := ((control >> 2) & 0x3) + 1
		len2 := ((control >> 4) & 0x3) + 1
		len3 := ((control >> 6) & 0x3) + 1
		streamVByte32DataLen[control] = uint8(len0 + len1 + len2 + len3)
	}
}

// streamVByte32ShuffleMasks contains precomputed shuffle masks for each control byte.
// For control byte c, masks[c] contains indices to shuffle 16 data bytes into 4 uint32 values.
// Index 255 means "output zero" (for padding shorter values to 4 bytes).
var streamVByte32ShuffleMasks [256][16]uint8

func init() {
	for ctrl := range 256 {
		len0 := ((ctrl >> 0) & 0x3) + 1
		len1 := ((ctrl >> 2) & 0x3) + 1
		len2 := ((ctrl >> 4) & 0x3) + 1
		len3 := ((ctrl >> 6) & 0x3) + 1

		off0 := 0
		off1 := len0
		off2 := len0 + len1
		off3 := len0 + len1 + len2

		var mask [16]uint8
		// Value 0 at output positions 0-3
		for i := range 4 {
			if i < len0 {
				mask[i] = uint8(off0 + i)
			} else {
				mask[i] = 255 // zero padding
			}
		}
		// Value 1 at output positions 4-7
		for i := range 4 {
			if i < len1 {
				mask[4+i] = uint8(off1 + i)
			} else {
				mask[4+i] = 255
			}
		}
		// Value 2 at output positions 8-11
		for i := range 4 {
			if i < len2 {
				mask[8+i] = uint8(off2 + i)
			} else {
				mask[8+i] = 255
			}
		}
		// Value 3 at output positions 12-15
		for i := range 4 {
			if i < len3 {
				mask[12+i] = uint8(off3 + i)
			} else {
				mask[12+i] = 255
			}
		}
		streamVByte32ShuffleMasks[ctrl] = mask
	}
}

// BaseDecodeStreamVByte32 decodes uint32 values from Stream-VByte format.
// control contains the control bytes, data contains the value bytes.
// n is the number of values to decode (must be <= len(control)*4).
// Returns the decoded values.
func BaseDecodeStreamVByte32(control []byte, data []uint8, n int) []uint32 {
	if n <= 0 || len(control) == 0 {
		return nil
	}

	result := make([]uint32, n)
	BaseDecodeStreamVByte32Into(control, data, result)
	return result
}

// BaseDecodeStreamVByte32Into decodes into a pre-allocated dst slice.
// Returns number of values decoded and data bytes consumed.
// Uses SIMD group decode when possible for better performance.
func BaseDecodeStreamVByte32Into(control []byte, data []uint8, dst []uint32) (decoded, dataConsumed int) {
	if len(dst) == 0 || len(control) == 0 {
		return 0, 0
	}

	dataPos := 0
	dstPos := 0
	n := len(dst)

	// Use SIMD group decode when we have enough dst space for full groups
	for _, ctrl := range control {
		if dstPos >= n {
			break
		}

		// If we have space for a full group of 4 and enough data for SIMD load (16 bytes)
		if dstPos+4 <= n && dataPos+16 <= len(data) {
			consumed := BaseDecodeStreamVByte32GroupSIMD(ctrl, data[dataPos:], dst[dstPos:])
			if consumed > 0 {
				dataPos += consumed
				dstPos += 4
				continue
			}
		}

		// Scalar fallback for partial groups or small buffers
		for i := 0; i < 4 && dstPos < n; i++ {
			length := int(((ctrl >> (i * 2)) & 0x3) + 1)

			if dataPos+length > len(data) {
				// Not enough data
				return dstPos, dataPos
			}

			var v uint32
			switch length {
			case 1:
				v = uint32(data[dataPos])
			case 2:
				v = uint32(data[dataPos]) | uint32(data[dataPos+1])<<8
			case 3:
				v = uint32(data[dataPos]) | uint32(data[dataPos+1])<<8 | uint32(data[dataPos+2])<<16
			case 4:
				v = uint32(data[dataPos]) | uint32(data[dataPos+1])<<8 | uint32(data[dataPos+2])<<16 | uint32(data[dataPos+3])<<24
			}

			dst[dstPos] = v
			dstPos++
			dataPos += length
		}
	}

	return dstPos, dataPos
}

// BaseDecodeStreamVByte32GroupSIMD decodes 4 uint32 values from one Stream-VByte group
// using SIMD shuffle operations. This is the core SIMD-accelerated decode function.
//
// ctrl: the control byte for this group
// data: at least 16 bytes of data (reads up to dataLen bytes based on control)
// dst: output slice for 4 decoded uint32 values
//
// Returns the number of data bytes consumed.
func BaseDecodeStreamVByte32GroupSIMD(ctrl byte, data []uint8, dst []uint32) int {
	dataLen := int(streamVByte32DataLen[ctrl])
	if len(data) < dataLen || len(dst) < 4 {
		return 0
	}

	// Ensure we have at least 16 bytes for vector load (may read past dataLen but within bounds)
	if len(data) < 16 {
		// Fallback to scalar for short buffers
		return decodeGroupScalarInto(ctrl, data, dst)
	}

	// Load data bytes into vector (up to 16 bytes)
	// Use LoadSlice since we're explicitly working with 16-byte chunks
	dataVec := hwy.LoadSlice[uint8](data[:16])

	// Load shuffle mask for this control byte
	maskSlice := streamVByte32ShuffleMasks[ctrl][:]
	maskVec := hwy.LoadSlice[uint8](maskSlice)

	// Shuffle: rearrange bytes according to mask
	// Index 255 (>= 16) produces zero in TableLookupBytes
	shuffled := hwy.TableLookupBytes(dataVec, maskVec)

	// Store shuffled bytes
	var result [16]uint8
	hwy.StoreSlice(shuffled, result[:])

	// Convert 16 bytes to 4 uint32 (little-endian)
	dst[0] = uint32(result[0]) | uint32(result[1])<<8 | uint32(result[2])<<16 | uint32(result[3])<<24
	dst[1] = uint32(result[4]) | uint32(result[5])<<8 | uint32(result[6])<<16 | uint32(result[7])<<24
	dst[2] = uint32(result[8]) | uint32(result[9])<<8 | uint32(result[10])<<16 | uint32(result[11])<<24
	dst[3] = uint32(result[12]) | uint32(result[13])<<8 | uint32(result[14])<<16 | uint32(result[15])<<24

	return dataLen
}

// decodeGroupScalarInto is a scalar fallback for small buffers.
func decodeGroupScalarInto(ctrl byte, data []uint8, dst []uint32) int {
	pos := 0
	for i := range 4 {
		length := int(((ctrl >> (i * 2)) & 0x3) + 1)
		if pos+length > len(data) {
			return 0
		}
		var v uint32
		switch length {
		case 1:
			v = uint32(data[pos])
		case 2:
			v = uint32(data[pos]) | uint32(data[pos+1])<<8
		case 3:
			v = uint32(data[pos]) | uint32(data[pos+1])<<8 | uint32(data[pos+2])<<16
		case 4:
			v = uint32(data[pos]) | uint32(data[pos+1])<<8 | uint32(data[pos+2])<<16 | uint32(data[pos+3])<<24
		}
		dst[i] = v
		pos += length
	}
	return pos
}

// ============================================================================
// Stream-VByte ENCODE functions with SIMD acceleration
// ============================================================================

// streamVByte32EncodeShuffleMasks contains precomputed shuffle masks for encoding.
// For control byte c, masks[c] contains indices to gather bytes from 16-byte input
// (4 uint32 values in little-endian) into a compact output.
// The first streamVByte32DataLen[c] bytes of output are valid.
var streamVByte32EncodeShuffleMasks [256][16]uint8

func init() {
	for ctrl := range 256 {
		len0 := ((ctrl >> 0) & 0x3) + 1
		len1 := ((ctrl >> 2) & 0x3) + 1
		len2 := ((ctrl >> 4) & 0x3) + 1
		len3 := ((ctrl >> 6) & 0x3) + 1

		var mask [16]uint8
		outPos := 0

		// Value 0: bytes at positions 0-3 in input
		for i := range len0 {
			mask[outPos] = uint8(i)
			outPos++
		}
		// Value 1: bytes at positions 4-7 in input
		for i := range len1 {
			mask[outPos] = uint8(4 + i)
			outPos++
		}
		// Value 2: bytes at positions 8-11 in input
		for i := range len2 {
			mask[outPos] = uint8(8 + i)
			outPos++
		}
		// Value 3: bytes at positions 12-15 in input
		for i := range len3 {
			mask[outPos] = uint8(12 + i)
			outPos++
		}
		// Fill remaining with 255 (produces zeros, unused anyway)
		for i := outPos; i < 16; i++ {
			mask[i] = 255
		}

		streamVByte32EncodeShuffleMasks[ctrl] = mask
	}
}

// BaseEncodeStreamVByte32 encodes uint32 values to Stream-VByte format.
// Returns (control bytes, data bytes).
func BaseEncodeStreamVByte32(values []uint32) (control, data []byte) {
	if len(values) == 0 {
		return nil, nil
	}

	numGroups := (len(values) + 3) / 4
	control = make([]byte, numGroups)
	data = make([]byte, 0, len(values)*4)

	for g := range numGroups {
		baseIdx := g * 4
		remaining := len(values) - baseIdx

		if remaining >= 4 {
			// Full group - use SIMD
			ctrl, groupData := BaseEncodeStreamVByte32GroupSIMD(values[baseIdx : baseIdx+4])
			control[g] = ctrl
			data = append(data, groupData...)
		} else {
			// Partial group - scalar with padding
			var group [4]uint32
			copy(group[:], values[baseIdx:])
			ctrl, groupData := encodeGroupScalar(group[:])
			control[g] = ctrl
			data = append(data, groupData...)
		}
	}

	return control, data
}

// BaseEncodeStreamVByte32Into encodes into pre-allocated buffers.
// Returns sliced control and data buffers.
func BaseEncodeStreamVByte32Into(values []uint32, controlBuf, dataBuf []byte) (control, data []byte) {
	if len(values) == 0 {
		return nil, nil
	}

	numGroups := (len(values) + 3) / 4

	// Ensure buffers are large enough
	if cap(controlBuf) < numGroups {
		controlBuf = make([]byte, numGroups)
	} else {
		controlBuf = controlBuf[:numGroups]
	}

	maxDataLen := len(values) * 4
	if cap(dataBuf) < maxDataLen {
		dataBuf = make([]byte, maxDataLen)
	} else {
		dataBuf = dataBuf[:maxDataLen]
	}

	dataPos := 0
	for g := range numGroups {
		baseIdx := g * 4
		remaining := len(values) - baseIdx

		if remaining >= 4 && dataPos+16 <= len(dataBuf) {
			// Full group - use SIMD directly into buffer
			ctrl, n := BaseEncodeStreamVByte32GroupSIMDInto(values[baseIdx:baseIdx+4], dataBuf[dataPos:])
			controlBuf[g] = ctrl
			dataPos += n
		} else {
			// Partial group - scalar with padding
			var group [4]uint32
			copy(group[:], values[baseIdx:])
			ctrl, n := encodeGroupScalarInto(group[:], dataBuf[dataPos:])
			controlBuf[g] = ctrl
			dataPos += n
		}
	}

	return controlBuf, dataBuf[:dataPos]
}

// BaseEncodeStreamVByte32GroupSIMD encodes 4 uint32 values using SIMD shuffle.
// Returns control byte and data bytes (4-16 bytes).
// Control byte computation is scalar (fast for 4 values), SIMD is used for byte packing.
func BaseEncodeStreamVByte32GroupSIMD(values []uint32) (ctrl byte, data []byte) {
	if len(values) < 4 {
		return encodeGroupScalar(values)
	}

	// Compute control byte using scalar operations (fast for 4 values)
	ctrl = 0
	for i := range 4 {
		length := encodedLengthU32(values[i])
		ctrl |= byte(length-1) << (i * 2)
	}

	// Get total data length
	dataLen := int(streamVByte32DataLen[ctrl])
	data = make([]byte, dataLen)

	// Reinterpret uint32 slice as bytes using unsafe
	// This is safe because both ARM64 and x86-64 are little-endian
	inputBytes := unsafe.Slice((*uint8)(unsafe.Pointer(&values[0])), 16)

	// Use SIMD shuffle to compact bytes
	// Use LoadSlice since we're explicitly working with 16-byte chunks
	inputVec := hwy.LoadSlice[uint8](inputBytes[:16])
	maskVec := hwy.LoadSlice[uint8](streamVByte32EncodeShuffleMasks[ctrl][:16])
	shuffled := hwy.TableLookupBytes(inputVec, maskVec)
	var outputBytes [16]uint8
	hwy.StoreSlice(shuffled, outputBytes[:16])
	copy(data, outputBytes[:dataLen])

	return ctrl, data
}

// BaseEncodeStreamVByte32GroupSIMDInto encodes 4 uint32 values directly into dst buffer.
// Returns control byte and number of bytes written.
// dst must have at least 16 bytes capacity.
func BaseEncodeStreamVByte32GroupSIMDInto(values []uint32, dst []uint8) (ctrl byte, n int) {
	if len(values) < 4 || len(dst) < 16 {
		return 0, 0
	}

	// Fast path: check if all values fit in 1 byte (very common for small integers)
	// Use bitwise OR to check all values at once - if result fits in 8 bits, all do
	combined := values[0] | values[1] | values[2] | values[3]
	if combined <= 0xFF {
		// All values are 1-byte, ctrl = 0x00, just copy low bytes
		dst[0] = byte(values[0])
		dst[1] = byte(values[1])
		dst[2] = byte(values[2])
		dst[3] = byte(values[3])
		return 0, 4
	}

	// Compute control byte using scalar operations
	ctrl = 0
	for i := range 4 {
		length := encodedLengthU32(values[i])
		ctrl |= byte(length-1) << (i * 2)
	}

	// Get total data length
	n = int(streamVByte32DataLen[ctrl])

	// Reinterpret uint32 slice as bytes using unsafe
	// This is safe because both ARM64 and x86-64 are little-endian
	inputBytes := unsafe.Slice((*uint8)(unsafe.Pointer(&values[0])), 16)

	// Use SIMD shuffle to compact bytes directly into dst
	// Use LoadSlice since we're explicitly working with 16-byte chunks
	inputVec := hwy.LoadSlice[uint8](inputBytes[:16])
	maskVec := hwy.LoadSlice[uint8](streamVByte32EncodeShuffleMasks[ctrl][:16])
	shuffled := hwy.TableLookupBytes(inputVec, maskVec)
	hwy.StoreSlice(shuffled, dst[:16])

	return ctrl, n
}

// encodeGroupScalar is scalar fallback for encoding.
func encodeGroupScalar(values []uint32) (ctrl byte, data []byte) {
	data = make([]byte, 0, 16)

	for i := range 4 {
		var v uint32
		if i < len(values) {
			v = values[i]
		}

		length := encodedLengthU32(v)
		ctrl |= byte(length-1) << (i * 2)

		switch length {
		case 1:
			data = append(data, byte(v))
		case 2:
			data = append(data, byte(v), byte(v>>8))
		case 3:
			data = append(data, byte(v), byte(v>>8), byte(v>>16))
		case 4:
			data = append(data, byte(v), byte(v>>8), byte(v>>16), byte(v>>24))
		}
	}

	return ctrl, data
}

// encodeGroupScalarInto is scalar fallback for encoding directly into a buffer.
func encodeGroupScalarInto(values []uint32, dst []byte) (ctrl byte, n int) {
	pos := 0
	for i := range 4 {
		var v uint32
		if i < len(values) {
			v = values[i]
		}

		length := encodedLengthU32(v)
		ctrl |= byte(length-1) << (i * 2)

		switch length {
		case 1:
			dst[pos] = byte(v)
			pos++
		case 2:
			dst[pos] = byte(v)
			dst[pos+1] = byte(v >> 8)
			pos += 2
		case 3:
			dst[pos] = byte(v)
			dst[pos+1] = byte(v >> 8)
			dst[pos+2] = byte(v >> 16)
			pos += 3
		case 4:
			dst[pos] = byte(v)
			dst[pos+1] = byte(v >> 8)
			dst[pos+2] = byte(v >> 16)
			dst[pos+3] = byte(v >> 24)
			pos += 4
		}
	}

	return ctrl, pos
}

// encodedLengthU32 returns the number of bytes needed to encode v.
// Uses CLZ for branchless computation: compiles to single CLZ instruction on ARM64.
func encodedLengthU32(v uint32) int {
	// bits.Len32(v) returns position of highest set bit + 1 (0 for v=0)
	// For v=0: Len32=0, we want length=1
	// For v=1-255: Len32=1-8, we want length=1
	// For v=256-65535: Len32=9-16, we want length=2
	// For v=65536-16777215: Len32=17-24, we want length=3
	// For v>=16777216: Len32=25-32, we want length=4
	//
	// Formula: (Len32(v) + 7) / 8, but need to handle v=0 specially
	// Since (0 + 7) / 8 = 0, we use max(1, (Len32(v) + 7) >> 3)
	//
	// Optimized: ((Len32(v) - 1) >> 3) + 1 works for v > 0
	// For v=0, Len32=0, (0-1)>>3 = 0xFFFFFFFF>>3 = large, then +1 = wrong
	//
	// Use: if v == 0 { return 1 }; return ((bits.Len32(v) - 1) >> 3) + 1
	// Or use the original for clarity - let the compiler optimize branches
	if v == 0 {
		return 1
	}
	return ((bits.Len32(v) - 1) >> 3) + 1
}
