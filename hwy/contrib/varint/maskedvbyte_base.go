// Copyright 2025 The Go Highway Authors
// SPDX-License-Identifier: Apache-2.0
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package varint

import "github.com/ajroetker/go-highway/hwy"

//go:generate go run ../../../cmd/hwygen -input maskedvbyte_base.go -output . -targets avx2,avx512,neon,fallback -dispatch maskedvbyte

// Masked-VByte decode functions with SIMD acceleration.
// These use hwy.* operations and get target-specific variants generated by hwygen.
// Encode functions are in maskedvbyte.go (standard varint encoding, no SIMD needed).
//
// Masked-VByte decodes STANDARD LEB128/varint format (no separate control bytes),
// making it fully compatible with encoding/binary.PutUvarint and existing data.
//
// Reference: "Vectorized VByte Decoding" by Plaisance, Kurz, Lemire (2015)
// https://arxiv.org/abs/1503.07387

// maskedVByte12Lookup contains precomputed decoding information for each
// possible 12-bit pattern of terminator bytes (lower 12 bits of mask).
// Each entry tells us how many varints end in this pattern and where.
type maskedVByte12Lookup struct {
	numValues     uint8    // Number of complete varints (0-12)
	bytesConsumed uint8    // Total bytes consumed
	valueEnds     [4]uint8 // End positions of first 4 varints (1-indexed)
}

var maskedVByte12LookupTable [4096]maskedVByte12Lookup

// maskedVByte12ShuffleMasks contains shuffle masks for extracting varint bytes.
// Index 255 means "output zero" for padding.
var maskedVByte12ShuffleMasks [4096][16]uint8

func init() {
	// Build lookup tables for all 4096 possible 12-bit terminator patterns
	for pattern := range 4096 {
		var lookup maskedVByte12Lookup
		var mask [16]uint8

		// Initialize mask with zero-padding values
		for i := range mask {
			mask[i] = 255
		}

		start := 0
		shufflePos := 0
		numVals := 0

		// Find terminator positions (bits set in pattern)
		for i := 0; i < 12 && numVals < 4; i++ {
			if pattern&(1<<i) != 0 {
				// Byte i is a terminator
				end := i + 1
				valueLen := end - start

				// Record end position
				lookup.valueEnds[numVals] = uint8(end)

				// Build shuffle mask for this value (extracts bytes start..end-1)
				// Each output value gets 4 bytes, zero-padded
				for j := 0; j < valueLen && j < 4; j++ {
					mask[shufflePos+j] = uint8(start + j)
				}
				shufflePos += 4

				start = end
				numVals++
			}
		}

		lookup.numValues = uint8(numVals)
		if numVals > 0 {
			lookup.bytesConsumed = lookup.valueEnds[numVals-1]
		}

		maskedVByte12LookupTable[pattern] = lookup
		maskedVByte12ShuffleMasks[pattern] = mask
	}
}

// BaseMaskedVByteDecodeBatch32 decodes up to n uint32 varints from src.
// Returns (values decoded, bytes consumed).
// Uses SIMD to find varint boundaries and extract values in parallel.
func BaseMaskedVByteDecodeBatch32(src []byte, dst []uint32, n int) (decoded int, consumed int) {
	if len(src) == 0 || n == 0 || len(dst) == 0 {
		return 0, 0
	}

	maxDecode := min(n, len(dst))
	pos := 0

	// Process with SIMD when we have enough data
	for decoded+4 <= maxDecode && pos+16 <= len(src) {
		// Decode up to 4 values using SIMD
		numDecoded, bytesUsed := BaseMaskedVByteDecodeGroup(src[pos:], dst[decoded:])
		if numDecoded == 0 {
			// No complete varints found, fall back to scalar
			break
		}
		decoded += numDecoded
		pos += bytesUsed
	}

	// Handle remaining with scalar decoder
	for decoded < maxDecode && pos < len(src) {
		val, bytesRead := baseMaskedVByteDecodeOne32(src[pos:])
		if bytesRead == 0 {
			break
		}
		dst[decoded] = val
		decoded++
		pos += bytesRead
	}

	return decoded, pos
}

// BaseMaskedVByteDecodeGroup decodes up to 4 uint32 varints using SIMD.
// src must have at least 16 bytes. dst must have at least 4 elements.
// Returns (values decoded, bytes consumed).
//
// This uses SIMD to find varint terminators (bytes < 0x80) and extract them as a bitmask.
// On x86, this uses PMOVMSKB which is very efficient.
// On ARM, there's no equivalent instruction so this may be slower than scalar.
func BaseMaskedVByteDecodeGroup(src []byte, dst []uint32) (decoded int, consumed int) {
	if len(src) < 16 || len(dst) < 4 {
		return 0, 0
	}

	// Load 16 bytes and find terminators using SIMD comparison
	srcVec := hwy.LoadSlice[uint8](src[:16])
	threshold := hwy.Set[uint8](0x80)
	terminatorMask := hwy.LessThan(srcVec, threshold)

	// Extract bitmask - on x86 this compiles to PMOVMSKB (1 instruction)
	// We only need the lower 12 bits for the lookup table
	pattern := uint16(hwy.BitsFromMask(terminatorMask)) & 0x0FFF

	if pattern == 0 {
		// No terminators in first 12 bytes - need scalar fallback
		return 0, 0
	}

	lookup := &maskedVByte12LookupTable[pattern]
	if lookup.numValues == 0 {
		return 0, 0
	}

	// Load shuffle mask and rearrange bytes using SIMD (srcVec already loaded above)
	shuffleMask := maskedVByte12ShuffleMasks[pattern][:]
	maskVec := hwy.LoadSlice[uint8](shuffleMask)
	shuffled := hwy.TableLookupBytes(srcVec, maskVec)

	// Store shuffled bytes
	var result [16]uint8
	hwy.StoreSlice(shuffled, result[:])

	// Combine bytes into uint32 values - always decode all 4 slots
	// The shuffle already arranged bytes with zeros for padding
	// Mask continuation bits (0x7f) and shift to combine
	dst[0] = uint32(result[0]&0x7f) | uint32(result[1]&0x7f)<<7 | uint32(result[2]&0x7f)<<14 | uint32(result[3])<<21
	dst[1] = uint32(result[4]&0x7f) | uint32(result[5]&0x7f)<<7 | uint32(result[6]&0x7f)<<14 | uint32(result[7])<<21
	dst[2] = uint32(result[8]&0x7f) | uint32(result[9]&0x7f)<<7 | uint32(result[10]&0x7f)<<14 | uint32(result[11])<<21
	dst[3] = uint32(result[12]&0x7f) | uint32(result[13]&0x7f)<<7 | uint32(result[14]&0x7f)<<14 | uint32(result[15])<<21

	return int(lookup.numValues), int(lookup.bytesConsumed)
}

// maskedVByteCombine combines varint bytes into a uint32.
// Bytes are already shuffled into position; we need to mask continuation bits
// and shift to combine. length is the number of actual bytes (1-4).
func maskedVByteCombine(b []uint8, length int) uint32 {
	switch length {
	case 1:
		return uint32(b[0])
	case 2:
		return uint32(b[0]&0x7f) | uint32(b[1])<<7
	case 3:
		return uint32(b[0]&0x7f) | uint32(b[1]&0x7f)<<7 | uint32(b[2])<<14
	case 4:
		return uint32(b[0]&0x7f) | uint32(b[1]&0x7f)<<7 | uint32(b[2]&0x7f)<<14 | uint32(b[3])<<21
	case 5:
		return uint32(b[0]&0x7f) | uint32(b[1]&0x7f)<<7 | uint32(b[2]&0x7f)<<14 | uint32(b[3]&0x7f)<<21
	default:
		return 0
	}
}

// baseMaskedVByteDecodeOne32 decodes a single uint32 varint.
func baseMaskedVByteDecodeOne32(src []byte) (uint32, int) {
	var x uint32
	var s uint
	for i, b := range src {
		if i >= 5 {
			return 0, 0
		}
		if b < 0x80 {
			if i == 4 && b > 0x0f {
				return 0, 0
			}
			return x | uint32(b)<<s, i + 1
		}
		x |= uint32(b&0x7f) << s
		s += 7
	}
	return 0, 0
}

// BaseMaskedVByteDecodeBatch64 decodes up to n uint64 varints from src.
// Returns (values decoded, bytes consumed).
// For uint64, varints can be up to 10 bytes, so SIMD is less beneficial.
func BaseMaskedVByteDecodeBatch64(src []byte, dst []uint64, n int) (decoded int, consumed int) {
	if len(src) == 0 || n == 0 || len(dst) == 0 {
		return 0, 0
	}

	maxDecode := min(n, len(dst))
	pos := 0

	// Use scalar decoding for uint64 (varints up to 10 bytes)
	for decoded < maxDecode && pos < len(src) {
		val, bytesRead := baseMaskedVByteDecodeOne64(src[pos:])
		if bytesRead == 0 {
			break
		}
		dst[decoded] = val
		decoded++
		pos += bytesRead
	}

	return decoded, pos
}

// baseMaskedVByteDecodeOne64 decodes a single uint64 varint.
func baseMaskedVByteDecodeOne64(src []byte) (uint64, int) {
	var x uint64
	var s uint
	for i, b := range src {
		if i >= 10 {
			return 0, 0
		}
		if b < 0x80 {
			if i == 9 && b > 1 {
				return 0, 0
			}
			return x | uint64(b)<<s, i + 1
		}
		x |= uint64(b&0x7f) << s
		s += 7
	}
	return 0, 0
}
