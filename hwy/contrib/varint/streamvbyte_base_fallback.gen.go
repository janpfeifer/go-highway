// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

package varint

import (
	"github.com/ajroetker/go-highway/hwy"
	"unsafe"
)

func BaseDecodeStreamVByte32_fallback(control []byte, data []uint8, n int) []uint32 {
	if n <= 0 || len(control) == 0 {
		return nil
	}
	result := make([]uint32, n)
	BaseDecodeStreamVByte32Into_fallback(control, data, result)
	return result
}

func BaseDecodeStreamVByte32Into_fallback(control []byte, data []uint8, dst []uint32) (decoded int, dataConsumed int) {
	if len(dst) == 0 || len(control) == 0 {
		return 0, 0
	}
	dataPos := 0
	dstPos := 0
	n := len(dst)
	for _, ctrl := range control {
		if dstPos >= n {
			break
		}
		if dstPos+4 <= n && dataPos+16 <= len(data) {
			consumed := BaseDecodeStreamVByte32GroupSIMD_fallback(ctrl, data[dataPos:], dst[dstPos:])
			if consumed > 0 {
				dataPos += consumed
				dstPos += 4
				continue
			}
		}
		for i := 0; i < 4 && dstPos < n; i++ {
			length := int(((ctrl >> (i * 2)) & 0x3) + 1)
			if dataPos+length > len(data) {
				return dstPos, dataPos
			}
			var v uint32
			switch length {
			case 1:
				v = uint32(data[dataPos])
			case 2:
				v = uint32(data[dataPos]) | uint32(data[dataPos+1])<<8
			case 3:
				v = uint32(data[dataPos]) | uint32(data[dataPos+1])<<8 | uint32(data[dataPos+2])<<16
			case 4:
				v = uint32(data[dataPos]) | uint32(data[dataPos+1])<<8 | uint32(data[dataPos+2])<<16 | uint32(data[dataPos+3])<<24
			}
			dst[dstPos] = v
			dstPos++
			dataPos += length
		}
	}
	return dstPos, dataPos
}

func BaseDecodeStreamVByte32GroupSIMD_fallback(ctrl byte, data []uint8, dst []uint32) int {
	dataLen := int(streamVByte32DataLen[ctrl])
	if len(data) < dataLen || len(dst) < 4 {
		return 0
	}
	if len(data) < 16 {
		return decodeGroupScalarInto(ctrl, data, dst)
	}
	dataVec := hwy.Load[uint8](data[:16])
	maskSlice := streamVByte32ShuffleMasks[ctrl][:]
	maskVec := hwy.Load[uint8](maskSlice)
	shuffled := hwy.TableLookupBytes(dataVec, maskVec)
	var result [16]uint8
	hwy.Store(shuffled, result[:])
	dst[0] = uint32(result[0]) | uint32(result[1])<<8 | uint32(result[2])<<16 | uint32(result[3])<<24
	dst[1] = uint32(result[4]) | uint32(result[5])<<8 | uint32(result[6])<<16 | uint32(result[7])<<24
	dst[2] = uint32(result[8]) | uint32(result[9])<<8 | uint32(result[10])<<16 | uint32(result[11])<<24
	dst[3] = uint32(result[12]) | uint32(result[13])<<8 | uint32(result[14])<<16 | uint32(result[15])<<24
	return dataLen
}

func BaseEncodeStreamVByte32_fallback(values []uint32) (control []byte, data []byte) {
	if len(values) == 0 {
		return nil, nil
	}
	numGroups := (len(values) + 3) / 4
	control = make([]byte, numGroups)
	data = make([]byte, 0, len(values)*4)
	for g := 0; g < numGroups; g++ {
		baseIdx := g * 4
		remaining := len(values) - baseIdx
		if remaining >= 4 {
			ctrl, groupData := BaseEncodeStreamVByte32GroupSIMD_fallback(values[baseIdx : baseIdx+4])
			control[g] = ctrl
			data = append(data, groupData...)
		} else {
			var group [4]uint32
			copy(group[:], values[baseIdx:])
			ctrl, groupData := encodeGroupScalar(group[:])
			control[g] = ctrl
			data = append(data, groupData...)
		}
	}
	return control, data
}

func BaseEncodeStreamVByte32Into_fallback(values []uint32, controlBuf []byte, dataBuf []byte) (control []byte, data []byte) {
	if len(values) == 0 {
		return nil, nil
	}
	numGroups := (len(values) + 3) / 4
	if cap(controlBuf) < numGroups {
		controlBuf = make([]byte, numGroups)
	} else {
		controlBuf = controlBuf[:numGroups]
	}
	maxDataLen := len(values) * 4
	if cap(dataBuf) < maxDataLen {
		dataBuf = make([]byte, maxDataLen)
	} else {
		dataBuf = dataBuf[:maxDataLen]
	}
	dataPos := 0
	for g := 0; g < numGroups; g++ {
		baseIdx := g * 4
		remaining := len(values) - baseIdx
		if remaining >= 4 && dataPos+16 <= len(dataBuf) {
			ctrl, n := BaseEncodeStreamVByte32GroupSIMDInto_fallback(values[baseIdx:baseIdx+4], dataBuf[dataPos:])
			controlBuf[g] = ctrl
			dataPos += n
		} else {
			var group [4]uint32
			copy(group[:], values[baseIdx:])
			ctrl, n := encodeGroupScalarInto(group[:], dataBuf[dataPos:])
			controlBuf[g] = ctrl
			dataPos += n
		}
	}
	return controlBuf, dataBuf[:dataPos]
}

func BaseEncodeStreamVByte32GroupSIMD_fallback(values []uint32) (ctrl byte, data []byte) {
	if len(values) < 4 {
		return encodeGroupScalar(values)
	}
	ctrl = 0
	for i := 0; i < 4; i++ {
		length := encodedLengthU32(values[i])
		ctrl |= byte(length-1) << (i * 2)
	}
	dataLen := int(streamVByte32DataLen[ctrl])
	data = make([]byte, dataLen)
	inputBytes := unsafe.Slice((*uint8)(unsafe.Pointer(&values[0])), 16)
	inputVec := hwy.Load[uint8](inputBytes[:16])
	maskVec := hwy.Load[uint8](streamVByte32EncodeShuffleMasks[ctrl][:16])
	shuffled := hwy.TableLookupBytes(inputVec, maskVec)
	var outputBytes [16]uint8
	hwy.Store(shuffled, outputBytes[:16])
	copy(data, outputBytes[:dataLen])
	return ctrl, data
}

func BaseEncodeStreamVByte32GroupSIMDInto_fallback(values []uint32, dst []uint8) (ctrl byte, n int) {
	if len(values) < 4 || len(dst) < 16 {
		return 0, 0
	}
	combined := values[0] | values[1] | values[2] | values[3]
	if combined <= 0xFF {
		dst[0] = byte(values[0])
		dst[1] = byte(values[1])
		dst[2] = byte(values[2])
		dst[3] = byte(values[3])
		return 0, 4
	}
	ctrl = 0
	for i := 0; i < 4; i++ {
		length := encodedLengthU32(values[i])
		ctrl |= byte(length-1) << (i * 2)
	}
	n = int(streamVByte32DataLen[ctrl])
	inputBytes := unsafe.Slice((*uint8)(unsafe.Pointer(&values[0])), 16)
	inputVec := hwy.Load[uint8](inputBytes[:16])
	maskVec := hwy.Load[uint8](streamVByte32EncodeShuffleMasks[ctrl][:16])
	shuffled := hwy.TableLookupBytes(inputVec, maskVec)
	hwy.Store(shuffled, dst[:16])
	return ctrl, n
}
