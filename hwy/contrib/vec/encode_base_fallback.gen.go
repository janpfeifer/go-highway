// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

package vec

import (
	"github.com/ajroetker/go-highway/hwy"
	"unsafe"
)

func BaseEncodeFloat32s_fallback(dst []byte, src []float32) {
	if len(src) == 0 {
		return
	}
	totalBytes := len(src) * 4
	if len(dst) < totalBytes {
		panic("dst is too short")
	}
	srcBytes := unsafe.Slice((*byte)(unsafe.Pointer(&src[0])), totalBytes)
	lanes := hwy.NumLanes[uint8]()
	i := 0
	for ; i+lanes <= totalBytes; i += lanes {
		v := hwy.LoadFull[uint8](srcBytes[i:])
		hwy.Store(v, dst[i:])
	}
	for ; i < totalBytes; i++ {
		dst[i] = srcBytes[i]
	}
}

func BaseDecodeFloat32s_fallback(dst []float32, src []byte) {
	if len(dst) == 0 {
		return
	}
	totalBytes := len(dst) * 4
	if len(src) < totalBytes {
		panic("src is too short")
	}
	dstBytes := unsafe.Slice((*byte)(unsafe.Pointer(&dst[0])), totalBytes)
	lanes := hwy.NumLanes[uint8]()
	i := 0
	for ; i+lanes <= totalBytes; i += lanes {
		v := hwy.LoadFull[uint8](src[i:])
		hwy.Store(v, dstBytes[i:])
	}
	for ; i < totalBytes; i++ {
		dstBytes[i] = src[i]
	}
}

func BaseEncodeFloat64s_fallback(dst []byte, src []float64) {
	if len(src) == 0 {
		return
	}
	totalBytes := len(src) * 8
	if len(dst) < totalBytes {
		panic("dst is too short")
	}
	srcBytes := unsafe.Slice((*byte)(unsafe.Pointer(&src[0])), totalBytes)
	lanes := hwy.NumLanes[uint8]()
	i := 0
	for ; i+lanes <= totalBytes; i += lanes {
		v := hwy.LoadFull[uint8](srcBytes[i:])
		hwy.Store(v, dst[i:])
	}
	for ; i < totalBytes; i++ {
		dst[i] = srcBytes[i]
	}
}

func BaseDecodeFloat64s_fallback(dst []float64, src []byte) {
	if len(dst) == 0 {
		return
	}
	totalBytes := len(dst) * 8
	if len(src) < totalBytes {
		panic("src is too short")
	}
	dstBytes := unsafe.Slice((*byte)(unsafe.Pointer(&dst[0])), totalBytes)
	lanes := hwy.NumLanes[uint8]()
	i := 0
	for ; i+lanes <= totalBytes; i += lanes {
		v := hwy.LoadFull[uint8](src[i:])
		hwy.Store(v, dstBytes[i:])
	}
	for ; i < totalBytes; i++ {
		dstBytes[i] = src[i]
	}
}
