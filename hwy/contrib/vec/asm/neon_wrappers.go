// Copyright 2025 go-highway Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//go:build !noasm && arm64

// NEON Vector Operations for ARM64
// Uses full-function NEON assembly implementations generated by GoAT.
// These keep the entire loop in assembly, eliminating per-operation function call overhead.
package asm

import "unsafe"

// Generate NEON assembly from C source
//go:generate go tool goat ../c/vec_neon_arm64.c -O3 --target arm64

// ============================================================================
// Reduction Operations
// ============================================================================

// SumF32 computes the sum of all elements in a float32 slice.
// Uses NEON SIMD for efficient parallel summation.
func SumF32(v []float32) float32 {
	if len(v) == 0 {
		return 0
	}
	n := int64(len(v))
	var result float32
	sum_f32(
		unsafe.Pointer(&v[0]),
		unsafe.Pointer(&n),
		unsafe.Pointer(&result),
	)
	return result
}

// SumF64 computes the sum of all elements in a float64 slice.
// Uses NEON SIMD for efficient parallel summation.
func SumF64(v []float64) float64 {
	if len(v) == 0 {
		return 0
	}
	n := int64(len(v))
	var result float64
	sum_f64(
		unsafe.Pointer(&v[0]),
		unsafe.Pointer(&n),
		unsafe.Pointer(&result),
	)
	return result
}

// MinF32 returns the minimum element in a float32 slice.
// Uses NEON SIMD for efficient parallel comparison.
func MinF32(v []float32) float32 {
	if len(v) == 0 {
		return 0
	}
	n := int64(len(v))
	var result float32
	min_f32(
		unsafe.Pointer(&v[0]),
		unsafe.Pointer(&n),
		unsafe.Pointer(&result),
	)
	return result
}

// MaxF32 returns the maximum element in a float32 slice.
// Uses NEON SIMD for efficient parallel comparison.
func MaxF32(v []float32) float32 {
	if len(v) == 0 {
		return 0
	}
	n := int64(len(v))
	var result float32
	max_f32(
		unsafe.Pointer(&v[0]),
		unsafe.Pointer(&n),
		unsafe.Pointer(&result),
	)
	return result
}

// ============================================================================
// Norm Operations
// ============================================================================

// SquaredNormF32 computes the squared L2 norm (sum of squares) of a float32 slice.
// Equivalent to Dot(v, v).
func SquaredNormF32(v []float32) float32 {
	if len(v) == 0 {
		return 0
	}
	n := int64(len(v))
	var result float32
	squared_norm_f32(
		unsafe.Pointer(&v[0]),
		unsafe.Pointer(&n),
		unsafe.Pointer(&result),
	)
	return result
}

// SquaredNormF64 computes the squared L2 norm (sum of squares) of a float64 slice.
func SquaredNormF64(v []float64) float64 {
	if len(v) == 0 {
		return 0
	}
	n := int64(len(v))
	var result float64
	squared_norm_f64(
		unsafe.Pointer(&v[0]),
		unsafe.Pointer(&n),
		unsafe.Pointer(&result),
	)
	return result
}

// ============================================================================
// Distance Operations
// ============================================================================

// L2SquaredDistanceF32 computes the squared Euclidean distance between two float32 slices.
// Returns sum((a[i] - b[i])^2).
func L2SquaredDistanceF32(a, b []float32) float32 {
	if len(a) == 0 || len(b) == 0 {
		return 0
	}
	n := int64(min(len(a), len(b)))
	var result float32
	l2_squared_distance_f32(
		unsafe.Pointer(&a[0]),
		unsafe.Pointer(&b[0]),
		unsafe.Pointer(&n),
		unsafe.Pointer(&result),
	)
	return result
}

// L2SquaredDistanceF64 computes the squared Euclidean distance between two float64 slices.
func L2SquaredDistanceF64(a, b []float64) float64 {
	if len(a) == 0 || len(b) == 0 {
		return 0
	}
	n := int64(min(len(a), len(b)))
	var result float64
	l2_squared_distance_f64(
		unsafe.Pointer(&a[0]),
		unsafe.Pointer(&b[0]),
		unsafe.Pointer(&n),
		unsafe.Pointer(&result),
	)
	return result
}

// ============================================================================
// Dot Product Operations
// ============================================================================

// DotF32 computes the dot product of two float32 slices.
// Returns sum(a[i] * b[i]).
func DotF32(a, b []float32) float32 {
	if len(a) == 0 || len(b) == 0 {
		return 0
	}
	n := int64(min(len(a), len(b)))
	var result float32
	dot_f32(
		unsafe.Pointer(&a[0]),
		unsafe.Pointer(&b[0]),
		unsafe.Pointer(&n),
		unsafe.Pointer(&result),
	)
	return result
}

// DotF64 computes the dot product of two float64 slices.
func DotF64(a, b []float64) float64 {
	if len(a) == 0 || len(b) == 0 {
		return 0
	}
	n := int64(min(len(a), len(b)))
	var result float64
	dot_f64(
		unsafe.Pointer(&a[0]),
		unsafe.Pointer(&b[0]),
		unsafe.Pointer(&n),
		unsafe.Pointer(&result),
	)
	return result
}

// ============================================================================
// Arithmetic Operations
// ============================================================================

// AddSlicesF32 performs element-wise addition: dst[i] = a[i] + b[i].
func AddSlicesF32(dst, a, b []float32) {
	if len(dst) == 0 || len(a) == 0 || len(b) == 0 {
		return
	}
	n := int64(min(len(dst), min(len(a), len(b))))
	add_slices_f32(
		unsafe.Pointer(&dst[0]),
		unsafe.Pointer(&a[0]),
		unsafe.Pointer(&b[0]),
		unsafe.Pointer(&n),
	)
}

// SubSlicesF32 performs element-wise subtraction: dst[i] = a[i] - b[i].
func SubSlicesF32(dst, a, b []float32) {
	if len(dst) == 0 || len(a) == 0 || len(b) == 0 {
		return
	}
	n := int64(min(len(dst), min(len(a), len(b))))
	sub_slices_f32(
		unsafe.Pointer(&dst[0]),
		unsafe.Pointer(&a[0]),
		unsafe.Pointer(&b[0]),
		unsafe.Pointer(&n),
	)
}

// MulSlicesF32 performs element-wise multiplication: dst[i] = a[i] * b[i].
func MulSlicesF32(dst, a, b []float32) {
	if len(dst) == 0 || len(a) == 0 || len(b) == 0 {
		return
	}
	n := int64(min(len(dst), min(len(a), len(b))))
	mul_slices_f32(
		unsafe.Pointer(&dst[0]),
		unsafe.Pointer(&a[0]),
		unsafe.Pointer(&b[0]),
		unsafe.Pointer(&n),
	)
}

// ScaleF32 scales all elements by a constant: dst[i] = c * src[i].
func ScaleF32(dst, src []float32, c float32) {
	if len(dst) == 0 || len(src) == 0 {
		return
	}
	n := int64(min(len(dst), len(src)))
	scale_f32(
		unsafe.Pointer(&dst[0]),
		unsafe.Pointer(&src[0]),
		unsafe.Pointer(&c),
		unsafe.Pointer(&n),
	)
}

// AddConstF32 adds a constant to all elements: dst[i] += c.
func AddConstF32(dst []float32, c float32) {
	if len(dst) == 0 {
		return
	}
	n := int64(len(dst))
	add_const_f32(
		unsafe.Pointer(&dst[0]),
		unsafe.Pointer(&c),
		unsafe.Pointer(&n),
	)
}

// AxpyF32 performs dst[i] += a * x[i] (BLAS-like axpy operation).
func AxpyF32(dst, x []float32, a float32) {
	if len(dst) == 0 || len(x) == 0 {
		return
	}
	n := int64(min(len(dst), len(x)))
	axpy_f32(
		unsafe.Pointer(&dst[0]),
		unsafe.Pointer(&x[0]),
		unsafe.Pointer(&a),
		unsafe.Pointer(&n),
	)
}

// ============================================================================
// Unsigned Integer Reduce Operations (whole-loop SIMD)
// ============================================================================

// ReduceMaxU32 returns the maximum value in a uint32 slice using whole-loop SIMD.
// This keeps vectors in registers throughout the loop, avoiding ABI overhead.
func ReduceMaxU32(v []uint32) uint32 {
	if len(v) == 0 {
		return 0
	}
	n := int64(len(v))
	var result int64
	reduce_max_u32_neon(
		unsafe.Pointer(&v[0]),
		unsafe.Pointer(&n),
		unsafe.Pointer(&result),
	)
	return uint32(result)
}

// ReduceMaxU64 returns the maximum value in a uint64 slice using whole-loop SIMD.
// This keeps vectors in registers throughout the loop, avoiding ABI overhead.
func ReduceMaxU64(v []uint64) uint64 {
	if len(v) == 0 {
		return 0
	}
	n := int64(len(v))
	var result int64
	reduce_max_u64_neon(
		unsafe.Pointer(&v[0]),
		unsafe.Pointer(&n),
		unsafe.Pointer(&result),
	)
	return uint64(result)
}
