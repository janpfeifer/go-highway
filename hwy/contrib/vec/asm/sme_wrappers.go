// Copyright 2025 go-highway Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//go:build !noasm && darwin && arm64

// SME Streaming Mode Batch Operations for ARM64 with SME extension
// Uses SME streaming mode to amortize smstart/smstop overhead across multiple distance calculations.
package asm

import (
	"unsafe"
)

// -march=armv9-a+sme enables SME streaming mode support
//go:generate go tool goat ../c/batch_sme_arm64.c -O3 --target arm64 --target-os darwin -e="-march=armv9-a+sme"

// ============================================================================
// SME Streaming Mode Batch Dot Product
// ============================================================================

// BatchDotSME computes dot products of one query vector with multiple data vectors
// using SME streaming mode. Enters streaming mode once and processes all vectors,
// amortizing the smstart/smstop overhead.
//
// Parameters:
//   - query: query vector (dims elements)
//   - data: flattened data matrix (count × dims elements, row-major)
//   - dots: output buffer (count elements)
//   - count: number of data vectors
//   - dims: dimensionality of each vector
//
// For i in [0, count): dots[i] = dot(query, data[i])
func BatchDotSME(query []float32, data []float32, dots []float32, count, dims int) {
	if count <= 0 || dims <= 0 {
		return
	}
	if len(data) < count*dims || len(dots) < count || len(query) < dims {
		return
	}
	countVal := int64(count)
	dimsVal := int64(dims)
	batch_dot_sme_f32(
		unsafe.Pointer(&query[0]),
		unsafe.Pointer(&data[0]),
		unsafe.Pointer(&dots[0]),
		unsafe.Pointer(&countVal),
		unsafe.Pointer(&dimsVal),
	)
}

// BatchDotSME64 computes dot products using SME streaming mode for float64.
func BatchDotSME64(query []float64, data []float64, dots []float64, count, dims int) {
	if count <= 0 || dims <= 0 {
		return
	}
	if len(data) < count*dims || len(dots) < count || len(query) < dims {
		return
	}
	countVal := int64(count)
	dimsVal := int64(dims)
	batch_dot_sme_f64(
		unsafe.Pointer(&query[0]),
		unsafe.Pointer(&data[0]),
		unsafe.Pointer(&dots[0]),
		unsafe.Pointer(&countVal),
		unsafe.Pointer(&dimsVal),
	)
}

// ============================================================================
// SME Streaming Mode Batch L2 Squared Distance
// ============================================================================

// BatchL2SquaredSME computes L2 squared distances from one query to multiple data vectors
// using SME streaming mode. Enters streaming mode once and processes all vectors,
// amortizing the smstart/smstop overhead.
//
// Parameters:
//   - query: query vector (dims elements)
//   - data: flattened data matrix (count × dims elements, row-major)
//   - distances: output buffer (count elements)
//   - count: number of data vectors
//   - dims: dimensionality of each vector
//
// For i in [0, count): distances[i] = sum((query[j] - data[i*dims+j])^2)
func BatchL2SquaredSME(query []float32, data []float32, distances []float32, count, dims int) {
	if count <= 0 || dims <= 0 {
		return
	}
	if len(data) < count*dims || len(distances) < count || len(query) < dims {
		return
	}
	countVal := int64(count)
	dimsVal := int64(dims)
	batch_l2_squared_sme_f32(
		unsafe.Pointer(&query[0]),
		unsafe.Pointer(&data[0]),
		unsafe.Pointer(&distances[0]),
		unsafe.Pointer(&countVal),
		unsafe.Pointer(&dimsVal),
	)
}

// BatchL2SquaredSME64 computes L2 squared distances using SME streaming mode for float64.
func BatchL2SquaredSME64(query []float64, data []float64, distances []float64, count, dims int) {
	if count <= 0 || dims <= 0 {
		return
	}
	if len(data) < count*dims || len(distances) < count || len(query) < dims {
		return
	}
	countVal := int64(count)
	dimsVal := int64(dims)
	batch_l2_squared_sme_f64(
		unsafe.Pointer(&query[0]),
		unsafe.Pointer(&data[0]),
		unsafe.Pointer(&distances[0]),
		unsafe.Pointer(&countVal),
		unsafe.Pointer(&dimsVal),
	)
}

// Assembly function declarations will be in batch_sme_arm64.go (generated by GoAT)
