// Code generated by hwygen. DO NOT EDIT.

package vec

import (
	"github.com/ajroetker/go-highway/hwy"
)

func BaseArgmax_fallback_Float16(v []hwy.Float16) int {
	if len(v) == 0 {
		panic("vec: Argmax called on empty slice")
	}
	lanes := hwy.MaxLanes[hwy.Float16]()
	if len(v) < lanes {
		return scalarArgmax(v)
	}
	maxVals := hwy.Load(v)
	maxIdxs := hwy.Iota[hwy.Float16]()
	i := lanes
	for ; i+lanes <= len(v); i += lanes {
		vals := hwy.Load(v[i:])
		curIdxs := hwy.Add(hwy.Set(hwy.Float16(i)), hwy.Iota[hwy.Float16]())
		mask := hwy.GreaterThan(vals, maxVals)
		maxVals = hwy.IfThenElse(mask, vals, maxVals)
		maxIdxs = hwy.IfThenElse(mask, curIdxs, maxIdxs)
	}
	valsData := maxVals.Data()
	idxsData := maxIdxs.Data()
	bestIdx := 0
	var maxVal float32
	foundValid := false
	for j := 0; j < lanes; j++ {
		val := valsData[j]
		if val.Float32() != val.Float32() {
			continue
		}
		idx := int(idxsData[j].Float32())
		if !foundValid || val.Float32() > maxVal || (val.Float32() == maxVal && idx < bestIdx) {
			maxVal = val.Float32()
			bestIdx = idx
			foundValid = true
		}
	}
	for ; i < len(v); i++ {
		if v[i].Float32() != v[i].Float32() {
			continue
		}
		if !foundValid || v[i].Float32() > maxVal || (v[i].Float32() == maxVal && i < bestIdx) {
			maxVal = v[i].Float32()
			bestIdx = i
			foundValid = true
		}
	}
	return bestIdx
}

func BaseArgmax_fallback_BFloat16(v []hwy.BFloat16) int {
	if len(v) == 0 {
		panic("vec: Argmax called on empty slice")
	}
	lanes := hwy.MaxLanes[hwy.BFloat16]()
	if len(v) < lanes {
		return scalarArgmax(v)
	}
	maxVals := hwy.Load(v)
	maxIdxs := hwy.Iota[hwy.BFloat16]()
	i := lanes
	for ; i+lanes <= len(v); i += lanes {
		vals := hwy.Load(v[i:])
		curIdxs := hwy.Add(hwy.Set(hwy.BFloat16(i)), hwy.Iota[hwy.BFloat16]())
		mask := hwy.GreaterThan(vals, maxVals)
		maxVals = hwy.IfThenElse(mask, vals, maxVals)
		maxIdxs = hwy.IfThenElse(mask, curIdxs, maxIdxs)
	}
	valsData := maxVals.Data()
	idxsData := maxIdxs.Data()
	bestIdx := 0
	var maxVal float32
	foundValid := false
	for j := 0; j < lanes; j++ {
		val := valsData[j]
		if val.Float32() != val.Float32() {
			continue
		}
		idx := int(idxsData[j].Float32())
		if !foundValid || val.Float32() > maxVal || (val.Float32() == maxVal && idx < bestIdx) {
			maxVal = val.Float32()
			bestIdx = idx
			foundValid = true
		}
	}
	for ; i < len(v); i++ {
		if v[i].Float32() != v[i].Float32() {
			continue
		}
		if !foundValid || v[i].Float32() > maxVal || (v[i].Float32() == maxVal && i < bestIdx) {
			maxVal = v[i].Float32()
			bestIdx = i
			foundValid = true
		}
	}
	return bestIdx
}

func BaseArgmax_fallback(v []float32) int {
	if len(v) == 0 {
		panic("vec: Argmax called on empty slice")
	}
	lanes := hwy.MaxLanes[float32]()
	if len(v) < lanes {
		return scalarArgmax(v)
	}
	maxVals := hwy.Load(v)
	maxIdxs := hwy.Iota[float32]()
	i := lanes
	for ; i+lanes <= len(v); i += lanes {
		vals := hwy.Load(v[i:])
		curIdxs := hwy.Add(hwy.Set(float32(i)), hwy.Iota[float32]())
		mask := hwy.GreaterThan(vals, maxVals)
		maxVals = hwy.IfThenElse(mask, vals, maxVals)
		maxIdxs = hwy.IfThenElse(mask, curIdxs, maxIdxs)
	}
	valsData := maxVals.Data()
	idxsData := maxIdxs.Data()
	bestIdx := 0
	var maxVal float32
	foundValid := false
	for j := 0; j < lanes; j++ {
		val := valsData[j]
		if val != val {
			continue
		}
		idx := int(idxsData[j])
		if !foundValid || val > maxVal || (val == maxVal && idx < bestIdx) {
			maxVal = val
			bestIdx = idx
			foundValid = true
		}
	}
	for ; i < len(v); i++ {
		if v[i] != v[i] {
			continue
		}
		if !foundValid || v[i] > maxVal || (v[i] == maxVal && i < bestIdx) {
			maxVal = v[i]
			bestIdx = i
			foundValid = true
		}
	}
	return bestIdx
}

func BaseArgmax_fallback_Float64(v []float64) int {
	if len(v) == 0 {
		panic("vec: Argmax called on empty slice")
	}
	lanes := hwy.MaxLanes[float64]()
	if len(v) < lanes {
		return scalarArgmax(v)
	}
	maxVals := hwy.Load(v)
	maxIdxs := hwy.Iota[float64]()
	i := lanes
	for ; i+lanes <= len(v); i += lanes {
		vals := hwy.Load(v[i:])
		curIdxs := hwy.Add(hwy.Set(float64(i)), hwy.Iota[float64]())
		mask := hwy.GreaterThan(vals, maxVals)
		maxVals = hwy.IfThenElse(mask, vals, maxVals)
		maxIdxs = hwy.IfThenElse(mask, curIdxs, maxIdxs)
	}
	valsData := maxVals.Data()
	idxsData := maxIdxs.Data()
	bestIdx := 0
	var maxVal float64
	foundValid := false
	for j := 0; j < lanes; j++ {
		val := valsData[j]
		if val != val {
			continue
		}
		idx := int(idxsData[j])
		if !foundValid || val > maxVal || (val == maxVal && idx < bestIdx) {
			maxVal = val
			bestIdx = idx
			foundValid = true
		}
	}
	for ; i < len(v); i++ {
		if v[i] != v[i] {
			continue
		}
		if !foundValid || v[i] > maxVal || (v[i] == maxVal && i < bestIdx) {
			maxVal = v[i]
			bestIdx = i
			foundValid = true
		}
	}
	return bestIdx
}

func BaseArgmin_fallback_Float16(v []hwy.Float16) int {
	if len(v) == 0 {
		panic("vec: Argmin called on empty slice")
	}
	lanes := hwy.MaxLanes[hwy.Float16]()
	if len(v) < lanes {
		return scalarArgmin(v)
	}
	minVals := hwy.Load(v)
	minIdxs := hwy.Iota[hwy.Float16]()
	i := lanes
	for ; i+lanes <= len(v); i += lanes {
		vals := hwy.Load(v[i:])
		curIdxs := hwy.Add(hwy.Set(hwy.Float16(i)), hwy.Iota[hwy.Float16]())
		mask := hwy.LessThan(vals, minVals)
		minVals = hwy.IfThenElse(mask, vals, minVals)
		minIdxs = hwy.IfThenElse(mask, curIdxs, minIdxs)
	}
	valsData := minVals.Data()
	idxsData := minIdxs.Data()
	bestIdx := 0
	var minVal float32
	foundValid := false
	for j := 0; j < lanes; j++ {
		val := valsData[j]
		if val.Float32() != val.Float32() {
			continue
		}
		idx := int(idxsData[j].Float32())
		if !foundValid || val.Float32() < minVal || (val.Float32() == minVal && idx < bestIdx) {
			minVal = val.Float32()
			bestIdx = idx
			foundValid = true
		}
	}
	for ; i < len(v); i++ {
		if v[i].Float32() != v[i].Float32() {
			continue
		}
		if !foundValid || v[i].Float32() < minVal || (v[i].Float32() == minVal && i < bestIdx) {
			minVal = v[i].Float32()
			bestIdx = i
			foundValid = true
		}
	}
	return bestIdx
}

func BaseArgmin_fallback_BFloat16(v []hwy.BFloat16) int {
	if len(v) == 0 {
		panic("vec: Argmin called on empty slice")
	}
	lanes := hwy.MaxLanes[hwy.BFloat16]()
	if len(v) < lanes {
		return scalarArgmin(v)
	}
	minVals := hwy.Load(v)
	minIdxs := hwy.Iota[hwy.BFloat16]()
	i := lanes
	for ; i+lanes <= len(v); i += lanes {
		vals := hwy.Load(v[i:])
		curIdxs := hwy.Add(hwy.Set(hwy.BFloat16(i)), hwy.Iota[hwy.BFloat16]())
		mask := hwy.LessThan(vals, minVals)
		minVals = hwy.IfThenElse(mask, vals, minVals)
		minIdxs = hwy.IfThenElse(mask, curIdxs, minIdxs)
	}
	valsData := minVals.Data()
	idxsData := minIdxs.Data()
	bestIdx := 0
	var minVal float32
	foundValid := false
	for j := 0; j < lanes; j++ {
		val := valsData[j]
		if val.Float32() != val.Float32() {
			continue
		}
		idx := int(idxsData[j].Float32())
		if !foundValid || val.Float32() < minVal || (val.Float32() == minVal && idx < bestIdx) {
			minVal = val.Float32()
			bestIdx = idx
			foundValid = true
		}
	}
	for ; i < len(v); i++ {
		if v[i].Float32() != v[i].Float32() {
			continue
		}
		if !foundValid || v[i].Float32() < minVal || (v[i].Float32() == minVal && i < bestIdx) {
			minVal = v[i].Float32()
			bestIdx = i
			foundValid = true
		}
	}
	return bestIdx
}

func BaseArgmin_fallback(v []float32) int {
	if len(v) == 0 {
		panic("vec: Argmin called on empty slice")
	}
	lanes := hwy.MaxLanes[float32]()
	if len(v) < lanes {
		return scalarArgmin(v)
	}
	minVals := hwy.Load(v)
	minIdxs := hwy.Iota[float32]()
	i := lanes
	for ; i+lanes <= len(v); i += lanes {
		vals := hwy.Load(v[i:])
		curIdxs := hwy.Add(hwy.Set(float32(i)), hwy.Iota[float32]())
		mask := hwy.LessThan(vals, minVals)
		minVals = hwy.IfThenElse(mask, vals, minVals)
		minIdxs = hwy.IfThenElse(mask, curIdxs, minIdxs)
	}
	valsData := minVals.Data()
	idxsData := minIdxs.Data()
	bestIdx := 0
	var minVal float32
	foundValid := false
	for j := 0; j < lanes; j++ {
		val := valsData[j]
		if val != val {
			continue
		}
		idx := int(idxsData[j])
		if !foundValid || val < minVal || (val == minVal && idx < bestIdx) {
			minVal = val
			bestIdx = idx
			foundValid = true
		}
	}
	for ; i < len(v); i++ {
		if v[i] != v[i] {
			continue
		}
		if !foundValid || v[i] < minVal || (v[i] == minVal && i < bestIdx) {
			minVal = v[i]
			bestIdx = i
			foundValid = true
		}
	}
	return bestIdx
}

func BaseArgmin_fallback_Float64(v []float64) int {
	if len(v) == 0 {
		panic("vec: Argmin called on empty slice")
	}
	lanes := hwy.MaxLanes[float64]()
	if len(v) < lanes {
		return scalarArgmin(v)
	}
	minVals := hwy.Load(v)
	minIdxs := hwy.Iota[float64]()
	i := lanes
	for ; i+lanes <= len(v); i += lanes {
		vals := hwy.Load(v[i:])
		curIdxs := hwy.Add(hwy.Set(float64(i)), hwy.Iota[float64]())
		mask := hwy.LessThan(vals, minVals)
		minVals = hwy.IfThenElse(mask, vals, minVals)
		minIdxs = hwy.IfThenElse(mask, curIdxs, minIdxs)
	}
	valsData := minVals.Data()
	idxsData := minIdxs.Data()
	bestIdx := 0
	var minVal float64
	foundValid := false
	for j := 0; j < lanes; j++ {
		val := valsData[j]
		if val != val {
			continue
		}
		idx := int(idxsData[j])
		if !foundValid || val < minVal || (val == minVal && idx < bestIdx) {
			minVal = val
			bestIdx = idx
			foundValid = true
		}
	}
	for ; i < len(v); i++ {
		if v[i] != v[i] {
			continue
		}
		if !foundValid || v[i] < minVal || (v[i] == minVal && i < bestIdx) {
			minVal = v[i]
			bestIdx = i
			foundValid = true
		}
	}
	return bestIdx
}
