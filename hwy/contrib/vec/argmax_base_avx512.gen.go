// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

//go:build amd64 && goexperiment.simd

package vec

import (
	"simd/archsimd"
	"unsafe"

	"github.com/ajroetker/go-highway/hwy"
	"github.com/ajroetker/go-highway/hwy/asm"
)

func BaseArgmax_avx512_Float16(v []hwy.Float16) int {
	if len(v) == 0 {
		panic("vec: Argmax called on empty slice")
	}
	lanes := 16
	if len(v) < lanes {
		return scalarArgmax(v)
	}
	maxVals := asm.LoadFloat16x16AVX512Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(v))), len(v)))
	maxIdxs := asm.IotaFloat16x16AVX512()
	i := lanes
	for ; i+lanes*3 <= len(v); i += lanes * 3 {
		vals := asm.LoadFloat16x16AVX512Ptr(unsafe.Pointer(&v[i:][0]))
		curIdxs := asm.BroadcastFloat16x16AVX512(uint16(hwy.Float16(i))).Add(asm.IotaFloat16x16AVX512())
		mask := vals.Greater(maxVals)
		maxVals = vals.Merge(maxVals, mask)
		maxIdxs = curIdxs.Merge(maxIdxs, mask)
		vals1 := asm.LoadFloat16x16AVX512Ptr(unsafe.Pointer(&v[i+16:][0]))
		curIdxs1 := asm.BroadcastFloat16x16AVX512(uint16(hwy.Float16(i))).Add(asm.IotaFloat16x16AVX512())
		mask1 := vals1.Greater(maxVals)
		maxVals = vals1.Merge(maxVals, mask1)
		maxIdxs = curIdxs1.Merge(maxIdxs, mask1)
		vals2 := asm.LoadFloat16x16AVX512Ptr(unsafe.Pointer(&v[i+32:][0]))
		curIdxs2 := asm.BroadcastFloat16x16AVX512(uint16(hwy.Float16(i))).Add(asm.IotaFloat16x16AVX512())
		mask2 := vals2.Greater(maxVals)
		maxVals = vals2.Merge(maxVals, mask2)
		maxIdxs = curIdxs2.Merge(maxIdxs, mask2)
	}
	valsData := func() []hwy.Float16 {
		var _simd_tmp [16]hwy.Float16
		maxVals.StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(_simd_tmp[:]))), len(_simd_tmp[:])))
		return _simd_tmp[:]
	}()
	idxsData := func() []hwy.Float16 {
		var _simd_tmp [16]hwy.Float16
		maxIdxs.StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(_simd_tmp[:]))), len(_simd_tmp[:])))
		return _simd_tmp[:]
	}()
	bestIdx := 0
	var maxVal float32
	foundValid := false
	for j := range lanes {
		val := valsData[j]
		if val.Float32() != val.Float32() {
			continue
		}
		idx := int(idxsData[j].Float32())
		if !foundValid || val.Float32() > maxVal || (val.Float32() == maxVal && idx < bestIdx) {
			maxVal = val.Float32()
			bestIdx = idx
			foundValid = true
		}
	}
	for ; i < len(v); i++ {
		if v[i].Float32() != v[i].Float32() {
			continue
		}
		if !foundValid || v[i].Float32() > maxVal || (v[i].Float32() == maxVal && i < bestIdx) {
			maxVal = v[i].Float32()
			bestIdx = i
			foundValid = true
		}
	}
	return bestIdx
}

func BaseArgmax_avx512_BFloat16(v []hwy.BFloat16) int {
	if len(v) == 0 {
		panic("vec: Argmax called on empty slice")
	}
	lanes := 16
	if len(v) < lanes {
		return scalarArgmax(v)
	}
	maxVals := asm.LoadBFloat16x16AVX512Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(v))), len(v)))
	maxIdxs := asm.IotaBFloat16x16AVX512()
	i := lanes
	for ; i+lanes*3 <= len(v); i += lanes * 3 {
		vals := asm.LoadBFloat16x16AVX512Ptr(unsafe.Pointer(&v[i:][0]))
		curIdxs := asm.BroadcastBFloat16x16AVX512(uint16(hwy.BFloat16(i))).Add(asm.IotaBFloat16x16AVX512())
		mask := vals.Greater(maxVals)
		maxVals = vals.Merge(maxVals, mask)
		maxIdxs = curIdxs.Merge(maxIdxs, mask)
		vals1 := asm.LoadBFloat16x16AVX512Ptr(unsafe.Pointer(&v[i+16:][0]))
		curIdxs1 := asm.BroadcastBFloat16x16AVX512(uint16(hwy.BFloat16(i))).Add(asm.IotaBFloat16x16AVX512())
		mask1 := vals1.Greater(maxVals)
		maxVals = vals1.Merge(maxVals, mask1)
		maxIdxs = curIdxs1.Merge(maxIdxs, mask1)
		vals2 := asm.LoadBFloat16x16AVX512Ptr(unsafe.Pointer(&v[i+32:][0]))
		curIdxs2 := asm.BroadcastBFloat16x16AVX512(uint16(hwy.BFloat16(i))).Add(asm.IotaBFloat16x16AVX512())
		mask2 := vals2.Greater(maxVals)
		maxVals = vals2.Merge(maxVals, mask2)
		maxIdxs = curIdxs2.Merge(maxIdxs, mask2)
	}
	valsData := func() []hwy.BFloat16 {
		var _simd_tmp [16]hwy.BFloat16
		maxVals.StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(_simd_tmp[:]))), len(_simd_tmp[:])))
		return _simd_tmp[:]
	}()
	idxsData := func() []hwy.BFloat16 {
		var _simd_tmp [16]hwy.BFloat16
		maxIdxs.StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(_simd_tmp[:]))), len(_simd_tmp[:])))
		return _simd_tmp[:]
	}()
	bestIdx := 0
	var maxVal float32
	foundValid := false
	for j := range lanes {
		val := valsData[j]
		if val.Float32() != val.Float32() {
			continue
		}
		idx := int(idxsData[j].Float32())
		if !foundValid || val.Float32() > maxVal || (val.Float32() == maxVal && idx < bestIdx) {
			maxVal = val.Float32()
			bestIdx = idx
			foundValid = true
		}
	}
	for ; i < len(v); i++ {
		if v[i].Float32() != v[i].Float32() {
			continue
		}
		if !foundValid || v[i].Float32() > maxVal || (v[i].Float32() == maxVal && i < bestIdx) {
			maxVal = v[i].Float32()
			bestIdx = i
			foundValid = true
		}
	}
	return bestIdx
}

func BaseArgmax_avx512(v []float32) int {
	if len(v) == 0 {
		panic("vec: Argmax called on empty slice")
	}
	lanes := 16
	if len(v) < lanes {
		return scalarArgmax(v)
	}
	maxVals := archsimd.LoadFloat32x16Slice(v)
	maxIdxs := hwy.Iota_AVX512_F32x16()
	i := lanes
	for ; i+lanes*3 <= len(v); i += lanes * 3 {
		vals := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&v[i])))
		curIdxs := archsimd.BroadcastFloat32x16(float32(i)).Add(hwy.Iota_AVX512_F32x16())
		mask := vals.Greater(maxVals)
		maxVals = hwy.IfThenElse_AVX512_F32x16(mask, vals, maxVals)
		maxIdxs = hwy.IfThenElse_AVX512_F32x16(mask, curIdxs, maxIdxs)
		vals1 := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&v[i+16])))
		curIdxs1 := archsimd.BroadcastFloat32x16(float32(i)).Add(hwy.Iota_AVX512_F32x16())
		mask1 := vals1.Greater(maxVals)
		maxVals = hwy.IfThenElse_AVX512_F32x16(mask1, vals1, maxVals)
		maxIdxs = hwy.IfThenElse_AVX512_F32x16(mask1, curIdxs1, maxIdxs)
		vals2 := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&v[i+32])))
		curIdxs2 := archsimd.BroadcastFloat32x16(float32(i)).Add(hwy.Iota_AVX512_F32x16())
		mask2 := vals2.Greater(maxVals)
		maxVals = hwy.IfThenElse_AVX512_F32x16(mask2, vals2, maxVals)
		maxIdxs = hwy.IfThenElse_AVX512_F32x16(mask2, curIdxs2, maxIdxs)
	}
	valsData := func() []float32 {
		var _simd_tmp [16]float32
		maxVals.StoreSlice(_simd_tmp[:])
		return _simd_tmp[:]
	}()
	idxsData := func() []float32 {
		var _simd_tmp [16]float32
		maxIdxs.StoreSlice(_simd_tmp[:])
		return _simd_tmp[:]
	}()
	bestIdx := 0
	var maxVal float32
	foundValid := false
	for j := range lanes {
		val := valsData[j]
		if val != val {
			continue
		}
		idx := int(idxsData[j])
		if !foundValid || val > maxVal || (val == maxVal && idx < bestIdx) {
			maxVal = val
			bestIdx = idx
			foundValid = true
		}
	}
	for ; i < len(v); i++ {
		if v[i] != v[i] {
			continue
		}
		if !foundValid || v[i] > maxVal || (v[i] == maxVal && i < bestIdx) {
			maxVal = v[i]
			bestIdx = i
			foundValid = true
		}
	}
	return bestIdx
}

func BaseArgmax_avx512_Float64(v []float64) int {
	if len(v) == 0 {
		panic("vec: Argmax called on empty slice")
	}
	lanes := 8
	if len(v) < lanes {
		return scalarArgmax(v)
	}
	maxVals := archsimd.LoadFloat64x8Slice(v)
	maxIdxs := hwy.Iota_AVX512_F64x8()
	i := lanes
	for ; i+lanes*3 <= len(v); i += lanes * 3 {
		vals := archsimd.LoadFloat64x8((*[8]float64)(unsafe.Pointer(&v[i])))
		curIdxs := archsimd.BroadcastFloat64x8(float64(i)).Add(hwy.Iota_AVX512_F64x8())
		mask := vals.Greater(maxVals)
		maxVals = hwy.IfThenElse_AVX512_F64x8(mask, vals, maxVals)
		maxIdxs = hwy.IfThenElse_AVX512_F64x8(mask, curIdxs, maxIdxs)
		vals1 := archsimd.LoadFloat64x8((*[8]float64)(unsafe.Pointer(&v[i+8])))
		curIdxs1 := archsimd.BroadcastFloat64x8(float64(i)).Add(hwy.Iota_AVX512_F64x8())
		mask1 := vals1.Greater(maxVals)
		maxVals = hwy.IfThenElse_AVX512_F64x8(mask1, vals1, maxVals)
		maxIdxs = hwy.IfThenElse_AVX512_F64x8(mask1, curIdxs1, maxIdxs)
		vals2 := archsimd.LoadFloat64x8((*[8]float64)(unsafe.Pointer(&v[i+16])))
		curIdxs2 := archsimd.BroadcastFloat64x8(float64(i)).Add(hwy.Iota_AVX512_F64x8())
		mask2 := vals2.Greater(maxVals)
		maxVals = hwy.IfThenElse_AVX512_F64x8(mask2, vals2, maxVals)
		maxIdxs = hwy.IfThenElse_AVX512_F64x8(mask2, curIdxs2, maxIdxs)
	}
	valsData := func() []float64 {
		var _simd_tmp [8]float64
		maxVals.StoreSlice(_simd_tmp[:])
		return _simd_tmp[:]
	}()
	idxsData := func() []float64 {
		var _simd_tmp [8]float64
		maxIdxs.StoreSlice(_simd_tmp[:])
		return _simd_tmp[:]
	}()
	bestIdx := 0
	var maxVal float64
	foundValid := false
	for j := range lanes {
		val := valsData[j]
		if val != val {
			continue
		}
		idx := int(idxsData[j])
		if !foundValid || val > maxVal || (val == maxVal && idx < bestIdx) {
			maxVal = val
			bestIdx = idx
			foundValid = true
		}
	}
	for ; i < len(v); i++ {
		if v[i] != v[i] {
			continue
		}
		if !foundValid || v[i] > maxVal || (v[i] == maxVal && i < bestIdx) {
			maxVal = v[i]
			bestIdx = i
			foundValid = true
		}
	}
	return bestIdx
}

func BaseArgmin_avx512_Float16(v []hwy.Float16) int {
	if len(v) == 0 {
		panic("vec: Argmin called on empty slice")
	}
	lanes := 16
	if len(v) < lanes {
		return scalarArgmin(v)
	}
	minVals := asm.LoadFloat16x16AVX512Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(v))), len(v)))
	minIdxs := asm.IotaFloat16x16AVX512()
	i := lanes
	for ; i+lanes*3 <= len(v); i += lanes * 3 {
		vals := asm.LoadFloat16x16AVX512Ptr(unsafe.Pointer(&v[i:][0]))
		curIdxs := asm.BroadcastFloat16x16AVX512(uint16(hwy.Float16(i))).Add(asm.IotaFloat16x16AVX512())
		mask := vals.Less(minVals)
		minVals = vals.Merge(minVals, mask)
		minIdxs = curIdxs.Merge(minIdxs, mask)
		vals1 := asm.LoadFloat16x16AVX512Ptr(unsafe.Pointer(&v[i+16:][0]))
		curIdxs1 := asm.BroadcastFloat16x16AVX512(uint16(hwy.Float16(i))).Add(asm.IotaFloat16x16AVX512())
		mask1 := vals1.Less(minVals)
		minVals = vals1.Merge(minVals, mask1)
		minIdxs = curIdxs1.Merge(minIdxs, mask1)
		vals2 := asm.LoadFloat16x16AVX512Ptr(unsafe.Pointer(&v[i+32:][0]))
		curIdxs2 := asm.BroadcastFloat16x16AVX512(uint16(hwy.Float16(i))).Add(asm.IotaFloat16x16AVX512())
		mask2 := vals2.Less(minVals)
		minVals = vals2.Merge(minVals, mask2)
		minIdxs = curIdxs2.Merge(minIdxs, mask2)
	}
	valsData := func() []hwy.Float16 {
		var _simd_tmp [16]hwy.Float16
		minVals.StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(_simd_tmp[:]))), len(_simd_tmp[:])))
		return _simd_tmp[:]
	}()
	idxsData := func() []hwy.Float16 {
		var _simd_tmp [16]hwy.Float16
		minIdxs.StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(_simd_tmp[:]))), len(_simd_tmp[:])))
		return _simd_tmp[:]
	}()
	bestIdx := 0
	var minVal float32
	foundValid := false
	for j := range lanes {
		val := valsData[j]
		if val.Float32() != val.Float32() {
			continue
		}
		idx := int(idxsData[j].Float32())
		if !foundValid || val.Float32() < minVal || (val.Float32() == minVal && idx < bestIdx) {
			minVal = val.Float32()
			bestIdx = idx
			foundValid = true
		}
	}
	for ; i < len(v); i++ {
		if v[i].Float32() != v[i].Float32() {
			continue
		}
		if !foundValid || v[i].Float32() < minVal || (v[i].Float32() == minVal && i < bestIdx) {
			minVal = v[i].Float32()
			bestIdx = i
			foundValid = true
		}
	}
	return bestIdx
}

func BaseArgmin_avx512_BFloat16(v []hwy.BFloat16) int {
	if len(v) == 0 {
		panic("vec: Argmin called on empty slice")
	}
	lanes := 16
	if len(v) < lanes {
		return scalarArgmin(v)
	}
	minVals := asm.LoadBFloat16x16AVX512Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(v))), len(v)))
	minIdxs := asm.IotaBFloat16x16AVX512()
	i := lanes
	for ; i+lanes*3 <= len(v); i += lanes * 3 {
		vals := asm.LoadBFloat16x16AVX512Ptr(unsafe.Pointer(&v[i:][0]))
		curIdxs := asm.BroadcastBFloat16x16AVX512(uint16(hwy.BFloat16(i))).Add(asm.IotaBFloat16x16AVX512())
		mask := vals.Less(minVals)
		minVals = vals.Merge(minVals, mask)
		minIdxs = curIdxs.Merge(minIdxs, mask)
		vals1 := asm.LoadBFloat16x16AVX512Ptr(unsafe.Pointer(&v[i+16:][0]))
		curIdxs1 := asm.BroadcastBFloat16x16AVX512(uint16(hwy.BFloat16(i))).Add(asm.IotaBFloat16x16AVX512())
		mask1 := vals1.Less(minVals)
		minVals = vals1.Merge(minVals, mask1)
		minIdxs = curIdxs1.Merge(minIdxs, mask1)
		vals2 := asm.LoadBFloat16x16AVX512Ptr(unsafe.Pointer(&v[i+32:][0]))
		curIdxs2 := asm.BroadcastBFloat16x16AVX512(uint16(hwy.BFloat16(i))).Add(asm.IotaBFloat16x16AVX512())
		mask2 := vals2.Less(minVals)
		minVals = vals2.Merge(minVals, mask2)
		minIdxs = curIdxs2.Merge(minIdxs, mask2)
	}
	valsData := func() []hwy.BFloat16 {
		var _simd_tmp [16]hwy.BFloat16
		minVals.StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(_simd_tmp[:]))), len(_simd_tmp[:])))
		return _simd_tmp[:]
	}()
	idxsData := func() []hwy.BFloat16 {
		var _simd_tmp [16]hwy.BFloat16
		minIdxs.StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(_simd_tmp[:]))), len(_simd_tmp[:])))
		return _simd_tmp[:]
	}()
	bestIdx := 0
	var minVal float32
	foundValid := false
	for j := range lanes {
		val := valsData[j]
		if val.Float32() != val.Float32() {
			continue
		}
		idx := int(idxsData[j].Float32())
		if !foundValid || val.Float32() < minVal || (val.Float32() == minVal && idx < bestIdx) {
			minVal = val.Float32()
			bestIdx = idx
			foundValid = true
		}
	}
	for ; i < len(v); i++ {
		if v[i].Float32() != v[i].Float32() {
			continue
		}
		if !foundValid || v[i].Float32() < minVal || (v[i].Float32() == minVal && i < bestIdx) {
			minVal = v[i].Float32()
			bestIdx = i
			foundValid = true
		}
	}
	return bestIdx
}

func BaseArgmin_avx512(v []float32) int {
	if len(v) == 0 {
		panic("vec: Argmin called on empty slice")
	}
	lanes := 16
	if len(v) < lanes {
		return scalarArgmin(v)
	}
	minVals := archsimd.LoadFloat32x16Slice(v)
	minIdxs := hwy.Iota_AVX512_F32x16()
	i := lanes
	for ; i+lanes*3 <= len(v); i += lanes * 3 {
		vals := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&v[i])))
		curIdxs := archsimd.BroadcastFloat32x16(float32(i)).Add(hwy.Iota_AVX512_F32x16())
		mask := vals.Less(minVals)
		minVals = hwy.IfThenElse_AVX512_F32x16(mask, vals, minVals)
		minIdxs = hwy.IfThenElse_AVX512_F32x16(mask, curIdxs, minIdxs)
		vals1 := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&v[i+16])))
		curIdxs1 := archsimd.BroadcastFloat32x16(float32(i)).Add(hwy.Iota_AVX512_F32x16())
		mask1 := vals1.Less(minVals)
		minVals = hwy.IfThenElse_AVX512_F32x16(mask1, vals1, minVals)
		minIdxs = hwy.IfThenElse_AVX512_F32x16(mask1, curIdxs1, minIdxs)
		vals2 := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&v[i+32])))
		curIdxs2 := archsimd.BroadcastFloat32x16(float32(i)).Add(hwy.Iota_AVX512_F32x16())
		mask2 := vals2.Less(minVals)
		minVals = hwy.IfThenElse_AVX512_F32x16(mask2, vals2, minVals)
		minIdxs = hwy.IfThenElse_AVX512_F32x16(mask2, curIdxs2, minIdxs)
	}
	valsData := func() []float32 {
		var _simd_tmp [16]float32
		minVals.StoreSlice(_simd_tmp[:])
		return _simd_tmp[:]
	}()
	idxsData := func() []float32 {
		var _simd_tmp [16]float32
		minIdxs.StoreSlice(_simd_tmp[:])
		return _simd_tmp[:]
	}()
	bestIdx := 0
	var minVal float32
	foundValid := false
	for j := range lanes {
		val := valsData[j]
		if val != val {
			continue
		}
		idx := int(idxsData[j])
		if !foundValid || val < minVal || (val == minVal && idx < bestIdx) {
			minVal = val
			bestIdx = idx
			foundValid = true
		}
	}
	for ; i < len(v); i++ {
		if v[i] != v[i] {
			continue
		}
		if !foundValid || v[i] < minVal || (v[i] == minVal && i < bestIdx) {
			minVal = v[i]
			bestIdx = i
			foundValid = true
		}
	}
	return bestIdx
}

func BaseArgmin_avx512_Float64(v []float64) int {
	if len(v) == 0 {
		panic("vec: Argmin called on empty slice")
	}
	lanes := 8
	if len(v) < lanes {
		return scalarArgmin(v)
	}
	minVals := archsimd.LoadFloat64x8Slice(v)
	minIdxs := hwy.Iota_AVX512_F64x8()
	i := lanes
	for ; i+lanes*3 <= len(v); i += lanes * 3 {
		vals := archsimd.LoadFloat64x8((*[8]float64)(unsafe.Pointer(&v[i])))
		curIdxs := archsimd.BroadcastFloat64x8(float64(i)).Add(hwy.Iota_AVX512_F64x8())
		mask := vals.Less(minVals)
		minVals = hwy.IfThenElse_AVX512_F64x8(mask, vals, minVals)
		minIdxs = hwy.IfThenElse_AVX512_F64x8(mask, curIdxs, minIdxs)
		vals1 := archsimd.LoadFloat64x8((*[8]float64)(unsafe.Pointer(&v[i+8])))
		curIdxs1 := archsimd.BroadcastFloat64x8(float64(i)).Add(hwy.Iota_AVX512_F64x8())
		mask1 := vals1.Less(minVals)
		minVals = hwy.IfThenElse_AVX512_F64x8(mask1, vals1, minVals)
		minIdxs = hwy.IfThenElse_AVX512_F64x8(mask1, curIdxs1, minIdxs)
		vals2 := archsimd.LoadFloat64x8((*[8]float64)(unsafe.Pointer(&v[i+16])))
		curIdxs2 := archsimd.BroadcastFloat64x8(float64(i)).Add(hwy.Iota_AVX512_F64x8())
		mask2 := vals2.Less(minVals)
		minVals = hwy.IfThenElse_AVX512_F64x8(mask2, vals2, minVals)
		minIdxs = hwy.IfThenElse_AVX512_F64x8(mask2, curIdxs2, minIdxs)
	}
	valsData := func() []float64 {
		var _simd_tmp [8]float64
		minVals.StoreSlice(_simd_tmp[:])
		return _simd_tmp[:]
	}()
	idxsData := func() []float64 {
		var _simd_tmp [8]float64
		minIdxs.StoreSlice(_simd_tmp[:])
		return _simd_tmp[:]
	}()
	bestIdx := 0
	var minVal float64
	foundValid := false
	for j := range lanes {
		val := valsData[j]
		if val != val {
			continue
		}
		idx := int(idxsData[j])
		if !foundValid || val < minVal || (val == minVal && idx < bestIdx) {
			minVal = val
			bestIdx = idx
			foundValid = true
		}
	}
	for ; i < len(v); i++ {
		if v[i] != v[i] {
			continue
		}
		if !foundValid || v[i] < minVal || (v[i] == minVal && i < bestIdx) {
			minVal = v[i]
			bestIdx = i
			foundValid = true
		}
	}
	return bestIdx
}
