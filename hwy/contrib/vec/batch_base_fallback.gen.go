// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

package vec

import (
	"github.com/ajroetker/go-highway/hwy"
)

func BaseBatchL2SquaredDistance_fallback_Float16(query []hwy.Float16, data []hwy.Float16, distances []hwy.Float16, count int, dims int) {
	if count <= 0 || dims <= 0 {
		return
	}
	if len(data) < count*dims {
		return
	}
	if len(distances) < count {
		return
	}
	if len(query) < dims {
		return
	}
	sum := hwy.Zero[hwy.Float16]()
	lanes := sum.NumLanes()
	for i := range count {
		dataStart := i * dims
		dataVec := data[dataStart : dataStart+dims]
		sum = hwy.Zero[hwy.Float16]()
		var j int
		for j = 0; j+lanes <= dims; j += lanes {
			vq := hwy.Load(query[j:])
			vd := hwy.Load(dataVec[j:])
			diff := hwy.Sub(vq, vd)
			diffSq := hwy.Mul(diff, diff)
			sum = hwy.Add(sum, diffSq)
		}
		result := hwy.ReduceSum(sum).Float32()
		for ; j < dims; j++ {
			diff := query[j].Float32() - dataVec[j].Float32()
			result += diff * diff
		}
		distances[i] = hwy.Float32ToFloat16(result)
	}
}

func BaseBatchL2SquaredDistance_fallback_BFloat16(query []hwy.BFloat16, data []hwy.BFloat16, distances []hwy.BFloat16, count int, dims int) {
	if count <= 0 || dims <= 0 {
		return
	}
	if len(data) < count*dims {
		return
	}
	if len(distances) < count {
		return
	}
	if len(query) < dims {
		return
	}
	sum := hwy.Zero[hwy.BFloat16]()
	lanes := sum.NumLanes()
	for i := range count {
		dataStart := i * dims
		dataVec := data[dataStart : dataStart+dims]
		sum = hwy.Zero[hwy.BFloat16]()
		var j int
		for j = 0; j+lanes <= dims; j += lanes {
			vq := hwy.Load(query[j:])
			vd := hwy.Load(dataVec[j:])
			diff := hwy.Sub(vq, vd)
			diffSq := hwy.Mul(diff, diff)
			sum = hwy.Add(sum, diffSq)
		}
		result := hwy.ReduceSum(sum).Float32()
		for ; j < dims; j++ {
			diff := query[j].Float32() - dataVec[j].Float32()
			result += diff * diff
		}
		distances[i] = hwy.Float32ToBFloat16(result)
	}
}

func BaseBatchL2SquaredDistance_fallback(query []float32, data []float32, distances []float32, count int, dims int) {
	if count <= 0 || dims <= 0 {
		return
	}
	if len(data) < count*dims {
		return
	}
	if len(distances) < count {
		return
	}
	if len(query) < dims {
		return
	}
	sum := hwy.Zero[float32]()
	lanes := sum.NumLanes()
	for i := range count {
		dataStart := i * dims
		dataVec := data[dataStart : dataStart+dims]
		sum = hwy.Zero[float32]()
		var j int
		for j = 0; j+lanes <= dims; j += lanes {
			vq := hwy.Load(query[j:])
			vd := hwy.Load(dataVec[j:])
			diff := hwy.Sub(vq, vd)
			diffSq := hwy.Mul(diff, diff)
			sum = hwy.Add(sum, diffSq)
		}
		result := hwy.ReduceSum(sum)
		for ; j < dims; j++ {
			diff := query[j] - dataVec[j]
			result += diff * diff
		}
		distances[i] = result
	}
}

func BaseBatchL2SquaredDistance_fallback_Float64(query []float64, data []float64, distances []float64, count int, dims int) {
	if count <= 0 || dims <= 0 {
		return
	}
	if len(data) < count*dims {
		return
	}
	if len(distances) < count {
		return
	}
	if len(query) < dims {
		return
	}
	sum := hwy.Zero[float64]()
	lanes := sum.NumLanes()
	for i := range count {
		dataStart := i * dims
		dataVec := data[dataStart : dataStart+dims]
		sum = hwy.Zero[float64]()
		var j int
		for j = 0; j+lanes <= dims; j += lanes {
			vq := hwy.Load(query[j:])
			vd := hwy.Load(dataVec[j:])
			diff := hwy.Sub(vq, vd)
			diffSq := hwy.Mul(diff, diff)
			sum = hwy.Add(sum, diffSq)
		}
		result := hwy.ReduceSum(sum)
		for ; j < dims; j++ {
			diff := query[j] - dataVec[j]
			result += diff * diff
		}
		distances[i] = result
	}
}

func BaseBatchDot_fallback_Float16(query []hwy.Float16, data []hwy.Float16, dots []hwy.Float16, count int, dims int) {
	if count <= 0 || dims <= 0 {
		return
	}
	if len(data) < count*dims {
		return
	}
	if len(dots) < count {
		return
	}
	if len(query) < dims {
		return
	}
	sum := hwy.Zero[hwy.Float16]()
	lanes := sum.NumLanes()
	for i := range count {
		dataStart := i * dims
		dataVec := data[dataStart : dataStart+dims]
		sum = hwy.Zero[hwy.Float16]()
		var j int
		for j = 0; j+lanes <= dims; j += lanes {
			vq := hwy.Load(query[j:])
			vd := hwy.Load(dataVec[j:])
			prod := hwy.Mul(vq, vd)
			sum = hwy.Add(sum, prod)
		}
		result := hwy.ReduceSum(sum).Float32()
		for ; j < dims; j++ {
			result += query[j].Float32() * dataVec[j].Float32()
		}
		dots[i] = hwy.Float32ToFloat16(result)
	}
}

func BaseBatchDot_fallback_BFloat16(query []hwy.BFloat16, data []hwy.BFloat16, dots []hwy.BFloat16, count int, dims int) {
	if count <= 0 || dims <= 0 {
		return
	}
	if len(data) < count*dims {
		return
	}
	if len(dots) < count {
		return
	}
	if len(query) < dims {
		return
	}
	sum := hwy.Zero[hwy.BFloat16]()
	lanes := sum.NumLanes()
	for i := range count {
		dataStart := i * dims
		dataVec := data[dataStart : dataStart+dims]
		sum = hwy.Zero[hwy.BFloat16]()
		var j int
		for j = 0; j+lanes <= dims; j += lanes {
			vq := hwy.Load(query[j:])
			vd := hwy.Load(dataVec[j:])
			prod := hwy.Mul(vq, vd)
			sum = hwy.Add(sum, prod)
		}
		result := hwy.ReduceSum(sum).Float32()
		for ; j < dims; j++ {
			result += query[j].Float32() * dataVec[j].Float32()
		}
		dots[i] = hwy.Float32ToBFloat16(result)
	}
}

func BaseBatchDot_fallback(query []float32, data []float32, dots []float32, count int, dims int) {
	if count <= 0 || dims <= 0 {
		return
	}
	if len(data) < count*dims {
		return
	}
	if len(dots) < count {
		return
	}
	if len(query) < dims {
		return
	}
	sum := hwy.Zero[float32]()
	lanes := sum.NumLanes()
	for i := range count {
		dataStart := i * dims
		dataVec := data[dataStart : dataStart+dims]
		sum = hwy.Zero[float32]()
		var j int
		for j = 0; j+lanes <= dims; j += lanes {
			vq := hwy.Load(query[j:])
			vd := hwy.Load(dataVec[j:])
			prod := hwy.Mul(vq, vd)
			sum = hwy.Add(sum, prod)
		}
		result := hwy.ReduceSum(sum)
		for ; j < dims; j++ {
			result += query[j] * dataVec[j]
		}
		dots[i] = result
	}
}

func BaseBatchDot_fallback_Float64(query []float64, data []float64, dots []float64, count int, dims int) {
	if count <= 0 || dims <= 0 {
		return
	}
	if len(data) < count*dims {
		return
	}
	if len(dots) < count {
		return
	}
	if len(query) < dims {
		return
	}
	sum := hwy.Zero[float64]()
	lanes := sum.NumLanes()
	for i := range count {
		dataStart := i * dims
		dataVec := data[dataStart : dataStart+dims]
		sum = hwy.Zero[float64]()
		var j int
		for j = 0; j+lanes <= dims; j += lanes {
			vq := hwy.Load(query[j:])
			vd := hwy.Load(dataVec[j:])
			prod := hwy.Mul(vq, vd)
			sum = hwy.Add(sum, prod)
		}
		result := hwy.ReduceSum(sum)
		for ; j < dims; j++ {
			result += query[j] * dataVec[j]
		}
		dots[i] = result
	}
}
