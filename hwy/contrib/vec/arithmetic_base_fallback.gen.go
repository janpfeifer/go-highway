// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

package vec

import (
	"github.com/ajroetker/go-highway/hwy"
)

func BaseAdd_fallback_Float16(dst []hwy.Float16, s []hwy.Float16) {
	if len(dst) == 0 || len(s) == 0 {
		return
	}
	n := min(len(dst), len(s))
	lanes := hwy.Zero[hwy.Float16]().NumLanes()
	var i int
	for i = 0; i+lanes <= n; i += lanes {
		vd := hwy.Load(dst[i:])
		vs := hwy.Load(s[i:])
		result := hwy.Add(vd, vs)
		hwy.Store(result, dst[i:])
	}
	for ; i < n; i++ {
		dst[i] = hwy.Float32ToFloat16(dst[i].Float32() + s[i].Float32())
	}
}

func BaseAdd_fallback_BFloat16(dst []hwy.BFloat16, s []hwy.BFloat16) {
	if len(dst) == 0 || len(s) == 0 {
		return
	}
	n := min(len(dst), len(s))
	lanes := hwy.Zero[hwy.BFloat16]().NumLanes()
	var i int
	for i = 0; i+lanes <= n; i += lanes {
		vd := hwy.Load(dst[i:])
		vs := hwy.Load(s[i:])
		result := hwy.Add(vd, vs)
		hwy.Store(result, dst[i:])
	}
	for ; i < n; i++ {
		dst[i] = hwy.Float32ToBFloat16(dst[i].Float32() + s[i].Float32())
	}
}

func BaseAdd_fallback(dst []float32, s []float32) {
	if len(dst) == 0 || len(s) == 0 {
		return
	}
	n := min(len(dst), len(s))
	var i int
	for i = 0; i < n; i++ {
		vd := dst[i]
		vs := s[i]
		result := vd + vs
		dst[i] = result
	}
	for ; i < n; i++ {
		dst[i] += s[i]
	}
}

func BaseAdd_fallback_Float64(dst []float64, s []float64) {
	if len(dst) == 0 || len(s) == 0 {
		return
	}
	n := min(len(dst), len(s))
	var i int
	for i = 0; i < n; i++ {
		vd := dst[i]
		vs := s[i]
		result := vd + vs
		dst[i] = result
	}
	for ; i < n; i++ {
		dst[i] += s[i]
	}
}

func BaseAddTo_fallback_Float16(dst []hwy.Float16, a []hwy.Float16, b []hwy.Float16) {
	if len(dst) == 0 || len(a) == 0 || len(b) == 0 {
		return
	}
	n := min(len(dst), min(len(a), len(b)))
	lanes := hwy.Zero[hwy.Float16]().NumLanes()
	var i int
	for i = 0; i+lanes <= n; i += lanes {
		va := hwy.Load(a[i:])
		vb := hwy.Load(b[i:])
		result := hwy.Add(va, vb)
		hwy.Store(result, dst[i:])
	}
	for ; i < n; i++ {
		dst[i] = hwy.Float32ToFloat16(a[i].Float32() + b[i].Float32())
	}
}

func BaseAddTo_fallback_BFloat16(dst []hwy.BFloat16, a []hwy.BFloat16, b []hwy.BFloat16) {
	if len(dst) == 0 || len(a) == 0 || len(b) == 0 {
		return
	}
	n := min(len(dst), min(len(a), len(b)))
	lanes := hwy.Zero[hwy.BFloat16]().NumLanes()
	var i int
	for i = 0; i+lanes <= n; i += lanes {
		va := hwy.Load(a[i:])
		vb := hwy.Load(b[i:])
		result := hwy.Add(va, vb)
		hwy.Store(result, dst[i:])
	}
	for ; i < n; i++ {
		dst[i] = hwy.Float32ToBFloat16(a[i].Float32() + b[i].Float32())
	}
}

func BaseAddTo_fallback(dst []float32, a []float32, b []float32) {
	if len(dst) == 0 || len(a) == 0 || len(b) == 0 {
		return
	}
	n := min(len(dst), min(len(a), len(b)))
	var i int
	for i = 0; i < n; i++ {
		va := a[i]
		vb := b[i]
		result := va + vb
		dst[i] = result
	}
	for ; i < n; i++ {
		dst[i] = a[i] + b[i]
	}
}

func BaseAddTo_fallback_Float64(dst []float64, a []float64, b []float64) {
	if len(dst) == 0 || len(a) == 0 || len(b) == 0 {
		return
	}
	n := min(len(dst), min(len(a), len(b)))
	var i int
	for i = 0; i < n; i++ {
		va := a[i]
		vb := b[i]
		result := va + vb
		dst[i] = result
	}
	for ; i < n; i++ {
		dst[i] = a[i] + b[i]
	}
}

func BaseSub_fallback_Float16(dst []hwy.Float16, s []hwy.Float16) {
	if len(dst) == 0 || len(s) == 0 {
		return
	}
	n := min(len(dst), len(s))
	lanes := hwy.Zero[hwy.Float16]().NumLanes()
	var i int
	for i = 0; i+lanes <= n; i += lanes {
		vd := hwy.Load(dst[i:])
		vs := hwy.Load(s[i:])
		result := hwy.Sub(vd, vs)
		hwy.Store(result, dst[i:])
	}
	for ; i < n; i++ {
		dst[i] = hwy.Float32ToFloat16(dst[i].Float32() - s[i].Float32())
	}
}

func BaseSub_fallback_BFloat16(dst []hwy.BFloat16, s []hwy.BFloat16) {
	if len(dst) == 0 || len(s) == 0 {
		return
	}
	n := min(len(dst), len(s))
	lanes := hwy.Zero[hwy.BFloat16]().NumLanes()
	var i int
	for i = 0; i+lanes <= n; i += lanes {
		vd := hwy.Load(dst[i:])
		vs := hwy.Load(s[i:])
		result := hwy.Sub(vd, vs)
		hwy.Store(result, dst[i:])
	}
	for ; i < n; i++ {
		dst[i] = hwy.Float32ToBFloat16(dst[i].Float32() - s[i].Float32())
	}
}

func BaseSub_fallback(dst []float32, s []float32) {
	if len(dst) == 0 || len(s) == 0 {
		return
	}
	n := min(len(dst), len(s))
	var i int
	for i = 0; i < n; i++ {
		vd := dst[i]
		vs := s[i]
		result := vd - vs
		dst[i] = result
	}
	for ; i < n; i++ {
		dst[i] -= s[i]
	}
}

func BaseSub_fallback_Float64(dst []float64, s []float64) {
	if len(dst) == 0 || len(s) == 0 {
		return
	}
	n := min(len(dst), len(s))
	var i int
	for i = 0; i < n; i++ {
		vd := dst[i]
		vs := s[i]
		result := vd - vs
		dst[i] = result
	}
	for ; i < n; i++ {
		dst[i] -= s[i]
	}
}

func BaseSubTo_fallback_Float16(dst []hwy.Float16, a []hwy.Float16, b []hwy.Float16) {
	if len(dst) == 0 || len(a) == 0 || len(b) == 0 {
		return
	}
	n := min(len(dst), min(len(a), len(b)))
	lanes := hwy.Zero[hwy.Float16]().NumLanes()
	var i int
	for i = 0; i+lanes <= n; i += lanes {
		va := hwy.Load(a[i:])
		vb := hwy.Load(b[i:])
		result := hwy.Sub(va, vb)
		hwy.Store(result, dst[i:])
	}
	for ; i < n; i++ {
		dst[i] = hwy.Float32ToFloat16(a[i].Float32() - b[i].Float32())
	}
}

func BaseSubTo_fallback_BFloat16(dst []hwy.BFloat16, a []hwy.BFloat16, b []hwy.BFloat16) {
	if len(dst) == 0 || len(a) == 0 || len(b) == 0 {
		return
	}
	n := min(len(dst), min(len(a), len(b)))
	lanes := hwy.Zero[hwy.BFloat16]().NumLanes()
	var i int
	for i = 0; i+lanes <= n; i += lanes {
		va := hwy.Load(a[i:])
		vb := hwy.Load(b[i:])
		result := hwy.Sub(va, vb)
		hwy.Store(result, dst[i:])
	}
	for ; i < n; i++ {
		dst[i] = hwy.Float32ToBFloat16(a[i].Float32() - b[i].Float32())
	}
}

func BaseSubTo_fallback(dst []float32, a []float32, b []float32) {
	if len(dst) == 0 || len(a) == 0 || len(b) == 0 {
		return
	}
	n := min(len(dst), min(len(a), len(b)))
	var i int
	for i = 0; i < n; i++ {
		va := a[i]
		vb := b[i]
		result := va - vb
		dst[i] = result
	}
	for ; i < n; i++ {
		dst[i] = a[i] - b[i]
	}
}

func BaseSubTo_fallback_Float64(dst []float64, a []float64, b []float64) {
	if len(dst) == 0 || len(a) == 0 || len(b) == 0 {
		return
	}
	n := min(len(dst), min(len(a), len(b)))
	var i int
	for i = 0; i < n; i++ {
		va := a[i]
		vb := b[i]
		result := va - vb
		dst[i] = result
	}
	for ; i < n; i++ {
		dst[i] = a[i] - b[i]
	}
}

func BaseMul_fallback_Float16(dst []hwy.Float16, s []hwy.Float16) {
	if len(dst) == 0 || len(s) == 0 {
		return
	}
	n := min(len(dst), len(s))
	lanes := hwy.Zero[hwy.Float16]().NumLanes()
	var i int
	for i = 0; i+lanes <= n; i += lanes {
		vd := hwy.Load(dst[i:])
		vs := hwy.Load(s[i:])
		result := hwy.Mul(vd, vs)
		hwy.Store(result, dst[i:])
	}
	for ; i < n; i++ {
		dst[i] = hwy.Float32ToFloat16(dst[i].Float32() * s[i].Float32())
	}
}

func BaseMul_fallback_BFloat16(dst []hwy.BFloat16, s []hwy.BFloat16) {
	if len(dst) == 0 || len(s) == 0 {
		return
	}
	n := min(len(dst), len(s))
	lanes := hwy.Zero[hwy.BFloat16]().NumLanes()
	var i int
	for i = 0; i+lanes <= n; i += lanes {
		vd := hwy.Load(dst[i:])
		vs := hwy.Load(s[i:])
		result := hwy.Mul(vd, vs)
		hwy.Store(result, dst[i:])
	}
	for ; i < n; i++ {
		dst[i] = hwy.Float32ToBFloat16(dst[i].Float32() * s[i].Float32())
	}
}

func BaseMul_fallback(dst []float32, s []float32) {
	if len(dst) == 0 || len(s) == 0 {
		return
	}
	n := min(len(dst), len(s))
	var i int
	for i = 0; i < n; i++ {
		vd := dst[i]
		vs := s[i]
		result := vd * vs
		dst[i] = result
	}
	for ; i < n; i++ {
		dst[i] *= s[i]
	}
}

func BaseMul_fallback_Float64(dst []float64, s []float64) {
	if len(dst) == 0 || len(s) == 0 {
		return
	}
	n := min(len(dst), len(s))
	var i int
	for i = 0; i < n; i++ {
		vd := dst[i]
		vs := s[i]
		result := vd * vs
		dst[i] = result
	}
	for ; i < n; i++ {
		dst[i] *= s[i]
	}
}

func BaseMulTo_fallback_Float16(dst []hwy.Float16, a []hwy.Float16, b []hwy.Float16) {
	if len(dst) == 0 || len(a) == 0 || len(b) == 0 {
		return
	}
	n := min(len(dst), min(len(a), len(b)))
	lanes := hwy.Zero[hwy.Float16]().NumLanes()
	var i int
	for i = 0; i+lanes <= n; i += lanes {
		va := hwy.Load(a[i:])
		vb := hwy.Load(b[i:])
		result := hwy.Mul(va, vb)
		hwy.Store(result, dst[i:])
	}
	for ; i < n; i++ {
		dst[i] = hwy.Float32ToFloat16(a[i].Float32() * b[i].Float32())
	}
}

func BaseMulTo_fallback_BFloat16(dst []hwy.BFloat16, a []hwy.BFloat16, b []hwy.BFloat16) {
	if len(dst) == 0 || len(a) == 0 || len(b) == 0 {
		return
	}
	n := min(len(dst), min(len(a), len(b)))
	lanes := hwy.Zero[hwy.BFloat16]().NumLanes()
	var i int
	for i = 0; i+lanes <= n; i += lanes {
		va := hwy.Load(a[i:])
		vb := hwy.Load(b[i:])
		result := hwy.Mul(va, vb)
		hwy.Store(result, dst[i:])
	}
	for ; i < n; i++ {
		dst[i] = hwy.Float32ToBFloat16(a[i].Float32() * b[i].Float32())
	}
}

func BaseMulTo_fallback(dst []float32, a []float32, b []float32) {
	if len(dst) == 0 || len(a) == 0 || len(b) == 0 {
		return
	}
	n := min(len(dst), min(len(a), len(b)))
	var i int
	for i = 0; i < n; i++ {
		va := a[i]
		vb := b[i]
		result := va * vb
		dst[i] = result
	}
	for ; i < n; i++ {
		dst[i] = a[i] * b[i]
	}
}

func BaseMulTo_fallback_Float64(dst []float64, a []float64, b []float64) {
	if len(dst) == 0 || len(a) == 0 || len(b) == 0 {
		return
	}
	n := min(len(dst), min(len(a), len(b)))
	var i int
	for i = 0; i < n; i++ {
		va := a[i]
		vb := b[i]
		result := va * vb
		dst[i] = result
	}
	for ; i < n; i++ {
		dst[i] = a[i] * b[i]
	}
}

func BaseDiv_fallback_Float16(dst []hwy.Float16, s []hwy.Float16) {
	if len(dst) == 0 || len(s) == 0 {
		return
	}
	n := min(len(dst), len(s))
	lanes := hwy.Zero[hwy.Float16]().NumLanes()
	var i int
	for i = 0; i+lanes <= n; i += lanes {
		vd := hwy.Load(dst[i:])
		vs := hwy.Load(s[i:])
		result := hwy.Div(vd, vs)
		hwy.Store(result, dst[i:])
	}
	for ; i < n; i++ {
		dst[i] = hwy.Float32ToFloat16(dst[i].Float32() / s[i].Float32())
	}
}

func BaseDiv_fallback_BFloat16(dst []hwy.BFloat16, s []hwy.BFloat16) {
	if len(dst) == 0 || len(s) == 0 {
		return
	}
	n := min(len(dst), len(s))
	lanes := hwy.Zero[hwy.BFloat16]().NumLanes()
	var i int
	for i = 0; i+lanes <= n; i += lanes {
		vd := hwy.Load(dst[i:])
		vs := hwy.Load(s[i:])
		result := hwy.Div(vd, vs)
		hwy.Store(result, dst[i:])
	}
	for ; i < n; i++ {
		dst[i] = hwy.Float32ToBFloat16(dst[i].Float32() / s[i].Float32())
	}
}

func BaseDiv_fallback(dst []float32, s []float32) {
	if len(dst) == 0 || len(s) == 0 {
		return
	}
	n := min(len(dst), len(s))
	var i int
	for i = 0; i < n; i++ {
		vd := dst[i]
		vs := s[i]
		result := vd / vs
		dst[i] = result
	}
	for ; i < n; i++ {
		dst[i] /= s[i]
	}
}

func BaseDiv_fallback_Float64(dst []float64, s []float64) {
	if len(dst) == 0 || len(s) == 0 {
		return
	}
	n := min(len(dst), len(s))
	var i int
	for i = 0; i < n; i++ {
		vd := dst[i]
		vs := s[i]
		result := vd / vs
		dst[i] = result
	}
	for ; i < n; i++ {
		dst[i] /= s[i]
	}
}

func BaseDivTo_fallback_Float16(dst []hwy.Float16, a []hwy.Float16, b []hwy.Float16) {
	if len(dst) == 0 || len(a) == 0 || len(b) == 0 {
		return
	}
	n := min(len(dst), min(len(a), len(b)))
	lanes := hwy.Zero[hwy.Float16]().NumLanes()
	var i int
	for i = 0; i+lanes <= n; i += lanes {
		va := hwy.Load(a[i:])
		vb := hwy.Load(b[i:])
		result := hwy.Div(va, vb)
		hwy.Store(result, dst[i:])
	}
	for ; i < n; i++ {
		dst[i] = hwy.Float32ToFloat16(a[i].Float32() / b[i].Float32())
	}
}

func BaseDivTo_fallback_BFloat16(dst []hwy.BFloat16, a []hwy.BFloat16, b []hwy.BFloat16) {
	if len(dst) == 0 || len(a) == 0 || len(b) == 0 {
		return
	}
	n := min(len(dst), min(len(a), len(b)))
	lanes := hwy.Zero[hwy.BFloat16]().NumLanes()
	var i int
	for i = 0; i+lanes <= n; i += lanes {
		va := hwy.Load(a[i:])
		vb := hwy.Load(b[i:])
		result := hwy.Div(va, vb)
		hwy.Store(result, dst[i:])
	}
	for ; i < n; i++ {
		dst[i] = hwy.Float32ToBFloat16(a[i].Float32() / b[i].Float32())
	}
}

func BaseDivTo_fallback(dst []float32, a []float32, b []float32) {
	if len(dst) == 0 || len(a) == 0 || len(b) == 0 {
		return
	}
	n := min(len(dst), min(len(a), len(b)))
	var i int
	for i = 0; i < n; i++ {
		va := a[i]
		vb := b[i]
		result := va / vb
		dst[i] = result
	}
	for ; i < n; i++ {
		dst[i] = a[i] / b[i]
	}
}

func BaseDivTo_fallback_Float64(dst []float64, a []float64, b []float64) {
	if len(dst) == 0 || len(a) == 0 || len(b) == 0 {
		return
	}
	n := min(len(dst), min(len(a), len(b)))
	var i int
	for i = 0; i < n; i++ {
		va := a[i]
		vb := b[i]
		result := va / vb
		dst[i] = result
	}
	for ; i < n; i++ {
		dst[i] = a[i] / b[i]
	}
}

func BaseScale_fallback_Float16(c hwy.Float16, dst []hwy.Float16) {
	if len(dst) == 0 {
		return
	}
	n := len(dst)
	vc := hwy.Set(c)
	lanes := vc.NumLanes()
	var i int
	for i = 0; i+lanes <= n; i += lanes {
		vd := hwy.Load(dst[i:])
		result := hwy.Mul(vd, vc)
		hwy.Store(result, dst[i:])
	}
	for ; i < n; i++ {
		dst[i] = hwy.Float32ToFloat16(dst[i].Float32() * c.Float32())
	}
}

func BaseScale_fallback_BFloat16(c hwy.BFloat16, dst []hwy.BFloat16) {
	if len(dst) == 0 {
		return
	}
	n := len(dst)
	vc := hwy.Set(c)
	lanes := vc.NumLanes()
	var i int
	for i = 0; i+lanes <= n; i += lanes {
		vd := hwy.Load(dst[i:])
		result := hwy.Mul(vd, vc)
		hwy.Store(result, dst[i:])
	}
	for ; i < n; i++ {
		dst[i] = hwy.Float32ToBFloat16(dst[i].Float32() * c.Float32())
	}
}

func BaseScale_fallback(c float32, dst []float32) {
	if len(dst) == 0 {
		return
	}
	n := len(dst)
	vc := float32(c)
	var i int
	for i = 0; i < n; i++ {
		vd := dst[i]
		result := vd * vc
		dst[i] = result
	}
	for ; i < n; i++ {
		dst[i] *= c
	}
}

func BaseScale_fallback_Float64(c float64, dst []float64) {
	if len(dst) == 0 {
		return
	}
	n := len(dst)
	vc := float64(c)
	var i int
	for i = 0; i < n; i++ {
		vd := dst[i]
		result := vd * vc
		dst[i] = result
	}
	for ; i < n; i++ {
		dst[i] *= c
	}
}

func BaseScaleTo_fallback_Float16(dst []hwy.Float16, c hwy.Float16, s []hwy.Float16) {
	if len(dst) == 0 || len(s) == 0 {
		return
	}
	n := min(len(dst), len(s))
	vc := hwy.Set(c)
	lanes := vc.NumLanes()
	var i int
	for i = 0; i+lanes <= n; i += lanes {
		vs := hwy.Load(s[i:])
		result := hwy.Mul(vc, vs)
		hwy.Store(result, dst[i:])
	}
	for ; i < n; i++ {
		dst[i] = hwy.Float32ToFloat16(c.Float32() * s[i].Float32())
	}
}

func BaseScaleTo_fallback_BFloat16(dst []hwy.BFloat16, c hwy.BFloat16, s []hwy.BFloat16) {
	if len(dst) == 0 || len(s) == 0 {
		return
	}
	n := min(len(dst), len(s))
	vc := hwy.Set(c)
	lanes := vc.NumLanes()
	var i int
	for i = 0; i+lanes <= n; i += lanes {
		vs := hwy.Load(s[i:])
		result := hwy.Mul(vc, vs)
		hwy.Store(result, dst[i:])
	}
	for ; i < n; i++ {
		dst[i] = hwy.Float32ToBFloat16(c.Float32() * s[i].Float32())
	}
}

func BaseScaleTo_fallback(dst []float32, c float32, s []float32) {
	if len(dst) == 0 || len(s) == 0 {
		return
	}
	n := min(len(dst), len(s))
	vc := float32(c)
	var i int
	for i = 0; i < n; i++ {
		vs := s[i]
		result := vc * vs
		dst[i] = result
	}
	for ; i < n; i++ {
		dst[i] = c * s[i]
	}
}

func BaseScaleTo_fallback_Float64(dst []float64, c float64, s []float64) {
	if len(dst) == 0 || len(s) == 0 {
		return
	}
	n := min(len(dst), len(s))
	vc := float64(c)
	var i int
	for i = 0; i < n; i++ {
		vs := s[i]
		result := vc * vs
		dst[i] = result
	}
	for ; i < n; i++ {
		dst[i] = c * s[i]
	}
}

func BaseAddConst_fallback_Float16(c hwy.Float16, dst []hwy.Float16) {
	if len(dst) == 0 {
		return
	}
	n := len(dst)
	vc := hwy.Set(c)
	lanes := vc.NumLanes()
	var i int
	for i = 0; i+lanes <= n; i += lanes {
		vd := hwy.Load(dst[i:])
		result := hwy.Add(vd, vc)
		hwy.Store(result, dst[i:])
	}
	for ; i < n; i++ {
		dst[i] = hwy.Float32ToFloat16(dst[i].Float32() + c.Float32())
	}
}

func BaseAddConst_fallback_BFloat16(c hwy.BFloat16, dst []hwy.BFloat16) {
	if len(dst) == 0 {
		return
	}
	n := len(dst)
	vc := hwy.Set(c)
	lanes := vc.NumLanes()
	var i int
	for i = 0; i+lanes <= n; i += lanes {
		vd := hwy.Load(dst[i:])
		result := hwy.Add(vd, vc)
		hwy.Store(result, dst[i:])
	}
	for ; i < n; i++ {
		dst[i] = hwy.Float32ToBFloat16(dst[i].Float32() + c.Float32())
	}
}

func BaseAddConst_fallback(c float32, dst []float32) {
	if len(dst) == 0 {
		return
	}
	n := len(dst)
	vc := float32(c)
	var i int
	for i = 0; i < n; i++ {
		vd := dst[i]
		result := vd + vc
		dst[i] = result
	}
	for ; i < n; i++ {
		dst[i] += c
	}
}

func BaseAddConst_fallback_Float64(c float64, dst []float64) {
	if len(dst) == 0 {
		return
	}
	n := len(dst)
	vc := float64(c)
	var i int
	for i = 0; i < n; i++ {
		vd := dst[i]
		result := vd + vc
		dst[i] = result
	}
	for ; i < n; i++ {
		dst[i] += c
	}
}

func BaseMulConstAddTo_fallback_Float16(dst []hwy.Float16, a hwy.Float16, x []hwy.Float16) {
	if len(dst) == 0 || len(x) == 0 {
		return
	}
	n := min(len(dst), len(x))
	va := hwy.Set(a)
	lanes := va.NumLanes()
	var i int
	for i = 0; i+lanes <= n; i += lanes {
		vd := hwy.Load(dst[i:])
		vx := hwy.Load(x[i:])
		result := hwy.MulAdd(va, vx, vd)
		hwy.Store(result, dst[i:])
	}
	for ; i < n; i++ {
		dst[i] = hwy.Float32ToFloat16(dst[i].Float32() + a.Float32()*x[i].Float32())
	}
}

func BaseMulConstAddTo_fallback_BFloat16(dst []hwy.BFloat16, a hwy.BFloat16, x []hwy.BFloat16) {
	if len(dst) == 0 || len(x) == 0 {
		return
	}
	n := min(len(dst), len(x))
	va := hwy.Set(a)
	lanes := va.NumLanes()
	var i int
	for i = 0; i+lanes <= n; i += lanes {
		vd := hwy.Load(dst[i:])
		vx := hwy.Load(x[i:])
		result := hwy.MulAdd(va, vx, vd)
		hwy.Store(result, dst[i:])
	}
	for ; i < n; i++ {
		dst[i] = hwy.Float32ToBFloat16(dst[i].Float32() + a.Float32()*x[i].Float32())
	}
}

func BaseMulConstAddTo_fallback(dst []float32, a float32, x []float32) {
	if len(dst) == 0 || len(x) == 0 {
		return
	}
	n := min(len(dst), len(x))
	va := float32(a)
	var i int
	for i = 0; i < n; i++ {
		vd := dst[i]
		vx := x[i]
		result := va*vx + vd
		dst[i] = result
	}
	for ; i < n; i++ {
		dst[i] += a * x[i]
	}
}

func BaseMulConstAddTo_fallback_Float64(dst []float64, a float64, x []float64) {
	if len(dst) == 0 || len(x) == 0 {
		return
	}
	n := min(len(dst), len(x))
	va := float64(a)
	var i int
	for i = 0; i < n; i++ {
		vd := dst[i]
		vx := x[i]
		result := va*vx + vd
		dst[i] = result
	}
	for ; i < n; i++ {
		dst[i] += a * x[i]
	}
}
