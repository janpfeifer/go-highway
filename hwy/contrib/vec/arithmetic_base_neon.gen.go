// Code generated by hwygen. DO NOT EDIT.
//go:build arm64

package vec

import (
	"github.com/ajroetker/go-highway/hwy"
	"github.com/ajroetker/go-highway/hwy/asm"
)

func BaseAdd_neon_Float16(dst []hwy.Float16, s []hwy.Float16) {
	if len(dst) == 0 || len(s) == 0 {
		return
	}
	n := min(len(dst), len(s))
	lanes := 8
	var i int
	i = 0
	for ; i+lanes <= n; i += lanes {
		vd := hwy.Load(dst[i:])
		vs := hwy.Load(s[i:])
		result := hwy.AddF16(vd, vs)
		hwy.Store(result, dst[i:])
	}
	if i < n {
		BaseAdd_fallback_Float16(dst[i:n], s[i:n])
	}
}

func BaseAdd_neon_BFloat16(dst []hwy.BFloat16, s []hwy.BFloat16) {
	if len(dst) == 0 || len(s) == 0 {
		return
	}
	n := min(len(dst), len(s))
	lanes := 8
	var i int
	i = 0
	for ; i+lanes <= n; i += lanes {
		vd := hwy.Load(dst[i:])
		vs := hwy.Load(s[i:])
		result := hwy.AddBF16(vd, vs)
		hwy.Store(result, dst[i:])
	}
	if i < n {
		BaseAdd_fallback_BFloat16(dst[i:n], s[i:n])
	}
}

func BaseAdd_neon(dst []float32, s []float32) {
	if len(dst) == 0 || len(s) == 0 {
		return
	}
	n := min(len(dst), len(s))
	lanes := 4
	var i int
	i = 0
	for ; i+lanes <= n; i += lanes {
		vd := asm.LoadFloat32x4Slice(dst[i:])
		vs := asm.LoadFloat32x4Slice(s[i:])
		result := vd.Add(vs)
		result.StoreSlice(dst[i:])
	}
	if i < n {
		BaseAdd_fallback(dst[i:n], s[i:n])
	}
}

func BaseAdd_neon_Float64(dst []float64, s []float64) {
	if len(dst) == 0 || len(s) == 0 {
		return
	}
	n := min(len(dst), len(s))
	lanes := 2
	var i int
	i = 0
	for ; i+lanes <= n; i += lanes {
		vd := asm.LoadFloat64x2Slice(dst[i:])
		vs := asm.LoadFloat64x2Slice(s[i:])
		result := vd.Add(vs)
		result.StoreSlice(dst[i:])
	}
	if i < n {
		BaseAdd_fallback_Float64(dst[i:n], s[i:n])
	}
}

func BaseAddTo_neon_Float16(dst []hwy.Float16, a []hwy.Float16, b []hwy.Float16) {
	if len(dst) == 0 || len(a) == 0 || len(b) == 0 {
		return
	}
	n := min(len(dst), min(len(a), len(b)))
	lanes := 8
	var i int
	i = 0
	for ; i+lanes <= n; i += lanes {
		va := hwy.Load(a[i:])
		vb := hwy.Load(b[i:])
		result := hwy.AddF16(va, vb)
		hwy.Store(result, dst[i:])
	}
	if i < n {
		BaseAddTo_fallback_Float16(dst[i:n], a[i:n], b[i:n])
	}
}

func BaseAddTo_neon_BFloat16(dst []hwy.BFloat16, a []hwy.BFloat16, b []hwy.BFloat16) {
	if len(dst) == 0 || len(a) == 0 || len(b) == 0 {
		return
	}
	n := min(len(dst), min(len(a), len(b)))
	lanes := 8
	var i int
	i = 0
	for ; i+lanes <= n; i += lanes {
		va := hwy.Load(a[i:])
		vb := hwy.Load(b[i:])
		result := hwy.AddBF16(va, vb)
		hwy.Store(result, dst[i:])
	}
	if i < n {
		BaseAddTo_fallback_BFloat16(dst[i:n], a[i:n], b[i:n])
	}
}

func BaseAddTo_neon(dst []float32, a []float32, b []float32) {
	if len(dst) == 0 || len(a) == 0 || len(b) == 0 {
		return
	}
	n := min(len(dst), min(len(a), len(b)))
	lanes := 4
	var i int
	i = 0
	for ; i+lanes <= n; i += lanes {
		va := asm.LoadFloat32x4Slice(a[i:])
		vb := asm.LoadFloat32x4Slice(b[i:])
		result := va.Add(vb)
		result.StoreSlice(dst[i:])
	}
	if i < n {
		BaseAddTo_fallback(dst[i:n], a[i:n], b[i:n])
	}
}

func BaseAddTo_neon_Float64(dst []float64, a []float64, b []float64) {
	if len(dst) == 0 || len(a) == 0 || len(b) == 0 {
		return
	}
	n := min(len(dst), min(len(a), len(b)))
	lanes := 2
	var i int
	i = 0
	for ; i+lanes <= n; i += lanes {
		va := asm.LoadFloat64x2Slice(a[i:])
		vb := asm.LoadFloat64x2Slice(b[i:])
		result := va.Add(vb)
		result.StoreSlice(dst[i:])
	}
	if i < n {
		BaseAddTo_fallback_Float64(dst[i:n], a[i:n], b[i:n])
	}
}

func BaseSub_neon_Float16(dst []hwy.Float16, s []hwy.Float16) {
	if len(dst) == 0 || len(s) == 0 {
		return
	}
	n := min(len(dst), len(s))
	lanes := 8
	var i int
	i = 0
	for ; i+lanes <= n; i += lanes {
		vd := hwy.Load(dst[i:])
		vs := hwy.Load(s[i:])
		result := hwy.SubF16(vd, vs)
		hwy.Store(result, dst[i:])
	}
	if i < n {
		BaseSub_fallback_Float16(dst[i:n], s[i:n])
	}
}

func BaseSub_neon_BFloat16(dst []hwy.BFloat16, s []hwy.BFloat16) {
	if len(dst) == 0 || len(s) == 0 {
		return
	}
	n := min(len(dst), len(s))
	lanes := 8
	var i int
	i = 0
	for ; i+lanes <= n; i += lanes {
		vd := hwy.Load(dst[i:])
		vs := hwy.Load(s[i:])
		result := hwy.SubBF16(vd, vs)
		hwy.Store(result, dst[i:])
	}
	if i < n {
		BaseSub_fallback_BFloat16(dst[i:n], s[i:n])
	}
}

func BaseSub_neon(dst []float32, s []float32) {
	if len(dst) == 0 || len(s) == 0 {
		return
	}
	n := min(len(dst), len(s))
	lanes := 4
	var i int
	i = 0
	for ; i+lanes <= n; i += lanes {
		vd := asm.LoadFloat32x4Slice(dst[i:])
		vs := asm.LoadFloat32x4Slice(s[i:])
		result := vd.Sub(vs)
		result.StoreSlice(dst[i:])
	}
	if i < n {
		BaseSub_fallback(dst[i:n], s[i:n])
	}
}

func BaseSub_neon_Float64(dst []float64, s []float64) {
	if len(dst) == 0 || len(s) == 0 {
		return
	}
	n := min(len(dst), len(s))
	lanes := 2
	var i int
	i = 0
	for ; i+lanes <= n; i += lanes {
		vd := asm.LoadFloat64x2Slice(dst[i:])
		vs := asm.LoadFloat64x2Slice(s[i:])
		result := vd.Sub(vs)
		result.StoreSlice(dst[i:])
	}
	if i < n {
		BaseSub_fallback_Float64(dst[i:n], s[i:n])
	}
}

func BaseSubTo_neon_Float16(dst []hwy.Float16, a []hwy.Float16, b []hwy.Float16) {
	if len(dst) == 0 || len(a) == 0 || len(b) == 0 {
		return
	}
	n := min(len(dst), min(len(a), len(b)))
	lanes := 8
	var i int
	i = 0
	for ; i+lanes <= n; i += lanes {
		va := hwy.Load(a[i:])
		vb := hwy.Load(b[i:])
		result := hwy.SubF16(va, vb)
		hwy.Store(result, dst[i:])
	}
	if i < n {
		BaseSubTo_fallback_Float16(dst[i:n], a[i:n], b[i:n])
	}
}

func BaseSubTo_neon_BFloat16(dst []hwy.BFloat16, a []hwy.BFloat16, b []hwy.BFloat16) {
	if len(dst) == 0 || len(a) == 0 || len(b) == 0 {
		return
	}
	n := min(len(dst), min(len(a), len(b)))
	lanes := 8
	var i int
	i = 0
	for ; i+lanes <= n; i += lanes {
		va := hwy.Load(a[i:])
		vb := hwy.Load(b[i:])
		result := hwy.SubBF16(va, vb)
		hwy.Store(result, dst[i:])
	}
	if i < n {
		BaseSubTo_fallback_BFloat16(dst[i:n], a[i:n], b[i:n])
	}
}

func BaseSubTo_neon(dst []float32, a []float32, b []float32) {
	if len(dst) == 0 || len(a) == 0 || len(b) == 0 {
		return
	}
	n := min(len(dst), min(len(a), len(b)))
	lanes := 4
	var i int
	i = 0
	for ; i+lanes <= n; i += lanes {
		va := asm.LoadFloat32x4Slice(a[i:])
		vb := asm.LoadFloat32x4Slice(b[i:])
		result := va.Sub(vb)
		result.StoreSlice(dst[i:])
	}
	if i < n {
		BaseSubTo_fallback(dst[i:n], a[i:n], b[i:n])
	}
}

func BaseSubTo_neon_Float64(dst []float64, a []float64, b []float64) {
	if len(dst) == 0 || len(a) == 0 || len(b) == 0 {
		return
	}
	n := min(len(dst), min(len(a), len(b)))
	lanes := 2
	var i int
	i = 0
	for ; i+lanes <= n; i += lanes {
		va := asm.LoadFloat64x2Slice(a[i:])
		vb := asm.LoadFloat64x2Slice(b[i:])
		result := va.Sub(vb)
		result.StoreSlice(dst[i:])
	}
	if i < n {
		BaseSubTo_fallback_Float64(dst[i:n], a[i:n], b[i:n])
	}
}

func BaseMul_neon_Float16(dst []hwy.Float16, s []hwy.Float16) {
	if len(dst) == 0 || len(s) == 0 {
		return
	}
	n := min(len(dst), len(s))
	lanes := 8
	var i int
	i = 0
	for ; i+lanes <= n; i += lanes {
		vd := hwy.Load(dst[i:])
		vs := hwy.Load(s[i:])
		result := hwy.MulF16(vd, vs)
		hwy.Store(result, dst[i:])
	}
	if i < n {
		BaseMul_fallback_Float16(dst[i:n], s[i:n])
	}
}

func BaseMul_neon_BFloat16(dst []hwy.BFloat16, s []hwy.BFloat16) {
	if len(dst) == 0 || len(s) == 0 {
		return
	}
	n := min(len(dst), len(s))
	lanes := 8
	var i int
	i = 0
	for ; i+lanes <= n; i += lanes {
		vd := hwy.Load(dst[i:])
		vs := hwy.Load(s[i:])
		result := hwy.MulBF16(vd, vs)
		hwy.Store(result, dst[i:])
	}
	if i < n {
		BaseMul_fallback_BFloat16(dst[i:n], s[i:n])
	}
}

func BaseMul_neon(dst []float32, s []float32) {
	if len(dst) == 0 || len(s) == 0 {
		return
	}
	n := min(len(dst), len(s))
	lanes := 4
	var i int
	i = 0
	for ; i+lanes <= n; i += lanes {
		vd := asm.LoadFloat32x4Slice(dst[i:])
		vs := asm.LoadFloat32x4Slice(s[i:])
		result := vd.Mul(vs)
		result.StoreSlice(dst[i:])
	}
	if i < n {
		BaseMul_fallback(dst[i:n], s[i:n])
	}
}

func BaseMul_neon_Float64(dst []float64, s []float64) {
	if len(dst) == 0 || len(s) == 0 {
		return
	}
	n := min(len(dst), len(s))
	lanes := 2
	var i int
	i = 0
	for ; i+lanes <= n; i += lanes {
		vd := asm.LoadFloat64x2Slice(dst[i:])
		vs := asm.LoadFloat64x2Slice(s[i:])
		result := vd.Mul(vs)
		result.StoreSlice(dst[i:])
	}
	if i < n {
		BaseMul_fallback_Float64(dst[i:n], s[i:n])
	}
}

func BaseMulTo_neon_Float16(dst []hwy.Float16, a []hwy.Float16, b []hwy.Float16) {
	if len(dst) == 0 || len(a) == 0 || len(b) == 0 {
		return
	}
	n := min(len(dst), min(len(a), len(b)))
	lanes := 8
	var i int
	i = 0
	for ; i+lanes <= n; i += lanes {
		va := hwy.Load(a[i:])
		vb := hwy.Load(b[i:])
		result := hwy.MulF16(va, vb)
		hwy.Store(result, dst[i:])
	}
	if i < n {
		BaseMulTo_fallback_Float16(dst[i:n], a[i:n], b[i:n])
	}
}

func BaseMulTo_neon_BFloat16(dst []hwy.BFloat16, a []hwy.BFloat16, b []hwy.BFloat16) {
	if len(dst) == 0 || len(a) == 0 || len(b) == 0 {
		return
	}
	n := min(len(dst), min(len(a), len(b)))
	lanes := 8
	var i int
	i = 0
	for ; i+lanes <= n; i += lanes {
		va := hwy.Load(a[i:])
		vb := hwy.Load(b[i:])
		result := hwy.MulBF16(va, vb)
		hwy.Store(result, dst[i:])
	}
	if i < n {
		BaseMulTo_fallback_BFloat16(dst[i:n], a[i:n], b[i:n])
	}
}

func BaseMulTo_neon(dst []float32, a []float32, b []float32) {
	if len(dst) == 0 || len(a) == 0 || len(b) == 0 {
		return
	}
	n := min(len(dst), min(len(a), len(b)))
	lanes := 4
	var i int
	i = 0
	for ; i+lanes <= n; i += lanes {
		va := asm.LoadFloat32x4Slice(a[i:])
		vb := asm.LoadFloat32x4Slice(b[i:])
		result := va.Mul(vb)
		result.StoreSlice(dst[i:])
	}
	if i < n {
		BaseMulTo_fallback(dst[i:n], a[i:n], b[i:n])
	}
}

func BaseMulTo_neon_Float64(dst []float64, a []float64, b []float64) {
	if len(dst) == 0 || len(a) == 0 || len(b) == 0 {
		return
	}
	n := min(len(dst), min(len(a), len(b)))
	lanes := 2
	var i int
	i = 0
	for ; i+lanes <= n; i += lanes {
		va := asm.LoadFloat64x2Slice(a[i:])
		vb := asm.LoadFloat64x2Slice(b[i:])
		result := va.Mul(vb)
		result.StoreSlice(dst[i:])
	}
	if i < n {
		BaseMulTo_fallback_Float64(dst[i:n], a[i:n], b[i:n])
	}
}

func BaseDiv_neon_Float16(dst []hwy.Float16, s []hwy.Float16) {
	if len(dst) == 0 || len(s) == 0 {
		return
	}
	n := min(len(dst), len(s))
	lanes := 8
	var i int
	i = 0
	for ; i+lanes <= n; i += lanes {
		vd := hwy.Load(dst[i:])
		vs := hwy.Load(s[i:])
		result := hwy.DivF16(vd, vs)
		hwy.Store(result, dst[i:])
	}
	if i < n {
		BaseDiv_fallback_Float16(dst[i:n], s[i:n])
	}
}

func BaseDiv_neon_BFloat16(dst []hwy.BFloat16, s []hwy.BFloat16) {
	if len(dst) == 0 || len(s) == 0 {
		return
	}
	n := min(len(dst), len(s))
	lanes := 8
	var i int
	i = 0
	for ; i+lanes <= n; i += lanes {
		vd := hwy.Load(dst[i:])
		vs := hwy.Load(s[i:])
		result := hwy.DivBF16(vd, vs)
		hwy.Store(result, dst[i:])
	}
	if i < n {
		BaseDiv_fallback_BFloat16(dst[i:n], s[i:n])
	}
}

func BaseDiv_neon(dst []float32, s []float32) {
	if len(dst) == 0 || len(s) == 0 {
		return
	}
	n := min(len(dst), len(s))
	lanes := 4
	var i int
	i = 0
	for ; i+lanes <= n; i += lanes {
		vd := asm.LoadFloat32x4Slice(dst[i:])
		vs := asm.LoadFloat32x4Slice(s[i:])
		result := vd.Div(vs)
		result.StoreSlice(dst[i:])
	}
	if i < n {
		BaseDiv_fallback(dst[i:n], s[i:n])
	}
}

func BaseDiv_neon_Float64(dst []float64, s []float64) {
	if len(dst) == 0 || len(s) == 0 {
		return
	}
	n := min(len(dst), len(s))
	lanes := 2
	var i int
	i = 0
	for ; i+lanes <= n; i += lanes {
		vd := asm.LoadFloat64x2Slice(dst[i:])
		vs := asm.LoadFloat64x2Slice(s[i:])
		result := vd.Div(vs)
		result.StoreSlice(dst[i:])
	}
	if i < n {
		BaseDiv_fallback_Float64(dst[i:n], s[i:n])
	}
}

func BaseDivTo_neon_Float16(dst []hwy.Float16, a []hwy.Float16, b []hwy.Float16) {
	if len(dst) == 0 || len(a) == 0 || len(b) == 0 {
		return
	}
	n := min(len(dst), min(len(a), len(b)))
	lanes := 8
	var i int
	i = 0
	for ; i+lanes <= n; i += lanes {
		va := hwy.Load(a[i:])
		vb := hwy.Load(b[i:])
		result := hwy.DivF16(va, vb)
		hwy.Store(result, dst[i:])
	}
	if i < n {
		BaseDivTo_fallback_Float16(dst[i:n], a[i:n], b[i:n])
	}
}

func BaseDivTo_neon_BFloat16(dst []hwy.BFloat16, a []hwy.BFloat16, b []hwy.BFloat16) {
	if len(dst) == 0 || len(a) == 0 || len(b) == 0 {
		return
	}
	n := min(len(dst), min(len(a), len(b)))
	lanes := 8
	var i int
	i = 0
	for ; i+lanes <= n; i += lanes {
		va := hwy.Load(a[i:])
		vb := hwy.Load(b[i:])
		result := hwy.DivBF16(va, vb)
		hwy.Store(result, dst[i:])
	}
	if i < n {
		BaseDivTo_fallback_BFloat16(dst[i:n], a[i:n], b[i:n])
	}
}

func BaseDivTo_neon(dst []float32, a []float32, b []float32) {
	if len(dst) == 0 || len(a) == 0 || len(b) == 0 {
		return
	}
	n := min(len(dst), min(len(a), len(b)))
	lanes := 4
	var i int
	i = 0
	for ; i+lanes <= n; i += lanes {
		va := asm.LoadFloat32x4Slice(a[i:])
		vb := asm.LoadFloat32x4Slice(b[i:])
		result := va.Div(vb)
		result.StoreSlice(dst[i:])
	}
	if i < n {
		BaseDivTo_fallback(dst[i:n], a[i:n], b[i:n])
	}
}

func BaseDivTo_neon_Float64(dst []float64, a []float64, b []float64) {
	if len(dst) == 0 || len(a) == 0 || len(b) == 0 {
		return
	}
	n := min(len(dst), min(len(a), len(b)))
	lanes := 2
	var i int
	i = 0
	for ; i+lanes <= n; i += lanes {
		va := asm.LoadFloat64x2Slice(a[i:])
		vb := asm.LoadFloat64x2Slice(b[i:])
		result := va.Div(vb)
		result.StoreSlice(dst[i:])
	}
	if i < n {
		BaseDivTo_fallback_Float64(dst[i:n], a[i:n], b[i:n])
	}
}

func BaseScale_neon_Float16(c hwy.Float16, dst []hwy.Float16) {
	if len(dst) == 0 {
		return
	}
	n := len(dst)
	vc := hwy.Set(c)
	lanes := 8
	var i int
	i = 0
	for ; i+lanes <= n; i += lanes {
		vd := hwy.Load(dst[i:])
		result := hwy.MulF16(vd, vc)
		hwy.Store(result, dst[i:])
	}
	if i < n {
		BaseScale_fallback_Float16(c, dst[i:n])
	}
}

func BaseScale_neon_BFloat16(c hwy.BFloat16, dst []hwy.BFloat16) {
	if len(dst) == 0 {
		return
	}
	n := len(dst)
	vc := hwy.Set(c)
	lanes := 8
	var i int
	i = 0
	for ; i+lanes <= n; i += lanes {
		vd := hwy.Load(dst[i:])
		result := hwy.MulBF16(vd, vc)
		hwy.Store(result, dst[i:])
	}
	if i < n {
		BaseScale_fallback_BFloat16(c, dst[i:n])
	}
}

func BaseScale_neon(c float32, dst []float32) {
	if len(dst) == 0 {
		return
	}
	n := len(dst)
	vc := asm.BroadcastFloat32x4(c)
	lanes := 4
	var i int
	i = 0
	for ; i+lanes <= n; i += lanes {
		vd := asm.LoadFloat32x4Slice(dst[i:])
		result := vd.Mul(vc)
		result.StoreSlice(dst[i:])
	}
	if i < n {
		BaseScale_fallback(c, dst[i:n])
	}
}

func BaseScale_neon_Float64(c float64, dst []float64) {
	if len(dst) == 0 {
		return
	}
	n := len(dst)
	vc := asm.BroadcastFloat64x2(c)
	lanes := 2
	var i int
	i = 0
	for ; i+lanes <= n; i += lanes {
		vd := asm.LoadFloat64x2Slice(dst[i:])
		result := vd.Mul(vc)
		result.StoreSlice(dst[i:])
	}
	if i < n {
		BaseScale_fallback_Float64(c, dst[i:n])
	}
}

func BaseScaleTo_neon_Float16(dst []hwy.Float16, c hwy.Float16, s []hwy.Float16) {
	if len(dst) == 0 || len(s) == 0 {
		return
	}
	n := min(len(dst), len(s))
	vc := hwy.Set(c)
	lanes := 8
	var i int
	i = 0
	for ; i+lanes <= n; i += lanes {
		vs := hwy.Load(s[i:])
		result := hwy.MulF16(vc, vs)
		hwy.Store(result, dst[i:])
	}
	if i < n {
		BaseScaleTo_fallback_Float16(dst[i:n], c, s[i:n])
	}
}

func BaseScaleTo_neon_BFloat16(dst []hwy.BFloat16, c hwy.BFloat16, s []hwy.BFloat16) {
	if len(dst) == 0 || len(s) == 0 {
		return
	}
	n := min(len(dst), len(s))
	vc := hwy.Set(c)
	lanes := 8
	var i int
	i = 0
	for ; i+lanes <= n; i += lanes {
		vs := hwy.Load(s[i:])
		result := hwy.MulBF16(vc, vs)
		hwy.Store(result, dst[i:])
	}
	if i < n {
		BaseScaleTo_fallback_BFloat16(dst[i:n], c, s[i:n])
	}
}

func BaseScaleTo_neon(dst []float32, c float32, s []float32) {
	if len(dst) == 0 || len(s) == 0 {
		return
	}
	n := min(len(dst), len(s))
	vc := asm.BroadcastFloat32x4(c)
	lanes := 4
	var i int
	i = 0
	for ; i+lanes <= n; i += lanes {
		vs := asm.LoadFloat32x4Slice(s[i:])
		result := vc.Mul(vs)
		result.StoreSlice(dst[i:])
	}
	if i < n {
		BaseScaleTo_fallback(dst[i:n], c, s[i:n])
	}
}

func BaseScaleTo_neon_Float64(dst []float64, c float64, s []float64) {
	if len(dst) == 0 || len(s) == 0 {
		return
	}
	n := min(len(dst), len(s))
	vc := asm.BroadcastFloat64x2(c)
	lanes := 2
	var i int
	i = 0
	for ; i+lanes <= n; i += lanes {
		vs := asm.LoadFloat64x2Slice(s[i:])
		result := vc.Mul(vs)
		result.StoreSlice(dst[i:])
	}
	if i < n {
		BaseScaleTo_fallback_Float64(dst[i:n], c, s[i:n])
	}
}

func BaseAddConst_neon_Float16(c hwy.Float16, dst []hwy.Float16) {
	if len(dst) == 0 {
		return
	}
	n := len(dst)
	vc := hwy.Set(c)
	lanes := 8
	var i int
	i = 0
	for ; i+lanes <= n; i += lanes {
		vd := hwy.Load(dst[i:])
		result := hwy.AddF16(vd, vc)
		hwy.Store(result, dst[i:])
	}
	if i < n {
		BaseAddConst_fallback_Float16(c, dst[i:n])
	}
}

func BaseAddConst_neon_BFloat16(c hwy.BFloat16, dst []hwy.BFloat16) {
	if len(dst) == 0 {
		return
	}
	n := len(dst)
	vc := hwy.Set(c)
	lanes := 8
	var i int
	i = 0
	for ; i+lanes <= n; i += lanes {
		vd := hwy.Load(dst[i:])
		result := hwy.AddBF16(vd, vc)
		hwy.Store(result, dst[i:])
	}
	if i < n {
		BaseAddConst_fallback_BFloat16(c, dst[i:n])
	}
}

func BaseAddConst_neon(c float32, dst []float32) {
	if len(dst) == 0 {
		return
	}
	n := len(dst)
	vc := asm.BroadcastFloat32x4(c)
	lanes := 4
	var i int
	i = 0
	for ; i+lanes <= n; i += lanes {
		vd := asm.LoadFloat32x4Slice(dst[i:])
		result := vd.Add(vc)
		result.StoreSlice(dst[i:])
	}
	if i < n {
		BaseAddConst_fallback(c, dst[i:n])
	}
}

func BaseAddConst_neon_Float64(c float64, dst []float64) {
	if len(dst) == 0 {
		return
	}
	n := len(dst)
	vc := asm.BroadcastFloat64x2(c)
	lanes := 2
	var i int
	i = 0
	for ; i+lanes <= n; i += lanes {
		vd := asm.LoadFloat64x2Slice(dst[i:])
		result := vd.Add(vc)
		result.StoreSlice(dst[i:])
	}
	if i < n {
		BaseAddConst_fallback_Float64(c, dst[i:n])
	}
}

func BaseMulConstAddTo_neon_Float16(dst []hwy.Float16, a hwy.Float16, x []hwy.Float16) {
	if len(dst) == 0 || len(x) == 0 {
		return
	}
	n := min(len(dst), len(x))
	va := hwy.Set(a)
	lanes := 8
	var i int
	i = 0
	for ; i+lanes <= n; i += lanes {
		vd := hwy.Load(dst[i:])
		vx := hwy.Load(x[i:])
		result := hwy.FMAF16(va, vx, vd)
		hwy.Store(result, dst[i:])
	}
	if i < n {
		BaseMulConstAddTo_fallback_Float16(dst[i:n], a, x[i:n])
	}
}

func BaseMulConstAddTo_neon_BFloat16(dst []hwy.BFloat16, a hwy.BFloat16, x []hwy.BFloat16) {
	if len(dst) == 0 || len(x) == 0 {
		return
	}
	n := min(len(dst), len(x))
	va := hwy.Set(a)
	lanes := 8
	var i int
	i = 0
	for ; i+lanes <= n; i += lanes {
		vd := hwy.Load(dst[i:])
		vx := hwy.Load(x[i:])
		result := hwy.FMABF16(va, vx, vd)
		hwy.Store(result, dst[i:])
	}
	if i < n {
		BaseMulConstAddTo_fallback_BFloat16(dst[i:n], a, x[i:n])
	}
}

func BaseMulConstAddTo_neon(dst []float32, a float32, x []float32) {
	if len(dst) == 0 || len(x) == 0 {
		return
	}
	n := min(len(dst), len(x))
	va := asm.BroadcastFloat32x4(a)
	lanes := 4
	var i int
	i = 0
	for ; i+lanes <= n; i += lanes {
		vd := asm.LoadFloat32x4Slice(dst[i:])
		vx := asm.LoadFloat32x4Slice(x[i:])
		result := va.MulAdd(vx, vd)
		result.StoreSlice(dst[i:])
	}
	if i < n {
		BaseMulConstAddTo_fallback(dst[i:n], a, x[i:n])
	}
}

func BaseMulConstAddTo_neon_Float64(dst []float64, a float64, x []float64) {
	if len(dst) == 0 || len(x) == 0 {
		return
	}
	n := min(len(dst), len(x))
	va := asm.BroadcastFloat64x2(a)
	lanes := 2
	var i int
	i = 0
	for ; i+lanes <= n; i += lanes {
		vd := asm.LoadFloat64x2Slice(dst[i:])
		vx := asm.LoadFloat64x2Slice(x[i:])
		result := va.MulAdd(vx, vd)
		result.StoreSlice(dst[i:])
	}
	if i < n {
		BaseMulConstAddTo_fallback_Float64(dst[i:n], a, x[i:n])
	}
}
