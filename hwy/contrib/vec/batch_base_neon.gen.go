// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

//go:build arm64

package vec

import (
	"github.com/ajroetker/go-highway/hwy"
	"github.com/ajroetker/go-highway/hwy/asm"
)

func BaseBatchL2SquaredDistance_neon_Float16(query []hwy.Float16, data []hwy.Float16, distances []hwy.Float16, count int, dims int) {
	if count <= 0 || dims <= 0 {
		return
	}
	if len(data) < count*dims {
		return
	}
	if len(distances) < count {
		return
	}
	if len(query) < dims {
		return
	}
	sum := hwy.Zero[hwy.Float16]()
	lanes := 8
	for i := range count {
		dataStart := i * dims
		dataVec := data[dataStart : dataStart+dims]
		sum = hwy.Zero[hwy.Float16]()
		var j int
		for j = 0; j+lanes <= dims; j += lanes {
			vq := hwy.Load(query[j:])
			vd := hwy.Load(dataVec[j:])
			diff := hwy.SubF16(vq, vd)
			diffSq := hwy.MulF16(diff, diff)
			sum = hwy.AddF16(sum, diffSq)
		}
		result := hwy.ReduceSumF16(sum)
		for ; j < dims; j++ {
			diff := query[j].Float32() - dataVec[j].Float32()
			result += diff * diff
		}
		distances[i] = hwy.Float32ToFloat16(result)
	}
}

func BaseBatchL2SquaredDistance_neon_BFloat16(query []hwy.BFloat16, data []hwy.BFloat16, distances []hwy.BFloat16, count int, dims int) {
	if count <= 0 || dims <= 0 {
		return
	}
	if len(data) < count*dims {
		return
	}
	if len(distances) < count {
		return
	}
	if len(query) < dims {
		return
	}
	sum := hwy.Zero[hwy.BFloat16]()
	lanes := 8
	for i := range count {
		dataStart := i * dims
		dataVec := data[dataStart : dataStart+dims]
		sum = hwy.Zero[hwy.BFloat16]()
		var j int
		for j = 0; j+lanes <= dims; j += lanes {
			vq := hwy.Load(query[j:])
			vd := hwy.Load(dataVec[j:])
			diff := hwy.SubBF16(vq, vd)
			diffSq := hwy.MulBF16(diff, diff)
			sum = hwy.AddBF16(sum, diffSq)
		}
		result := hwy.ReduceSumBF16(sum)
		for ; j < dims; j++ {
			diff := query[j].Float32() - dataVec[j].Float32()
			result += diff * diff
		}
		distances[i] = hwy.Float32ToBFloat16(result)
	}
}

func BaseBatchL2SquaredDistance_neon(query []float32, data []float32, distances []float32, count int, dims int) {
	if count <= 0 || dims <= 0 {
		return
	}
	if len(data) < count*dims {
		return
	}
	if len(distances) < count {
		return
	}
	if len(query) < dims {
		return
	}
	sum := asm.ZeroFloat32x4()
	lanes := 4
	for i := range count {
		dataStart := i * dims
		dataVec := data[dataStart : dataStart+dims]
		sum = asm.ZeroFloat32x4()
		var j int
		for j = 0; j+lanes <= dims; j += lanes {
			vq := asm.LoadFloat32x4Slice(query[j:])
			vd := asm.LoadFloat32x4Slice(dataVec[j:])
			diff := vq.Sub(vd)
			diffSq := diff.Mul(diff)
			sum = sum.Add(diffSq)
		}
		result := sum.ReduceSum()
		for ; j < dims; j++ {
			diff := query[j] - dataVec[j]
			result += diff * diff
		}
		distances[i] = result
	}
}

func BaseBatchL2SquaredDistance_neon_Float64(query []float64, data []float64, distances []float64, count int, dims int) {
	if count <= 0 || dims <= 0 {
		return
	}
	if len(data) < count*dims {
		return
	}
	if len(distances) < count {
		return
	}
	if len(query) < dims {
		return
	}
	sum := asm.ZeroFloat64x2()
	lanes := 2
	for i := range count {
		dataStart := i * dims
		dataVec := data[dataStart : dataStart+dims]
		sum = asm.ZeroFloat64x2()
		var j int
		for j = 0; j+lanes <= dims; j += lanes {
			vq := asm.LoadFloat64x2Slice(query[j:])
			vd := asm.LoadFloat64x2Slice(dataVec[j:])
			diff := vq.Sub(vd)
			diffSq := diff.Mul(diff)
			sum = sum.Add(diffSq)
		}
		result := sum.ReduceSum()
		for ; j < dims; j++ {
			diff := query[j] - dataVec[j]
			result += diff * diff
		}
		distances[i] = result
	}
}

func BaseBatchDot_neon_Float16(query []hwy.Float16, data []hwy.Float16, dots []hwy.Float16, count int, dims int) {
	if count <= 0 || dims <= 0 {
		return
	}
	if len(data) < count*dims {
		return
	}
	if len(dots) < count {
		return
	}
	if len(query) < dims {
		return
	}
	sum := hwy.Zero[hwy.Float16]()
	lanes := 8
	for i := range count {
		dataStart := i * dims
		dataVec := data[dataStart : dataStart+dims]
		sum = hwy.Zero[hwy.Float16]()
		var j int
		for j = 0; j+lanes <= dims; j += lanes {
			vq := hwy.Load(query[j:])
			vd := hwy.Load(dataVec[j:])
			prod := hwy.MulF16(vq, vd)
			sum = hwy.AddF16(sum, prod)
		}
		result := hwy.ReduceSumF16(sum)
		for ; j < dims; j++ {
			result += query[j].Float32() * dataVec[j].Float32()
		}
		dots[i] = hwy.Float32ToFloat16(result)
	}
}

func BaseBatchDot_neon_BFloat16(query []hwy.BFloat16, data []hwy.BFloat16, dots []hwy.BFloat16, count int, dims int) {
	if count <= 0 || dims <= 0 {
		return
	}
	if len(data) < count*dims {
		return
	}
	if len(dots) < count {
		return
	}
	if len(query) < dims {
		return
	}
	sum := hwy.Zero[hwy.BFloat16]()
	lanes := 8
	for i := range count {
		dataStart := i * dims
		dataVec := data[dataStart : dataStart+dims]
		sum = hwy.Zero[hwy.BFloat16]()
		var j int
		for j = 0; j+lanes <= dims; j += lanes {
			vq := hwy.Load(query[j:])
			vd := hwy.Load(dataVec[j:])
			prod := hwy.MulBF16(vq, vd)
			sum = hwy.AddBF16(sum, prod)
		}
		result := hwy.ReduceSumBF16(sum)
		for ; j < dims; j++ {
			result += query[j].Float32() * dataVec[j].Float32()
		}
		dots[i] = hwy.Float32ToBFloat16(result)
	}
}

func BaseBatchDot_neon(query []float32, data []float32, dots []float32, count int, dims int) {
	if count <= 0 || dims <= 0 {
		return
	}
	if len(data) < count*dims {
		return
	}
	if len(dots) < count {
		return
	}
	if len(query) < dims {
		return
	}
	sum := asm.ZeroFloat32x4()
	lanes := 4
	for i := range count {
		dataStart := i * dims
		dataVec := data[dataStart : dataStart+dims]
		sum = asm.ZeroFloat32x4()
		var j int
		for j = 0; j+lanes <= dims; j += lanes {
			vq := asm.LoadFloat32x4Slice(query[j:])
			vd := asm.LoadFloat32x4Slice(dataVec[j:])
			prod := vq.Mul(vd)
			sum = sum.Add(prod)
		}
		result := sum.ReduceSum()
		for ; j < dims; j++ {
			result += query[j] * dataVec[j]
		}
		dots[i] = result
	}
}

func BaseBatchDot_neon_Float64(query []float64, data []float64, dots []float64, count int, dims int) {
	if count <= 0 || dims <= 0 {
		return
	}
	if len(data) < count*dims {
		return
	}
	if len(dots) < count {
		return
	}
	if len(query) < dims {
		return
	}
	sum := asm.ZeroFloat64x2()
	lanes := 2
	for i := range count {
		dataStart := i * dims
		dataVec := data[dataStart : dataStart+dims]
		sum = asm.ZeroFloat64x2()
		var j int
		for j = 0; j+lanes <= dims; j += lanes {
			vq := asm.LoadFloat64x2Slice(query[j:])
			vd := asm.LoadFloat64x2Slice(dataVec[j:])
			prod := vq.Mul(vd)
			sum = sum.Add(prod)
		}
		result := sum.ReduceSum()
		for ; j < dims; j++ {
			result += query[j] * dataVec[j]
		}
		dots[i] = result
	}
}
