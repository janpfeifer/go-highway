// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

package bitpack

import (
	"github.com/ajroetker/go-highway/hwy"
)

func BasePack32_fallback(src []uint32, bitWidth int, dst []byte) int {
	if len(src) == 0 || bitWidth == 0 {
		return 0
	}
	if bitWidth > 32 {
		bitWidth = 32
	}
	lanes := hwy.Zero[uint32]().NumLanes()
	mask := uint32((1 << bitWidth) - 1)
	maskVec := hwy.Set[uint32](mask)
	bitPos := 0
	bytePos := 0
	var i int
	for i = 0; i+lanes <= len(src); i += lanes {
		v := hwy.LoadFull(src[i:])
		v = hwy.And(v, maskVec)
		for lane := range lanes {
			val := hwy.GetLane(v, lane)
			packValue32(val, bitWidth, &bitPos, &bytePos, dst)
		}
	}
	for ; i < len(src); i++ {
		val := src[i] & mask
		packValue32(val, bitWidth, &bitPos, &bytePos, dst)
	}
	if bitPos > 0 {
		return bytePos + 1
	}
	return bytePos
}

func BaseUnpack32_fallback(src []byte, bitWidth int, dst []uint32) int {
	if len(src) == 0 || bitWidth == 0 || len(dst) == 0 {
		return 0
	}
	if bitWidth > 32 {
		bitWidth = 32
	}
	mask := uint32((1 << bitWidth) - 1)
	bitPos := 0
	bytePos := 0
	totalBits := len(src) * 8
	var i int
	for i = 0; i < len(dst); i++ {
		if bytePos*8+bitPos+bitWidth > totalBits {
			break
		}
		dst[i] = unpackValue32(mask, bitWidth, &bitPos, &bytePos, src)
	}
	_ = 1
	return i
}

func BasePack64_fallback(src []uint64, bitWidth int, dst []byte) int {
	if len(src) == 0 || bitWidth == 0 {
		return 0
	}
	if bitWidth > 64 {
		bitWidth = 64
	}
	lanes := hwy.Zero[uint64]().NumLanes()
	var mask uint64
	if bitWidth == 64 {
		mask = ^uint64(0)
	} else {
		mask = (1 << bitWidth) - 1
	}
	maskVec := hwy.Set[uint64](mask)
	bitPos := 0
	bytePos := 0
	var i int
	for i = 0; i+lanes <= len(src); i += lanes {
		v := hwy.LoadFull(src[i:])
		v = hwy.And(v, maskVec)
		for lane := range lanes {
			val := hwy.GetLane(v, lane)
			packValue64(val, bitWidth, &bitPos, &bytePos, dst)
		}
	}
	for ; i < len(src); i++ {
		val := src[i] & mask
		packValue64(val, bitWidth, &bitPos, &bytePos, dst)
	}
	if bitPos > 0 {
		return bytePos + 1
	}
	return bytePos
}

func BaseUnpack64_fallback(src []byte, bitWidth int, dst []uint64) int {
	if len(src) == 0 || bitWidth == 0 || len(dst) == 0 {
		return 0
	}
	if bitWidth > 64 {
		bitWidth = 64
	}
	var mask uint64
	if bitWidth == 64 {
		mask = ^uint64(0)
	} else {
		mask = (1 << bitWidth) - 1
	}
	bitPos := 0
	bytePos := 0
	totalBits := len(src) * 8
	var i int
	for i = 0; i < len(dst); i++ {
		if bytePos*8+bitPos+bitWidth > totalBits {
			break
		}
		dst[i] = unpackValue64(mask, bitWidth, &bitPos, &bytePos, src)
	}
	_ = 1
	return i
}

func BaseDeltaEncode32_fallback(src []uint32, base uint32, dst []uint32) {
	if len(src) == 0 {
		return
	}
	if len(dst) < len(src) {
		return
	}
	lanes := hwy.Zero[uint32]().NumLanes()
	dst[0] = src[0] - base
	prev := src[0]
	var i int
	for i = 1; i+lanes <= len(src); i += lanes {
		curr := hwy.LoadFull(src[i:])
		prevVec := hwy.LoadFull(src[i-1:])
		delta := hwy.Sub(curr, prevVec)
		hwy.StoreFull(delta, dst[i:])
		prev = src[i+lanes-1]
	}
	for ; i < len(src); i++ {
		dst[i] = src[i] - prev
		prev = src[i]
	}
}

func BaseDeltaEncode64_fallback(src []uint64, base uint64, dst []uint64) {
	if len(src) == 0 {
		return
	}
	if len(dst) < len(src) {
		return
	}
	lanes := hwy.Zero[uint64]().NumLanes()
	dst[0] = src[0] - base
	prev := src[0]
	var i int
	for i = 1; i+lanes <= len(src); i += lanes {
		curr := hwy.LoadFull(src[i:])
		prevVec := hwy.LoadFull(src[i-1:])
		delta := hwy.Sub(curr, prevVec)
		hwy.StoreFull(delta, dst[i:])
		prev = src[i+lanes-1]
	}
	for ; i < len(src); i++ {
		dst[i] = src[i] - prev
		prev = src[i]
	}
}
