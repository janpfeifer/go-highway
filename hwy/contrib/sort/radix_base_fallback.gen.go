// Code generated by hwygen. DO NOT EDIT.

package sort

import (
	"github.com/ajroetker/go-highway/hwy"
)

func BaseRadixPass_fallback_Int32(src []int32, dst []int32, shift int) {
	n := len(src)
	if n == 0 {
		return
	}
	lanes := hwy.MaxLanes[int32]()
	mask := int32(0xFF)
	maskVec := hwy.Set(mask)
	var count [256]int
	i := 0
	for i+lanes <= n {
		v := hwy.Load(src[i:])
		shifted := hwy.ShiftRight(v, shift)
		digits := hwy.And(shifted, maskVec)
		var buf [16]int32
		hwy.Store(digits, buf[:])
		for j := 0; j < lanes; j++ {
			digit := int(buf[j] & 0xFF)
			count[digit]++
		}
		i += lanes
	}
	for ; i < n; i++ {
		digit := int((src[i] >> shift) & 0xFF)
		count[digit]++
	}
	offset := 0
	for b := 0; b < 256; b++ {
		c := count[b]
		count[b] = offset
		offset += c
	}
	for i := 0; i < n; i++ {
		digit := int((src[i] >> shift) & 0xFF)
		dst[count[digit]] = src[i]
		count[digit]++
	}
}

func BaseRadixPass_fallback_Int64(src []int64, dst []int64, shift int) {
	n := len(src)
	if n == 0 {
		return
	}
	lanes := hwy.MaxLanes[int64]()
	mask := int64(0xFF)
	maskVec := hwy.Set(mask)
	var count [256]int
	i := 0
	for i+lanes <= n {
		v := hwy.Load(src[i:])
		shifted := hwy.ShiftRight(v, shift)
		digits := hwy.And(shifted, maskVec)
		var buf [16]int64
		hwy.Store(digits, buf[:])
		for j := 0; j < lanes; j++ {
			digit := int(buf[j] & 0xFF)
			count[digit]++
		}
		i += lanes
	}
	for ; i < n; i++ {
		digit := int((src[i] >> shift) & 0xFF)
		count[digit]++
	}
	offset := 0
	for b := 0; b < 256; b++ {
		c := count[b]
		count[b] = offset
		offset += c
	}
	for i := 0; i < n; i++ {
		digit := int((src[i] >> shift) & 0xFF)
		dst[count[digit]] = src[i]
		count[digit]++
	}
}

func BaseRadixPassSigned_fallback_Int32(src []int32, dst []int32, shift int) {
	n := len(src)
	if n == 0 {
		return
	}
	lanes := hwy.MaxLanes[int32]()
	mask := int32(0xFF)
	maskVec := hwy.Set(mask)
	var count [256]int
	i := 0
	for i+lanes <= n {
		v := hwy.Load(src[i:])
		shifted := hwy.ShiftRight(v, shift)
		digits := hwy.And(shifted, maskVec)
		var buf [16]int32
		hwy.Store(digits, buf[:])
		for j := 0; j < lanes; j++ {
			digit := int(buf[j] & 0xFF)
			count[digit]++
		}
		i += lanes
	}
	for ; i < n; i++ {
		digit := int((src[i] >> shift) & 0xFF)
		count[digit]++
	}
	offset := 0
	for b := 128; b < 256; b++ {
		c := count[b]
		count[b] = offset
		offset += c
	}
	for b := 0; b < 128; b++ {
		c := count[b]
		count[b] = offset
		offset += c
	}
	for i := 0; i < n; i++ {
		digit := int((src[i] >> shift) & 0xFF)
		dst[count[digit]] = src[i]
		count[digit]++
	}
}

func BaseRadixPassSigned_fallback_Int64(src []int64, dst []int64, shift int) {
	n := len(src)
	if n == 0 {
		return
	}
	lanes := hwy.MaxLanes[int64]()
	mask := int64(0xFF)
	maskVec := hwy.Set(mask)
	var count [256]int
	i := 0
	for i+lanes <= n {
		v := hwy.Load(src[i:])
		shifted := hwy.ShiftRight(v, shift)
		digits := hwy.And(shifted, maskVec)
		var buf [16]int64
		hwy.Store(digits, buf[:])
		for j := 0; j < lanes; j++ {
			digit := int(buf[j] & 0xFF)
			count[digit]++
		}
		i += lanes
	}
	for ; i < n; i++ {
		digit := int((src[i] >> shift) & 0xFF)
		count[digit]++
	}
	offset := 0
	for b := 128; b < 256; b++ {
		c := count[b]
		count[b] = offset
		offset += c
	}
	for b := 0; b < 128; b++ {
		c := count[b]
		count[b] = offset
		offset += c
	}
	for i := 0; i < n; i++ {
		digit := int((src[i] >> shift) & 0xFF)
		dst[count[digit]] = src[i]
		count[digit]++
	}
}
