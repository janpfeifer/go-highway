// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

//go:build arm64

package sort

import (
	"unsafe"

	"github.com/ajroetker/go-highway/hwy/asm"
)

func BaseRadixPass_neon_Int32(src []int32, dst []int32, shift int) {
	n := len(src)
	if n == 0 {
		return
	}
	lanes := 4
	mask := int32(radixMask8_i32)
	maskVec := asm.BroadcastInt32x4(mask)
	var count [256]int
	i := 0
	for i+lanes <= n {
		v := asm.LoadInt32x4((*[4]int32)(unsafe.Pointer(&src[i])))
		shifted := v.ShiftAllRight(shift)
		digits := shifted.And(maskVec)
		var buf [16]int32
		digits.StoreSlice(buf[:])
		for j := range lanes {
			digit := int(buf[j]) & 0xFF
			count[digit]++
		}
		i += lanes
	}
	for ; i < n; i++ {
		digit := int(src[i]>>shift) & 0xFF
		count[digit]++
	}
	offset := 0
	for b := range 256 {
		c := count[b]
		count[b] = offset
		offset += c
	}
	for i := range n {
		digit := int(src[i]>>shift) & 0xFF
		dst[count[digit]] = src[i]
		count[digit]++
	}
}

func BaseRadixPass_neon_Int64(src []int64, dst []int64, shift int) {
	n := len(src)
	if n == 0 {
		return
	}
	lanes := 2
	mask := int64(radixMask8_i64)
	maskVec := asm.BroadcastInt64x2(mask)
	var count [256]int
	i := 0
	for i+lanes <= n {
		v := asm.LoadInt64x2((*[2]int64)(unsafe.Pointer(&src[i])))
		shifted := v.ShiftAllRight(shift)
		digits := shifted.And(maskVec)
		var buf [16]int64
		digits.StoreSlice(buf[:])
		for j := range lanes {
			digit := int(buf[j]) & 0xFF
			count[digit]++
		}
		i += lanes
	}
	for ; i < n; i++ {
		digit := int(src[i]>>shift) & 0xFF
		count[digit]++
	}
	offset := 0
	for b := range 256 {
		c := count[b]
		count[b] = offset
		offset += c
	}
	for i := range n {
		digit := int(src[i]>>shift) & 0xFF
		dst[count[digit]] = src[i]
		count[digit]++
	}
}

func BaseRadixPass16_neon_Int32(src []int32, dst []int32, shift int) {
	n := len(src)
	if n == 0 {
		return
	}
	mask := int32(radixMask16_i32)
	var count [65536]int
	for i := range n {
		digit := int((src[i] >> shift) & mask)
		count[digit]++
	}
	offset := 0
	for b := range 65536 {
		c := count[b]
		count[b] = offset
		offset += c
	}
	for i := range n {
		digit := int((src[i] >> shift) & mask)
		dst[count[digit]] = src[i]
		count[digit]++
	}
}

func BaseRadixPass16_neon_Int64(src []int64, dst []int64, shift int) {
	n := len(src)
	if n == 0 {
		return
	}
	mask := int64(radixMask16_i64)
	var count [65536]int
	for i := range n {
		digit := int((src[i] >> shift) & mask)
		count[digit]++
	}
	offset := 0
	for b := range 65536 {
		c := count[b]
		count[b] = offset
		offset += c
	}
	for i := range n {
		digit := int((src[i] >> shift) & mask)
		dst[count[digit]] = src[i]
		count[digit]++
	}
}

func BaseRadixPass16Signed_neon_Int32(src []int32, dst []int32, shift int) {
	n := len(src)
	if n == 0 {
		return
	}
	mask := int32(radixMask16_i32)
	var count [65536]int
	for i := range n {
		digit := int((src[i] >> shift) & mask)
		count[digit]++
	}
	offset := 0
	for b := 32768; b < 65536; b++ {
		c := count[b]
		count[b] = offset
		offset += c
	}
	for b := range 32768 {
		c := count[b]
		count[b] = offset
		offset += c
	}
	for i := range n {
		digit := int((src[i] >> shift) & mask)
		dst[count[digit]] = src[i]
		count[digit]++
	}
}

func BaseRadixPass16Signed_neon_Int64(src []int64, dst []int64, shift int) {
	n := len(src)
	if n == 0 {
		return
	}
	mask := int64(radixMask16_i64)
	var count [65536]int
	for i := range n {
		digit := int((src[i] >> shift) & mask)
		count[digit]++
	}
	offset := 0
	for b := 32768; b < 65536; b++ {
		c := count[b]
		count[b] = offset
		offset += c
	}
	for b := range 32768 {
		c := count[b]
		count[b] = offset
		offset += c
	}
	for i := range n {
		digit := int((src[i] >> shift) & mask)
		dst[count[digit]] = src[i]
		count[digit]++
	}
}

func BaseRadixPassSigned_neon_Int32(src []int32, dst []int32, shift int) {
	n := len(src)
	if n == 0 {
		return
	}
	lanes := 4
	mask := int32(radixMask8_i32)
	maskVec := asm.BroadcastInt32x4(mask)
	var count [256]int
	i := 0
	for i+lanes <= n {
		v := asm.LoadInt32x4((*[4]int32)(unsafe.Pointer(&src[i])))
		shifted := v.ShiftAllRight(shift)
		digits := shifted.And(maskVec)
		var buf [16]int32
		digits.StoreSlice(buf[:])
		for j := range lanes {
			digit := int(buf[j]) & 0xFF
			count[digit]++
		}
		i += lanes
	}
	for ; i < n; i++ {
		digit := int(src[i]>>shift) & 0xFF
		count[digit]++
	}
	offset := 0
	for b := 128; b < 256; b++ {
		c := count[b]
		count[b] = offset
		offset += c
	}
	for b := range 128 {
		c := count[b]
		count[b] = offset
		offset += c
	}
	for i := range n {
		digit := int(src[i]>>shift) & 0xFF
		dst[count[digit]] = src[i]
		count[digit]++
	}
}

func BaseRadixPassSigned_neon_Int64(src []int64, dst []int64, shift int) {
	n := len(src)
	if n == 0 {
		return
	}
	lanes := 2
	mask := int64(radixMask8_i64)
	maskVec := asm.BroadcastInt64x2(mask)
	var count [256]int
	i := 0
	for i+lanes <= n {
		v := asm.LoadInt64x2((*[2]int64)(unsafe.Pointer(&src[i])))
		shifted := v.ShiftAllRight(shift)
		digits := shifted.And(maskVec)
		var buf [16]int64
		digits.StoreSlice(buf[:])
		for j := range lanes {
			digit := int(buf[j]) & 0xFF
			count[digit]++
		}
		i += lanes
	}
	for ; i < n; i++ {
		digit := int(src[i]>>shift) & 0xFF
		count[digit]++
	}
	offset := 0
	for b := 128; b < 256; b++ {
		c := count[b]
		count[b] = offset
		offset += c
	}
	for b := range 128 {
		c := count[b]
		count[b] = offset
		offset += c
	}
	for i := range n {
		digit := int(src[i]>>shift) & 0xFF
		dst[count[digit]] = src[i]
		count[digit]++
	}
}
