// Code generated by hwygen. DO NOT EDIT.
//go:build arm64

package sort

import (
	"github.com/ajroetker/go-highway/hwy/asm"
)

func BasePartition3Way_neon(data []float32, pivot float32) (int, int) {
	n := len(data)
	if n == 0 {
		return 0, 0
	}
	lanes := 4
	if n < lanes*4 {
		return scalarPartition3Way(data, pivot)
	}
	pivotVec := asm.BroadcastFloat32x4(pivot)
	lt := 0
	gt := n
	i := 0
	for i+lanes <= gt {
		if gt-lanes < i+lanes {
			break
		}
		v := asm.LoadFloat32x4Slice(data[i:])
		maskLess := v.LessThan(pivotVec)
		maskGreater := v.GreaterThan(pivotVec)
		if asm.AllTrueVal(maskLess) {
			if lt == i {
				lt += lanes
				i += lanes
				continue
			}
			if lt+lanes <= i {
				vLt := asm.LoadFloat32x4Slice(data[lt:])
				v.StoreSlice(data[lt:])
				vLt.StoreSlice(data[i:])
				lt += lanes
				i += lanes
				continue
			}
			break
		}
		if asm.AllTrueVal(maskGreater) {
			gt -= lanes
			vGt := asm.LoadFloat32x4Slice(data[gt:])
			v.StoreSlice(data[gt:])
			vGt.StoreSlice(data[i:])
			continue
		}
		if asm.AllFalseVal(maskLess) && asm.AllFalseVal(maskGreater) {
			i += lanes
			continue
		}
		end := i + lanes
		if end > gt {
			end = gt
		}
		for i < end {
			if data[i] < pivot {
				data[lt], data[i] = data[i], data[lt]
				lt++
				i++
			} else if data[i] > pivot {
				gt--
				data[i], data[gt] = data[gt], data[i]
				if gt < end {
					end = gt
				}
			} else {
				i++
			}
		}
	}
	for i < gt {
		if data[i] < pivot {
			data[lt], data[i] = data[i], data[lt]
			lt++
			i++
		} else if data[i] > pivot {
			gt--
			data[i], data[gt] = data[gt], data[i]
		} else {
			i++
		}
	}
	return lt, gt
}

func BasePartition3Way_neon_Float64(data []float64, pivot float64) (int, int) {
	n := len(data)
	if n == 0 {
		return 0, 0
	}
	lanes := 2
	if n < lanes*4 {
		return scalarPartition3Way(data, pivot)
	}
	pivotVec := asm.BroadcastFloat64x2(pivot)
	lt := 0
	gt := n
	i := 0
	for i+lanes <= gt {
		if gt-lanes < i+lanes {
			break
		}
		v := asm.LoadFloat64x2Slice(data[i:])
		maskLess := v.LessThan(pivotVec)
		maskGreater := v.GreaterThan(pivotVec)
		if asm.AllTrueValFloat64(maskLess) {
			if lt == i {
				lt += lanes
				i += lanes
				continue
			}
			if lt+lanes <= i {
				vLt := asm.LoadFloat64x2Slice(data[lt:])
				v.StoreSlice(data[lt:])
				vLt.StoreSlice(data[i:])
				lt += lanes
				i += lanes
				continue
			}
			break
		}
		if asm.AllTrueValFloat64(maskGreater) {
			gt -= lanes
			vGt := asm.LoadFloat64x2Slice(data[gt:])
			v.StoreSlice(data[gt:])
			vGt.StoreSlice(data[i:])
			continue
		}
		if asm.AllFalseValFloat64(maskLess) && asm.AllFalseValFloat64(maskGreater) {
			i += lanes
			continue
		}
		end := i + lanes
		if end > gt {
			end = gt
		}
		for i < end {
			if data[i] < pivot {
				data[lt], data[i] = data[i], data[lt]
				lt++
				i++
			} else if data[i] > pivot {
				gt--
				data[i], data[gt] = data[gt], data[i]
				if gt < end {
					end = gt
				}
			} else {
				i++
			}
		}
	}
	for i < gt {
		if data[i] < pivot {
			data[lt], data[i] = data[i], data[lt]
			lt++
			i++
		} else if data[i] > pivot {
			gt--
			data[i], data[gt] = data[gt], data[i]
		} else {
			i++
		}
	}
	return lt, gt
}

func BasePartition3Way_neon_Int32(data []int32, pivot int32) (int, int) {
	n := len(data)
	if n == 0 {
		return 0, 0
	}
	lanes := 4
	if n < lanes*4 {
		return scalarPartition3Way(data, pivot)
	}
	pivotVec := asm.BroadcastInt32x4(pivot)
	lt := 0
	gt := n
	i := 0
	for i+lanes <= gt {
		if gt-lanes < i+lanes {
			break
		}
		v := asm.LoadInt32x4Slice(data[i:])
		maskLess := v.LessThan(pivotVec)
		maskGreater := v.GreaterThan(pivotVec)
		if asm.AllTrueVal(maskLess) {
			if lt == i {
				lt += lanes
				i += lanes
				continue
			}
			if lt+lanes <= i {
				vLt := asm.LoadInt32x4Slice(data[lt:])
				v.StoreSlice(data[lt:])
				vLt.StoreSlice(data[i:])
				lt += lanes
				i += lanes
				continue
			}
			break
		}
		if asm.AllTrueVal(maskGreater) {
			gt -= lanes
			vGt := asm.LoadInt32x4Slice(data[gt:])
			v.StoreSlice(data[gt:])
			vGt.StoreSlice(data[i:])
			continue
		}
		if asm.AllFalseVal(maskLess) && asm.AllFalseVal(maskGreater) {
			i += lanes
			continue
		}
		end := i + lanes
		if end > gt {
			end = gt
		}
		for i < end {
			if data[i] < pivot {
				data[lt], data[i] = data[i], data[lt]
				lt++
				i++
			} else if data[i] > pivot {
				gt--
				data[i], data[gt] = data[gt], data[i]
				if gt < end {
					end = gt
				}
			} else {
				i++
			}
		}
	}
	for i < gt {
		if data[i] < pivot {
			data[lt], data[i] = data[i], data[lt]
			lt++
			i++
		} else if data[i] > pivot {
			gt--
			data[i], data[gt] = data[gt], data[i]
		} else {
			i++
		}
	}
	return lt, gt
}

func BasePartition3Way_neon_Int64(data []int64, pivot int64) (int, int) {
	n := len(data)
	if n == 0 {
		return 0, 0
	}
	lanes := 2
	if n < lanes*4 {
		return scalarPartition3Way(data, pivot)
	}
	pivotVec := asm.BroadcastInt64x2(pivot)
	lt := 0
	gt := n
	i := 0
	for i+lanes <= gt {
		if gt-lanes < i+lanes {
			break
		}
		v := asm.LoadInt64x2Slice(data[i:])
		maskLess := v.LessThan(pivotVec)
		maskGreater := v.GreaterThan(pivotVec)
		if asm.AllTrueValFloat64(maskLess) {
			if lt == i {
				lt += lanes
				i += lanes
				continue
			}
			if lt+lanes <= i {
				vLt := asm.LoadInt64x2Slice(data[lt:])
				v.StoreSlice(data[lt:])
				vLt.StoreSlice(data[i:])
				lt += lanes
				i += lanes
				continue
			}
			break
		}
		if asm.AllTrueValFloat64(maskGreater) {
			gt -= lanes
			vGt := asm.LoadInt64x2Slice(data[gt:])
			v.StoreSlice(data[gt:])
			vGt.StoreSlice(data[i:])
			continue
		}
		if asm.AllFalseValFloat64(maskLess) && asm.AllFalseValFloat64(maskGreater) {
			i += lanes
			continue
		}
		end := i + lanes
		if end > gt {
			end = gt
		}
		for i < end {
			if data[i] < pivot {
				data[lt], data[i] = data[i], data[lt]
				lt++
				i++
			} else if data[i] > pivot {
				gt--
				data[i], data[gt] = data[gt], data[i]
				if gt < end {
					end = gt
				}
			} else {
				i++
			}
		}
	}
	for i < gt {
		if data[i] < pivot {
			data[lt], data[i] = data[i], data[lt]
			lt++
			i++
		} else if data[i] > pivot {
			gt--
			data[i], data[gt] = data[gt], data[i]
		} else {
			i++
		}
	}
	return lt, gt
}

func BasePartition_neon(data []float32, pivot float32) int {
	n := len(data)
	if n == 0 {
		return 0
	}
	lanes := 4
	if n < lanes*4 {
		return scalarPartition2Way(data, pivot)
	}
	pivotVec := asm.BroadcastFloat32x4(pivot)
	left := 0
	right := n
	for left+lanes <= right {
		if right-lanes < left+lanes {
			break
		}
		v := asm.LoadFloat32x4Slice(data[left:])
		mask := v.LessEqual(pivotVec)
		if asm.AllTrueVal(mask) {
			left += lanes
			continue
		}
		if asm.AllFalseVal(mask) {
			right -= lanes
			vRight := asm.LoadFloat32x4Slice(data[right:])
			v.StoreSlice(data[right:])
			vRight.StoreSlice(data[left:])
			continue
		}
		end := left + lanes
		if end > right {
			end = right
		}
		for left < end {
			if data[left] <= pivot {
				left++
			} else {
				right--
				data[left], data[right] = data[right], data[left]
				if right < end {
					end = right
				}
			}
		}
	}
	for left < right {
		if data[left] <= pivot {
			left++
		} else {
			right--
			data[left], data[right] = data[right], data[left]
		}
	}
	return left
}

func BasePartition_neon_Float64(data []float64, pivot float64) int {
	n := len(data)
	if n == 0 {
		return 0
	}
	lanes := 2
	if n < lanes*4 {
		return scalarPartition2Way(data, pivot)
	}
	pivotVec := asm.BroadcastFloat64x2(pivot)
	left := 0
	right := n
	for left+lanes <= right {
		if right-lanes < left+lanes {
			break
		}
		v := asm.LoadFloat64x2Slice(data[left:])
		mask := v.LessEqual(pivotVec)
		if asm.AllTrueValFloat64(mask) {
			left += lanes
			continue
		}
		if asm.AllFalseValFloat64(mask) {
			right -= lanes
			vRight := asm.LoadFloat64x2Slice(data[right:])
			v.StoreSlice(data[right:])
			vRight.StoreSlice(data[left:])
			continue
		}
		end := left + lanes
		if end > right {
			end = right
		}
		for left < end {
			if data[left] <= pivot {
				left++
			} else {
				right--
				data[left], data[right] = data[right], data[left]
				if right < end {
					end = right
				}
			}
		}
	}
	for left < right {
		if data[left] <= pivot {
			left++
		} else {
			right--
			data[left], data[right] = data[right], data[left]
		}
	}
	return left
}

func BasePartition_neon_Int32(data []int32, pivot int32) int {
	n := len(data)
	if n == 0 {
		return 0
	}
	lanes := 4
	if n < lanes*4 {
		return scalarPartition2Way(data, pivot)
	}
	pivotVec := asm.BroadcastInt32x4(pivot)
	left := 0
	right := n
	for left+lanes <= right {
		if right-lanes < left+lanes {
			break
		}
		v := asm.LoadInt32x4Slice(data[left:])
		mask := v.LessEqual(pivotVec)
		if asm.AllTrueVal(mask) {
			left += lanes
			continue
		}
		if asm.AllFalseVal(mask) {
			right -= lanes
			vRight := asm.LoadInt32x4Slice(data[right:])
			v.StoreSlice(data[right:])
			vRight.StoreSlice(data[left:])
			continue
		}
		end := left + lanes
		if end > right {
			end = right
		}
		for left < end {
			if data[left] <= pivot {
				left++
			} else {
				right--
				data[left], data[right] = data[right], data[left]
				if right < end {
					end = right
				}
			}
		}
	}
	for left < right {
		if data[left] <= pivot {
			left++
		} else {
			right--
			data[left], data[right] = data[right], data[left]
		}
	}
	return left
}

func BasePartition_neon_Int64(data []int64, pivot int64) int {
	n := len(data)
	if n == 0 {
		return 0
	}
	lanes := 2
	if n < lanes*4 {
		return scalarPartition2Way(data, pivot)
	}
	pivotVec := asm.BroadcastInt64x2(pivot)
	left := 0
	right := n
	for left+lanes <= right {
		if right-lanes < left+lanes {
			break
		}
		v := asm.LoadInt64x2Slice(data[left:])
		mask := v.LessEqual(pivotVec)
		if asm.AllTrueValFloat64(mask) {
			left += lanes
			continue
		}
		if asm.AllFalseValFloat64(mask) {
			right -= lanes
			vRight := asm.LoadInt64x2Slice(data[right:])
			v.StoreSlice(data[right:])
			vRight.StoreSlice(data[left:])
			continue
		}
		end := left + lanes
		if end > right {
			end = right
		}
		for left < end {
			if data[left] <= pivot {
				left++
			} else {
				right--
				data[left], data[right] = data[right], data[left]
				if right < end {
					end = right
				}
			}
		}
	}
	for left < right {
		if data[left] <= pivot {
			left++
		} else {
			right--
			data[left], data[right] = data[right], data[left]
		}
	}
	return left
}
