// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

package sort

import (
	"github.com/ajroetker/go-highway/hwy"
)

func BaseCompressPartition3Way_fallback(data []float32, pivot float32) (int, int) {
	lt := 0
	gt := len(data)
	i := 0
	for i < gt {
		if data[i] < pivot {
			data[lt], data[i] = data[i], data[lt]
			lt++
			i++
		} else if data[i] > pivot {
			gt--
			data[i], data[gt] = data[gt], data[i]
		} else {
			i++
		}
	}
	return lt, gt
}

func BaseCompressPartition3Way_fallback_Float64(data []float64, pivot float64) (int, int) {
	lt := 0
	gt := len(data)
	i := 0
	for i < gt {
		if data[i] < pivot {
			data[lt], data[i] = data[i], data[lt]
			lt++
			i++
		} else if data[i] > pivot {
			gt--
			data[i], data[gt] = data[gt], data[i]
		} else {
			i++
		}
	}
	return lt, gt
}

func BaseCompressPartition3Way_fallback_Int32(data []int32, pivot int32) (int, int) {
	lt := 0
	gt := len(data)
	i := 0
	for i < gt {
		if data[i] < pivot {
			data[lt], data[i] = data[i], data[lt]
			lt++
			i++
		} else if data[i] > pivot {
			gt--
			data[i], data[gt] = data[gt], data[i]
		} else {
			i++
		}
	}
	return lt, gt
}

func BaseCompressPartition3Way_fallback_Int64(data []int64, pivot int64) (int, int) {
	lt := 0
	gt := len(data)
	i := 0
	for i < gt {
		if data[i] < pivot {
			data[lt], data[i] = data[i], data[lt]
			lt++
			i++
		} else if data[i] > pivot {
			gt--
			data[i], data[gt] = data[gt], data[i]
		} else {
			i++
		}
	}
	return lt, gt
}

func BaseCompressPartition3Way_fallback_Uint32(data []uint32, pivot uint32) (int, int) {
	lt := 0
	gt := len(data)
	i := 0
	for i < gt {
		if data[i] < pivot {
			data[lt], data[i] = data[i], data[lt]
			lt++
			i++
		} else if data[i] > pivot {
			gt--
			data[i], data[gt] = data[gt], data[i]
		} else {
			i++
		}
	}
	return lt, gt
}

func BaseCompressPartition3Way_fallback_Uint64(data []uint64, pivot uint64) (int, int) {
	lt := 0
	gt := len(data)
	i := 0
	for i < gt {
		if data[i] < pivot {
			data[lt], data[i] = data[i], data[lt]
			lt++
			i++
		} else if data[i] > pivot {
			gt--
			data[i], data[gt] = data[gt], data[i]
		} else {
			i++
		}
	}
	return lt, gt
}

func BaseCompressPartition_fallback(data []float32, pivot float32) int {
	n := len(data)
	if n == 0 {
		return 0
	}
	lanes := hwy.MaxLanes[float32]()
	kUnroll := 4
	preloadSize := kUnroll * lanes
	if n < 2*preloadSize {
		return scalarPartition2Way(data, pivot)
	}
	middleSize := n - 2*preloadSize
	if middleSize%lanes != 0 {
		return scalarPartition2Way(data, pivot)
	}
	pivotVec := hwy.Set(pivot)
	preloadL := make([]float32, preloadSize)
	preloadR := make([]float32, preloadSize)
	copy(preloadL, data[:preloadSize])
	copy(preloadR, data[n-preloadSize:])
	readL := preloadSize
	readR := n - preloadSize
	writeL := 0
	remaining := n
	for readL < readR {
		var v hwy.Vec[float32]
		capacityL := readL - writeL
		if capacityL > preloadSize {
			readR -= lanes
			v = hwy.LoadFull(data[readR:])
		} else {
			v = hwy.LoadFull(data[readL:])
			readL += lanes
		}
		maskLess := hwy.LessThan(v, pivotVec)
		numLess := hwy.CountTrue(maskLess)
		compressed, _ := hwy.Compress(v, maskLess)
		remaining -= lanes
		hwy.StoreFull(compressed, data[writeL:])
		hwy.StoreFull(compressed, data[remaining+writeL:])
		writeL += numLess
	}
	for i := 0; i < preloadSize; i += lanes {
		v := hwy.LoadFull(preloadL[i:])
		maskLess := hwy.LessThan(v, pivotVec)
		numLess := hwy.CountTrue(maskLess)
		compressed, _ := hwy.Compress(v, maskLess)
		remaining -= lanes
		hwy.StoreFull(compressed, data[writeL:])
		hwy.StoreFull(compressed, data[remaining+writeL:])
		writeL += numLess
	}
	for i := 0; i < preloadSize-2*lanes; i += lanes {
		v := hwy.LoadFull(preloadR[i:])
		maskLess := hwy.LessThan(v, pivotVec)
		numLess := hwy.CountTrue(maskLess)
		compressed, _ := hwy.Compress(v, maskLess)
		remaining -= lanes
		hwy.StoreFull(compressed, data[writeL:])
		hwy.StoreFull(compressed, data[remaining+writeL:])
		writeL += numLess
	}
	var buf [32]float32
	bufL := 0
	writeR := writeL + remaining
	for i := preloadSize - 2*lanes; i < preloadSize; i += lanes {
		v := hwy.LoadFull(preloadR[i:])
		maskLess := hwy.LessThan(v, pivotVec)
		numLess := hwy.CountTrue(maskLess)
		compressed, _ := hwy.Compress(v, maskLess)
		hwy.Store(compressed, buf[bufL:])
		bufL += numLess
		numRight := lanes - numLess
		writeR -= numRight
		copy(data[writeR:], buf[bufL:bufL+numRight])
	}
	copy(data[writeL:], buf[:bufL])
	return writeL + bufL
}

func BaseCompressPartition_fallback_Float64(data []float64, pivot float64) int {
	n := len(data)
	if n == 0 {
		return 0
	}
	lanes := hwy.MaxLanes[float64]()
	kUnroll := 4
	preloadSize := kUnroll * lanes
	if n < 2*preloadSize {
		return scalarPartition2Way(data, pivot)
	}
	middleSize := n - 2*preloadSize
	if middleSize%lanes != 0 {
		return scalarPartition2Way(data, pivot)
	}
	pivotVec := hwy.Set(pivot)
	preloadL := make([]float64, preloadSize)
	preloadR := make([]float64, preloadSize)
	copy(preloadL, data[:preloadSize])
	copy(preloadR, data[n-preloadSize:])
	readL := preloadSize
	readR := n - preloadSize
	writeL := 0
	remaining := n
	for readL < readR {
		var v hwy.Vec[float64]
		capacityL := readL - writeL
		if capacityL > preloadSize {
			readR -= lanes
			v = hwy.LoadFull(data[readR:])
		} else {
			v = hwy.LoadFull(data[readL:])
			readL += lanes
		}
		maskLess := hwy.LessThan(v, pivotVec)
		numLess := hwy.CountTrue(maskLess)
		compressed, _ := hwy.Compress(v, maskLess)
		remaining -= lanes
		hwy.StoreFull(compressed, data[writeL:])
		hwy.StoreFull(compressed, data[remaining+writeL:])
		writeL += numLess
	}
	for i := 0; i < preloadSize; i += lanes {
		v := hwy.LoadFull(preloadL[i:])
		maskLess := hwy.LessThan(v, pivotVec)
		numLess := hwy.CountTrue(maskLess)
		compressed, _ := hwy.Compress(v, maskLess)
		remaining -= lanes
		hwy.StoreFull(compressed, data[writeL:])
		hwy.StoreFull(compressed, data[remaining+writeL:])
		writeL += numLess
	}
	for i := 0; i < preloadSize-2*lanes; i += lanes {
		v := hwy.LoadFull(preloadR[i:])
		maskLess := hwy.LessThan(v, pivotVec)
		numLess := hwy.CountTrue(maskLess)
		compressed, _ := hwy.Compress(v, maskLess)
		remaining -= lanes
		hwy.StoreFull(compressed, data[writeL:])
		hwy.StoreFull(compressed, data[remaining+writeL:])
		writeL += numLess
	}
	var buf [32]float64
	bufL := 0
	writeR := writeL + remaining
	for i := preloadSize - 2*lanes; i < preloadSize; i += lanes {
		v := hwy.LoadFull(preloadR[i:])
		maskLess := hwy.LessThan(v, pivotVec)
		numLess := hwy.CountTrue(maskLess)
		compressed, _ := hwy.Compress(v, maskLess)
		hwy.Store(compressed, buf[bufL:])
		bufL += numLess
		numRight := lanes - numLess
		writeR -= numRight
		copy(data[writeR:], buf[bufL:bufL+numRight])
	}
	copy(data[writeL:], buf[:bufL])
	return writeL + bufL
}

func BaseCompressPartition_fallback_Int32(data []int32, pivot int32) int {
	n := len(data)
	if n == 0 {
		return 0
	}
	lanes := hwy.MaxLanes[int32]()
	kUnroll := 4
	preloadSize := kUnroll * lanes
	if n < 2*preloadSize {
		return scalarPartition2Way(data, pivot)
	}
	middleSize := n - 2*preloadSize
	if middleSize%lanes != 0 {
		return scalarPartition2Way(data, pivot)
	}
	pivotVec := hwy.Set(pivot)
	preloadL := make([]int32, preloadSize)
	preloadR := make([]int32, preloadSize)
	copy(preloadL, data[:preloadSize])
	copy(preloadR, data[n-preloadSize:])
	readL := preloadSize
	readR := n - preloadSize
	writeL := 0
	remaining := n
	for readL < readR {
		var v hwy.Vec[int32]
		capacityL := readL - writeL
		if capacityL > preloadSize {
			readR -= lanes
			v = hwy.LoadFull(data[readR:])
		} else {
			v = hwy.LoadFull(data[readL:])
			readL += lanes
		}
		maskLess := hwy.LessThan(v, pivotVec)
		numLess := hwy.CountTrue(maskLess)
		compressed, _ := hwy.Compress(v, maskLess)
		remaining -= lanes
		hwy.StoreFull(compressed, data[writeL:])
		hwy.StoreFull(compressed, data[remaining+writeL:])
		writeL += numLess
	}
	for i := 0; i < preloadSize; i += lanes {
		v := hwy.LoadFull(preloadL[i:])
		maskLess := hwy.LessThan(v, pivotVec)
		numLess := hwy.CountTrue(maskLess)
		compressed, _ := hwy.Compress(v, maskLess)
		remaining -= lanes
		hwy.StoreFull(compressed, data[writeL:])
		hwy.StoreFull(compressed, data[remaining+writeL:])
		writeL += numLess
	}
	for i := 0; i < preloadSize-2*lanes; i += lanes {
		v := hwy.LoadFull(preloadR[i:])
		maskLess := hwy.LessThan(v, pivotVec)
		numLess := hwy.CountTrue(maskLess)
		compressed, _ := hwy.Compress(v, maskLess)
		remaining -= lanes
		hwy.StoreFull(compressed, data[writeL:])
		hwy.StoreFull(compressed, data[remaining+writeL:])
		writeL += numLess
	}
	var buf [32]int32
	bufL := 0
	writeR := writeL + remaining
	for i := preloadSize - 2*lanes; i < preloadSize; i += lanes {
		v := hwy.LoadFull(preloadR[i:])
		maskLess := hwy.LessThan(v, pivotVec)
		numLess := hwy.CountTrue(maskLess)
		compressed, _ := hwy.Compress(v, maskLess)
		hwy.Store(compressed, buf[bufL:])
		bufL += numLess
		numRight := lanes - numLess
		writeR -= numRight
		copy(data[writeR:], buf[bufL:bufL+numRight])
	}
	copy(data[writeL:], buf[:bufL])
	return writeL + bufL
}

func BaseCompressPartition_fallback_Int64(data []int64, pivot int64) int {
	n := len(data)
	if n == 0 {
		return 0
	}
	lanes := hwy.MaxLanes[int64]()
	kUnroll := 4
	preloadSize := kUnroll * lanes
	if n < 2*preloadSize {
		return scalarPartition2Way(data, pivot)
	}
	middleSize := n - 2*preloadSize
	if middleSize%lanes != 0 {
		return scalarPartition2Way(data, pivot)
	}
	pivotVec := hwy.Set(pivot)
	preloadL := make([]int64, preloadSize)
	preloadR := make([]int64, preloadSize)
	copy(preloadL, data[:preloadSize])
	copy(preloadR, data[n-preloadSize:])
	readL := preloadSize
	readR := n - preloadSize
	writeL := 0
	remaining := n
	for readL < readR {
		var v hwy.Vec[int64]
		capacityL := readL - writeL
		if capacityL > preloadSize {
			readR -= lanes
			v = hwy.LoadFull(data[readR:])
		} else {
			v = hwy.LoadFull(data[readL:])
			readL += lanes
		}
		maskLess := hwy.LessThan(v, pivotVec)
		numLess := hwy.CountTrue(maskLess)
		compressed, _ := hwy.Compress(v, maskLess)
		remaining -= lanes
		hwy.StoreFull(compressed, data[writeL:])
		hwy.StoreFull(compressed, data[remaining+writeL:])
		writeL += numLess
	}
	for i := 0; i < preloadSize; i += lanes {
		v := hwy.LoadFull(preloadL[i:])
		maskLess := hwy.LessThan(v, pivotVec)
		numLess := hwy.CountTrue(maskLess)
		compressed, _ := hwy.Compress(v, maskLess)
		remaining -= lanes
		hwy.StoreFull(compressed, data[writeL:])
		hwy.StoreFull(compressed, data[remaining+writeL:])
		writeL += numLess
	}
	for i := 0; i < preloadSize-2*lanes; i += lanes {
		v := hwy.LoadFull(preloadR[i:])
		maskLess := hwy.LessThan(v, pivotVec)
		numLess := hwy.CountTrue(maskLess)
		compressed, _ := hwy.Compress(v, maskLess)
		remaining -= lanes
		hwy.StoreFull(compressed, data[writeL:])
		hwy.StoreFull(compressed, data[remaining+writeL:])
		writeL += numLess
	}
	var buf [32]int64
	bufL := 0
	writeR := writeL + remaining
	for i := preloadSize - 2*lanes; i < preloadSize; i += lanes {
		v := hwy.LoadFull(preloadR[i:])
		maskLess := hwy.LessThan(v, pivotVec)
		numLess := hwy.CountTrue(maskLess)
		compressed, _ := hwy.Compress(v, maskLess)
		hwy.Store(compressed, buf[bufL:])
		bufL += numLess
		numRight := lanes - numLess
		writeR -= numRight
		copy(data[writeR:], buf[bufL:bufL+numRight])
	}
	copy(data[writeL:], buf[:bufL])
	return writeL + bufL
}

func BaseCompressPartition_fallback_Uint32(data []uint32, pivot uint32) int {
	n := len(data)
	if n == 0 {
		return 0
	}
	lanes := hwy.MaxLanes[uint32]()
	kUnroll := 4
	preloadSize := kUnroll * lanes
	if n < 2*preloadSize {
		return scalarPartition2Way(data, pivot)
	}
	middleSize := n - 2*preloadSize
	if middleSize%lanes != 0 {
		return scalarPartition2Way(data, pivot)
	}
	pivotVec := hwy.Set(pivot)
	preloadL := make([]uint32, preloadSize)
	preloadR := make([]uint32, preloadSize)
	copy(preloadL, data[:preloadSize])
	copy(preloadR, data[n-preloadSize:])
	readL := preloadSize
	readR := n - preloadSize
	writeL := 0
	remaining := n
	for readL < readR {
		var v hwy.Vec[uint32]
		capacityL := readL - writeL
		if capacityL > preloadSize {
			readR -= lanes
			v = hwy.LoadFull(data[readR:])
		} else {
			v = hwy.LoadFull(data[readL:])
			readL += lanes
		}
		maskLess := hwy.LessThan(v, pivotVec)
		numLess := hwy.CountTrue(maskLess)
		compressed, _ := hwy.Compress(v, maskLess)
		remaining -= lanes
		hwy.StoreFull(compressed, data[writeL:])
		hwy.StoreFull(compressed, data[remaining+writeL:])
		writeL += numLess
	}
	for i := 0; i < preloadSize; i += lanes {
		v := hwy.LoadFull(preloadL[i:])
		maskLess := hwy.LessThan(v, pivotVec)
		numLess := hwy.CountTrue(maskLess)
		compressed, _ := hwy.Compress(v, maskLess)
		remaining -= lanes
		hwy.StoreFull(compressed, data[writeL:])
		hwy.StoreFull(compressed, data[remaining+writeL:])
		writeL += numLess
	}
	for i := 0; i < preloadSize-2*lanes; i += lanes {
		v := hwy.LoadFull(preloadR[i:])
		maskLess := hwy.LessThan(v, pivotVec)
		numLess := hwy.CountTrue(maskLess)
		compressed, _ := hwy.Compress(v, maskLess)
		remaining -= lanes
		hwy.StoreFull(compressed, data[writeL:])
		hwy.StoreFull(compressed, data[remaining+writeL:])
		writeL += numLess
	}
	var buf [32]uint32
	bufL := 0
	writeR := writeL + remaining
	for i := preloadSize - 2*lanes; i < preloadSize; i += lanes {
		v := hwy.LoadFull(preloadR[i:])
		maskLess := hwy.LessThan(v, pivotVec)
		numLess := hwy.CountTrue(maskLess)
		compressed, _ := hwy.Compress(v, maskLess)
		hwy.Store(compressed, buf[bufL:])
		bufL += numLess
		numRight := lanes - numLess
		writeR -= numRight
		copy(data[writeR:], buf[bufL:bufL+numRight])
	}
	copy(data[writeL:], buf[:bufL])
	return writeL + bufL
}

func BaseCompressPartition_fallback_Uint64(data []uint64, pivot uint64) int {
	n := len(data)
	if n == 0 {
		return 0
	}
	lanes := hwy.MaxLanes[uint64]()
	kUnroll := 4
	preloadSize := kUnroll * lanes
	if n < 2*preloadSize {
		return scalarPartition2Way(data, pivot)
	}
	middleSize := n - 2*preloadSize
	if middleSize%lanes != 0 {
		return scalarPartition2Way(data, pivot)
	}
	pivotVec := hwy.Set(pivot)
	preloadL := make([]uint64, preloadSize)
	preloadR := make([]uint64, preloadSize)
	copy(preloadL, data[:preloadSize])
	copy(preloadR, data[n-preloadSize:])
	readL := preloadSize
	readR := n - preloadSize
	writeL := 0
	remaining := n
	for readL < readR {
		var v hwy.Vec[uint64]
		capacityL := readL - writeL
		if capacityL > preloadSize {
			readR -= lanes
			v = hwy.LoadFull(data[readR:])
		} else {
			v = hwy.LoadFull(data[readL:])
			readL += lanes
		}
		maskLess := hwy.LessThan(v, pivotVec)
		numLess := hwy.CountTrue(maskLess)
		compressed, _ := hwy.Compress(v, maskLess)
		remaining -= lanes
		hwy.StoreFull(compressed, data[writeL:])
		hwy.StoreFull(compressed, data[remaining+writeL:])
		writeL += numLess
	}
	for i := 0; i < preloadSize; i += lanes {
		v := hwy.LoadFull(preloadL[i:])
		maskLess := hwy.LessThan(v, pivotVec)
		numLess := hwy.CountTrue(maskLess)
		compressed, _ := hwy.Compress(v, maskLess)
		remaining -= lanes
		hwy.StoreFull(compressed, data[writeL:])
		hwy.StoreFull(compressed, data[remaining+writeL:])
		writeL += numLess
	}
	for i := 0; i < preloadSize-2*lanes; i += lanes {
		v := hwy.LoadFull(preloadR[i:])
		maskLess := hwy.LessThan(v, pivotVec)
		numLess := hwy.CountTrue(maskLess)
		compressed, _ := hwy.Compress(v, maskLess)
		remaining -= lanes
		hwy.StoreFull(compressed, data[writeL:])
		hwy.StoreFull(compressed, data[remaining+writeL:])
		writeL += numLess
	}
	var buf [32]uint64
	bufL := 0
	writeR := writeL + remaining
	for i := preloadSize - 2*lanes; i < preloadSize; i += lanes {
		v := hwy.LoadFull(preloadR[i:])
		maskLess := hwy.LessThan(v, pivotVec)
		numLess := hwy.CountTrue(maskLess)
		compressed, _ := hwy.Compress(v, maskLess)
		hwy.Store(compressed, buf[bufL:])
		bufL += numLess
		numRight := lanes - numLess
		writeR -= numRight
		copy(data[writeR:], buf[bufL:bufL+numRight])
	}
	copy(data[writeL:], buf[:bufL])
	return writeL + bufL
}
