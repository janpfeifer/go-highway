// Code generated by hwygen. DO NOT EDIT.
//go:build amd64 && goexperiment.simd

package sort

import (
	"github.com/ajroetker/go-highway/hwy"
	"simd/archsimd"
)

func BaseFloatToSortable_avx512(data []float32) {
	n := len(data)
	lanes := 16
	signBitVec := hwy.SignBit_AVX512_F32x16()
	zeroVec := archsimd.BroadcastFloat32x16(0)
	allOnesVec := hwy.Not_AVX512_F32x16(zeroVec)
	i := 0
	for i+lanes <= n {
		v := archsimd.LoadFloat32x16Slice(data[i:])
		isNeg := v.Less(zeroVec)
		negResult := hwy.Xor_AVX512_F32x16(v, allOnesVec)
		posResult := hwy.Xor_AVX512_F32x16(v, signBitVec)
		result := hwy.IfThenElse_AVX512_F32x16(isNeg, negResult, posResult)
		result.StoreSlice(data[i:])
		i += lanes
	}
}

func BaseFloatToSortable_avx512_Float64(data []float64) {
	n := len(data)
	lanes := 8
	signBitVec := hwy.SignBit_AVX512_F64x8()
	zeroVec := archsimd.BroadcastFloat64x8(0)
	allOnesVec := hwy.Not_AVX512_F64x8(zeroVec)
	i := 0
	for i+lanes <= n {
		v := archsimd.LoadFloat64x8Slice(data[i:])
		isNeg := v.Less(zeroVec)
		negResult := hwy.Xor_AVX512_F64x8(v, allOnesVec)
		posResult := hwy.Xor_AVX512_F64x8(v, signBitVec)
		result := hwy.IfThenElse_AVX512_F64x8(isNeg, negResult, posResult)
		result.StoreSlice(data[i:])
		i += lanes
	}
}

func BaseSortableToFloat_avx512(data []float32) {
	n := len(data)
	lanes := 16
	signBitVec := hwy.SignBit_AVX512_F32x16()
	zeroVec := archsimd.BroadcastFloat32x16(0)
	allOnesVec := hwy.Not_AVX512_F32x16(zeroVec)
	i := 0
	for i+lanes <= n {
		v := archsimd.LoadFloat32x16Slice(data[i:])
		masked := hwy.And_AVX512_F32x16(v, signBitVec)
		wasPositive := masked.NotEqual(zeroVec)
		posResult := hwy.Xor_AVX512_F32x16(v, signBitVec)
		negResult := hwy.Xor_AVX512_F32x16(v, allOnesVec)
		result := hwy.IfThenElse_AVX512_F32x16(wasPositive, posResult, negResult)
		result.StoreSlice(data[i:])
		i += lanes
	}
}

func BaseSortableToFloat_avx512_Float64(data []float64) {
	n := len(data)
	lanes := 8
	signBitVec := hwy.SignBit_AVX512_F64x8()
	zeroVec := archsimd.BroadcastFloat64x8(0)
	allOnesVec := hwy.Not_AVX512_F64x8(zeroVec)
	i := 0
	for i+lanes <= n {
		v := archsimd.LoadFloat64x8Slice(data[i:])
		masked := hwy.And_AVX512_F64x8(v, signBitVec)
		wasPositive := masked.NotEqual(zeroVec)
		posResult := hwy.Xor_AVX512_F64x8(v, signBitVec)
		negResult := hwy.Xor_AVX512_F64x8(v, allOnesVec)
		result := hwy.IfThenElse_AVX512_F64x8(wasPositive, posResult, negResult)
		result.StoreSlice(data[i:])
		i += lanes
	}
}
