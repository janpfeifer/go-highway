// Code generated by hwygen. DO NOT EDIT.
//go:build amd64 && goexperiment.simd

package sort

import (
	"github.com/ajroetker/go-highway/hwy"
	"simd/archsimd"
)

func BasePartition3Way_avx512(data []float32, pivot float32) (int, int) {
	n := len(data)
	if n == 0 {
		return 0, 0
	}
	lanes := 16
	if n < lanes*4 {
		return scalarPartition3Way(data, pivot)
	}
	pivotVec := archsimd.BroadcastFloat32x16(pivot)
	lt := 0
	gt := n
	i := 0
	for i+lanes <= gt {
		if gt-lanes < i+lanes {
			break
		}
		v := archsimd.LoadFloat32x16Slice(data[i:])
		maskLess := v.Less(pivotVec)
		maskGreater := v.Greater(pivotVec)
		if hwy.AllTrue_AVX512_F32x16(maskLess) {
			if lt == i {
				lt += lanes
				i += lanes
				continue
			}
			if lt+lanes <= i {
				vLt := archsimd.LoadFloat32x16Slice(data[lt:])
				v.StoreSlice(data[lt:])
				vLt.StoreSlice(data[i:])
				lt += lanes
				i += lanes
				continue
			}
			break
		}
		if hwy.AllTrue_AVX512_F32x16(maskGreater) {
			gt -= lanes
			vGt := archsimd.LoadFloat32x16Slice(data[gt:])
			v.StoreSlice(data[gt:])
			vGt.StoreSlice(data[i:])
			continue
		}
		if hwy.AllFalse_AVX512_F32x16(maskLess) && hwy.AllFalse_AVX512_F32x16(maskGreater) {
			i += lanes
			continue
		}
		end := min(i+lanes, gt)
		for i < end {
			if data[i] < pivot {
				data[lt], data[i] = data[i], data[lt]
				lt++
				i++
			} else if data[i] > pivot {
				gt--
				data[i], data[gt] = data[gt], data[i]
				if gt < end {
					end = gt
				}
			} else {
				i++
			}
		}
	}
	for i < gt {
		if data[i] < pivot {
			data[lt], data[i] = data[i], data[lt]
			lt++
			i++
		} else if data[i] > pivot {
			gt--
			data[i], data[gt] = data[gt], data[i]
		} else {
			i++
		}
	}
	return lt, gt
}

func BasePartition3Way_avx512_Float64(data []float64, pivot float64) (int, int) {
	n := len(data)
	if n == 0 {
		return 0, 0
	}
	lanes := 8
	if n < lanes*4 {
		return scalarPartition3Way(data, pivot)
	}
	pivotVec := archsimd.BroadcastFloat64x8(pivot)
	lt := 0
	gt := n
	i := 0
	for i+lanes <= gt {
		if gt-lanes < i+lanes {
			break
		}
		v := archsimd.LoadFloat64x8Slice(data[i:])
		maskLess := v.Less(pivotVec)
		maskGreater := v.Greater(pivotVec)
		if hwy.AllTrue_AVX512_F64x8(maskLess) {
			if lt == i {
				lt += lanes
				i += lanes
				continue
			}
			if lt+lanes <= i {
				vLt := archsimd.LoadFloat64x8Slice(data[lt:])
				v.StoreSlice(data[lt:])
				vLt.StoreSlice(data[i:])
				lt += lanes
				i += lanes
				continue
			}
			break
		}
		if hwy.AllTrue_AVX512_F64x8(maskGreater) {
			gt -= lanes
			vGt := archsimd.LoadFloat64x8Slice(data[gt:])
			v.StoreSlice(data[gt:])
			vGt.StoreSlice(data[i:])
			continue
		}
		if hwy.AllFalse_AVX512_F64x8(maskLess) && hwy.AllFalse_AVX512_F64x8(maskGreater) {
			i += lanes
			continue
		}
		end := min(i+lanes, gt)
		for i < end {
			if data[i] < pivot {
				data[lt], data[i] = data[i], data[lt]
				lt++
				i++
			} else if data[i] > pivot {
				gt--
				data[i], data[gt] = data[gt], data[i]
				if gt < end {
					end = gt
				}
			} else {
				i++
			}
		}
	}
	for i < gt {
		if data[i] < pivot {
			data[lt], data[i] = data[i], data[lt]
			lt++
			i++
		} else if data[i] > pivot {
			gt--
			data[i], data[gt] = data[gt], data[i]
		} else {
			i++
		}
	}
	return lt, gt
}

func BasePartition3Way_avx512_Int32(data []int32, pivot int32) (int, int) {
	n := len(data)
	if n == 0 {
		return 0, 0
	}
	lanes := 16
	if n < lanes*4 {
		return scalarPartition3Way(data, pivot)
	}
	pivotVec := archsimd.BroadcastInt32x16(pivot)
	lt := 0
	gt := n
	i := 0
	for i+lanes <= gt {
		if gt-lanes < i+lanes {
			break
		}
		v := archsimd.LoadInt32x16Slice(data[i:])
		maskLess := v.Less(pivotVec)
		maskGreater := v.Greater(pivotVec)
		if hwy.AllTrue_AVX512_I32x16(maskLess) {
			if lt == i {
				lt += lanes
				i += lanes
				continue
			}
			if lt+lanes <= i {
				vLt := archsimd.LoadInt32x16Slice(data[lt:])
				v.StoreSlice(data[lt:])
				vLt.StoreSlice(data[i:])
				lt += lanes
				i += lanes
				continue
			}
			break
		}
		if hwy.AllTrue_AVX512_I32x16(maskGreater) {
			gt -= lanes
			vGt := archsimd.LoadInt32x16Slice(data[gt:])
			v.StoreSlice(data[gt:])
			vGt.StoreSlice(data[i:])
			continue
		}
		if hwy.AllFalse_AVX512_I32x16(maskLess) && hwy.AllFalse_AVX512_I32x16(maskGreater) {
			i += lanes
			continue
		}
		end := min(i+lanes, gt)
		for i < end {
			if data[i] < pivot {
				data[lt], data[i] = data[i], data[lt]
				lt++
				i++
			} else if data[i] > pivot {
				gt--
				data[i], data[gt] = data[gt], data[i]
				if gt < end {
					end = gt
				}
			} else {
				i++
			}
		}
	}
	for i < gt {
		if data[i] < pivot {
			data[lt], data[i] = data[i], data[lt]
			lt++
			i++
		} else if data[i] > pivot {
			gt--
			data[i], data[gt] = data[gt], data[i]
		} else {
			i++
		}
	}
	return lt, gt
}

func BasePartition3Way_avx512_Int64(data []int64, pivot int64) (int, int) {
	n := len(data)
	if n == 0 {
		return 0, 0
	}
	lanes := 8
	if n < lanes*4 {
		return scalarPartition3Way(data, pivot)
	}
	pivotVec := archsimd.BroadcastInt64x8(pivot)
	lt := 0
	gt := n
	i := 0
	for i+lanes <= gt {
		if gt-lanes < i+lanes {
			break
		}
		v := archsimd.LoadInt64x8Slice(data[i:])
		maskLess := v.Less(pivotVec)
		maskGreater := v.Greater(pivotVec)
		if hwy.AllTrue_AVX512_I64x8(maskLess) {
			if lt == i {
				lt += lanes
				i += lanes
				continue
			}
			if lt+lanes <= i {
				vLt := archsimd.LoadInt64x8Slice(data[lt:])
				v.StoreSlice(data[lt:])
				vLt.StoreSlice(data[i:])
				lt += lanes
				i += lanes
				continue
			}
			break
		}
		if hwy.AllTrue_AVX512_I64x8(maskGreater) {
			gt -= lanes
			vGt := archsimd.LoadInt64x8Slice(data[gt:])
			v.StoreSlice(data[gt:])
			vGt.StoreSlice(data[i:])
			continue
		}
		if hwy.AllFalse_AVX512_I64x8(maskLess) && hwy.AllFalse_AVX512_I64x8(maskGreater) {
			i += lanes
			continue
		}
		end := min(i+lanes, gt)
		for i < end {
			if data[i] < pivot {
				data[lt], data[i] = data[i], data[lt]
				lt++
				i++
			} else if data[i] > pivot {
				gt--
				data[i], data[gt] = data[gt], data[i]
				if gt < end {
					end = gt
				}
			} else {
				i++
			}
		}
	}
	for i < gt {
		if data[i] < pivot {
			data[lt], data[i] = data[i], data[lt]
			lt++
			i++
		} else if data[i] > pivot {
			gt--
			data[i], data[gt] = data[gt], data[i]
		} else {
			i++
		}
	}
	return lt, gt
}

func BasePartition3Way_avx512_Uint32(data []uint32, pivot uint32) (int, int) {
	n := len(data)
	if n == 0 {
		return 0, 0
	}
	lanes := 16
	if n < lanes*4 {
		return scalarPartition3Way(data, pivot)
	}
	pivotVec := archsimd.BroadcastUint32x16(pivot)
	lt := 0
	gt := n
	i := 0
	for i+lanes <= gt {
		if gt-lanes < i+lanes {
			break
		}
		v := archsimd.LoadUint32x16Slice(data[i:])
		maskLess := v.Less(pivotVec)
		maskGreater := v.Greater(pivotVec)
		if hwy.AllTrue_AVX512_Uint32x16(maskLess) {
			if lt == i {
				lt += lanes
				i += lanes
				continue
			}
			if lt+lanes <= i {
				vLt := archsimd.LoadUint32x16Slice(data[lt:])
				v.StoreSlice(data[lt:])
				vLt.StoreSlice(data[i:])
				lt += lanes
				i += lanes
				continue
			}
			break
		}
		if hwy.AllTrue_AVX512_Uint32x16(maskGreater) {
			gt -= lanes
			vGt := archsimd.LoadUint32x16Slice(data[gt:])
			v.StoreSlice(data[gt:])
			vGt.StoreSlice(data[i:])
			continue
		}
		if hwy.AllFalse_AVX512_Uint32x16(maskLess) && hwy.AllFalse_AVX512_Uint32x16(maskGreater) {
			i += lanes
			continue
		}
		end := min(i+lanes, gt)
		for i < end {
			if data[i] < pivot {
				data[lt], data[i] = data[i], data[lt]
				lt++
				i++
			} else if data[i] > pivot {
				gt--
				data[i], data[gt] = data[gt], data[i]
				if gt < end {
					end = gt
				}
			} else {
				i++
			}
		}
	}
	for i < gt {
		if data[i] < pivot {
			data[lt], data[i] = data[i], data[lt]
			lt++
			i++
		} else if data[i] > pivot {
			gt--
			data[i], data[gt] = data[gt], data[i]
		} else {
			i++
		}
	}
	return lt, gt
}

func BasePartition3Way_avx512_Uint64(data []uint64, pivot uint64) (int, int) {
	n := len(data)
	if n == 0 {
		return 0, 0
	}
	lanes := 8
	if n < lanes*4 {
		return scalarPartition3Way(data, pivot)
	}
	pivotVec := archsimd.BroadcastUint64x8(pivot)
	lt := 0
	gt := n
	i := 0
	for i+lanes <= gt {
		if gt-lanes < i+lanes {
			break
		}
		v := archsimd.LoadUint64x8Slice(data[i:])
		maskLess := v.Less(pivotVec)
		maskGreater := v.Greater(pivotVec)
		if hwy.AllTrue_AVX512_Uint64x8(maskLess) {
			if lt == i {
				lt += lanes
				i += lanes
				continue
			}
			if lt+lanes <= i {
				vLt := archsimd.LoadUint64x8Slice(data[lt:])
				v.StoreSlice(data[lt:])
				vLt.StoreSlice(data[i:])
				lt += lanes
				i += lanes
				continue
			}
			break
		}
		if hwy.AllTrue_AVX512_Uint64x8(maskGreater) {
			gt -= lanes
			vGt := archsimd.LoadUint64x8Slice(data[gt:])
			v.StoreSlice(data[gt:])
			vGt.StoreSlice(data[i:])
			continue
		}
		if hwy.AllFalse_AVX512_Uint64x8(maskLess) && hwy.AllFalse_AVX512_Uint64x8(maskGreater) {
			i += lanes
			continue
		}
		end := min(i+lanes, gt)
		for i < end {
			if data[i] < pivot {
				data[lt], data[i] = data[i], data[lt]
				lt++
				i++
			} else if data[i] > pivot {
				gt--
				data[i], data[gt] = data[gt], data[i]
				if gt < end {
					end = gt
				}
			} else {
				i++
			}
		}
	}
	for i < gt {
		if data[i] < pivot {
			data[lt], data[i] = data[i], data[lt]
			lt++
			i++
		} else if data[i] > pivot {
			gt--
			data[i], data[gt] = data[gt], data[i]
		} else {
			i++
		}
	}
	return lt, gt
}

func BasePartition_avx512(data []float32, pivot float32) int {
	n := len(data)
	if n == 0 {
		return 0
	}
	lanes := 16
	if n < lanes*4 {
		return scalarPartition2Way(data, pivot)
	}
	pivotVec := archsimd.BroadcastFloat32x16(pivot)
	left := 0
	right := n
	for left+lanes <= right {
		if right-lanes < left+lanes {
			break
		}
		v := archsimd.LoadFloat32x16Slice(data[left:])
		mask := v.LessEqual(pivotVec)
		if hwy.AllTrue_AVX512_F32x16(mask) {
			left += lanes
			continue
		}
		if hwy.AllFalse_AVX512_F32x16(mask) {
			right -= lanes
			vRight := archsimd.LoadFloat32x16Slice(data[right:])
			v.StoreSlice(data[right:])
			vRight.StoreSlice(data[left:])
			continue
		}
		end := min(left+lanes, right)
		for left < end {
			if data[left] <= pivot {
				left++
			} else {
				right--
				data[left], data[right] = data[right], data[left]
				if right < end {
					end = right
				}
			}
		}
	}
	for left < right {
		if data[left] <= pivot {
			left++
		} else {
			right--
			data[left], data[right] = data[right], data[left]
		}
	}
	return left
}

func BasePartition_avx512_Float64(data []float64, pivot float64) int {
	n := len(data)
	if n == 0 {
		return 0
	}
	lanes := 8
	if n < lanes*4 {
		return scalarPartition2Way(data, pivot)
	}
	pivotVec := archsimd.BroadcastFloat64x8(pivot)
	left := 0
	right := n
	for left+lanes <= right {
		if right-lanes < left+lanes {
			break
		}
		v := archsimd.LoadFloat64x8Slice(data[left:])
		mask := v.LessEqual(pivotVec)
		if hwy.AllTrue_AVX512_F64x8(mask) {
			left += lanes
			continue
		}
		if hwy.AllFalse_AVX512_F64x8(mask) {
			right -= lanes
			vRight := archsimd.LoadFloat64x8Slice(data[right:])
			v.StoreSlice(data[right:])
			vRight.StoreSlice(data[left:])
			continue
		}
		end := min(left+lanes, right)
		for left < end {
			if data[left] <= pivot {
				left++
			} else {
				right--
				data[left], data[right] = data[right], data[left]
				if right < end {
					end = right
				}
			}
		}
	}
	for left < right {
		if data[left] <= pivot {
			left++
		} else {
			right--
			data[left], data[right] = data[right], data[left]
		}
	}
	return left
}

func BasePartition_avx512_Int32(data []int32, pivot int32) int {
	n := len(data)
	if n == 0 {
		return 0
	}
	lanes := 16
	if n < lanes*4 {
		return scalarPartition2Way(data, pivot)
	}
	pivotVec := archsimd.BroadcastInt32x16(pivot)
	left := 0
	right := n
	for left+lanes <= right {
		if right-lanes < left+lanes {
			break
		}
		v := archsimd.LoadInt32x16Slice(data[left:])
		mask := v.LessEqual(pivotVec)
		if hwy.AllTrue_AVX512_I32x16(mask) {
			left += lanes
			continue
		}
		if hwy.AllFalse_AVX512_I32x16(mask) {
			right -= lanes
			vRight := archsimd.LoadInt32x16Slice(data[right:])
			v.StoreSlice(data[right:])
			vRight.StoreSlice(data[left:])
			continue
		}
		end := min(left+lanes, right)
		for left < end {
			if data[left] <= pivot {
				left++
			} else {
				right--
				data[left], data[right] = data[right], data[left]
				if right < end {
					end = right
				}
			}
		}
	}
	for left < right {
		if data[left] <= pivot {
			left++
		} else {
			right--
			data[left], data[right] = data[right], data[left]
		}
	}
	return left
}

func BasePartition_avx512_Int64(data []int64, pivot int64) int {
	n := len(data)
	if n == 0 {
		return 0
	}
	lanes := 8
	if n < lanes*4 {
		return scalarPartition2Way(data, pivot)
	}
	pivotVec := archsimd.BroadcastInt64x8(pivot)
	left := 0
	right := n
	for left+lanes <= right {
		if right-lanes < left+lanes {
			break
		}
		v := archsimd.LoadInt64x8Slice(data[left:])
		mask := v.LessEqual(pivotVec)
		if hwy.AllTrue_AVX512_I64x8(mask) {
			left += lanes
			continue
		}
		if hwy.AllFalse_AVX512_I64x8(mask) {
			right -= lanes
			vRight := archsimd.LoadInt64x8Slice(data[right:])
			v.StoreSlice(data[right:])
			vRight.StoreSlice(data[left:])
			continue
		}
		end := min(left+lanes, right)
		for left < end {
			if data[left] <= pivot {
				left++
			} else {
				right--
				data[left], data[right] = data[right], data[left]
				if right < end {
					end = right
				}
			}
		}
	}
	for left < right {
		if data[left] <= pivot {
			left++
		} else {
			right--
			data[left], data[right] = data[right], data[left]
		}
	}
	return left
}

func BasePartition_avx512_Uint32(data []uint32, pivot uint32) int {
	n := len(data)
	if n == 0 {
		return 0
	}
	lanes := 16
	if n < lanes*4 {
		return scalarPartition2Way(data, pivot)
	}
	pivotVec := archsimd.BroadcastUint32x16(pivot)
	left := 0
	right := n
	for left+lanes <= right {
		if right-lanes < left+lanes {
			break
		}
		v := archsimd.LoadUint32x16Slice(data[left:])
		mask := v.LessEqual(pivotVec)
		if hwy.AllTrue_AVX512_Uint32x16(mask) {
			left += lanes
			continue
		}
		if hwy.AllFalse_AVX512_Uint32x16(mask) {
			right -= lanes
			vRight := archsimd.LoadUint32x16Slice(data[right:])
			v.StoreSlice(data[right:])
			vRight.StoreSlice(data[left:])
			continue
		}
		end := min(left+lanes, right)
		for left < end {
			if data[left] <= pivot {
				left++
			} else {
				right--
				data[left], data[right] = data[right], data[left]
				if right < end {
					end = right
				}
			}
		}
	}
	for left < right {
		if data[left] <= pivot {
			left++
		} else {
			right--
			data[left], data[right] = data[right], data[left]
		}
	}
	return left
}

func BasePartition_avx512_Uint64(data []uint64, pivot uint64) int {
	n := len(data)
	if n == 0 {
		return 0
	}
	lanes := 8
	if n < lanes*4 {
		return scalarPartition2Way(data, pivot)
	}
	pivotVec := archsimd.BroadcastUint64x8(pivot)
	left := 0
	right := n
	for left+lanes <= right {
		if right-lanes < left+lanes {
			break
		}
		v := archsimd.LoadUint64x8Slice(data[left:])
		mask := v.LessEqual(pivotVec)
		if hwy.AllTrue_AVX512_Uint64x8(mask) {
			left += lanes
			continue
		}
		if hwy.AllFalse_AVX512_Uint64x8(mask) {
			right -= lanes
			vRight := archsimd.LoadUint64x8Slice(data[right:])
			v.StoreSlice(data[right:])
			vRight.StoreSlice(data[left:])
			continue
		}
		end := min(left+lanes, right)
		for left < end {
			if data[left] <= pivot {
				left++
			} else {
				right--
				data[left], data[right] = data[right], data[left]
				if right < end {
					end = right
				}
			}
		}
	}
	for left < right {
		if data[left] <= pivot {
			left++
		} else {
			right--
			data[left], data[right] = data[right], data[left]
		}
	}
	return left
}
