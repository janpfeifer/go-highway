// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

//go:build amd64 && goexperiment.simd

package sort

import (
	"simd/archsimd"
	"unsafe"

	"github.com/ajroetker/go-highway/hwy"
	"github.com/ajroetker/go-highway/hwy/asm"
)

func BaseFloatToSortable_avx2_Float16(data []hwy.Float16) {
	n := len(data)
	lanes := 8
	signBitVec := asm.SignBitFloat16x8AVX2()
	zeroVec := asm.ZeroFloat16x8AVX2()
	allOnesVec := zeroVec.Not()
	i := 0
	for i+lanes <= n {
		v := asm.LoadFloat16x8AVX2Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(data[i:]))), len(data[i:])))
		isNeg := v.Less(zeroVec)
		negResult := v.Xor(allOnesVec)
		posResult := v.Xor(signBitVec)
		result := negResult.Merge(posResult, isNeg)
		result.StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(data[i:]))), len(data[i:])))
		i += lanes
	}
}

func BaseFloatToSortable_avx2_BFloat16(data []hwy.BFloat16) {
	n := len(data)
	lanes := 8
	signBitVec := asm.SignBitBFloat16x8AVX2()
	zeroVec := asm.ZeroBFloat16x8AVX2()
	allOnesVec := zeroVec.Not()
	i := 0
	for i+lanes <= n {
		v := asm.LoadBFloat16x8AVX2Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(data[i:]))), len(data[i:])))
		isNeg := v.Less(zeroVec)
		negResult := v.Xor(allOnesVec)
		posResult := v.Xor(signBitVec)
		result := negResult.Merge(posResult, isNeg)
		result.StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(data[i:]))), len(data[i:])))
		i += lanes
	}
}

func BaseFloatToSortable_avx2(data []float32) {
	n := len(data)
	lanes := 8
	signBitVec := hwy.SignBit_AVX2_F32x8()
	zeroVec := archsimd.BroadcastFloat32x8(0)
	allOnesVec := hwy.Not_AVX2_F32x8(zeroVec)
	i := 0
	for i+lanes <= n {
		v := archsimd.LoadFloat32x8Slice(data[i:])
		isNeg := v.Less(zeroVec)
		negResult := hwy.Xor_AVX2_F32x8(v, allOnesVec)
		posResult := hwy.Xor_AVX2_F32x8(v, signBitVec)
		result := hwy.IfThenElse_AVX2_F32x8(isNeg, negResult, posResult)
		result.StoreSlice(data[i:])
		i += lanes
	}
}

func BaseFloatToSortable_avx2_Float64(data []float64) {
	n := len(data)
	lanes := 4
	signBitVec := hwy.SignBit_AVX2_F64x4()
	zeroVec := archsimd.BroadcastFloat64x4(0)
	allOnesVec := hwy.Not_AVX2_F64x4(zeroVec)
	i := 0
	for i+lanes <= n {
		v := archsimd.LoadFloat64x4Slice(data[i:])
		isNeg := v.Less(zeroVec)
		negResult := hwy.Xor_AVX2_F64x4(v, allOnesVec)
		posResult := hwy.Xor_AVX2_F64x4(v, signBitVec)
		result := hwy.IfThenElse_AVX2_F64x4(isNeg, negResult, posResult)
		result.StoreSlice(data[i:])
		i += lanes
	}
}

func BaseSortableToFloat_avx2_Float16(data []hwy.Float16) {
	n := len(data)
	lanes := 8
	signBitVec := asm.SignBitFloat16x8AVX2()
	zeroVec := asm.ZeroFloat16x8AVX2()
	allOnesVec := zeroVec.Not()
	i := 0
	for i+lanes <= n {
		v := asm.LoadFloat16x8AVX2Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(data[i:]))), len(data[i:])))
		masked := v.And(signBitVec)
		wasPositive := masked.NotEqual(zeroVec)
		posResult := v.Xor(signBitVec)
		negResult := v.Xor(allOnesVec)
		result := posResult.Merge(negResult, wasPositive)
		result.StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(data[i:]))), len(data[i:])))
		i += lanes
	}
}

func BaseSortableToFloat_avx2_BFloat16(data []hwy.BFloat16) {
	n := len(data)
	lanes := 8
	signBitVec := asm.SignBitBFloat16x8AVX2()
	zeroVec := asm.ZeroBFloat16x8AVX2()
	allOnesVec := zeroVec.Not()
	i := 0
	for i+lanes <= n {
		v := asm.LoadBFloat16x8AVX2Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(data[i:]))), len(data[i:])))
		masked := v.And(signBitVec)
		wasPositive := masked.NotEqual(zeroVec)
		posResult := v.Xor(signBitVec)
		negResult := v.Xor(allOnesVec)
		result := posResult.Merge(negResult, wasPositive)
		result.StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(data[i:]))), len(data[i:])))
		i += lanes
	}
}

func BaseSortableToFloat_avx2(data []float32) {
	n := len(data)
	lanes := 8
	signBitVec := hwy.SignBit_AVX2_F32x8()
	zeroVec := archsimd.BroadcastFloat32x8(0)
	allOnesVec := hwy.Not_AVX2_F32x8(zeroVec)
	i := 0
	for i+lanes <= n {
		v := archsimd.LoadFloat32x8Slice(data[i:])
		masked := hwy.And_AVX2_F32x8(v, signBitVec)
		wasPositive := masked.NotEqual(zeroVec)
		posResult := hwy.Xor_AVX2_F32x8(v, signBitVec)
		negResult := hwy.Xor_AVX2_F32x8(v, allOnesVec)
		result := hwy.IfThenElse_AVX2_F32x8(wasPositive, posResult, negResult)
		result.StoreSlice(data[i:])
		i += lanes
	}
}

func BaseSortableToFloat_avx2_Float64(data []float64) {
	n := len(data)
	lanes := 4
	signBitVec := hwy.SignBit_AVX2_F64x4()
	zeroVec := archsimd.BroadcastFloat64x4(0)
	allOnesVec := hwy.Not_AVX2_F64x4(zeroVec)
	i := 0
	for i+lanes <= n {
		v := archsimd.LoadFloat64x4Slice(data[i:])
		masked := hwy.And_AVX2_F64x4(v, signBitVec)
		wasPositive := masked.NotEqual(zeroVec)
		posResult := hwy.Xor_AVX2_F64x4(v, signBitVec)
		negResult := hwy.Xor_AVX2_F64x4(v, allOnesVec)
		result := hwy.IfThenElse_AVX2_F64x4(wasPositive, posResult, negResult)
		result.StoreSlice(data[i:])
		i += lanes
	}
}
