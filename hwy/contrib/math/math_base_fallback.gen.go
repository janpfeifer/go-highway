// Code generated by hwygen. DO NOT EDIT.

package math

import (
	"github.com/ajroetker/go-highway/hwy"
	stdmath "math"
)

func BaseExpPoly_fallback(input []float32, output []float32) {
	size := len(input)
	if len(output) < size {
		size = len(output)
	}
	overflow := hwy.Set[float32](float32(expOverflow_f32))
	underflow := hwy.Set[float32](float32(expUnderflow_f32))
	one := hwy.Set[float32](float32(expOne_f32))
	zero := hwy.Set[float32](float32(expZero_f32))
	inf := hwy.Set[float32](float32(expOverflow_f32 * 2))
	invLn2 := hwy.Set[float32](float32(expInvLn2_f32))
	ln2Hi := hwy.Set[float32](float32(expLn2Hi_f32))
	ln2Lo := hwy.Set[float32](float32(expLn2Lo_f32))
	c1 := hwy.Set[float32](float32(expC1_f32))
	c2 := hwy.Set[float32](float32(expC2_f32))
	c3 := hwy.Set[float32](float32(expC3_f32))
	c4 := hwy.Set[float32](float32(expC4_f32))
	c5 := hwy.Set[float32](float32(expC5_f32))
	c6 := hwy.Set[float32](float32(expC6_f32))
	lanes := one.NumLanes()
	for ii := 0; ii < size; ii += lanes {
		x := hwy.Load(input[ii:])
		overflowMask := hwy.Greater(x, overflow)
		underflowMask := hwy.Less(x, underflow)
		kFloat := hwy.RoundToEven(hwy.Mul(x, invLn2))
		r := hwy.Sub(x, hwy.Mul(kFloat, ln2Hi))
		r = hwy.Sub(r, hwy.Mul(kFloat, ln2Lo))
		p := hwy.MulAdd(c6, r, c5)
		p = hwy.MulAdd(p, r, c4)
		p = hwy.MulAdd(p, r, c3)
		p = hwy.MulAdd(p, r, c2)
		p = hwy.MulAdd(p, r, c1)
		p = hwy.MulAdd(p, r, one)
		kInt := hwy.ConvertToInt32(kFloat)
		scale := hwy.Pow2[float32](kInt)
		result := hwy.Mul(p, scale)
		result = hwy.Merge(inf, result, overflowMask)
		result = hwy.Merge(zero, result, underflowMask)
		hwy.Store(result, output[ii:])
	}
}

func BaseExpPoly_fallback_Float64(input []float64, output []float64) {
	size := len(input)
	if len(output) < size {
		size = len(output)
	}
	overflow := hwy.Set[float64](float64(expOverflow_f64))
	underflow := hwy.Set[float64](float64(expUnderflow_f64))
	one := hwy.Set[float64](float64(expOne_f64))
	zero := hwy.Set[float64](float64(expZero_f64))
	inf := hwy.Set[float64](float64(expOverflow_f64 * 2))
	invLn2 := hwy.Set[float64](float64(expInvLn2_f64))
	ln2Hi := hwy.Set[float64](float64(expLn2Hi_f64))
	ln2Lo := hwy.Set[float64](float64(expLn2Lo_f64))
	c1 := hwy.Set[float64](float64(expC1_f64))
	c2 := hwy.Set[float64](float64(expC2_f64))
	c3 := hwy.Set[float64](float64(expC3_f64))
	c4 := hwy.Set[float64](float64(expC4_f64))
	c5 := hwy.Set[float64](float64(expC5_f64))
	c6 := hwy.Set[float64](float64(expC6_f64))
	lanes := one.NumLanes()
	for ii := 0; ii < size; ii += lanes {
		x := hwy.Load(input[ii:])
		overflowMask := hwy.Greater(x, overflow)
		underflowMask := hwy.Less(x, underflow)
		kFloat := hwy.RoundToEven(hwy.Mul(x, invLn2))
		r := hwy.Sub(x, hwy.Mul(kFloat, ln2Hi))
		r = hwy.Sub(r, hwy.Mul(kFloat, ln2Lo))
		p := hwy.MulAdd(c6, r, c5)
		p = hwy.MulAdd(p, r, c4)
		p = hwy.MulAdd(p, r, c3)
		p = hwy.MulAdd(p, r, c2)
		p = hwy.MulAdd(p, r, c1)
		p = hwy.MulAdd(p, r, one)
		kInt := hwy.ConvertToInt32(kFloat)
		scale := hwy.Pow2[float64](kInt)
		result := hwy.Mul(p, scale)
		result = hwy.Merge(inf, result, overflowMask)
		result = hwy.Merge(zero, result, underflowMask)
		hwy.Store(result, output[ii:])
	}
}

func BaseTanhPoly_fallback(input []float32, output []float32) {
	size := len(input)
	if len(output) < size {
		size = len(output)
	}
	two := hwy.Set[float32](float32(2.0))
	one := hwy.Set[float32](float32(tanhOne_f32))
	negOne := hwy.Set[float32](float32(tanhNegOne_f32))
	threshold := hwy.Set[float32](float32(tanhClamp_f32))
	negThreshold := hwy.Neg(threshold)
	lanes := one.NumLanes()
	tempIn := make([]float32, lanes)
	tempOut := make([]float32, lanes)
	for ii := 0; ii < size; ii += lanes {
		x := hwy.Load(input[ii:])
		twoX := hwy.Mul(two, x)
		hwy.Store(twoX, tempIn)
		BaseSigmoidPoly_fallback(tempIn, tempOut)
		sigTwoX := hwy.Load(tempOut)
		result := hwy.Sub(hwy.Mul(two, sigTwoX), one)
		result = hwy.Merge(one, result, hwy.Greater(x, threshold))
		result = hwy.Merge(negOne, result, hwy.Less(x, negThreshold))
		hwy.Store(result, output[ii:])
	}
}

func BaseTanhPoly_fallback_Float64(input []float64, output []float64) {
	size := len(input)
	if len(output) < size {
		size = len(output)
	}
	two := hwy.Set[float64](float64(2.0))
	one := hwy.Set[float64](float64(tanhOne_f64))
	negOne := hwy.Set[float64](float64(tanhNegOne_f64))
	threshold := hwy.Set[float64](float64(tanhClamp_f64))
	negThreshold := hwy.Neg(threshold)
	lanes := one.NumLanes()
	tempIn := make([]float64, lanes)
	tempOut := make([]float64, lanes)
	for ii := 0; ii < size; ii += lanes {
		x := hwy.Load(input[ii:])
		twoX := hwy.Mul(two, x)
		hwy.Store(twoX, tempIn)
		BaseSigmoidPoly_fallback_Float64(tempIn, tempOut)
		sigTwoX := hwy.Load(tempOut)
		result := hwy.Sub(hwy.Mul(two, sigTwoX), one)
		result = hwy.Merge(one, result, hwy.Greater(x, threshold))
		result = hwy.Merge(negOne, result, hwy.Less(x, negThreshold))
		hwy.Store(result, output[ii:])
	}
}

func BaseSigmoidPoly_fallback(input []float32, output []float32) {
	size := len(input)
	if len(output) < size {
		size = len(output)
	}
	one := hwy.Set[float32](float32(sigmoidOne_f32))
	zero := hwy.Set[float32](float32(0.0))
	satHi := hwy.Set[float32](float32(20.0))
	satLo := hwy.Set[float32](float32(-20.0))
	lanes := one.NumLanes()
	tempIn := make([]float32, lanes)
	tempOut := make([]float32, lanes)
	for ii := 0; ii < size; ii += lanes {
		x := hwy.Load(input[ii:])
		clampedX := hwy.Max(hwy.Min(x, satHi), satLo)
		negX := hwy.Neg(clampedX)
		hwy.Store(negX, tempIn)
		BaseExpPoly_fallback(tempIn, tempOut)
		expNegX := hwy.Load(tempOut)
		result := hwy.Div(one, hwy.Add(one, expNegX))
		result = hwy.Merge(one, result, hwy.Greater(x, satHi))
		result = hwy.Merge(zero, result, hwy.Less(x, satLo))
		hwy.Store(result, output[ii:])
	}
}

func BaseSigmoidPoly_fallback_Float64(input []float64, output []float64) {
	size := len(input)
	if len(output) < size {
		size = len(output)
	}
	one := hwy.Set[float64](float64(sigmoidOne_f64))
	zero := hwy.Set[float64](float64(0.0))
	satHi := hwy.Set[float64](float64(20.0))
	satLo := hwy.Set[float64](float64(-20.0))
	lanes := one.NumLanes()
	tempIn := make([]float64, lanes)
	tempOut := make([]float64, lanes)
	for ii := 0; ii < size; ii += lanes {
		x := hwy.Load(input[ii:])
		clampedX := hwy.Max(hwy.Min(x, satHi), satLo)
		negX := hwy.Neg(clampedX)
		hwy.Store(negX, tempIn)
		BaseExpPoly_fallback_Float64(tempIn, tempOut)
		expNegX := hwy.Load(tempOut)
		result := hwy.Div(one, hwy.Add(one, expNegX))
		result = hwy.Merge(one, result, hwy.Greater(x, satHi))
		result = hwy.Merge(zero, result, hwy.Less(x, satLo))
		hwy.Store(result, output[ii:])
	}
}

func BaseSinPoly_fallback(input []float32, output []float32) {
	size := len(input)
	if len(output) < size {
		size = len(output)
	}
	twoOverPi := hwy.Set[float32](float32(trig2OverPi_f32))
	piOver2Hi := hwy.Set[float32](float32(trigPiOver2Hi_f32))
	piOver2Lo := hwy.Set[float32](float32(trigPiOver2Lo_f32))
	one := hwy.Set[float32](float32(trigOne_f32))
	s1 := hwy.Set[float32](float32(trigS1_f32))
	s2 := hwy.Set[float32](float32(trigS2_f32))
	s3 := hwy.Set[float32](float32(trigS3_f32))
	s4 := hwy.Set[float32](float32(trigS4_f32))
	c1 := hwy.Set[float32](float32(trigC1_f32))
	c2 := hwy.Set[float32](float32(trigC2_f32))
	c3 := hwy.Set[float32](float32(trigC3_f32))
	c4 := hwy.Set[float32](float32(trigC4_f32))
	intOne := hwy.Set[int32](1)
	intTwo := hwy.Set[int32](2)
	intThree := hwy.Set[int32](3)
	lanes := one.NumLanes()
	for ii := 0; ii < size; ii += lanes {
		x := hwy.Load(input[ii:])
		kFloat := hwy.RoundToEven(hwy.Mul(x, twoOverPi))
		kInt := hwy.ConvertToInt32(kFloat)
		r := hwy.Sub(x, hwy.Mul(kFloat, piOver2Hi))
		r = hwy.Sub(r, hwy.Mul(kFloat, piOver2Lo))
		r2 := hwy.Mul(r, r)
		sinPoly := hwy.MulAdd(s4, r2, s3)
		sinPoly = hwy.MulAdd(sinPoly, r2, s2)
		sinPoly = hwy.MulAdd(sinPoly, r2, s1)
		sinPoly = hwy.MulAdd(sinPoly, r2, one)
		sinR := hwy.Mul(r, sinPoly)
		cosPoly := hwy.MulAdd(c4, r2, c3)
		cosPoly = hwy.MulAdd(cosPoly, r2, c2)
		cosPoly = hwy.MulAdd(cosPoly, r2, c1)
		cosR := hwy.MulAdd(cosPoly, r2, one)
		octant := hwy.And(kInt, intThree)
		useCosMask := hwy.Equal(hwy.And(octant, intOne), intOne)
		negateMask := hwy.Equal(hwy.And(octant, intTwo), intTwo)
		sinRData := sinR.Data()
		cosRData := cosR.Data()
		resultData := make([]float32, len(sinRData))
		for i := range sinRData {
			if useCosMask.GetBit(i) {
				resultData[i] = cosRData[i]
			} else {
				resultData[i] = sinRData[i]
			}
		}
		result := hwy.Load(resultData)
		negResult := hwy.Neg(result)
		negResultData := negResult.Data()
		for i := range resultData {
			if negateMask.GetBit(i) {
				resultData[i] = negResultData[i]
			}
		}
		result = hwy.Load(resultData)
		hwy.Store(result, output[ii:])
	}
}

func BaseSinPoly_fallback_Float64(input []float64, output []float64) {
	size := len(input)
	if len(output) < size {
		size = len(output)
	}
	twoOverPi := hwy.Set[float64](float64(trig2OverPi_f64))
	piOver2Hi := hwy.Set[float64](float64(trigPiOver2Hi_f64))
	piOver2Lo := hwy.Set[float64](float64(trigPiOver2Lo_f64))
	one := hwy.Set[float64](float64(trigOne_f64))
	s1 := hwy.Set[float64](float64(trigS1_f64))
	s2 := hwy.Set[float64](float64(trigS2_f64))
	s3 := hwy.Set[float64](float64(trigS3_f64))
	s4 := hwy.Set[float64](float64(trigS4_f64))
	c1 := hwy.Set[float64](float64(trigC1_f64))
	c2 := hwy.Set[float64](float64(trigC2_f64))
	c3 := hwy.Set[float64](float64(trigC3_f64))
	c4 := hwy.Set[float64](float64(trigC4_f64))
	intOne := hwy.Set[int32](1)
	intTwo := hwy.Set[int32](2)
	intThree := hwy.Set[int32](3)
	lanes := one.NumLanes()
	for ii := 0; ii < size; ii += lanes {
		x := hwy.Load(input[ii:])
		kFloat := hwy.RoundToEven(hwy.Mul(x, twoOverPi))
		kInt := hwy.ConvertToInt32(kFloat)
		r := hwy.Sub(x, hwy.Mul(kFloat, piOver2Hi))
		r = hwy.Sub(r, hwy.Mul(kFloat, piOver2Lo))
		r2 := hwy.Mul(r, r)
		sinPoly := hwy.MulAdd(s4, r2, s3)
		sinPoly = hwy.MulAdd(sinPoly, r2, s2)
		sinPoly = hwy.MulAdd(sinPoly, r2, s1)
		sinPoly = hwy.MulAdd(sinPoly, r2, one)
		sinR := hwy.Mul(r, sinPoly)
		cosPoly := hwy.MulAdd(c4, r2, c3)
		cosPoly = hwy.MulAdd(cosPoly, r2, c2)
		cosPoly = hwy.MulAdd(cosPoly, r2, c1)
		cosR := hwy.MulAdd(cosPoly, r2, one)
		octant := hwy.And(kInt, intThree)
		useCosMask := hwy.Equal(hwy.And(octant, intOne), intOne)
		negateMask := hwy.Equal(hwy.And(octant, intTwo), intTwo)
		sinRData := sinR.Data()
		cosRData := cosR.Data()
		resultData := make([]float64, len(sinRData))
		for i := range sinRData {
			if useCosMask.GetBit(i) {
				resultData[i] = cosRData[i]
			} else {
				resultData[i] = sinRData[i]
			}
		}
		result := hwy.Load(resultData)
		negResult := hwy.Neg(result)
		negResultData := negResult.Data()
		for i := range resultData {
			if negateMask.GetBit(i) {
				resultData[i] = negResultData[i]
			}
		}
		result = hwy.Load(resultData)
		hwy.Store(result, output[ii:])
	}
}

func BaseCosPoly_fallback(input []float32, output []float32) {
	size := len(input)
	if len(output) < size {
		size = len(output)
	}
	twoOverPi := hwy.Set[float32](float32(trig2OverPi_f32))
	piOver2Hi := hwy.Set[float32](float32(trigPiOver2Hi_f32))
	piOver2Lo := hwy.Set[float32](float32(trigPiOver2Lo_f32))
	one := hwy.Set[float32](float32(trigOne_f32))
	s1 := hwy.Set[float32](float32(trigS1_f32))
	s2 := hwy.Set[float32](float32(trigS2_f32))
	s3 := hwy.Set[float32](float32(trigS3_f32))
	s4 := hwy.Set[float32](float32(trigS4_f32))
	c1 := hwy.Set[float32](float32(trigC1_f32))
	c2 := hwy.Set[float32](float32(trigC2_f32))
	c3 := hwy.Set[float32](float32(trigC3_f32))
	c4 := hwy.Set[float32](float32(trigC4_f32))
	intOne := hwy.Set[int32](1)
	intTwo := hwy.Set[int32](2)
	intThree := hwy.Set[int32](3)
	lanes := one.NumLanes()
	for ii := 0; ii < size; ii += lanes {
		x := hwy.Load(input[ii:])
		kFloat := hwy.RoundToEven(hwy.Mul(x, twoOverPi))
		kInt := hwy.ConvertToInt32(kFloat)
		r := hwy.Sub(x, hwy.Mul(kFloat, piOver2Hi))
		r = hwy.Sub(r, hwy.Mul(kFloat, piOver2Lo))
		r2 := hwy.Mul(r, r)
		sinPoly := hwy.MulAdd(s4, r2, s3)
		sinPoly = hwy.MulAdd(sinPoly, r2, s2)
		sinPoly = hwy.MulAdd(sinPoly, r2, s1)
		sinPoly = hwy.MulAdd(sinPoly, r2, one)
		sinR := hwy.Mul(r, sinPoly)
		cosPoly := hwy.MulAdd(c4, r2, c3)
		cosPoly = hwy.MulAdd(cosPoly, r2, c2)
		cosPoly = hwy.MulAdd(cosPoly, r2, c1)
		cosR := hwy.MulAdd(cosPoly, r2, one)
		cosOctant := hwy.And(hwy.Add(kInt, intOne), intThree)
		useCosMask := hwy.Equal(hwy.And(cosOctant, intOne), intOne)
		negateMask := hwy.Equal(hwy.And(cosOctant, intTwo), intTwo)
		sinRData := sinR.Data()
		cosRData := cosR.Data()
		resultData := make([]float32, len(sinRData))
		for i := range sinRData {
			if useCosMask.GetBit(i) {
				resultData[i] = cosRData[i]
			} else {
				resultData[i] = sinRData[i]
			}
		}
		result := hwy.Load(resultData)
		negResult := hwy.Neg(result)
		negResultData := negResult.Data()
		for i := range resultData {
			if negateMask.GetBit(i) {
				resultData[i] = negResultData[i]
			}
		}
		result = hwy.Load(resultData)
		hwy.Store(result, output[ii:])
	}
}

func BaseCosPoly_fallback_Float64(input []float64, output []float64) {
	size := len(input)
	if len(output) < size {
		size = len(output)
	}
	twoOverPi := hwy.Set[float64](float64(trig2OverPi_f64))
	piOver2Hi := hwy.Set[float64](float64(trigPiOver2Hi_f64))
	piOver2Lo := hwy.Set[float64](float64(trigPiOver2Lo_f64))
	one := hwy.Set[float64](float64(trigOne_f64))
	s1 := hwy.Set[float64](float64(trigS1_f64))
	s2 := hwy.Set[float64](float64(trigS2_f64))
	s3 := hwy.Set[float64](float64(trigS3_f64))
	s4 := hwy.Set[float64](float64(trigS4_f64))
	c1 := hwy.Set[float64](float64(trigC1_f64))
	c2 := hwy.Set[float64](float64(trigC2_f64))
	c3 := hwy.Set[float64](float64(trigC3_f64))
	c4 := hwy.Set[float64](float64(trigC4_f64))
	intOne := hwy.Set[int32](1)
	intTwo := hwy.Set[int32](2)
	intThree := hwy.Set[int32](3)
	lanes := one.NumLanes()
	for ii := 0; ii < size; ii += lanes {
		x := hwy.Load(input[ii:])
		kFloat := hwy.RoundToEven(hwy.Mul(x, twoOverPi))
		kInt := hwy.ConvertToInt32(kFloat)
		r := hwy.Sub(x, hwy.Mul(kFloat, piOver2Hi))
		r = hwy.Sub(r, hwy.Mul(kFloat, piOver2Lo))
		r2 := hwy.Mul(r, r)
		sinPoly := hwy.MulAdd(s4, r2, s3)
		sinPoly = hwy.MulAdd(sinPoly, r2, s2)
		sinPoly = hwy.MulAdd(sinPoly, r2, s1)
		sinPoly = hwy.MulAdd(sinPoly, r2, one)
		sinR := hwy.Mul(r, sinPoly)
		cosPoly := hwy.MulAdd(c4, r2, c3)
		cosPoly = hwy.MulAdd(cosPoly, r2, c2)
		cosPoly = hwy.MulAdd(cosPoly, r2, c1)
		cosR := hwy.MulAdd(cosPoly, r2, one)
		cosOctant := hwy.And(hwy.Add(kInt, intOne), intThree)
		useCosMask := hwy.Equal(hwy.And(cosOctant, intOne), intOne)
		negateMask := hwy.Equal(hwy.And(cosOctant, intTwo), intTwo)
		sinRData := sinR.Data()
		cosRData := cosR.Data()
		resultData := make([]float64, len(sinRData))
		for i := range sinRData {
			if useCosMask.GetBit(i) {
				resultData[i] = cosRData[i]
			} else {
				resultData[i] = sinRData[i]
			}
		}
		result := hwy.Load(resultData)
		negResult := hwy.Neg(result)
		negResultData := negResult.Data()
		for i := range resultData {
			if negateMask.GetBit(i) {
				resultData[i] = negResultData[i]
			}
		}
		result = hwy.Load(resultData)
		hwy.Store(result, output[ii:])
	}
}

func BaseAtanPoly_fallback(input []float32, output []float32) {
	size := len(input)
	if len(output) < size {
		size = len(output)
	}
	piOver2 := hwy.Set[float32](float32(atanPiOver2_f32))
	piOver4 := hwy.Set[float32](float32(atanPiOver4_f32))
	tanPiOver8 := hwy.Set[float32](float32(atanTanPiOver8_f32))
	one := hwy.Set[float32](float32(atanOne_f32))
	zero := hwy.Set[float32](float32(atanZero_f32))
	c1 := hwy.Set[float32](float32(atanC1_f32))
	c2 := hwy.Set[float32](float32(atanC2_f32))
	c3 := hwy.Set[float32](float32(atanC3_f32))
	c4 := hwy.Set[float32](float32(atanC4_f32))
	c5 := hwy.Set[float32](float32(atanC5_f32))
	lanes := one.NumLanes()
	for ii := 0; ii < size; ii += lanes {
		x := hwy.Load(input[ii:])
		absX := hwy.Abs(x)
		signMask := hwy.Less(x, zero)
		useReciprocalMask := hwy.Greater(absX, one)
		recipAbsX := hwy.Div(one, absX)
		reduced := hwy.Merge(recipAbsX, absX, useReciprocalMask)
		useIdentityMask := hwy.Greater(reduced, tanPiOver8)
		xMinus1 := hwy.Sub(reduced, one)
		xPlus1 := hwy.Add(reduced, one)
		transformed := hwy.Div(xMinus1, xPlus1)
		reduced = hwy.Merge(transformed, reduced, useIdentityMask)
		z2 := hwy.Mul(reduced, reduced)
		poly := hwy.MulAdd(c5, z2, c4)
		poly = hwy.MulAdd(poly, z2, c3)
		poly = hwy.MulAdd(poly, z2, c2)
		poly = hwy.MulAdd(poly, z2, c1)
		poly = hwy.MulAdd(poly, z2, one)
		atanCore := hwy.Mul(reduced, poly)
		atanWithIdentity := hwy.Add(piOver4, atanCore)
		atanReduced := hwy.Merge(atanWithIdentity, atanCore, useIdentityMask)
		atanWithReciprocal := hwy.Sub(piOver2, atanReduced)
		resultAbs := hwy.Merge(atanWithReciprocal, atanReduced, useReciprocalMask)
		negResult := hwy.Neg(resultAbs)
		result := hwy.Merge(negResult, resultAbs, signMask)
		hwy.Store(result, output[ii:])
	}
}

func BaseAtanPoly_fallback_Float64(input []float64, output []float64) {
	size := len(input)
	if len(output) < size {
		size = len(output)
	}
	piOver2 := hwy.Set[float64](float64(atanPiOver2_f64))
	piOver4 := hwy.Set[float64](float64(atanPiOver4_f64))
	tanPiOver8 := hwy.Set[float64](float64(atanTanPiOver8_f64))
	one := hwy.Set[float64](float64(atanOne_f64))
	zero := hwy.Set[float64](float64(atanZero_f64))
	c1 := hwy.Set[float64](float64(atanC1_f64))
	c2 := hwy.Set[float64](float64(atanC2_f64))
	c3 := hwy.Set[float64](float64(atanC3_f64))
	c4 := hwy.Set[float64](float64(atanC4_f64))
	c5 := hwy.Set[float64](float64(atanC5_f64))
	lanes := one.NumLanes()
	for ii := 0; ii < size; ii += lanes {
		x := hwy.Load(input[ii:])
		absX := hwy.Abs(x)
		signMask := hwy.Less(x, zero)
		useReciprocalMask := hwy.Greater(absX, one)
		recipAbsX := hwy.Div(one, absX)
		reduced := hwy.Merge(recipAbsX, absX, useReciprocalMask)
		useIdentityMask := hwy.Greater(reduced, tanPiOver8)
		xMinus1 := hwy.Sub(reduced, one)
		xPlus1 := hwy.Add(reduced, one)
		transformed := hwy.Div(xMinus1, xPlus1)
		reduced = hwy.Merge(transformed, reduced, useIdentityMask)
		z2 := hwy.Mul(reduced, reduced)
		poly := hwy.MulAdd(c5, z2, c4)
		poly = hwy.MulAdd(poly, z2, c3)
		poly = hwy.MulAdd(poly, z2, c2)
		poly = hwy.MulAdd(poly, z2, c1)
		poly = hwy.MulAdd(poly, z2, one)
		atanCore := hwy.Mul(reduced, poly)
		atanWithIdentity := hwy.Add(piOver4, atanCore)
		atanReduced := hwy.Merge(atanWithIdentity, atanCore, useIdentityMask)
		atanWithReciprocal := hwy.Sub(piOver2, atanReduced)
		resultAbs := hwy.Merge(atanWithReciprocal, atanReduced, useReciprocalMask)
		negResult := hwy.Neg(resultAbs)
		result := hwy.Merge(negResult, resultAbs, signMask)
		hwy.Store(result, output[ii:])
	}
}

func BaseAsinPoly_fallback(input []float32, output []float32) {
	size := len(input)
	if len(output) < size {
		size = len(output)
	}
	piOver2 := hwy.Set[float32](float32(asinPiOver2_f32))
	half := hwy.Set[float32](float32(asinHalf_f32))
	two := hwy.Set[float32](float32(asinTwo_f32))
	one := hwy.Set[float32](float32(asinOne_f32))
	zero := hwy.Set[float32](float32(asinZero_f32))
	p1 := hwy.Set[float32](float32(asinP1_f32))
	p2 := hwy.Set[float32](float32(asinP2_f32))
	p3 := hwy.Set[float32](float32(asinP3_f32))
	p4 := hwy.Set[float32](float32(asinP4_f32))
	p5 := hwy.Set[float32](float32(asinP5_f32))
	p6 := hwy.Set[float32](float32(asinP6_f32))
	lanes := one.NumLanes()
	for ii := 0; ii < size; ii += lanes {
		x := hwy.Load(input[ii:])
		absX := hwy.Abs(x)
		signMask := hwy.Less(x, zero)
		largeMask := hwy.Greater(absX, half)
		x2Small := hwy.Mul(x, x)
		poly := hwy.MulAdd(p6, x2Small, p5)
		poly = hwy.MulAdd(poly, x2Small, p4)
		poly = hwy.MulAdd(poly, x2Small, p3)
		poly = hwy.MulAdd(poly, x2Small, p2)
		poly = hwy.MulAdd(poly, x2Small, p1)
		smallResult := hwy.Add(x, hwy.Mul(hwy.Mul(x, x2Small), poly))
		oneMinusAbsX := hwy.Sub(one, absX)
		halfOneMinusAbsX := hwy.Mul(oneMinusAbsX, half)
		sqrtArg := hwy.Sqrt(halfOneMinusAbsX)
		sqrtArg2 := hwy.Mul(sqrtArg, sqrtArg)
		polyLarge := hwy.MulAdd(p6, sqrtArg2, p5)
		polyLarge = hwy.MulAdd(polyLarge, sqrtArg2, p4)
		polyLarge = hwy.MulAdd(polyLarge, sqrtArg2, p3)
		polyLarge = hwy.MulAdd(polyLarge, sqrtArg2, p2)
		polyLarge = hwy.MulAdd(polyLarge, sqrtArg2, p1)
		asinSqrtArg := hwy.Add(sqrtArg, hwy.Mul(hwy.Mul(sqrtArg, sqrtArg2), polyLarge))
		largeResultPos := hwy.Sub(piOver2, hwy.Mul(two, asinSqrtArg))
		largeResultNeg := hwy.Neg(largeResultPos)
		largeResult := hwy.Merge(largeResultNeg, largeResultPos, signMask)
		result := hwy.Merge(largeResult, smallResult, largeMask)
		hwy.Store(result, output[ii:])
	}
}

func BaseAsinPoly_fallback_Float64(input []float64, output []float64) {
	size := len(input)
	if len(output) < size {
		size = len(output)
	}
	piOver2 := hwy.Set[float64](float64(asinPiOver2_f64))
	half := hwy.Set[float64](float64(asinHalf_f64))
	two := hwy.Set[float64](float64(asinTwo_f64))
	one := hwy.Set[float64](float64(asinOne_f64))
	zero := hwy.Set[float64](float64(asinZero_f64))
	p1 := hwy.Set[float64](float64(asinP1_f64))
	p2 := hwy.Set[float64](float64(asinP2_f64))
	p3 := hwy.Set[float64](float64(asinP3_f64))
	p4 := hwy.Set[float64](float64(asinP4_f64))
	p5 := hwy.Set[float64](float64(asinP5_f64))
	p6 := hwy.Set[float64](float64(asinP6_f64))
	lanes := one.NumLanes()
	for ii := 0; ii < size; ii += lanes {
		x := hwy.Load(input[ii:])
		absX := hwy.Abs(x)
		signMask := hwy.Less(x, zero)
		largeMask := hwy.Greater(absX, half)
		x2Small := hwy.Mul(x, x)
		poly := hwy.MulAdd(p6, x2Small, p5)
		poly = hwy.MulAdd(poly, x2Small, p4)
		poly = hwy.MulAdd(poly, x2Small, p3)
		poly = hwy.MulAdd(poly, x2Small, p2)
		poly = hwy.MulAdd(poly, x2Small, p1)
		smallResult := hwy.Add(x, hwy.Mul(hwy.Mul(x, x2Small), poly))
		oneMinusAbsX := hwy.Sub(one, absX)
		halfOneMinusAbsX := hwy.Mul(oneMinusAbsX, half)
		sqrtArg := hwy.Sqrt(halfOneMinusAbsX)
		sqrtArg2 := hwy.Mul(sqrtArg, sqrtArg)
		polyLarge := hwy.MulAdd(p6, sqrtArg2, p5)
		polyLarge = hwy.MulAdd(polyLarge, sqrtArg2, p4)
		polyLarge = hwy.MulAdd(polyLarge, sqrtArg2, p3)
		polyLarge = hwy.MulAdd(polyLarge, sqrtArg2, p2)
		polyLarge = hwy.MulAdd(polyLarge, sqrtArg2, p1)
		asinSqrtArg := hwy.Add(sqrtArg, hwy.Mul(hwy.Mul(sqrtArg, sqrtArg2), polyLarge))
		largeResultPos := hwy.Sub(piOver2, hwy.Mul(two, asinSqrtArg))
		largeResultNeg := hwy.Neg(largeResultPos)
		largeResult := hwy.Merge(largeResultNeg, largeResultPos, signMask)
		result := hwy.Merge(largeResult, smallResult, largeMask)
		hwy.Store(result, output[ii:])
	}
}

func BaseAcosPoly_fallback(input []float32, output []float32) {
	size := len(input)
	if len(output) < size {
		size = len(output)
	}
	piOver2 := hwy.Set[float32](float32(asinPiOver2_f32))
	half := hwy.Set[float32](float32(asinHalf_f32))
	two := hwy.Set[float32](float32(asinTwo_f32))
	one := hwy.Set[float32](float32(asinOne_f32))
	zero := hwy.Set[float32](float32(asinZero_f32))
	p1 := hwy.Set[float32](float32(asinP1_f32))
	p2 := hwy.Set[float32](float32(asinP2_f32))
	p3 := hwy.Set[float32](float32(asinP3_f32))
	p4 := hwy.Set[float32](float32(asinP4_f32))
	p5 := hwy.Set[float32](float32(asinP5_f32))
	p6 := hwy.Set[float32](float32(asinP6_f32))
	lanes := one.NumLanes()
	for ii := 0; ii < size; ii += lanes {
		x := hwy.Load(input[ii:])
		absX := hwy.Abs(x)
		signMask := hwy.Less(x, zero)
		largeMask := hwy.Greater(absX, half)
		x2Small := hwy.Mul(x, x)
		poly := hwy.MulAdd(p6, x2Small, p5)
		poly = hwy.MulAdd(poly, x2Small, p4)
		poly = hwy.MulAdd(poly, x2Small, p3)
		poly = hwy.MulAdd(poly, x2Small, p2)
		poly = hwy.MulAdd(poly, x2Small, p1)
		asinSmall := hwy.Add(x, hwy.Mul(hwy.Mul(x, x2Small), poly))
		oneMinusAbsX := hwy.Sub(one, absX)
		halfOneMinusAbsX := hwy.Mul(oneMinusAbsX, half)
		sqrtArg := hwy.Sqrt(halfOneMinusAbsX)
		sqrtArg2 := hwy.Mul(sqrtArg, sqrtArg)
		polyLarge := hwy.MulAdd(p6, sqrtArg2, p5)
		polyLarge = hwy.MulAdd(polyLarge, sqrtArg2, p4)
		polyLarge = hwy.MulAdd(polyLarge, sqrtArg2, p3)
		polyLarge = hwy.MulAdd(polyLarge, sqrtArg2, p2)
		polyLarge = hwy.MulAdd(polyLarge, sqrtArg2, p1)
		asinSqrtArg := hwy.Add(sqrtArg, hwy.Mul(hwy.Mul(sqrtArg, sqrtArg2), polyLarge))
		largeResultPos := hwy.Sub(piOver2, hwy.Mul(two, asinSqrtArg))
		largeResultNeg := hwy.Neg(largeResultPos)
		asinLarge := hwy.Merge(largeResultNeg, largeResultPos, signMask)
		asinX := hwy.Merge(asinLarge, asinSmall, largeMask)
		result := hwy.Sub(piOver2, asinX)
		hwy.Store(result, output[ii:])
	}
}

func BaseAcosPoly_fallback_Float64(input []float64, output []float64) {
	size := len(input)
	if len(output) < size {
		size = len(output)
	}
	piOver2 := hwy.Set[float64](float64(asinPiOver2_f64))
	half := hwy.Set[float64](float64(asinHalf_f64))
	two := hwy.Set[float64](float64(asinTwo_f64))
	one := hwy.Set[float64](float64(asinOne_f64))
	zero := hwy.Set[float64](float64(asinZero_f64))
	p1 := hwy.Set[float64](float64(asinP1_f64))
	p2 := hwy.Set[float64](float64(asinP2_f64))
	p3 := hwy.Set[float64](float64(asinP3_f64))
	p4 := hwy.Set[float64](float64(asinP4_f64))
	p5 := hwy.Set[float64](float64(asinP5_f64))
	p6 := hwy.Set[float64](float64(asinP6_f64))
	lanes := one.NumLanes()
	for ii := 0; ii < size; ii += lanes {
		x := hwy.Load(input[ii:])
		absX := hwy.Abs(x)
		signMask := hwy.Less(x, zero)
		largeMask := hwy.Greater(absX, half)
		x2Small := hwy.Mul(x, x)
		poly := hwy.MulAdd(p6, x2Small, p5)
		poly = hwy.MulAdd(poly, x2Small, p4)
		poly = hwy.MulAdd(poly, x2Small, p3)
		poly = hwy.MulAdd(poly, x2Small, p2)
		poly = hwy.MulAdd(poly, x2Small, p1)
		asinSmall := hwy.Add(x, hwy.Mul(hwy.Mul(x, x2Small), poly))
		oneMinusAbsX := hwy.Sub(one, absX)
		halfOneMinusAbsX := hwy.Mul(oneMinusAbsX, half)
		sqrtArg := hwy.Sqrt(halfOneMinusAbsX)
		sqrtArg2 := hwy.Mul(sqrtArg, sqrtArg)
		polyLarge := hwy.MulAdd(p6, sqrtArg2, p5)
		polyLarge = hwy.MulAdd(polyLarge, sqrtArg2, p4)
		polyLarge = hwy.MulAdd(polyLarge, sqrtArg2, p3)
		polyLarge = hwy.MulAdd(polyLarge, sqrtArg2, p2)
		polyLarge = hwy.MulAdd(polyLarge, sqrtArg2, p1)
		asinSqrtArg := hwy.Add(sqrtArg, hwy.Mul(hwy.Mul(sqrtArg, sqrtArg2), polyLarge))
		largeResultPos := hwy.Sub(piOver2, hwy.Mul(two, asinSqrtArg))
		largeResultNeg := hwy.Neg(largeResultPos)
		asinLarge := hwy.Merge(largeResultNeg, largeResultPos, signMask)
		asinX := hwy.Merge(asinLarge, asinSmall, largeMask)
		result := hwy.Sub(piOver2, asinX)
		hwy.Store(result, output[ii:])
	}
}

func BaseSinhPoly_fallback(input []float32, output []float32) {
	size := len(input)
	if len(output) < size {
		size = len(output)
	}
	half := hwy.Set[float32](float32(0.5))
	lanes := half.NumLanes()
	expPos := make([]float32, lanes)
	expNeg := make([]float32, lanes)
	negInput := make([]float32, lanes)
	for ii := 0; ii < size; ii += lanes {
		x := hwy.Load(input[ii:])
		hwy.Store(x, expPos)
		BaseExpPoly_fallback(expPos, expPos)
		expX := hwy.Load(expPos)
		negX := hwy.Neg(x)
		hwy.Store(negX, negInput)
		BaseExpPoly_fallback(negInput, expNeg)
		expNegX := hwy.Load(expNeg)
		diff := hwy.Sub(expX, expNegX)
		result := hwy.Mul(diff, half)
		hwy.Store(result, output[ii:])
	}
}

func BaseSinhPoly_fallback_Float64(input []float64, output []float64) {
	size := len(input)
	if len(output) < size {
		size = len(output)
	}
	half := hwy.Set[float64](float64(0.5))
	lanes := half.NumLanes()
	expPos := make([]float64, lanes)
	expNeg := make([]float64, lanes)
	negInput := make([]float64, lanes)
	for ii := 0; ii < size; ii += lanes {
		x := hwy.Load(input[ii:])
		hwy.Store(x, expPos)
		BaseExpPoly_fallback_Float64(expPos, expPos)
		expX := hwy.Load(expPos)
		negX := hwy.Neg(x)
		hwy.Store(negX, negInput)
		BaseExpPoly_fallback_Float64(negInput, expNeg)
		expNegX := hwy.Load(expNeg)
		diff := hwy.Sub(expX, expNegX)
		result := hwy.Mul(diff, half)
		hwy.Store(result, output[ii:])
	}
}

func BaseCoshPoly_fallback(input []float32, output []float32) {
	size := len(input)
	if len(output) < size {
		size = len(output)
	}
	half := hwy.Set[float32](float32(0.5))
	lanes := half.NumLanes()
	expPos := make([]float32, lanes)
	expNeg := make([]float32, lanes)
	negInput := make([]float32, lanes)
	for ii := 0; ii < size; ii += lanes {
		x := hwy.Load(input[ii:])
		hwy.Store(x, expPos)
		BaseExpPoly_fallback(expPos, expPos)
		expX := hwy.Load(expPos)
		negX := hwy.Neg(x)
		hwy.Store(negX, negInput)
		BaseExpPoly_fallback(negInput, expNeg)
		expNegX := hwy.Load(expNeg)
		sum := hwy.Add(expX, expNegX)
		result := hwy.Mul(sum, half)
		hwy.Store(result, output[ii:])
	}
}

func BaseCoshPoly_fallback_Float64(input []float64, output []float64) {
	size := len(input)
	if len(output) < size {
		size = len(output)
	}
	half := hwy.Set[float64](float64(0.5))
	lanes := half.NumLanes()
	expPos := make([]float64, lanes)
	expNeg := make([]float64, lanes)
	negInput := make([]float64, lanes)
	for ii := 0; ii < size; ii += lanes {
		x := hwy.Load(input[ii:])
		hwy.Store(x, expPos)
		BaseExpPoly_fallback_Float64(expPos, expPos)
		expX := hwy.Load(expPos)
		negX := hwy.Neg(x)
		hwy.Store(negX, negInput)
		BaseExpPoly_fallback_Float64(negInput, expNeg)
		expNegX := hwy.Load(expNeg)
		sum := hwy.Add(expX, expNegX)
		result := hwy.Mul(sum, half)
		hwy.Store(result, output[ii:])
	}
}

func BaseErfPoly_fallback(input []float32, output []float32) {
	size := len(input)
	if len(output) < size {
		size = len(output)
	}
	a1 := hwy.Set[float32](float32(erfA1_f32))
	a2 := hwy.Set[float32](float32(erfA2_f32))
	a3 := hwy.Set[float32](float32(erfA3_f32))
	a4 := hwy.Set[float32](float32(erfA4_f32))
	a5 := hwy.Set[float32](float32(erfA5_f32))
	p := hwy.Set[float32](float32(erfP_f32))
	one := hwy.Set[float32](float32(erfOne_f32))
	zero := hwy.Set[float32](float32(erfZero_f32))
	lanes := one.NumLanes()
	tempIn := make([]float32, lanes)
	tempOut := make([]float32, lanes)
	for ii := 0; ii < size; ii += lanes {
		x := hwy.Load(input[ii:])
		absX := hwy.Abs(x)
		signMask := hwy.Less(x, zero)
		t := hwy.Div(one, hwy.Add(one, hwy.Mul(p, absX)))
		poly := hwy.MulAdd(a5, t, a4)
		poly = hwy.MulAdd(poly, t, a3)
		poly = hwy.MulAdd(poly, t, a2)
		poly = hwy.MulAdd(poly, t, a1)
		poly = hwy.Mul(poly, t)
		x2 := hwy.Mul(absX, absX)
		negX2 := hwy.Neg(x2)
		hwy.Store(negX2, tempIn)
		BaseExpPoly_fallback(tempIn, tempOut)
		expNegX2 := hwy.Load(tempOut)
		erfAbs := hwy.Sub(one, hwy.Mul(poly, expNegX2))
		erfAbs = hwy.Max(hwy.Min(erfAbs, one), zero)
		negErfAbs := hwy.Neg(erfAbs)
		result := hwy.Merge(negErfAbs, erfAbs, signMask)
		hwy.Store(result, output[ii:])
	}
}

func BaseErfPoly_fallback_Float64(input []float64, output []float64) {
	size := len(input)
	if len(output) < size {
		size = len(output)
	}
	a1 := hwy.Set[float64](float64(erfA1_f64))
	a2 := hwy.Set[float64](float64(erfA2_f64))
	a3 := hwy.Set[float64](float64(erfA3_f64))
	a4 := hwy.Set[float64](float64(erfA4_f64))
	a5 := hwy.Set[float64](float64(erfA5_f64))
	p := hwy.Set[float64](float64(erfP_f64))
	one := hwy.Set[float64](float64(erfOne_f64))
	zero := hwy.Set[float64](float64(erfZero_f64))
	lanes := one.NumLanes()
	tempIn := make([]float64, lanes)
	tempOut := make([]float64, lanes)
	for ii := 0; ii < size; ii += lanes {
		x := hwy.Load(input[ii:])
		absX := hwy.Abs(x)
		signMask := hwy.Less(x, zero)
		t := hwy.Div(one, hwy.Add(one, hwy.Mul(p, absX)))
		poly := hwy.MulAdd(a5, t, a4)
		poly = hwy.MulAdd(poly, t, a3)
		poly = hwy.MulAdd(poly, t, a2)
		poly = hwy.MulAdd(poly, t, a1)
		poly = hwy.Mul(poly, t)
		x2 := hwy.Mul(absX, absX)
		negX2 := hwy.Neg(x2)
		hwy.Store(negX2, tempIn)
		BaseExpPoly_fallback_Float64(tempIn, tempOut)
		expNegX2 := hwy.Load(tempOut)
		erfAbs := hwy.Sub(one, hwy.Mul(poly, expNegX2))
		erfAbs = hwy.Max(hwy.Min(erfAbs, one), zero)
		negErfAbs := hwy.Neg(erfAbs)
		result := hwy.Merge(negErfAbs, erfAbs, signMask)
		hwy.Store(result, output[ii:])
	}
}

func BaseExpm1Poly_fallback(input []float32, output []float32) {
	size := len(input)
	if len(output) < size {
		size = len(output)
	}
	one := hwy.Set[float32](float32(expm1One_f32))
	negOne := hwy.Set[float32](float32(-1.0))
	zero := hwy.Set[float32](float32(0.0))
	threshold := hwy.Set[float32](float32(expm1Threshold_f32))
	c2 := hwy.Set[float32](float32(expm1C2_f32))
	c3 := hwy.Set[float32](float32(expm1C3_f32))
	c4 := hwy.Set[float32](float32(expm1C4_f32))
	c5 := hwy.Set[float32](float32(expm1C5_f32))
	lanes := one.NumLanes()
	tempIn := make([]float32, lanes)
	tempOut := make([]float32, lanes)
	for ii := 0; ii < size; ii += lanes {
		x := hwy.Load(input[ii:])
		absX := hwy.Abs(x)
		smallMask := hwy.Less(absX, threshold)
		poly := hwy.MulAdd(c5, x, c4)
		poly = hwy.MulAdd(poly, x, c3)
		poly = hwy.MulAdd(poly, x, c2)
		poly = hwy.MulAdd(poly, x, one)
		taylorResult := hwy.Mul(x, poly)
		hwy.Store(x, tempIn)
		BaseExpPoly_fallback(tempIn, tempOut)
		expX := hwy.Load(tempOut)
		expResult := hwy.Sub(expX, one)
		result := hwy.Merge(taylorResult, expResult, smallMask)
		veryNegMask := hwy.Less(x, hwy.Set[float32](float32(-20.0)))
		result = hwy.Merge(negOne, result, veryNegMask)
		zeroMask := hwy.Equal(x, zero)
		result = hwy.Merge(zero, result, zeroMask)
		hwy.Store(result, output[ii:])
	}
}

func BaseExpm1Poly_fallback_Float64(input []float64, output []float64) {
	size := len(input)
	if len(output) < size {
		size = len(output)
	}
	one := hwy.Set[float64](float64(expm1One_f64))
	negOne := hwy.Set[float64](float64(-1.0))
	zero := hwy.Set[float64](float64(0.0))
	threshold := hwy.Set[float64](float64(expm1Threshold_f64))
	c2 := hwy.Set[float64](float64(expm1C2_f64))
	c3 := hwy.Set[float64](float64(expm1C3_f64))
	c4 := hwy.Set[float64](float64(expm1C4_f64))
	c5 := hwy.Set[float64](float64(expm1C5_f64))
	lanes := one.NumLanes()
	tempIn := make([]float64, lanes)
	tempOut := make([]float64, lanes)
	for ii := 0; ii < size; ii += lanes {
		x := hwy.Load(input[ii:])
		absX := hwy.Abs(x)
		smallMask := hwy.Less(absX, threshold)
		poly := hwy.MulAdd(c5, x, c4)
		poly = hwy.MulAdd(poly, x, c3)
		poly = hwy.MulAdd(poly, x, c2)
		poly = hwy.MulAdd(poly, x, one)
		taylorResult := hwy.Mul(x, poly)
		hwy.Store(x, tempIn)
		BaseExpPoly_fallback_Float64(tempIn, tempOut)
		expX := hwy.Load(tempOut)
		expResult := hwy.Sub(expX, one)
		result := hwy.Merge(taylorResult, expResult, smallMask)
		veryNegMask := hwy.Less(x, hwy.Set[float64](float64(-20.0)))
		result = hwy.Merge(negOne, result, veryNegMask)
		zeroMask := hwy.Equal(x, zero)
		result = hwy.Merge(zero, result, zeroMask)
		hwy.Store(result, output[ii:])
	}
}

func BaseLog1pPoly_fallback(input []float32, output []float32) {
	size := len(input)
	if len(output) < size {
		size = len(output)
	}
	one := hwy.Set[float32](float32(log1pOne_f32))
	zero := hwy.Set[float32](float32(0.0))
	negOne := hwy.Set[float32](float32(-1.0))
	threshold := hwy.Set[float32](float32(log1pHalf_f32))
	c2 := hwy.Set[float32](float32(log1pC2_f32))
	c3 := hwy.Set[float32](float32(log1pC3_f32))
	c4 := hwy.Set[float32](float32(log1pC4_f32))
	c5 := hwy.Set[float32](float32(log1pC5_f32))
	negInf := hwy.Set[float32](float32(stdmath.Inf(-1)))
	nan := hwy.Set[float32](float32(stdmath.NaN()))
	lanes := one.NumLanes()
	tempIn := make([]float32, lanes)
	tempOut := make([]float32, lanes)
	for ii := 0; ii < size; ii += lanes {
		x := hwy.Load(input[ii:])
		absX := hwy.Abs(x)
		smallMask := hwy.Less(absX, threshold)
		poly := hwy.MulAdd(c5, x, c4)
		poly = hwy.MulAdd(poly, x, c3)
		poly = hwy.MulAdd(poly, x, c2)
		poly = hwy.MulAdd(poly, x, one)
		taylorResult := hwy.Mul(x, poly)
		onePlusX := hwy.Add(one, x)
		hwy.Store(onePlusX, tempIn)
		BaseLogPoly_fallback(tempIn, tempOut)
		logResult := hwy.Load(tempOut)
		result := hwy.Merge(taylorResult, logResult, smallMask)
		zeroMask := hwy.Equal(x, zero)
		result = hwy.Merge(zero, result, zeroMask)
		negOneMask := hwy.Equal(x, negOne)
		result = hwy.Merge(negInf, result, negOneMask)
		invalidMask := hwy.Less(x, negOne)
		result = hwy.Merge(nan, result, invalidMask)
		hwy.Store(result, output[ii:])
	}
}

func BaseLog1pPoly_fallback_Float64(input []float64, output []float64) {
	size := len(input)
	if len(output) < size {
		size = len(output)
	}
	one := hwy.Set[float64](float64(log1pOne_f64))
	zero := hwy.Set[float64](float64(0.0))
	negOne := hwy.Set[float64](float64(-1.0))
	threshold := hwy.Set[float64](float64(log1pHalf_f64))
	c2 := hwy.Set[float64](float64(log1pC2_f64))
	c3 := hwy.Set[float64](float64(log1pC3_f64))
	c4 := hwy.Set[float64](float64(log1pC4_f64))
	c5 := hwy.Set[float64](float64(log1pC5_f64))
	negInf := hwy.Set[float64](float64(stdmath.Inf(-1)))
	nan := hwy.Set[float64](float64(stdmath.NaN()))
	lanes := one.NumLanes()
	tempIn := make([]float64, lanes)
	tempOut := make([]float64, lanes)
	for ii := 0; ii < size; ii += lanes {
		x := hwy.Load(input[ii:])
		absX := hwy.Abs(x)
		smallMask := hwy.Less(absX, threshold)
		poly := hwy.MulAdd(c5, x, c4)
		poly = hwy.MulAdd(poly, x, c3)
		poly = hwy.MulAdd(poly, x, c2)
		poly = hwy.MulAdd(poly, x, one)
		taylorResult := hwy.Mul(x, poly)
		onePlusX := hwy.Add(one, x)
		hwy.Store(onePlusX, tempIn)
		BaseLogPoly_fallback_Float64(tempIn, tempOut)
		logResult := hwy.Load(tempOut)
		result := hwy.Merge(taylorResult, logResult, smallMask)
		zeroMask := hwy.Equal(x, zero)
		result = hwy.Merge(zero, result, zeroMask)
		negOneMask := hwy.Equal(x, negOne)
		result = hwy.Merge(negInf, result, negOneMask)
		invalidMask := hwy.Less(x, negOne)
		result = hwy.Merge(nan, result, invalidMask)
		hwy.Store(result, output[ii:])
	}
}

func BaseLogPoly_fallback(input []float32, output []float32) {
	size := len(input)
	if len(output) < size {
		size = len(output)
	}
	one := hwy.Set[float32](float32(logOne_f32))
	two := hwy.Set[float32](float32(logTwo_f32))
	zero := hwy.Set[float32](float32(0.0))
	ln2Hi := hwy.Set[float32](float32(logLn2Hi_f32))
	ln2Lo := hwy.Set[float32](float32(logLn2Lo_f32))
	negInf := hwy.Set[float32](float32(stdmath.Inf(-1)))
	nan := hwy.Set[float32](float32(stdmath.NaN()))
	c1 := hwy.Set[float32](float32(logC1_f32))
	c2 := hwy.Set[float32](float32(logC2_f32))
	c3 := hwy.Set[float32](float32(logC3_f32))
	c4 := hwy.Set[float32](float32(logC4_f32))
	c5 := hwy.Set[float32](float32(logC5_f32))
	lanes := one.NumLanes()
	for ii := 0; ii < size; ii += lanes {
		x := hwy.Load(input[ii:])
		zeroMask := hwy.Equal(x, zero)
		negMask := hwy.Less(x, zero)
		oneMask := hwy.Equal(x, one)
		e := hwy.GetExponent(x)
		m := hwy.GetMantissa(x)
		mLarge := hwy.Greater(m, hwy.Set[float32](float32(1.414)))
		mAdjusted := hwy.Merge(hwy.Mul(m, hwy.Set[float32](float32(0.5))), m, mLarge)
		eData := e.Data()
		eFloatData := make([]float32, len(eData))
		for i, v := range eData {
			eFloatData[i] = float32(v)
		}
		eFloat := hwy.Load(eFloatData)
		eAdjusted := hwy.Merge(hwy.Add(eFloat, one), eFloat, mLarge)
		mMinus1 := hwy.Sub(mAdjusted, one)
		mPlus1 := hwy.Add(mAdjusted, one)
		y := hwy.Div(mMinus1, mPlus1)
		y2 := hwy.Mul(y, y)
		poly := hwy.MulAdd(c5, y2, c4)
		poly = hwy.MulAdd(poly, y2, c3)
		poly = hwy.MulAdd(poly, y2, c2)
		poly = hwy.MulAdd(poly, y2, c1)
		logM := hwy.Mul(hwy.Mul(two, y), poly)
		result := hwy.Add(hwy.MulAdd(eAdjusted, ln2Hi, logM), hwy.Mul(eAdjusted, ln2Lo))
		result = hwy.Merge(negInf, result, zeroMask)
		result = hwy.Merge(nan, result, negMask)
		result = hwy.Merge(zero, result, oneMask)
		hwy.Store(result, output[ii:])
	}
}

func BaseLogPoly_fallback_Float64(input []float64, output []float64) {
	size := len(input)
	if len(output) < size {
		size = len(output)
	}
	one := hwy.Set[float64](float64(logOne_f64))
	two := hwy.Set[float64](float64(logTwo_f64))
	zero := hwy.Set[float64](float64(0.0))
	ln2Hi := hwy.Set[float64](float64(logLn2Hi_f64))
	ln2Lo := hwy.Set[float64](float64(logLn2Lo_f64))
	negInf := hwy.Set[float64](float64(stdmath.Inf(-1)))
	nan := hwy.Set[float64](float64(stdmath.NaN()))
	c1 := hwy.Set[float64](float64(logC1_f64))
	c2 := hwy.Set[float64](float64(logC2_f64))
	c3 := hwy.Set[float64](float64(logC3_f64))
	c4 := hwy.Set[float64](float64(logC4_f64))
	c5 := hwy.Set[float64](float64(logC5_f64))
	lanes := one.NumLanes()
	for ii := 0; ii < size; ii += lanes {
		x := hwy.Load(input[ii:])
		zeroMask := hwy.Equal(x, zero)
		negMask := hwy.Less(x, zero)
		oneMask := hwy.Equal(x, one)
		e := hwy.GetExponent(x)
		m := hwy.GetMantissa(x)
		mLarge := hwy.Greater(m, hwy.Set[float64](float64(1.414)))
		mAdjusted := hwy.Merge(hwy.Mul(m, hwy.Set[float64](float64(0.5))), m, mLarge)
		eData := e.Data()
		eFloatData := make([]float64, len(eData))
		for i, v := range eData {
			eFloatData[i] = float64(v)
		}
		eFloat := hwy.Load(eFloatData)
		eAdjusted := hwy.Merge(hwy.Add(eFloat, one), eFloat, mLarge)
		mMinus1 := hwy.Sub(mAdjusted, one)
		mPlus1 := hwy.Add(mAdjusted, one)
		y := hwy.Div(mMinus1, mPlus1)
		y2 := hwy.Mul(y, y)
		poly := hwy.MulAdd(c5, y2, c4)
		poly = hwy.MulAdd(poly, y2, c3)
		poly = hwy.MulAdd(poly, y2, c2)
		poly = hwy.MulAdd(poly, y2, c1)
		logM := hwy.Mul(hwy.Mul(two, y), poly)
		result := hwy.Add(hwy.MulAdd(eAdjusted, ln2Hi, logM), hwy.Mul(eAdjusted, ln2Lo))
		result = hwy.Merge(negInf, result, zeroMask)
		result = hwy.Merge(nan, result, negMask)
		result = hwy.Merge(zero, result, oneMask)
		hwy.Store(result, output[ii:])
	}
}

func BaseLog2Poly_fallback(input []float32, output []float32) {
	size := len(input)
	if len(output) < size {
		size = len(output)
	}
	log2E_f32 := hwy.Set[float32](float32(log2E_f32))
	lanes := log2E_f32.NumLanes()
	tempOut := make([]float32, lanes)
	for ii := 0; ii < size; ii += lanes {
		x := hwy.Load(input[ii:])
		hwy.Store(x, output[ii:])
		BaseLogPoly_fallback(output[ii:ii+lanes], tempOut)
		lnX := hwy.Load(tempOut)
		result := hwy.Mul(lnX, log2E_f32)
		hwy.Store(result, output[ii:])
	}
}

func BaseLog2Poly_fallback_Float64(input []float64, output []float64) {
	size := len(input)
	if len(output) < size {
		size = len(output)
	}
	log2E_f64 := hwy.Set[float64](float64(log2E_f64))
	lanes := log2E_f64.NumLanes()
	tempOut := make([]float64, lanes)
	for ii := 0; ii < size; ii += lanes {
		x := hwy.Load(input[ii:])
		hwy.Store(x, output[ii:])
		BaseLogPoly_fallback_Float64(output[ii:ii+lanes], tempOut)
		lnX := hwy.Load(tempOut)
		result := hwy.Mul(lnX, log2E_f64)
		hwy.Store(result, output[ii:])
	}
}

func BaseLog10Poly_fallback(input []float32, output []float32) {
	size := len(input)
	if len(output) < size {
		size = len(output)
	}
	log10E_f32 := hwy.Set[float32](float32(log10E_f32))
	lanes := log10E_f32.NumLanes()
	tempOut := make([]float32, lanes)
	for ii := 0; ii < size; ii += lanes {
		x := hwy.Load(input[ii:])
		hwy.Store(x, output[ii:])
		BaseLogPoly_fallback(output[ii:ii+lanes], tempOut)
		lnX := hwy.Load(tempOut)
		result := hwy.Mul(lnX, log10E_f32)
		hwy.Store(result, output[ii:])
	}
}

func BaseLog10Poly_fallback_Float64(input []float64, output []float64) {
	size := len(input)
	if len(output) < size {
		size = len(output)
	}
	log10E_f64 := hwy.Set[float64](float64(log10E_f64))
	lanes := log10E_f64.NumLanes()
	tempOut := make([]float64, lanes)
	for ii := 0; ii < size; ii += lanes {
		x := hwy.Load(input[ii:])
		hwy.Store(x, output[ii:])
		BaseLogPoly_fallback_Float64(output[ii:ii+lanes], tempOut)
		lnX := hwy.Load(tempOut)
		result := hwy.Mul(lnX, log10E_f64)
		hwy.Store(result, output[ii:])
	}
}

func BaseTanPoly_fallback(input []float32, output []float32) {
	size := len(input)
	if len(output) < size {
		size = len(output)
	}
	lanes := hwy.Set[float32](float32(1.0)).NumLanes()
	sinOut := make([]float32, lanes)
	cosOut := make([]float32, lanes)
	tempIn := make([]float32, lanes)
	for ii := 0; ii < size; ii += lanes {
		x := hwy.Load(input[ii:])
		hwy.Store(x, tempIn)
		BaseSinPoly_fallback(tempIn, sinOut)
		hwy.Store(x, tempIn)
		BaseCosPoly_fallback(tempIn, cosOut)
		sinX := hwy.Load(sinOut)
		cosX := hwy.Load(cosOut)
		result := hwy.Div(sinX, cosX)
		hwy.Store(result, output[ii:])
	}
}

func BaseTanPoly_fallback_Float64(input []float64, output []float64) {
	size := len(input)
	if len(output) < size {
		size = len(output)
	}
	lanes := hwy.Set[float64](float64(1.0)).NumLanes()
	sinOut := make([]float64, lanes)
	cosOut := make([]float64, lanes)
	tempIn := make([]float64, lanes)
	for ii := 0; ii < size; ii += lanes {
		x := hwy.Load(input[ii:])
		hwy.Store(x, tempIn)
		BaseSinPoly_fallback_Float64(tempIn, sinOut)
		hwy.Store(x, tempIn)
		BaseCosPoly_fallback_Float64(tempIn, cosOut)
		sinX := hwy.Load(sinOut)
		cosX := hwy.Load(cosOut)
		result := hwy.Div(sinX, cosX)
		hwy.Store(result, output[ii:])
	}
}

func BaseAtan2Poly_fallback(inputY []float32, inputX []float32, output []float32) {
	size := len(inputY)
	if len(inputX) < size {
		size = len(inputX)
	}
	if len(output) < size {
		size = len(output)
	}
	pi := hwy.Set[float32](float32(atanPi_f32))
	piOver2 := hwy.Set[float32](float32(atanPiOver2_f32))
	zero := hwy.Set[float32](float32(0.0))
	lanes := pi.NumLanes()
	tempIn := make([]float32, lanes)
	tempOut := make([]float32, lanes)
	for ii := 0; ii < size; ii += lanes {
		y := hwy.Load(inputY[ii:])
		x := hwy.Load(inputX[ii:])
		ratio := hwy.Div(y, x)
		hwy.Store(ratio, tempIn)
		BaseAtanPoly_fallback(tempIn, tempOut)
		atanRatio := hwy.Load(tempOut)
		xNegMask := hwy.Less(x, zero)
		yNonNegMask := hwy.GreaterEqual(y, zero)
		xZeroMask := hwy.Equal(x, zero)
		yPosZeroMask := hwy.Greater(y, zero)
		yNegMask := hwy.Less(y, zero)
		result := atanRatio
		addPiMask := hwy.MaskAnd(xNegMask, yNonNegMask)
		result = hwy.Merge(hwy.Add(result, pi), result, addPiMask)
		subPiMask := hwy.MaskAnd(xNegMask, yNegMask)
		result = hwy.Merge(hwy.Sub(result, pi), result, subPiMask)
		result = hwy.Merge(piOver2, result, hwy.MaskAnd(xZeroMask, yPosZeroMask))
		result = hwy.Merge(hwy.Neg(piOver2), result, hwy.MaskAnd(xZeroMask, yNegMask))
		hwy.Store(result, output[ii:])
	}
}

func BaseAtan2Poly_fallback_Float64(inputY []float64, inputX []float64, output []float64) {
	size := len(inputY)
	if len(inputX) < size {
		size = len(inputX)
	}
	if len(output) < size {
		size = len(output)
	}
	pi := hwy.Set[float64](float64(atanPi_f64))
	piOver2 := hwy.Set[float64](float64(atanPiOver2_f64))
	zero := hwy.Set[float64](float64(0.0))
	lanes := pi.NumLanes()
	tempIn := make([]float64, lanes)
	tempOut := make([]float64, lanes)
	for ii := 0; ii < size; ii += lanes {
		y := hwy.Load(inputY[ii:])
		x := hwy.Load(inputX[ii:])
		ratio := hwy.Div(y, x)
		hwy.Store(ratio, tempIn)
		BaseAtanPoly_fallback_Float64(tempIn, tempOut)
		atanRatio := hwy.Load(tempOut)
		xNegMask := hwy.Less(x, zero)
		yNonNegMask := hwy.GreaterEqual(y, zero)
		xZeroMask := hwy.Equal(x, zero)
		yPosZeroMask := hwy.Greater(y, zero)
		yNegMask := hwy.Less(y, zero)
		result := atanRatio
		addPiMask := hwy.MaskAnd(xNegMask, yNonNegMask)
		result = hwy.Merge(hwy.Add(result, pi), result, addPiMask)
		subPiMask := hwy.MaskAnd(xNegMask, yNegMask)
		result = hwy.Merge(hwy.Sub(result, pi), result, subPiMask)
		result = hwy.Merge(piOver2, result, hwy.MaskAnd(xZeroMask, yPosZeroMask))
		result = hwy.Merge(hwy.Neg(piOver2), result, hwy.MaskAnd(xZeroMask, yNegMask))
		hwy.Store(result, output[ii:])
	}
}

func BaseSinCosPoly_fallback(input []float32, sinOutput []float32, cosOutput []float32) {
	size := len(input)
	if len(sinOutput) < size {
		size = len(sinOutput)
	}
	if len(cosOutput) < size {
		size = len(cosOutput)
	}
	twoOverPi := hwy.Set[float32](float32(trig2OverPi_f32))
	piOver2Hi := hwy.Set[float32](float32(trigPiOver2Hi_f32))
	piOver2Lo := hwy.Set[float32](float32(trigPiOver2Lo_f32))
	one := hwy.Set[float32](float32(trigOne_f32))
	s1 := hwy.Set[float32](float32(trigS1_f32))
	s2 := hwy.Set[float32](float32(trigS2_f32))
	s3 := hwy.Set[float32](float32(trigS3_f32))
	s4 := hwy.Set[float32](float32(trigS4_f32))
	c1 := hwy.Set[float32](float32(trigC1_f32))
	c2 := hwy.Set[float32](float32(trigC2_f32))
	c3 := hwy.Set[float32](float32(trigC3_f32))
	c4 := hwy.Set[float32](float32(trigC4_f32))
	intOne := hwy.Set[int32](1)
	intTwo := hwy.Set[int32](2)
	intThree := hwy.Set[int32](3)
	lanes := one.NumLanes()
	for ii := 0; ii < size; ii += lanes {
		x := hwy.Load(input[ii:])
		kFloat := hwy.RoundToEven(hwy.Mul(x, twoOverPi))
		kInt := hwy.ConvertToInt32(kFloat)
		r := hwy.Sub(x, hwy.Mul(kFloat, piOver2Hi))
		r = hwy.Sub(r, hwy.Mul(kFloat, piOver2Lo))
		r2 := hwy.Mul(r, r)
		sinPoly := hwy.MulAdd(s4, r2, s3)
		sinPoly = hwy.MulAdd(sinPoly, r2, s2)
		sinPoly = hwy.MulAdd(sinPoly, r2, s1)
		sinPoly = hwy.MulAdd(sinPoly, r2, one)
		sinR := hwy.Mul(r, sinPoly)
		cosPoly := hwy.MulAdd(c4, r2, c3)
		cosPoly = hwy.MulAdd(cosPoly, r2, c2)
		cosPoly = hwy.MulAdd(cosPoly, r2, c1)
		cosR := hwy.MulAdd(cosPoly, r2, one)
		sinOctant := hwy.And(kInt, intThree)
		sinUseCosMask := hwy.Equal(hwy.And(sinOctant, intOne), intOne)
		sinNegateMask := hwy.Equal(hwy.And(sinOctant, intTwo), intTwo)
		cosOctant := hwy.And(hwy.Add(kInt, intOne), intThree)
		cosUseCosMask := hwy.Equal(hwy.And(cosOctant, intOne), intOne)
		cosNegateMask := hwy.Equal(hwy.And(cosOctant, intTwo), intTwo)
		sinRData := sinR.Data()
		cosRData := cosR.Data()
		sinResultData := make([]float32, len(sinRData))
		cosResultData := make([]float32, len(sinRData))
		for i := range sinRData {
			if sinUseCosMask.GetBit(i) {
				sinResultData[i] = cosRData[i]
			} else {
				sinResultData[i] = sinRData[i]
			}
			if cosUseCosMask.GetBit(i) {
				cosResultData[i] = cosRData[i]
			} else {
				cosResultData[i] = sinRData[i]
			}
		}
		for i := range sinResultData {
			if sinNegateMask.GetBit(i) {
				sinResultData[i] = -sinResultData[i]
			}
			if cosNegateMask.GetBit(i) {
				cosResultData[i] = -cosResultData[i]
			}
		}
		hwy.Store(hwy.Load(sinResultData), sinOutput[ii:])
		hwy.Store(hwy.Load(cosResultData), cosOutput[ii:])
	}
}

func BaseSinCosPoly_fallback_Float64(input []float64, sinOutput []float64, cosOutput []float64) {
	size := len(input)
	if len(sinOutput) < size {
		size = len(sinOutput)
	}
	if len(cosOutput) < size {
		size = len(cosOutput)
	}
	twoOverPi := hwy.Set[float64](float64(trig2OverPi_f64))
	piOver2Hi := hwy.Set[float64](float64(trigPiOver2Hi_f64))
	piOver2Lo := hwy.Set[float64](float64(trigPiOver2Lo_f64))
	one := hwy.Set[float64](float64(trigOne_f64))
	s1 := hwy.Set[float64](float64(trigS1_f64))
	s2 := hwy.Set[float64](float64(trigS2_f64))
	s3 := hwy.Set[float64](float64(trigS3_f64))
	s4 := hwy.Set[float64](float64(trigS4_f64))
	c1 := hwy.Set[float64](float64(trigC1_f64))
	c2 := hwy.Set[float64](float64(trigC2_f64))
	c3 := hwy.Set[float64](float64(trigC3_f64))
	c4 := hwy.Set[float64](float64(trigC4_f64))
	intOne := hwy.Set[int32](1)
	intTwo := hwy.Set[int32](2)
	intThree := hwy.Set[int32](3)
	lanes := one.NumLanes()
	for ii := 0; ii < size; ii += lanes {
		x := hwy.Load(input[ii:])
		kFloat := hwy.RoundToEven(hwy.Mul(x, twoOverPi))
		kInt := hwy.ConvertToInt32(kFloat)
		r := hwy.Sub(x, hwy.Mul(kFloat, piOver2Hi))
		r = hwy.Sub(r, hwy.Mul(kFloat, piOver2Lo))
		r2 := hwy.Mul(r, r)
		sinPoly := hwy.MulAdd(s4, r2, s3)
		sinPoly = hwy.MulAdd(sinPoly, r2, s2)
		sinPoly = hwy.MulAdd(sinPoly, r2, s1)
		sinPoly = hwy.MulAdd(sinPoly, r2, one)
		sinR := hwy.Mul(r, sinPoly)
		cosPoly := hwy.MulAdd(c4, r2, c3)
		cosPoly = hwy.MulAdd(cosPoly, r2, c2)
		cosPoly = hwy.MulAdd(cosPoly, r2, c1)
		cosR := hwy.MulAdd(cosPoly, r2, one)
		sinOctant := hwy.And(kInt, intThree)
		sinUseCosMask := hwy.Equal(hwy.And(sinOctant, intOne), intOne)
		sinNegateMask := hwy.Equal(hwy.And(sinOctant, intTwo), intTwo)
		cosOctant := hwy.And(hwy.Add(kInt, intOne), intThree)
		cosUseCosMask := hwy.Equal(hwy.And(cosOctant, intOne), intOne)
		cosNegateMask := hwy.Equal(hwy.And(cosOctant, intTwo), intTwo)
		sinRData := sinR.Data()
		cosRData := cosR.Data()
		sinResultData := make([]float64, len(sinRData))
		cosResultData := make([]float64, len(sinRData))
		for i := range sinRData {
			if sinUseCosMask.GetBit(i) {
				sinResultData[i] = cosRData[i]
			} else {
				sinResultData[i] = sinRData[i]
			}
			if cosUseCosMask.GetBit(i) {
				cosResultData[i] = cosRData[i]
			} else {
				cosResultData[i] = sinRData[i]
			}
		}
		for i := range sinResultData {
			if sinNegateMask.GetBit(i) {
				sinResultData[i] = -sinResultData[i]
			}
			if cosNegateMask.GetBit(i) {
				cosResultData[i] = -cosResultData[i]
			}
		}
		hwy.Store(hwy.Load(sinResultData), sinOutput[ii:])
		hwy.Store(hwy.Load(cosResultData), cosOutput[ii:])
	}
}

func BasePowPoly_fallback(inputX []float32, inputY []float32, output []float32) {
	size := len(inputX)
	if len(inputY) < size {
		size = len(inputY)
	}
	if len(output) < size {
		size = len(output)
	}
	one := hwy.Set[float32](float32(powOne_f32))
	zero := hwy.Set[float32](float32(powZero_f32))
	posInf := hwy.Set[float32](float32(stdmath.Inf(1)))
	lanes := one.NumLanes()
	logIn := make([]float32, lanes)
	logOut := make([]float32, lanes)
	expIn := make([]float32, lanes)
	expOut := make([]float32, lanes)
	for ii := 0; ii < size; ii += lanes {
		x := hwy.Load(inputX[ii:])
		y := hwy.Load(inputY[ii:])
		hwy.Store(x, logIn)
		BaseLogPoly_fallback(logIn, logOut)
		logX := hwy.Load(logOut)
		yLogX := hwy.Mul(y, logX)
		hwy.Store(yLogX, expIn)
		BaseExpPoly_fallback(expIn, expOut)
		result := hwy.Load(expOut)
		xZeroMask := hwy.Equal(x, zero)
		xOneMask := hwy.Equal(x, one)
		xInfMask := hwy.IsInf(x, 0)
		yZeroMask := hwy.Equal(y, zero)
		yPosMask := hwy.Greater(y, zero)
		yNegMask := hwy.Less(y, zero)
		result = hwy.Merge(one, result, yZeroMask)
		result = hwy.Merge(zero, result, hwy.MaskAnd(xZeroMask, yPosMask))
		result = hwy.Merge(posInf, result, hwy.MaskAnd(xZeroMask, yNegMask))
		result = hwy.Merge(one, result, xOneMask)
		result = hwy.Merge(posInf, result, hwy.MaskAnd(xInfMask, yPosMask))
		result = hwy.Merge(zero, result, hwy.MaskAnd(xInfMask, yNegMask))
		hwy.Store(result, output[ii:])
	}
}

func BasePowPoly_fallback_Float64(inputX []float64, inputY []float64, output []float64) {
	size := len(inputX)
	if len(inputY) < size {
		size = len(inputY)
	}
	if len(output) < size {
		size = len(output)
	}
	one := hwy.Set[float64](float64(powOne_f64))
	zero := hwy.Set[float64](float64(powZero_f64))
	posInf := hwy.Set[float64](float64(stdmath.Inf(1)))
	lanes := one.NumLanes()
	logIn := make([]float64, lanes)
	logOut := make([]float64, lanes)
	expIn := make([]float64, lanes)
	expOut := make([]float64, lanes)
	for ii := 0; ii < size; ii += lanes {
		x := hwy.Load(inputX[ii:])
		y := hwy.Load(inputY[ii:])
		hwy.Store(x, logIn)
		BaseLogPoly_fallback_Float64(logIn, logOut)
		logX := hwy.Load(logOut)
		yLogX := hwy.Mul(y, logX)
		hwy.Store(yLogX, expIn)
		BaseExpPoly_fallback_Float64(expIn, expOut)
		result := hwy.Load(expOut)
		xZeroMask := hwy.Equal(x, zero)
		xOneMask := hwy.Equal(x, one)
		xInfMask := hwy.IsInf(x, 0)
		yZeroMask := hwy.Equal(y, zero)
		yPosMask := hwy.Greater(y, zero)
		yNegMask := hwy.Less(y, zero)
		result = hwy.Merge(one, result, yZeroMask)
		result = hwy.Merge(zero, result, hwy.MaskAnd(xZeroMask, yPosMask))
		result = hwy.Merge(posInf, result, hwy.MaskAnd(xZeroMask, yNegMask))
		result = hwy.Merge(one, result, xOneMask)
		result = hwy.Merge(posInf, result, hwy.MaskAnd(xInfMask, yPosMask))
		result = hwy.Merge(zero, result, hwy.MaskAnd(xInfMask, yNegMask))
		hwy.Store(result, output[ii:])
	}
}

func BaseExp2Poly_fallback(input []float32, output []float32) {
	size := len(input)
	if len(output) < size {
		size = len(output)
	}
	ln2_f32 := hwy.Set[float32](float32(ln2_f32))
	lanes := ln2_f32.NumLanes()
	expIn := make([]float32, lanes)
	for ii := 0; ii < size; ii += lanes {
		x := hwy.Load(input[ii:])
		xLn2 := hwy.Mul(x, ln2_f32)
		hwy.Store(xLn2, expIn)
		BaseExpPoly_fallback(expIn, output[ii:ii+lanes])
	}
}

func BaseExp2Poly_fallback_Float64(input []float64, output []float64) {
	size := len(input)
	if len(output) < size {
		size = len(output)
	}
	ln2_f64 := hwy.Set[float64](float64(ln2_f64))
	lanes := ln2_f64.NumLanes()
	expIn := make([]float64, lanes)
	for ii := 0; ii < size; ii += lanes {
		x := hwy.Load(input[ii:])
		xLn2 := hwy.Mul(x, ln2_f64)
		hwy.Store(xLn2, expIn)
		BaseExpPoly_fallback_Float64(expIn, output[ii:ii+lanes])
	}
}

func BaseExp10Poly_fallback(input []float32, output []float32) {
	size := len(input)
	if len(output) < size {
		size = len(output)
	}
	ln10_f32 := hwy.Set[float32](float32(ln10_f32))
	lanes := ln10_f32.NumLanes()
	expIn := make([]float32, lanes)
	for ii := 0; ii < size; ii += lanes {
		x := hwy.Load(input[ii:])
		xLn10 := hwy.Mul(x, ln10_f32)
		hwy.Store(xLn10, expIn)
		BaseExpPoly_fallback(expIn, output[ii:ii+lanes])
	}
}

func BaseExp10Poly_fallback_Float64(input []float64, output []float64) {
	size := len(input)
	if len(output) < size {
		size = len(output)
	}
	ln10_f64 := hwy.Set[float64](float64(ln10_f64))
	lanes := ln10_f64.NumLanes()
	expIn := make([]float64, lanes)
	for ii := 0; ii < size; ii += lanes {
		x := hwy.Load(input[ii:])
		xLn10 := hwy.Mul(x, ln10_f64)
		hwy.Store(xLn10, expIn)
		BaseExpPoly_fallback_Float64(expIn, output[ii:ii+lanes])
	}
}

func BaseAsinhPoly_fallback(input []float32, output []float32) {
	size := len(input)
	if len(output) < size {
		size = len(output)
	}
	one := hwy.Set[float32](float32(1.0))
	lanes := one.NumLanes()
	logIn := make([]float32, lanes)
	logOut := make([]float32, lanes)
	for ii := 0; ii < size; ii += lanes {
		x := hwy.Load(input[ii:])
		x2 := hwy.Mul(x, x)
		x2Plus1 := hwy.Add(x2, one)
		sqrtPart := hwy.Sqrt(x2Plus1)
		arg := hwy.Add(x, sqrtPart)
		hwy.Store(arg, logIn)
		BaseLogPoly_fallback(logIn, logOut)
		result := hwy.Load(logOut)
		hwy.Store(result, output[ii:])
	}
}

func BaseAsinhPoly_fallback_Float64(input []float64, output []float64) {
	size := len(input)
	if len(output) < size {
		size = len(output)
	}
	one := hwy.Set[float64](float64(1.0))
	lanes := one.NumLanes()
	logIn := make([]float64, lanes)
	logOut := make([]float64, lanes)
	for ii := 0; ii < size; ii += lanes {
		x := hwy.Load(input[ii:])
		x2 := hwy.Mul(x, x)
		x2Plus1 := hwy.Add(x2, one)
		sqrtPart := hwy.Sqrt(x2Plus1)
		arg := hwy.Add(x, sqrtPart)
		hwy.Store(arg, logIn)
		BaseLogPoly_fallback_Float64(logIn, logOut)
		result := hwy.Load(logOut)
		hwy.Store(result, output[ii:])
	}
}

func BaseAcoshPoly_fallback(input []float32, output []float32) {
	size := len(input)
	if len(output) < size {
		size = len(output)
	}
	one := hwy.Set[float32](float32(1.0))
	zero := hwy.Set[float32](float32(0.0))
	lanes := one.NumLanes()
	logIn := make([]float32, lanes)
	logOut := make([]float32, lanes)
	for ii := 0; ii < size; ii += lanes {
		x := hwy.Load(input[ii:])
		x2 := hwy.Mul(x, x)
		x2Minus1 := hwy.Sub(x2, one)
		sqrtPart := hwy.Sqrt(x2Minus1)
		arg := hwy.Add(x, sqrtPart)
		hwy.Store(arg, logIn)
		BaseLogPoly_fallback(logIn, logOut)
		result := hwy.Load(logOut)
		oneMask := hwy.Equal(x, one)
		result = hwy.Merge(zero, result, oneMask)
		invalidMask := hwy.Less(x, one)
		nan := hwy.Div(zero, zero)
		result = hwy.Merge(nan, result, invalidMask)
		hwy.Store(result, output[ii:])
	}
}

func BaseAcoshPoly_fallback_Float64(input []float64, output []float64) {
	size := len(input)
	if len(output) < size {
		size = len(output)
	}
	one := hwy.Set[float64](float64(1.0))
	zero := hwy.Set[float64](float64(0.0))
	lanes := one.NumLanes()
	logIn := make([]float64, lanes)
	logOut := make([]float64, lanes)
	for ii := 0; ii < size; ii += lanes {
		x := hwy.Load(input[ii:])
		x2 := hwy.Mul(x, x)
		x2Minus1 := hwy.Sub(x2, one)
		sqrtPart := hwy.Sqrt(x2Minus1)
		arg := hwy.Add(x, sqrtPart)
		hwy.Store(arg, logIn)
		BaseLogPoly_fallback_Float64(logIn, logOut)
		result := hwy.Load(logOut)
		oneMask := hwy.Equal(x, one)
		result = hwy.Merge(zero, result, oneMask)
		invalidMask := hwy.Less(x, one)
		nan := hwy.Div(zero, zero)
		result = hwy.Merge(nan, result, invalidMask)
		hwy.Store(result, output[ii:])
	}
}

func BaseAtanhPoly_fallback(input []float32, output []float32) {
	size := len(input)
	if len(output) < size {
		size = len(output)
	}
	one := hwy.Set[float32](float32(1.0))
	half := hwy.Set[float32](float32(0.5))
	zero := hwy.Set[float32](float32(0.0))
	lanes := one.NumLanes()
	logIn := make([]float32, lanes)
	logOut := make([]float32, lanes)
	for ii := 0; ii < size; ii += lanes {
		x := hwy.Load(input[ii:])
		onePlusX := hwy.Add(one, x)
		oneMinusX := hwy.Sub(one, x)
		ratio := hwy.Div(onePlusX, oneMinusX)
		hwy.Store(ratio, logIn)
		BaseLogPoly_fallback(logIn, logOut)
		logRatio := hwy.Load(logOut)
		result := hwy.Mul(half, logRatio)
		zeroMask := hwy.Equal(x, zero)
		result = hwy.Merge(zero, result, zeroMask)
		inf := hwy.Div(one, zero)
		negInf := hwy.Neg(inf)
		oneMask := hwy.Equal(x, one)
		negOneMask := hwy.Equal(x, hwy.Neg(one))
		result = hwy.Merge(inf, result, oneMask)
		result = hwy.Merge(negInf, result, negOneMask)
		hwy.Store(result, output[ii:])
	}
}

func BaseAtanhPoly_fallback_Float64(input []float64, output []float64) {
	size := len(input)
	if len(output) < size {
		size = len(output)
	}
	one := hwy.Set[float64](float64(1.0))
	half := hwy.Set[float64](float64(0.5))
	zero := hwy.Set[float64](float64(0.0))
	lanes := one.NumLanes()
	logIn := make([]float64, lanes)
	logOut := make([]float64, lanes)
	for ii := 0; ii < size; ii += lanes {
		x := hwy.Load(input[ii:])
		onePlusX := hwy.Add(one, x)
		oneMinusX := hwy.Sub(one, x)
		ratio := hwy.Div(onePlusX, oneMinusX)
		hwy.Store(ratio, logIn)
		BaseLogPoly_fallback_Float64(logIn, logOut)
		logRatio := hwy.Load(logOut)
		result := hwy.Mul(half, logRatio)
		zeroMask := hwy.Equal(x, zero)
		result = hwy.Merge(zero, result, zeroMask)
		inf := hwy.Div(one, zero)
		negInf := hwy.Neg(inf)
		oneMask := hwy.Equal(x, one)
		negOneMask := hwy.Equal(x, hwy.Neg(one))
		result = hwy.Merge(inf, result, oneMask)
		result = hwy.Merge(negInf, result, negOneMask)
		hwy.Store(result, output[ii:])
	}
}

func BaseCbrtPoly_fallback(input []float32, output []float32) {
	size := len(input)
	if len(output) < size {
		size = len(output)
	}
	zero := hwy.Set[float32](float32(0.0))
	third := hwy.Set[float32](float32(1.0 / 3.0))
	posInf := hwy.Set[float32](float32(stdmath.Inf(1)))
	negInf := hwy.Set[float32](float32(stdmath.Inf(-1)))
	nan := hwy.Set[float32](float32(stdmath.NaN()))
	lanes := zero.NumLanes()
	logIn := make([]float32, lanes)
	logOut := make([]float32, lanes)
	expIn := make([]float32, lanes)
	expOut := make([]float32, lanes)
	for ii := 0; ii < size; ii += lanes {
		x := hwy.Load(input[ii:])
		posInfMask := hwy.Equal(x, posInf)
		negInfMask := hwy.Equal(x, negInf)
		nanMask := hwy.IsNaN(x)
		signMask := hwy.Less(x, zero)
		absX := hwy.Abs(x)
		hwy.Store(absX, logIn)
		BaseLogPoly_fallback(logIn, logOut)
		logAbsX := hwy.Load(logOut)
		logAbsXOver3 := hwy.Mul(logAbsX, third)
		hwy.Store(logAbsXOver3, expIn)
		BaseExpPoly_fallback(expIn, expOut)
		cbrtAbsX := hwy.Load(expOut)
		negCbrt := hwy.Neg(cbrtAbsX)
		result := hwy.Merge(negCbrt, cbrtAbsX, signMask)
		zeroMask := hwy.Equal(x, zero)
		result = hwy.Merge(zero, result, zeroMask)
		result = hwy.Merge(posInf, result, posInfMask)
		result = hwy.Merge(negInf, result, negInfMask)
		result = hwy.Merge(nan, result, nanMask)
		hwy.Store(result, output[ii:])
	}
}

func BaseCbrtPoly_fallback_Float64(input []float64, output []float64) {
	size := len(input)
	if len(output) < size {
		size = len(output)
	}
	zero := hwy.Set[float64](float64(0.0))
	third := hwy.Set[float64](float64(1.0 / 3.0))
	posInf := hwy.Set[float64](float64(stdmath.Inf(1)))
	negInf := hwy.Set[float64](float64(stdmath.Inf(-1)))
	nan := hwy.Set[float64](float64(stdmath.NaN()))
	lanes := zero.NumLanes()
	logIn := make([]float64, lanes)
	logOut := make([]float64, lanes)
	expIn := make([]float64, lanes)
	expOut := make([]float64, lanes)
	for ii := 0; ii < size; ii += lanes {
		x := hwy.Load(input[ii:])
		posInfMask := hwy.Equal(x, posInf)
		negInfMask := hwy.Equal(x, negInf)
		nanMask := hwy.IsNaN(x)
		signMask := hwy.Less(x, zero)
		absX := hwy.Abs(x)
		hwy.Store(absX, logIn)
		BaseLogPoly_fallback_Float64(logIn, logOut)
		logAbsX := hwy.Load(logOut)
		logAbsXOver3 := hwy.Mul(logAbsX, third)
		hwy.Store(logAbsXOver3, expIn)
		BaseExpPoly_fallback_Float64(expIn, expOut)
		cbrtAbsX := hwy.Load(expOut)
		negCbrt := hwy.Neg(cbrtAbsX)
		result := hwy.Merge(negCbrt, cbrtAbsX, signMask)
		zeroMask := hwy.Equal(x, zero)
		result = hwy.Merge(zero, result, zeroMask)
		result = hwy.Merge(posInf, result, posInfMask)
		result = hwy.Merge(negInf, result, negInfMask)
		result = hwy.Merge(nan, result, nanMask)
		hwy.Store(result, output[ii:])
	}
}

func BaseHypotPoly_fallback(inputX []float32, inputY []float32, output []float32) {
	size := len(inputX)
	if len(inputY) < size {
		size = len(inputY)
	}
	if len(output) < size {
		size = len(output)
	}
	one := hwy.Set[float32](float32(1.0))
	zero := hwy.Set[float32](float32(0.0))
	posInf := hwy.Set[float32](float32(stdmath.Inf(1)))
	nan := hwy.Set[float32](float32(stdmath.NaN()))
	lanes := one.NumLanes()
	for ii := 0; ii < size; ii += lanes {
		x := hwy.Load(inputX[ii:])
		y := hwy.Load(inputY[ii:])
		xIsInf := hwy.IsInf(x, 0)
		yIsInf := hwy.IsInf(y, 0)
		xIsNaN := hwy.IsNaN(x)
		yIsNaN := hwy.IsNaN(y)
		eitherInf := hwy.MaskOr(xIsInf, yIsInf)
		eitherNaN := hwy.MaskOr(xIsNaN, yIsNaN)
		absX := hwy.Abs(x)
		absY := hwy.Abs(y)
		maxXY := hwy.Max(absX, absY)
		minXY := hwy.Min(absX, absY)
		ratio := hwy.Div(minXY, maxXY)
		ratio2 := hwy.Mul(ratio, ratio)
		sqrtArg := hwy.Add(one, ratio2)
		sqrtPart := hwy.Sqrt(sqrtArg)
		result := hwy.Mul(maxXY, sqrtPart)
		zeroMask := hwy.Equal(maxXY, zero)
		result = hwy.Merge(zero, result, zeroMask)
		result = hwy.Merge(nan, result, eitherNaN)
		result = hwy.Merge(posInf, result, eitherInf)
		hwy.Store(result, output[ii:])
	}
}

func BaseHypotPoly_fallback_Float64(inputX []float64, inputY []float64, output []float64) {
	size := len(inputX)
	if len(inputY) < size {
		size = len(inputY)
	}
	if len(output) < size {
		size = len(output)
	}
	one := hwy.Set[float64](float64(1.0))
	zero := hwy.Set[float64](float64(0.0))
	posInf := hwy.Set[float64](float64(stdmath.Inf(1)))
	nan := hwy.Set[float64](float64(stdmath.NaN()))
	lanes := one.NumLanes()
	for ii := 0; ii < size; ii += lanes {
		x := hwy.Load(inputX[ii:])
		y := hwy.Load(inputY[ii:])
		xIsInf := hwy.IsInf(x, 0)
		yIsInf := hwy.IsInf(y, 0)
		xIsNaN := hwy.IsNaN(x)
		yIsNaN := hwy.IsNaN(y)
		eitherInf := hwy.MaskOr(xIsInf, yIsInf)
		eitherNaN := hwy.MaskOr(xIsNaN, yIsNaN)
		absX := hwy.Abs(x)
		absY := hwy.Abs(y)
		maxXY := hwy.Max(absX, absY)
		minXY := hwy.Min(absX, absY)
		ratio := hwy.Div(minXY, maxXY)
		ratio2 := hwy.Mul(ratio, ratio)
		sqrtArg := hwy.Add(one, ratio2)
		sqrtPart := hwy.Sqrt(sqrtArg)
		result := hwy.Mul(maxXY, sqrtPart)
		zeroMask := hwy.Equal(maxXY, zero)
		result = hwy.Merge(zero, result, zeroMask)
		result = hwy.Merge(nan, result, eitherNaN)
		result = hwy.Merge(posInf, result, eitherInf)
		hwy.Store(result, output[ii:])
	}
}
