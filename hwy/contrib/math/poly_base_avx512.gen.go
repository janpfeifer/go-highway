// Code generated by hwygen. DO NOT EDIT.
//go:build amd64 && goexperiment.simd

package math

import (
	"simd/archsimd"
)

func BasePoly2_avx512(x []float32, c0 float32, c1 float32, c2 float32, result []float32) {
	size := len(x)
	if len(result) < size {
		size = len(result)
	}
	vc0 := archsimd.BroadcastFloat32x16(c0)
	vc1 := archsimd.BroadcastFloat32x16(c1)
	vc2 := archsimd.BroadcastFloat32x16(c2)
	lanes := 16
	ii := 0
	for ; ii+16 <= size; ii += lanes {
		vx := archsimd.LoadFloat32x16Slice(x[ii:])
		p := vc2.MulAdd(vx, vc1)
		p = p.MulAdd(vx, vc0)
		p.StoreSlice(result[ii:])
	}
	if ii < size {
		BasePoly2_fallback(x[ii:size], c0, c1, c2, result[ii:size])
	}
}

func BasePoly2_avx512_Float64(x []float64, c0 float64, c1 float64, c2 float64, result []float64) {
	size := len(x)
	if len(result) < size {
		size = len(result)
	}
	vc0 := archsimd.BroadcastFloat64x8(c0)
	vc1 := archsimd.BroadcastFloat64x8(c1)
	vc2 := archsimd.BroadcastFloat64x8(c2)
	lanes := 8
	ii := 0
	for ; ii+8 <= size; ii += lanes {
		vx := archsimd.LoadFloat64x8Slice(x[ii:])
		p := vc2.MulAdd(vx, vc1)
		p = p.MulAdd(vx, vc0)
		p.StoreSlice(result[ii:])
	}
	if ii < size {
		BasePoly2_fallback_Float64(x[ii:size], c0, c1, c2, result[ii:size])
	}
}

func BaseClamp_avx512(input []float32, minVal float32, maxVal float32, output []float32) {
	size := len(input)
	if len(output) < size {
		size = len(output)
	}
	vmin := archsimd.BroadcastFloat32x16(minVal)
	vmax := archsimd.BroadcastFloat32x16(maxVal)
	lanes := 16
	ii := 0
	for ; ii+16 <= size; ii += lanes {
		vx := archsimd.LoadFloat32x16Slice(input[ii:])
		clamped := vx.Min(vmax).Max(vmin)
		clamped.StoreSlice(output[ii:])
	}
	if ii < size {
		BaseClamp_fallback(input[ii:size], minVal, maxVal, output[ii:size])
	}
}

func BaseClamp_avx512_Float64(input []float64, minVal float64, maxVal float64, output []float64) {
	size := len(input)
	if len(output) < size {
		size = len(output)
	}
	vmin := archsimd.BroadcastFloat64x8(minVal)
	vmax := archsimd.BroadcastFloat64x8(maxVal)
	lanes := 8
	ii := 0
	for ; ii+8 <= size; ii += lanes {
		vx := archsimd.LoadFloat64x8Slice(input[ii:])
		clamped := vx.Min(vmax).Max(vmin)
		clamped.StoreSlice(output[ii:])
	}
	if ii < size {
		BaseClamp_fallback_Float64(input[ii:size], minVal, maxVal, output[ii:size])
	}
}
