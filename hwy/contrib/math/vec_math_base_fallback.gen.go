// Code generated by hwygen. DO NOT EDIT.

package math

import (
	"github.com/ajroetker/go-highway/hwy"
)

func BaseExpVec_fallback(x hwy.Vec[float32]) hwy.Vec[float32] {
	overflow := hwy.Set[float32](float32(expOverflow_f32))
	underflow := hwy.Set[float32](float32(expUnderflow_f32))
	one := hwy.Set[float32](float32(expOne_f32))
	zero := hwy.Set[float32](float32(expZero_f32))
	inf := hwy.Set[float32](float32(expOverflow_f32 * 2))
	invLn2 := hwy.Set[float32](float32(expInvLn2_f32))
	ln2Hi := hwy.Set[float32](float32(expLn2Hi_f32))
	ln2Lo := hwy.Set[float32](float32(expLn2Lo_f32))
	c1 := hwy.Set[float32](float32(expC1_f32))
	c2 := hwy.Set[float32](float32(expC2_f32))
	c3 := hwy.Set[float32](float32(expC3_f32))
	c4 := hwy.Set[float32](float32(expC4_f32))
	c5 := hwy.Set[float32](float32(expC5_f32))
	c6 := hwy.Set[float32](float32(expC6_f32))
	overflowMask := hwy.Greater(x, overflow)
	underflowMask := hwy.Less(x, underflow)
	kFloat := hwy.RoundToEven(hwy.Mul(x, invLn2))
	r := hwy.Sub(x, hwy.Mul(kFloat, ln2Hi))
	r = hwy.Sub(r, hwy.Mul(kFloat, ln2Lo))
	p := hwy.MulAdd(c6, r, c5)
	p = hwy.MulAdd(p, r, c4)
	p = hwy.MulAdd(p, r, c3)
	p = hwy.MulAdd(p, r, c2)
	p = hwy.MulAdd(p, r, c1)
	p = hwy.MulAdd(p, r, one)
	kInt := hwy.ConvertToInt32(kFloat)
	scale := hwy.Pow2[float32](kInt)
	result := hwy.Mul(p, scale)
	result = hwy.Merge(inf, result, overflowMask)
	result = hwy.Merge(zero, result, underflowMask)
	return result
}

func BaseExpVec_fallback_Float64(x hwy.Vec[float64]) hwy.Vec[float64] {
	overflow := hwy.Set[float64](float64(expOverflow_f64))
	underflow := hwy.Set[float64](float64(expUnderflow_f64))
	one := hwy.Set[float64](float64(expOne_f64))
	zero := hwy.Set[float64](float64(expZero_f64))
	inf := hwy.Set[float64](float64(expOverflow_f64 * 2))
	invLn2 := hwy.Set[float64](float64(expInvLn2_f64))
	ln2Hi := hwy.Set[float64](float64(expLn2Hi_f64))
	ln2Lo := hwy.Set[float64](float64(expLn2Lo_f64))
	c1 := hwy.Set[float64](float64(expC1_f64))
	c2 := hwy.Set[float64](float64(expC2_f64))
	c3 := hwy.Set[float64](float64(expC3_f64))
	c4 := hwy.Set[float64](float64(expC4_f64))
	c5 := hwy.Set[float64](float64(expC5_f64))
	c6 := hwy.Set[float64](float64(expC6_f64))
	overflowMask := hwy.Greater(x, overflow)
	underflowMask := hwy.Less(x, underflow)
	kFloat := hwy.RoundToEven(hwy.Mul(x, invLn2))
	r := hwy.Sub(x, hwy.Mul(kFloat, ln2Hi))
	r = hwy.Sub(r, hwy.Mul(kFloat, ln2Lo))
	p := hwy.MulAdd(c6, r, c5)
	p = hwy.MulAdd(p, r, c4)
	p = hwy.MulAdd(p, r, c3)
	p = hwy.MulAdd(p, r, c2)
	p = hwy.MulAdd(p, r, c1)
	p = hwy.MulAdd(p, r, one)
	kInt := hwy.ConvertToInt32(kFloat)
	scale := hwy.Pow2[float64](kInt)
	result := hwy.Mul(p, scale)
	result = hwy.Merge(inf, result, overflowMask)
	result = hwy.Merge(zero, result, underflowMask)
	return result
}

func BaseSigmoidVec_fallback(x hwy.Vec[float32]) hwy.Vec[float32] {
	one := hwy.Set[float32](float32(sigmoidOne_f32))
	zero := hwy.Set[float32](float32(0.0))
	satHi := hwy.Set[float32](float32(20.0))
	satLo := hwy.Set[float32](float32(-20.0))
	clampedX := hwy.Max(hwy.Min(x, satHi), satLo)
	negX := hwy.Neg(clampedX)
	expNegX := BaseExpVec_fallback(negX)
	result := hwy.Div(one, hwy.Add(one, expNegX))
	result = hwy.Merge(one, result, hwy.Greater(x, satHi))
	result = hwy.Merge(zero, result, hwy.Less(x, satLo))
	return result
}

func BaseSigmoidVec_fallback_Float64(x hwy.Vec[float64]) hwy.Vec[float64] {
	one := hwy.Set[float64](float64(sigmoidOne_f64))
	zero := hwy.Set[float64](float64(0.0))
	satHi := hwy.Set[float64](float64(20.0))
	satLo := hwy.Set[float64](float64(-20.0))
	clampedX := hwy.Max(hwy.Min(x, satHi), satLo)
	negX := hwy.Neg(clampedX)
	expNegX := BaseExpVec_fallback_Float64(negX)
	result := hwy.Div(one, hwy.Add(one, expNegX))
	result = hwy.Merge(one, result, hwy.Greater(x, satHi))
	result = hwy.Merge(zero, result, hwy.Less(x, satLo))
	return result
}

func BaseTanhVec_fallback(x hwy.Vec[float32]) hwy.Vec[float32] {
	two := hwy.Set[float32](float32(2.0))
	one := hwy.Set[float32](float32(tanhOne_f32))
	negOne := hwy.Set[float32](float32(tanhNegOne_f32))
	threshold := hwy.Set[float32](float32(tanhClamp_f32))
	negThreshold := hwy.Neg(threshold)
	twoX := hwy.Mul(two, x)
	sigTwoX := BaseSigmoidVec_fallback(twoX)
	result := hwy.Sub(hwy.Mul(two, sigTwoX), one)
	result = hwy.Merge(one, result, hwy.Greater(x, threshold))
	result = hwy.Merge(negOne, result, hwy.Less(x, negThreshold))
	return result
}

func BaseTanhVec_fallback_Float64(x hwy.Vec[float64]) hwy.Vec[float64] {
	two := hwy.Set[float64](float64(2.0))
	one := hwy.Set[float64](float64(tanhOne_f64))
	negOne := hwy.Set[float64](float64(tanhNegOne_f64))
	threshold := hwy.Set[float64](float64(tanhClamp_f64))
	negThreshold := hwy.Neg(threshold)
	twoX := hwy.Mul(two, x)
	sigTwoX := BaseSigmoidVec_fallback_Float64(twoX)
	result := hwy.Sub(hwy.Mul(two, sigTwoX), one)
	result = hwy.Merge(one, result, hwy.Greater(x, threshold))
	result = hwy.Merge(negOne, result, hwy.Less(x, negThreshold))
	return result
}

func BaseLogVec_fallback(x hwy.Vec[float32]) hwy.Vec[float32] {
	one := hwy.Set[float32](float32(logOne_f32))
	two := hwy.Set[float32](float32(logTwo_f32))
	zero := hwy.Set[float32](float32(0.0))
	ln2Hi := hwy.Set[float32](float32(logLn2Hi_f32))
	ln2Lo := hwy.Set[float32](float32(logLn2Lo_f32))
	negInf := hwy.Set[float32](float32(-1e38))
	nan := hwy.Set[float32](float32(0.0))
	c1 := hwy.Set[float32](float32(logC1_f32))
	c2 := hwy.Set[float32](float32(logC2_f32))
	c3 := hwy.Set[float32](float32(logC3_f32))
	c4 := hwy.Set[float32](float32(logC4_f32))
	c5 := hwy.Set[float32](float32(logC5_f32))
	zeroMask := hwy.Equal(x, zero)
	negMask := hwy.Less(x, zero)
	oneMask := hwy.Equal(x, one)
	e := hwy.GetExponent(x)
	m := hwy.GetMantissa(x)
	mLarge := hwy.Greater(m, hwy.Set[float32](float32(1.414)))
	mAdjusted := hwy.Merge(hwy.Mul(m, hwy.Set[float32](float32(0.5))), m, mLarge)
	eData := e.Data()
	eFloatData := make([]float32, len(eData))
	for i, v := range eData {
		eFloatData[i] = float32(v)
	}
	eFloat := hwy.Load(eFloatData)
	eAdjusted := hwy.Merge(hwy.Add(eFloat, one), eFloat, mLarge)
	mMinus1 := hwy.Sub(mAdjusted, one)
	mPlus1 := hwy.Add(mAdjusted, one)
	y := hwy.Div(mMinus1, mPlus1)
	y2 := hwy.Mul(y, y)
	poly := hwy.MulAdd(c5, y2, c4)
	poly = hwy.MulAdd(poly, y2, c3)
	poly = hwy.MulAdd(poly, y2, c2)
	poly = hwy.MulAdd(poly, y2, c1)
	logM := hwy.Mul(hwy.Mul(two, y), poly)
	result := hwy.Add(hwy.MulAdd(eAdjusted, ln2Hi, logM), hwy.Mul(eAdjusted, ln2Lo))
	result = hwy.Merge(negInf, result, zeroMask)
	result = hwy.Merge(nan, result, negMask)
	result = hwy.Merge(zero, result, oneMask)
	return result
}

func BaseLogVec_fallback_Float64(x hwy.Vec[float64]) hwy.Vec[float64] {
	one := hwy.Set[float64](float64(logOne_f64))
	two := hwy.Set[float64](float64(logTwo_f64))
	zero := hwy.Set[float64](float64(0.0))
	ln2Hi := hwy.Set[float64](float64(logLn2Hi_f64))
	ln2Lo := hwy.Set[float64](float64(logLn2Lo_f64))
	negInf := hwy.Set[float64](float64(-1e38))
	nan := hwy.Set[float64](float64(0.0))
	c1 := hwy.Set[float64](float64(logC1_f64))
	c2 := hwy.Set[float64](float64(logC2_f64))
	c3 := hwy.Set[float64](float64(logC3_f64))
	c4 := hwy.Set[float64](float64(logC4_f64))
	c5 := hwy.Set[float64](float64(logC5_f64))
	zeroMask := hwy.Equal(x, zero)
	negMask := hwy.Less(x, zero)
	oneMask := hwy.Equal(x, one)
	e := hwy.GetExponent(x)
	m := hwy.GetMantissa(x)
	mLarge := hwy.Greater(m, hwy.Set[float64](float64(1.414)))
	mAdjusted := hwy.Merge(hwy.Mul(m, hwy.Set[float64](float64(0.5))), m, mLarge)
	eData := e.Data()
	eFloatData := make([]float64, len(eData))
	for i, v := range eData {
		eFloatData[i] = float64(v)
	}
	eFloat := hwy.Load(eFloatData)
	eAdjusted := hwy.Merge(hwy.Add(eFloat, one), eFloat, mLarge)
	mMinus1 := hwy.Sub(mAdjusted, one)
	mPlus1 := hwy.Add(mAdjusted, one)
	y := hwy.Div(mMinus1, mPlus1)
	y2 := hwy.Mul(y, y)
	poly := hwy.MulAdd(c5, y2, c4)
	poly = hwy.MulAdd(poly, y2, c3)
	poly = hwy.MulAdd(poly, y2, c2)
	poly = hwy.MulAdd(poly, y2, c1)
	logM := hwy.Mul(hwy.Mul(two, y), poly)
	result := hwy.Add(hwy.MulAdd(eAdjusted, ln2Hi, logM), hwy.Mul(eAdjusted, ln2Lo))
	result = hwy.Merge(negInf, result, zeroMask)
	result = hwy.Merge(nan, result, negMask)
	result = hwy.Merge(zero, result, oneMask)
	return result
}

func BaseSinVec_fallback(x hwy.Vec[float32]) hwy.Vec[float32] {
	twoOverPi := hwy.Set[float32](float32(trig2OverPi_f32))
	piOver2Hi := hwy.Set[float32](float32(trigPiOver2Hi_f32))
	piOver2Lo := hwy.Set[float32](float32(trigPiOver2Lo_f32))
	one := hwy.Set[float32](float32(trigOne_f32))
	s1 := hwy.Set[float32](float32(trigS1_f32))
	s2 := hwy.Set[float32](float32(trigS2_f32))
	s3 := hwy.Set[float32](float32(trigS3_f32))
	s4 := hwy.Set[float32](float32(trigS4_f32))
	c1 := hwy.Set[float32](float32(trigC1_f32))
	c2 := hwy.Set[float32](float32(trigC2_f32))
	c3 := hwy.Set[float32](float32(trigC3_f32))
	c4 := hwy.Set[float32](float32(trigC4_f32))
	intOne := hwy.Set[int32](1)
	intTwo := hwy.Set[int32](2)
	intThree := hwy.Set[int32](3)
	kFloat := hwy.RoundToEven(hwy.Mul(x, twoOverPi))
	kInt := hwy.ConvertToInt32(kFloat)
	r := hwy.Sub(x, hwy.Mul(kFloat, piOver2Hi))
	r = hwy.Sub(r, hwy.Mul(kFloat, piOver2Lo))
	r2 := hwy.Mul(r, r)
	sinPoly := hwy.MulAdd(s4, r2, s3)
	sinPoly = hwy.MulAdd(sinPoly, r2, s2)
	sinPoly = hwy.MulAdd(sinPoly, r2, s1)
	sinPoly = hwy.MulAdd(sinPoly, r2, one)
	sinR := hwy.Mul(r, sinPoly)
	cosPoly := hwy.MulAdd(c4, r2, c3)
	cosPoly = hwy.MulAdd(cosPoly, r2, c2)
	cosPoly = hwy.MulAdd(cosPoly, r2, c1)
	cosR := hwy.MulAdd(cosPoly, r2, one)
	octant := hwy.And(kInt, intThree)
	useCosMask := hwy.Equal(hwy.And(octant, intOne), intOne)
	negateMask := hwy.Equal(hwy.And(octant, intTwo), intTwo)
	sinRData := sinR.Data()
	cosRData := cosR.Data()
	resultData := make([]float32, len(sinRData))
	for i := range sinRData {
		if useCosMask.GetBit(i) {
			resultData[i] = cosRData[i]
		} else {
			resultData[i] = sinRData[i]
		}
	}
	result := hwy.Load(resultData)
	negResult := hwy.Neg(result)
	negResultData := negResult.Data()
	for i := range resultData {
		if negateMask.GetBit(i) {
			resultData[i] = negResultData[i]
		}
	}
	return hwy.Load(resultData)
}

func BaseSinVec_fallback_Float64(x hwy.Vec[float64]) hwy.Vec[float64] {
	twoOverPi := hwy.Set[float64](float64(trig2OverPi_f64))
	piOver2Hi := hwy.Set[float64](float64(trigPiOver2Hi_f64))
	piOver2Lo := hwy.Set[float64](float64(trigPiOver2Lo_f64))
	one := hwy.Set[float64](float64(trigOne_f64))
	s1 := hwy.Set[float64](float64(trigS1_f64))
	s2 := hwy.Set[float64](float64(trigS2_f64))
	s3 := hwy.Set[float64](float64(trigS3_f64))
	s4 := hwy.Set[float64](float64(trigS4_f64))
	c1 := hwy.Set[float64](float64(trigC1_f64))
	c2 := hwy.Set[float64](float64(trigC2_f64))
	c3 := hwy.Set[float64](float64(trigC3_f64))
	c4 := hwy.Set[float64](float64(trigC4_f64))
	intOne := hwy.Set[int32](1)
	intTwo := hwy.Set[int32](2)
	intThree := hwy.Set[int32](3)
	kFloat := hwy.RoundToEven(hwy.Mul(x, twoOverPi))
	kInt := hwy.ConvertToInt32(kFloat)
	r := hwy.Sub(x, hwy.Mul(kFloat, piOver2Hi))
	r = hwy.Sub(r, hwy.Mul(kFloat, piOver2Lo))
	r2 := hwy.Mul(r, r)
	sinPoly := hwy.MulAdd(s4, r2, s3)
	sinPoly = hwy.MulAdd(sinPoly, r2, s2)
	sinPoly = hwy.MulAdd(sinPoly, r2, s1)
	sinPoly = hwy.MulAdd(sinPoly, r2, one)
	sinR := hwy.Mul(r, sinPoly)
	cosPoly := hwy.MulAdd(c4, r2, c3)
	cosPoly = hwy.MulAdd(cosPoly, r2, c2)
	cosPoly = hwy.MulAdd(cosPoly, r2, c1)
	cosR := hwy.MulAdd(cosPoly, r2, one)
	octant := hwy.And(kInt, intThree)
	useCosMask := hwy.Equal(hwy.And(octant, intOne), intOne)
	negateMask := hwy.Equal(hwy.And(octant, intTwo), intTwo)
	sinRData := sinR.Data()
	cosRData := cosR.Data()
	resultData := make([]float64, len(sinRData))
	for i := range sinRData {
		if useCosMask.GetBit(i) {
			resultData[i] = cosRData[i]
		} else {
			resultData[i] = sinRData[i]
		}
	}
	result := hwy.Load(resultData)
	negResult := hwy.Neg(result)
	negResultData := negResult.Data()
	for i := range resultData {
		if negateMask.GetBit(i) {
			resultData[i] = negResultData[i]
		}
	}
	return hwy.Load(resultData)
}

func BaseCosVec_fallback(x hwy.Vec[float32]) hwy.Vec[float32] {
	twoOverPi := hwy.Set[float32](float32(trig2OverPi_f32))
	piOver2Hi := hwy.Set[float32](float32(trigPiOver2Hi_f32))
	piOver2Lo := hwy.Set[float32](float32(trigPiOver2Lo_f32))
	one := hwy.Set[float32](float32(trigOne_f32))
	s1 := hwy.Set[float32](float32(trigS1_f32))
	s2 := hwy.Set[float32](float32(trigS2_f32))
	s3 := hwy.Set[float32](float32(trigS3_f32))
	s4 := hwy.Set[float32](float32(trigS4_f32))
	c1 := hwy.Set[float32](float32(trigC1_f32))
	c2 := hwy.Set[float32](float32(trigC2_f32))
	c3 := hwy.Set[float32](float32(trigC3_f32))
	c4 := hwy.Set[float32](float32(trigC4_f32))
	intOne := hwy.Set[int32](1)
	intTwo := hwy.Set[int32](2)
	intThree := hwy.Set[int32](3)
	kFloat := hwy.RoundToEven(hwy.Mul(x, twoOverPi))
	kInt := hwy.ConvertToInt32(kFloat)
	r := hwy.Sub(x, hwy.Mul(kFloat, piOver2Hi))
	r = hwy.Sub(r, hwy.Mul(kFloat, piOver2Lo))
	r2 := hwy.Mul(r, r)
	sinPoly := hwy.MulAdd(s4, r2, s3)
	sinPoly = hwy.MulAdd(sinPoly, r2, s2)
	sinPoly = hwy.MulAdd(sinPoly, r2, s1)
	sinPoly = hwy.MulAdd(sinPoly, r2, one)
	sinR := hwy.Mul(r, sinPoly)
	cosPoly := hwy.MulAdd(c4, r2, c3)
	cosPoly = hwy.MulAdd(cosPoly, r2, c2)
	cosPoly = hwy.MulAdd(cosPoly, r2, c1)
	cosR := hwy.MulAdd(cosPoly, r2, one)
	cosOctant := hwy.And(hwy.Add(kInt, intOne), intThree)
	useCosMask := hwy.Equal(hwy.And(cosOctant, intOne), intOne)
	negateMask := hwy.Equal(hwy.And(cosOctant, intTwo), intTwo)
	sinRData := sinR.Data()
	cosRData := cosR.Data()
	resultData := make([]float32, len(sinRData))
	for i := range sinRData {
		if useCosMask.GetBit(i) {
			resultData[i] = cosRData[i]
		} else {
			resultData[i] = sinRData[i]
		}
	}
	result := hwy.Load(resultData)
	negResult := hwy.Neg(result)
	negResultData := negResult.Data()
	for i := range resultData {
		if negateMask.GetBit(i) {
			resultData[i] = negResultData[i]
		}
	}
	return hwy.Load(resultData)
}

func BaseCosVec_fallback_Float64(x hwy.Vec[float64]) hwy.Vec[float64] {
	twoOverPi := hwy.Set[float64](float64(trig2OverPi_f64))
	piOver2Hi := hwy.Set[float64](float64(trigPiOver2Hi_f64))
	piOver2Lo := hwy.Set[float64](float64(trigPiOver2Lo_f64))
	one := hwy.Set[float64](float64(trigOne_f64))
	s1 := hwy.Set[float64](float64(trigS1_f64))
	s2 := hwy.Set[float64](float64(trigS2_f64))
	s3 := hwy.Set[float64](float64(trigS3_f64))
	s4 := hwy.Set[float64](float64(trigS4_f64))
	c1 := hwy.Set[float64](float64(trigC1_f64))
	c2 := hwy.Set[float64](float64(trigC2_f64))
	c3 := hwy.Set[float64](float64(trigC3_f64))
	c4 := hwy.Set[float64](float64(trigC4_f64))
	intOne := hwy.Set[int32](1)
	intTwo := hwy.Set[int32](2)
	intThree := hwy.Set[int32](3)
	kFloat := hwy.RoundToEven(hwy.Mul(x, twoOverPi))
	kInt := hwy.ConvertToInt32(kFloat)
	r := hwy.Sub(x, hwy.Mul(kFloat, piOver2Hi))
	r = hwy.Sub(r, hwy.Mul(kFloat, piOver2Lo))
	r2 := hwy.Mul(r, r)
	sinPoly := hwy.MulAdd(s4, r2, s3)
	sinPoly = hwy.MulAdd(sinPoly, r2, s2)
	sinPoly = hwy.MulAdd(sinPoly, r2, s1)
	sinPoly = hwy.MulAdd(sinPoly, r2, one)
	sinR := hwy.Mul(r, sinPoly)
	cosPoly := hwy.MulAdd(c4, r2, c3)
	cosPoly = hwy.MulAdd(cosPoly, r2, c2)
	cosPoly = hwy.MulAdd(cosPoly, r2, c1)
	cosR := hwy.MulAdd(cosPoly, r2, one)
	cosOctant := hwy.And(hwy.Add(kInt, intOne), intThree)
	useCosMask := hwy.Equal(hwy.And(cosOctant, intOne), intOne)
	negateMask := hwy.Equal(hwy.And(cosOctant, intTwo), intTwo)
	sinRData := sinR.Data()
	cosRData := cosR.Data()
	resultData := make([]float64, len(sinRData))
	for i := range sinRData {
		if useCosMask.GetBit(i) {
			resultData[i] = cosRData[i]
		} else {
			resultData[i] = sinRData[i]
		}
	}
	result := hwy.Load(resultData)
	negResult := hwy.Neg(result)
	negResultData := negResult.Data()
	for i := range resultData {
		if negateMask.GetBit(i) {
			resultData[i] = negResultData[i]
		}
	}
	return hwy.Load(resultData)
}

func BaseErfVec_fallback(x hwy.Vec[float32]) hwy.Vec[float32] {
	a1 := hwy.Set[float32](float32(erfA1_f32))
	a2 := hwy.Set[float32](float32(erfA2_f32))
	a3 := hwy.Set[float32](float32(erfA3_f32))
	a4 := hwy.Set[float32](float32(erfA4_f32))
	a5 := hwy.Set[float32](float32(erfA5_f32))
	p := hwy.Set[float32](float32(erfP_f32))
	one := hwy.Set[float32](float32(erfOne_f32))
	zero := hwy.Set[float32](float32(erfZero_f32))
	absX := hwy.Abs(x)
	signMask := hwy.Less(x, zero)
	t := hwy.Div(one, hwy.Add(one, hwy.Mul(p, absX)))
	poly := hwy.MulAdd(a5, t, a4)
	poly = hwy.MulAdd(poly, t, a3)
	poly = hwy.MulAdd(poly, t, a2)
	poly = hwy.MulAdd(poly, t, a1)
	poly = hwy.Mul(poly, t)
	x2 := hwy.Mul(absX, absX)
	negX2 := hwy.Neg(x2)
	expNegX2 := BaseExpVec_fallback(negX2)
	erfAbs := hwy.Sub(one, hwy.Mul(poly, expNegX2))
	erfAbs = hwy.Max(hwy.Min(erfAbs, one), zero)
	negErfAbs := hwy.Neg(erfAbs)
	result := hwy.Merge(negErfAbs, erfAbs, signMask)
	return result
}

func BaseErfVec_fallback_Float64(x hwy.Vec[float64]) hwy.Vec[float64] {
	a1 := hwy.Set[float64](float64(erfA1_f64))
	a2 := hwy.Set[float64](float64(erfA2_f64))
	a3 := hwy.Set[float64](float64(erfA3_f64))
	a4 := hwy.Set[float64](float64(erfA4_f64))
	a5 := hwy.Set[float64](float64(erfA5_f64))
	p := hwy.Set[float64](float64(erfP_f64))
	one := hwy.Set[float64](float64(erfOne_f64))
	zero := hwy.Set[float64](float64(erfZero_f64))
	absX := hwy.Abs(x)
	signMask := hwy.Less(x, zero)
	t := hwy.Div(one, hwy.Add(one, hwy.Mul(p, absX)))
	poly := hwy.MulAdd(a5, t, a4)
	poly = hwy.MulAdd(poly, t, a3)
	poly = hwy.MulAdd(poly, t, a2)
	poly = hwy.MulAdd(poly, t, a1)
	poly = hwy.Mul(poly, t)
	x2 := hwy.Mul(absX, absX)
	negX2 := hwy.Neg(x2)
	expNegX2 := BaseExpVec_fallback_Float64(negX2)
	erfAbs := hwy.Sub(one, hwy.Mul(poly, expNegX2))
	erfAbs = hwy.Max(hwy.Min(erfAbs, one), zero)
	negErfAbs := hwy.Neg(erfAbs)
	result := hwy.Merge(negErfAbs, erfAbs, signMask)
	return result
}

func BaseLog2Vec_fallback(x hwy.Vec[float32]) hwy.Vec[float32] {
	log2E := hwy.Set[float32](float32(log2E_f32))
	lnX := BaseLogVec_fallback(x)
	return hwy.Mul(lnX, log2E)
}

func BaseLog2Vec_fallback_Float64(x hwy.Vec[float64]) hwy.Vec[float64] {
	log2E := hwy.Set[float64](float64(log2E_f64))
	lnX := BaseLogVec_fallback_Float64(x)
	return hwy.Mul(lnX, log2E)
}

func BaseLog10Vec_fallback(x hwy.Vec[float32]) hwy.Vec[float32] {
	log10E := hwy.Set[float32](float32(log10E_f32))
	lnX := BaseLogVec_fallback(x)
	return hwy.Mul(lnX, log10E)
}

func BaseLog10Vec_fallback_Float64(x hwy.Vec[float64]) hwy.Vec[float64] {
	log10E := hwy.Set[float64](float64(log10E_f64))
	lnX := BaseLogVec_fallback_Float64(x)
	return hwy.Mul(lnX, log10E)
}

func BaseExp2Vec_fallback(x hwy.Vec[float32]) hwy.Vec[float32] {
	ln2 := hwy.Set[float32](float32(ln2_f32))
	xLn2 := hwy.Mul(x, ln2)
	return BaseExpVec_fallback(xLn2)
}

func BaseExp2Vec_fallback_Float64(x hwy.Vec[float64]) hwy.Vec[float64] {
	ln2 := hwy.Set[float64](float64(ln2_f64))
	xLn2 := hwy.Mul(x, ln2)
	return BaseExpVec_fallback_Float64(xLn2)
}

func BaseSinhVec_fallback(x hwy.Vec[float32]) hwy.Vec[float32] {
	one := hwy.Set[float32](float32(sinhOne_f32))
	c3 := hwy.Set[float32](float32(sinhC3_f32))
	c5 := hwy.Set[float32](float32(sinhC5_f32))
	c7 := hwy.Set[float32](float32(sinhC7_f32))
	x2 := hwy.Mul(x, x)
	poly := hwy.MulAdd(c7, x2, c5)
	poly = hwy.MulAdd(poly, x2, c3)
	poly = hwy.MulAdd(poly, x2, one)
	return hwy.Mul(x, poly)
}

func BaseSinhVec_fallback_Float64(x hwy.Vec[float64]) hwy.Vec[float64] {
	one := hwy.Set[float64](float64(sinhOne_f64))
	c3 := hwy.Set[float64](float64(sinhC3_f64))
	c5 := hwy.Set[float64](float64(sinhC5_f64))
	c7 := hwy.Set[float64](float64(sinhC7_f64))
	x2 := hwy.Mul(x, x)
	poly := hwy.MulAdd(c7, x2, c5)
	poly = hwy.MulAdd(poly, x2, c3)
	poly = hwy.MulAdd(poly, x2, one)
	return hwy.Mul(x, poly)
}

func BaseCoshVec_fallback(x hwy.Vec[float32]) hwy.Vec[float32] {
	one := hwy.Set[float32](float32(1.0))
	c2 := hwy.Set[float32](float32(0.5))
	c4 := hwy.Set[float32](float32(0.041666666666666664))
	c6 := hwy.Set[float32](float32(0.001388888888888889))
	x2 := hwy.Mul(x, x)
	poly := hwy.MulAdd(c6, x2, c4)
	poly = hwy.MulAdd(poly, x2, c2)
	return hwy.MulAdd(poly, x2, one)
}

func BaseCoshVec_fallback_Float64(x hwy.Vec[float64]) hwy.Vec[float64] {
	one := hwy.Set[float64](float64(1.0))
	c2 := hwy.Set[float64](float64(0.5))
	c4 := hwy.Set[float64](float64(0.041666666666666664))
	c6 := hwy.Set[float64](float64(0.001388888888888889))
	x2 := hwy.Mul(x, x)
	poly := hwy.MulAdd(c6, x2, c4)
	poly = hwy.MulAdd(poly, x2, c2)
	return hwy.MulAdd(poly, x2, one)
}

func BaseAsinhVec_fallback(x hwy.Vec[float32]) hwy.Vec[float32] {
	one := hwy.Set[float32](float32(1.0))
	x2 := hwy.Mul(x, x)
	x2Plus1 := hwy.Add(x2, one)
	sqrtPart := hwy.Sqrt(x2Plus1)
	arg := hwy.Add(x, sqrtPart)
	return BaseLogVec_fallback(arg)
}

func BaseAsinhVec_fallback_Float64(x hwy.Vec[float64]) hwy.Vec[float64] {
	one := hwy.Set[float64](float64(1.0))
	x2 := hwy.Mul(x, x)
	x2Plus1 := hwy.Add(x2, one)
	sqrtPart := hwy.Sqrt(x2Plus1)
	arg := hwy.Add(x, sqrtPart)
	return BaseLogVec_fallback_Float64(arg)
}

func BaseAcoshVec_fallback(x hwy.Vec[float32]) hwy.Vec[float32] {
	one := hwy.Set[float32](float32(1.0))
	zero := hwy.Set[float32](float32(0.0))
	x2 := hwy.Mul(x, x)
	x2Minus1 := hwy.Sub(x2, one)
	sqrtPart := hwy.Sqrt(x2Minus1)
	arg := hwy.Add(x, sqrtPart)
	result := BaseLogVec_fallback(arg)
	oneMask := hwy.Equal(x, one)
	result = hwy.Merge(zero, result, oneMask)
	return result
}

func BaseAcoshVec_fallback_Float64(x hwy.Vec[float64]) hwy.Vec[float64] {
	one := hwy.Set[float64](float64(1.0))
	zero := hwy.Set[float64](float64(0.0))
	x2 := hwy.Mul(x, x)
	x2Minus1 := hwy.Sub(x2, one)
	sqrtPart := hwy.Sqrt(x2Minus1)
	arg := hwy.Add(x, sqrtPart)
	result := BaseLogVec_fallback_Float64(arg)
	oneMask := hwy.Equal(x, one)
	result = hwy.Merge(zero, result, oneMask)
	return result
}

func BaseAtanhVec_fallback(x hwy.Vec[float32]) hwy.Vec[float32] {
	one := hwy.Set[float32](float32(1.0))
	half := hwy.Set[float32](float32(0.5))
	zero := hwy.Set[float32](float32(0.0))
	onePlusX := hwy.Add(one, x)
	oneMinusX := hwy.Sub(one, x)
	ratio := hwy.Div(onePlusX, oneMinusX)
	logRatio := BaseLogVec_fallback(ratio)
	result := hwy.Mul(half, logRatio)
	zeroMask := hwy.Equal(x, zero)
	result = hwy.Merge(zero, result, zeroMask)
	return result
}

func BaseAtanhVec_fallback_Float64(x hwy.Vec[float64]) hwy.Vec[float64] {
	one := hwy.Set[float64](float64(1.0))
	half := hwy.Set[float64](float64(0.5))
	zero := hwy.Set[float64](float64(0.0))
	onePlusX := hwy.Add(one, x)
	oneMinusX := hwy.Sub(one, x)
	ratio := hwy.Div(onePlusX, oneMinusX)
	logRatio := BaseLogVec_fallback_Float64(ratio)
	result := hwy.Mul(half, logRatio)
	zeroMask := hwy.Equal(x, zero)
	result = hwy.Merge(zero, result, zeroMask)
	return result
}

func BasePowVec_fallback(base hwy.Vec[float32], exp hwy.Vec[float32]) hwy.Vec[float32] {
	one := hwy.Set[float32](float32(1.0))
	zero := hwy.Set[float32](float32(0.0))
	logBase := BaseLogVec_fallback(base)
	expTimesLog := hwy.Mul(exp, logBase)
	result := BaseExpVec_fallback(expTimesLog)
	expZeroMask := hwy.Equal(exp, zero)
	result = hwy.Merge(one, result, expZeroMask)
	baseOneMask := hwy.Equal(base, one)
	result = hwy.Merge(one, result, baseOneMask)
	baseZeroMask := hwy.Equal(base, zero)
	expPosMask := hwy.GreaterThan(exp, zero)
	baseZeroExpPosMask := hwy.MaskAnd(baseZeroMask, expPosMask)
	result = hwy.Merge(zero, result, baseZeroExpPosMask)
	return result
}

func BasePowVec_fallback_Float64(base hwy.Vec[float64], exp hwy.Vec[float64]) hwy.Vec[float64] {
	one := hwy.Set[float64](float64(1.0))
	zero := hwy.Set[float64](float64(0.0))
	logBase := BaseLogVec_fallback_Float64(base)
	expTimesLog := hwy.Mul(exp, logBase)
	result := BaseExpVec_fallback_Float64(expTimesLog)
	expZeroMask := hwy.Equal(exp, zero)
	result = hwy.Merge(one, result, expZeroMask)
	baseOneMask := hwy.Equal(base, one)
	result = hwy.Merge(one, result, baseOneMask)
	baseZeroMask := hwy.Equal(base, zero)
	expPosMask := hwy.GreaterThan(exp, zero)
	baseZeroExpPosMask := hwy.MaskAnd(baseZeroMask, expPosMask)
	result = hwy.Merge(zero, result, baseZeroExpPosMask)
	return result
}
