// Code generated by hwygen. DO NOT EDIT.
//go:build amd64 && goexperiment.simd

package math

import (
	"github.com/ajroetker/go-highway/hwy"
	"simd/archsimd"
)

// Hoisted constants - pre-broadcasted at package init time
var (
	BaseCosVec_AVX2_intOne_i32_f32   = archsimd.BroadcastInt32x8(1)
	BaseCosVec_AVX2_intOne_i32_f64   = archsimd.BroadcastInt32x4(1)
	BaseCosVec_AVX2_intTwo_i32_f64   = archsimd.BroadcastInt32x4(2)
	BaseCosVec_AVX2_intThree_i32_f64 = archsimd.BroadcastInt32x4(3)
	BaseSinVec_AVX2_intOne_i32_f32   = archsimd.BroadcastInt32x8(1)
	BaseSinVec_AVX2_intTwo_i32_f32   = archsimd.BroadcastInt32x8(2)
	BaseSinVec_AVX2_intOne_i32_f64   = archsimd.BroadcastInt32x4(1)
	BaseSinVec_AVX2_intTwo_i32_f64   = archsimd.BroadcastInt32x4(2)
	BaseSinVec_AVX2_intThree_i32_f64 = archsimd.BroadcastInt32x4(3)
	BaseCosVec_AVX2_intThree_i32_f32 = archsimd.BroadcastInt32x8(3)
	BaseSinVec_AVX2_intThree_i32_f32 = archsimd.BroadcastInt32x8(3)
	BaseCosVec_AVX2_intTwo_i32_f32   = archsimd.BroadcastInt32x8(2)
)

func BaseExpVec_avx2_Float16(x hwy.Vec[hwy.Float16]) hwy.Vec[hwy.Float16] {
	overflow := hwy.Set[hwy.Float16](expOverflow_f16)
	underflow := hwy.Set[hwy.Float16](expUnderflow_f16)
	one := hwy.Set[hwy.Float16](expOne_f16)
	zero := hwy.Set[hwy.Float16](expZero_f16)
	inf := hwy.Set[hwy.Float16](expOverflow_f16 * 2)
	invLn2 := hwy.Set[hwy.Float16](expInvLn2_f16)
	ln2Hi := hwy.Set[hwy.Float16](expLn2Hi_f16)
	ln2Lo := hwy.Set[hwy.Float16](expLn2Lo_f16)
	c1 := hwy.Set[hwy.Float16](expC1_f16)
	c2 := hwy.Set[hwy.Float16](expC2_f16)
	c3 := hwy.Set[hwy.Float16](expC3_f16)
	c4 := hwy.Set[hwy.Float16](expC4_f16)
	c5 := hwy.Set[hwy.Float16](expC5_f16)
	c6 := hwy.Set[hwy.Float16](expC6_f16)
	overflowMask := hwy.GreaterThanF16(x, overflow)
	underflowMask := hwy.LessThanF16(x, underflow)
	kFloat := hwy.RoundToEven(hwy.MulF16(x, invLn2))
	r := hwy.SubF16(x, hwy.MulF16(kFloat, ln2Hi))
	r = hwy.SubF16(r, hwy.MulF16(kFloat, ln2Lo))
	p := hwy.FMAF16(c6, r, c5)
	p = hwy.FMAF16(p, r, c4)
	p = hwy.FMAF16(p, r, c3)
	p = hwy.FMAF16(p, r, c2)
	p = hwy.FMAF16(p, r, c1)
	p = hwy.FMAF16(p, r, one)
	kInt := hwy.ConvertToInt32(kFloat)
	scale := hwy.Pow2[hwy.Float16](kInt)
	result := hwy.MulF16(p, scale)
	result = hwy.IfThenElseF16(overflowMask, inf, result)
	result = hwy.IfThenElseF16(underflowMask, zero, result)
	return result
}

func BaseExpVec_avx2_BFloat16(x hwy.Vec[hwy.BFloat16]) hwy.Vec[hwy.BFloat16] {
	overflow := hwy.Set[hwy.BFloat16](expOverflow_bf16)
	underflow := hwy.Set[hwy.BFloat16](expUnderflow_bf16)
	one := hwy.Set[hwy.BFloat16](expOne_bf16)
	zero := hwy.Set[hwy.BFloat16](expZero_bf16)
	inf := hwy.Set[hwy.BFloat16](expOverflow_bf16 * 2)
	invLn2 := hwy.Set[hwy.BFloat16](expInvLn2_bf16)
	ln2Hi := hwy.Set[hwy.BFloat16](expLn2Hi_bf16)
	ln2Lo := hwy.Set[hwy.BFloat16](expLn2Lo_bf16)
	c1 := hwy.Set[hwy.BFloat16](expC1_bf16)
	c2 := hwy.Set[hwy.BFloat16](expC2_bf16)
	c3 := hwy.Set[hwy.BFloat16](expC3_bf16)
	c4 := hwy.Set[hwy.BFloat16](expC4_bf16)
	c5 := hwy.Set[hwy.BFloat16](expC5_bf16)
	c6 := hwy.Set[hwy.BFloat16](expC6_bf16)
	overflowMask := hwy.GreaterThanBF16(x, overflow)
	underflowMask := hwy.LessThanBF16(x, underflow)
	kFloat := hwy.RoundToEven(hwy.MulBF16(x, invLn2))
	r := hwy.SubBF16(x, hwy.MulBF16(kFloat, ln2Hi))
	r = hwy.SubBF16(r, hwy.MulBF16(kFloat, ln2Lo))
	p := hwy.FMABF16(c6, r, c5)
	p = hwy.FMABF16(p, r, c4)
	p = hwy.FMABF16(p, r, c3)
	p = hwy.FMABF16(p, r, c2)
	p = hwy.FMABF16(p, r, c1)
	p = hwy.FMABF16(p, r, one)
	kInt := hwy.ConvertToInt32(kFloat)
	scale := hwy.Pow2[hwy.BFloat16](kInt)
	result := hwy.MulBF16(p, scale)
	result = hwy.IfThenElseBF16(overflowMask, inf, result)
	result = hwy.IfThenElseBF16(underflowMask, zero, result)
	return result
}

func BaseExpVec_avx2(x archsimd.Float32x8) archsimd.Float32x8 {
	overflow := archsimd.BroadcastFloat32x8(expOverflow_f32)
	underflow := archsimd.BroadcastFloat32x8(expUnderflow_f32)
	one := archsimd.BroadcastFloat32x8(expOne_f32)
	zero := archsimd.BroadcastFloat32x8(expZero_f32)
	inf := archsimd.BroadcastFloat32x8(expOverflow_f32 * 2)
	invLn2 := archsimd.BroadcastFloat32x8(expInvLn2_f32)
	ln2Hi := archsimd.BroadcastFloat32x8(expLn2Hi_f32)
	ln2Lo := archsimd.BroadcastFloat32x8(expLn2Lo_f32)
	c1 := archsimd.BroadcastFloat32x8(expC1_f32)
	c2 := archsimd.BroadcastFloat32x8(expC2_f32)
	c3 := archsimd.BroadcastFloat32x8(expC3_f32)
	c4 := archsimd.BroadcastFloat32x8(expC4_f32)
	c5 := archsimd.BroadcastFloat32x8(expC5_f32)
	c6 := archsimd.BroadcastFloat32x8(expC6_f32)
	overflowMask := x.Greater(overflow)
	underflowMask := x.Less(underflow)
	kFloat := x.Mul(invLn2).RoundToEven()
	r := x.Sub(kFloat.Mul(ln2Hi))
	r = r.Sub(kFloat.Mul(ln2Lo))
	p := c6.MulAdd(r, c5)
	p = p.MulAdd(r, c4)
	p = p.MulAdd(r, c3)
	p = p.MulAdd(r, c2)
	p = p.MulAdd(r, c1)
	p = p.MulAdd(r, one)
	kInt := kFloat.ConvertToInt32()
	scale := hwy.Pow2_AVX2_F32x8(kInt)
	result := p.Mul(scale)
	result = inf.Merge(result, overflowMask)
	result = zero.Merge(result, underflowMask)
	return result
}

func BaseExpVec_avx2_Float64(x archsimd.Float64x4) archsimd.Float64x4 {
	overflow := archsimd.BroadcastFloat64x4(expOverflow_f64)
	underflow := archsimd.BroadcastFloat64x4(expUnderflow_f64)
	one := archsimd.BroadcastFloat64x4(expOne_f64)
	zero := archsimd.BroadcastFloat64x4(expZero_f64)
	inf := archsimd.BroadcastFloat64x4(expOverflow_f64 * 2)
	invLn2 := archsimd.BroadcastFloat64x4(expInvLn2_f64)
	ln2Hi := archsimd.BroadcastFloat64x4(expLn2Hi_f64)
	ln2Lo := archsimd.BroadcastFloat64x4(expLn2Lo_f64)
	c1 := archsimd.BroadcastFloat64x4(expC1_f64)
	c2 := archsimd.BroadcastFloat64x4(expC2_f64)
	c3 := archsimd.BroadcastFloat64x4(expC3_f64)
	c4 := archsimd.BroadcastFloat64x4(expC4_f64)
	c5 := archsimd.BroadcastFloat64x4(expC5_f64)
	c6 := archsimd.BroadcastFloat64x4(expC6_f64)
	overflowMask := x.Greater(overflow)
	underflowMask := x.Less(underflow)
	kFloat := x.Mul(invLn2).RoundToEven()
	r := x.Sub(kFloat.Mul(ln2Hi))
	r = r.Sub(kFloat.Mul(ln2Lo))
	p := c6.MulAdd(r, c5)
	p = p.MulAdd(r, c4)
	p = p.MulAdd(r, c3)
	p = p.MulAdd(r, c2)
	p = p.MulAdd(r, c1)
	p = p.MulAdd(r, one)
	kInt := kFloat.ConvertToInt32()
	scale := hwy.Pow2_AVX2_F64x4(kInt)
	result := p.Mul(scale)
	result = inf.Merge(result, overflowMask)
	result = zero.Merge(result, underflowMask)
	return result
}

func BaseSigmoidVec_avx2_Float16(x hwy.Vec[hwy.Float16]) hwy.Vec[hwy.Float16] {
	one := hwy.Set[hwy.Float16](sigmoidOne_f16)
	zero := hwy.Set[hwy.Float16](sigmoidZero_f16)
	satHi := hwy.Set[hwy.Float16](sigmoidSatHi_f16)
	satLo := hwy.Set[hwy.Float16](sigmoidSatLo_f16)
	clampedX := hwy.MaxF16(hwy.MinF16(x, satHi), satLo)
	negX := hwy.NegF16(clampedX)
	expNegX := BaseExpVec_avx2_Float16(negX)
	result := hwy.DivF16(one, hwy.AddF16(one, expNegX))
	result = hwy.IfThenElseF16(hwy.GreaterThanF16(x, satHi), one, result)
	result = hwy.IfThenElseF16(hwy.LessThanF16(x, satLo), zero, result)
	return result
}

func BaseSigmoidVec_avx2_BFloat16(x hwy.Vec[hwy.BFloat16]) hwy.Vec[hwy.BFloat16] {
	one := hwy.Set[hwy.BFloat16](sigmoidOne_bf16)
	zero := hwy.Set[hwy.BFloat16](sigmoidZero_bf16)
	satHi := hwy.Set[hwy.BFloat16](sigmoidSatHi_bf16)
	satLo := hwy.Set[hwy.BFloat16](sigmoidSatLo_bf16)
	clampedX := hwy.MaxBF16(hwy.MinBF16(x, satHi), satLo)
	negX := hwy.NegBF16(clampedX)
	expNegX := BaseExpVec_avx2_BFloat16(negX)
	result := hwy.DivBF16(one, hwy.AddBF16(one, expNegX))
	result = hwy.IfThenElseBF16(hwy.GreaterThanBF16(x, satHi), one, result)
	result = hwy.IfThenElseBF16(hwy.LessThanBF16(x, satLo), zero, result)
	return result
}

func BaseSigmoidVec_avx2(x archsimd.Float32x8) archsimd.Float32x8 {
	one := archsimd.BroadcastFloat32x8(sigmoidOne_f32)
	zero := archsimd.BroadcastFloat32x8(sigmoidZero_f32)
	satHi := archsimd.BroadcastFloat32x8(sigmoidSatHi_f32)
	satLo := archsimd.BroadcastFloat32x8(sigmoidSatLo_f32)
	clampedX := x.Min(satHi).Max(satLo)
	negX := archsimd.BroadcastFloat32x8(0).Sub(clampedX)
	expNegX := BaseExpVec_avx2(negX)
	result := one.Div(one.Add(expNegX))
	result = one.Merge(result, x.Greater(satHi))
	result = zero.Merge(result, x.Less(satLo))
	return result
}

func BaseSigmoidVec_avx2_Float64(x archsimd.Float64x4) archsimd.Float64x4 {
	one := archsimd.BroadcastFloat64x4(sigmoidOne_f64)
	zero := archsimd.BroadcastFloat64x4(sigmoidZero_f64)
	satHi := archsimd.BroadcastFloat64x4(sigmoidSatHi_f64)
	satLo := archsimd.BroadcastFloat64x4(sigmoidSatLo_f64)
	clampedX := x.Min(satHi).Max(satLo)
	negX := archsimd.BroadcastFloat64x4(0).Sub(clampedX)
	expNegX := BaseExpVec_avx2_Float64(negX)
	result := one.Div(one.Add(expNegX))
	result = one.Merge(result, x.Greater(satHi))
	result = zero.Merge(result, x.Less(satLo))
	return result
}

func BaseTanhVec_avx2_Float16(x hwy.Vec[hwy.Float16]) hwy.Vec[hwy.Float16] {
	two := hwy.Const[hwy.Float16](2.0)
	one := hwy.Set[hwy.Float16](tanhOne_f16)
	negOne := hwy.Set[hwy.Float16](tanhNegOne_f16)
	threshold := hwy.Set[hwy.Float16](tanhClamp_f16)
	negThreshold := hwy.NegF16(threshold)
	twoX := hwy.MulF16(two, x)
	sigTwoX := BaseSigmoidVec_avx2_Float16(twoX)
	result := hwy.SubF16(hwy.MulF16(two, sigTwoX), one)
	result = hwy.IfThenElseF16(hwy.GreaterThanF16(x, threshold), one, result)
	result = hwy.IfThenElseF16(hwy.LessThanF16(x, negThreshold), negOne, result)
	return result
}

func BaseTanhVec_avx2_BFloat16(x hwy.Vec[hwy.BFloat16]) hwy.Vec[hwy.BFloat16] {
	two := hwy.Const[hwy.BFloat16](2.0)
	one := hwy.Set[hwy.BFloat16](tanhOne_bf16)
	negOne := hwy.Set[hwy.BFloat16](tanhNegOne_bf16)
	threshold := hwy.Set[hwy.BFloat16](tanhClamp_bf16)
	negThreshold := hwy.NegBF16(threshold)
	twoX := hwy.MulBF16(two, x)
	sigTwoX := BaseSigmoidVec_avx2_BFloat16(twoX)
	result := hwy.SubBF16(hwy.MulBF16(two, sigTwoX), one)
	result = hwy.IfThenElseBF16(hwy.GreaterThanBF16(x, threshold), one, result)
	result = hwy.IfThenElseBF16(hwy.LessThanBF16(x, negThreshold), negOne, result)
	return result
}

func BaseTanhVec_avx2(x archsimd.Float32x8) archsimd.Float32x8 {
	two := archsimd.BroadcastFloat32x8(2.0)
	one := archsimd.BroadcastFloat32x8(tanhOne_f32)
	negOne := archsimd.BroadcastFloat32x8(tanhNegOne_f32)
	threshold := archsimd.BroadcastFloat32x8(tanhClamp_f32)
	negThreshold := archsimd.BroadcastFloat32x8(0).Sub(threshold)
	twoX := two.Mul(x)
	sigTwoX := BaseSigmoidVec_avx2(twoX)
	result := two.Mul(sigTwoX).Sub(one)
	result = one.Merge(result, x.Greater(threshold))
	result = negOne.Merge(result, x.Less(negThreshold))
	return result
}

func BaseTanhVec_avx2_Float64(x archsimd.Float64x4) archsimd.Float64x4 {
	two := archsimd.BroadcastFloat64x4(2.0)
	one := archsimd.BroadcastFloat64x4(tanhOne_f64)
	negOne := archsimd.BroadcastFloat64x4(tanhNegOne_f64)
	threshold := archsimd.BroadcastFloat64x4(tanhClamp_f64)
	negThreshold := archsimd.BroadcastFloat64x4(0).Sub(threshold)
	twoX := two.Mul(x)
	sigTwoX := BaseSigmoidVec_avx2_Float64(twoX)
	result := two.Mul(sigTwoX).Sub(one)
	result = one.Merge(result, x.Greater(threshold))
	result = negOne.Merge(result, x.Less(negThreshold))
	return result
}

func BaseLogVec_avx2_Float16(x hwy.Vec[hwy.Float16]) hwy.Vec[hwy.Float16] {
	one := hwy.Set[hwy.Float16](logOne_f16)
	two := hwy.Set[hwy.Float16](logTwo_f16)
	zero := hwy.Const[hwy.Float16](0.0)
	ln2Hi := hwy.Set[hwy.Float16](logLn2Hi_f16)
	ln2Lo := hwy.Set[hwy.Float16](logLn2Lo_f16)
	negInf := hwy.Set[hwy.Float16](logNegInf_f16)
	nan := hwy.Const[hwy.Float16](0.0)
	c1 := hwy.Set[hwy.Float16](logC1_f16)
	c2 := hwy.Set[hwy.Float16](logC2_f16)
	c3 := hwy.Set[hwy.Float16](logC3_f16)
	c4 := hwy.Set[hwy.Float16](logC4_f16)
	c5 := hwy.Set[hwy.Float16](logC5_f16)
	zeroMask := hwy.EqualF16(x, zero)
	negMask := hwy.LessThanF16(x, zero)
	oneMask := hwy.EqualF16(x, one)
	e := hwy.GetExponent(x)
	m := hwy.GetMantissa(x)
	mLarge := hwy.GreaterThanF16(m, hwy.Set[hwy.Float16](logSqrt2_f16))
	mAdjusted := hwy.IfThenElseF16(mLarge, hwy.MulF16(m, hwy.Set[hwy.Float16](logHalf_f16)), m)
	eFloat := hwy.ConvertToF16(e)
	eAdjusted := hwy.IfThenElseF16(mLarge, hwy.AddF16(eFloat, one), eFloat)
	mMinus1 := hwy.SubF16(mAdjusted, one)
	mPlus1 := hwy.AddF16(mAdjusted, one)
	y := hwy.DivF16(mMinus1, mPlus1)
	y2 := hwy.MulF16(y, y)
	poly := hwy.FMAF16(c5, y2, c4)
	poly = hwy.FMAF16(poly, y2, c3)
	poly = hwy.FMAF16(poly, y2, c2)
	poly = hwy.FMAF16(poly, y2, c1)
	logM := hwy.MulF16(hwy.MulF16(two, y), poly)
	result := hwy.AddF16(hwy.FMAF16(eAdjusted, ln2Hi, logM), hwy.MulF16(eAdjusted, ln2Lo))
	result = hwy.IfThenElseF16(zeroMask, negInf, result)
	result = hwy.IfThenElseF16(negMask, nan, result)
	result = hwy.IfThenElseF16(oneMask, zero, result)
	return result
}

func BaseLogVec_avx2_BFloat16(x hwy.Vec[hwy.BFloat16]) hwy.Vec[hwy.BFloat16] {
	one := hwy.Set[hwy.BFloat16](logOne_bf16)
	two := hwy.Set[hwy.BFloat16](logTwo_bf16)
	zero := hwy.Const[hwy.BFloat16](0.0)
	ln2Hi := hwy.Set[hwy.BFloat16](logLn2Hi_bf16)
	ln2Lo := hwy.Set[hwy.BFloat16](logLn2Lo_bf16)
	negInf := hwy.Set[hwy.BFloat16](logNegInf_bf16)
	nan := hwy.Const[hwy.BFloat16](0.0)
	c1 := hwy.Set[hwy.BFloat16](logC1_bf16)
	c2 := hwy.Set[hwy.BFloat16](logC2_bf16)
	c3 := hwy.Set[hwy.BFloat16](logC3_bf16)
	c4 := hwy.Set[hwy.BFloat16](logC4_bf16)
	c5 := hwy.Set[hwy.BFloat16](logC5_bf16)
	zeroMask := hwy.EqualBF16(x, zero)
	negMask := hwy.LessThanBF16(x, zero)
	oneMask := hwy.EqualBF16(x, one)
	e := hwy.GetExponent(x)
	m := hwy.GetMantissa(x)
	mLarge := hwy.GreaterThanBF16(m, hwy.Set[hwy.BFloat16](logSqrt2_bf16))
	mAdjusted := hwy.IfThenElseBF16(mLarge, hwy.MulBF16(m, hwy.Set[hwy.BFloat16](logHalf_bf16)), m)
	eFloat := hwy.ConvertToBF16(e)
	eAdjusted := hwy.IfThenElseBF16(mLarge, hwy.AddBF16(eFloat, one), eFloat)
	mMinus1 := hwy.SubBF16(mAdjusted, one)
	mPlus1 := hwy.AddBF16(mAdjusted, one)
	y := hwy.DivBF16(mMinus1, mPlus1)
	y2 := hwy.MulBF16(y, y)
	poly := hwy.FMABF16(c5, y2, c4)
	poly = hwy.FMABF16(poly, y2, c3)
	poly = hwy.FMABF16(poly, y2, c2)
	poly = hwy.FMABF16(poly, y2, c1)
	logM := hwy.MulBF16(hwy.MulBF16(two, y), poly)
	result := hwy.AddBF16(hwy.FMABF16(eAdjusted, ln2Hi, logM), hwy.MulBF16(eAdjusted, ln2Lo))
	result = hwy.IfThenElseBF16(zeroMask, negInf, result)
	result = hwy.IfThenElseBF16(negMask, nan, result)
	result = hwy.IfThenElseBF16(oneMask, zero, result)
	return result
}

func BaseLogVec_avx2(x archsimd.Float32x8) archsimd.Float32x8 {
	one := archsimd.BroadcastFloat32x8(logOne_f32)
	two := archsimd.BroadcastFloat32x8(logTwo_f32)
	zero := archsimd.BroadcastFloat32x8(0.0)
	ln2Hi := archsimd.BroadcastFloat32x8(logLn2Hi_f32)
	ln2Lo := archsimd.BroadcastFloat32x8(logLn2Lo_f32)
	negInf := archsimd.BroadcastFloat32x8(logNegInf_f32)
	nan := archsimd.BroadcastFloat32x8(0.0)
	c1 := archsimd.BroadcastFloat32x8(logC1_f32)
	c2 := archsimd.BroadcastFloat32x8(logC2_f32)
	c3 := archsimd.BroadcastFloat32x8(logC3_f32)
	c4 := archsimd.BroadcastFloat32x8(logC4_f32)
	c5 := archsimd.BroadcastFloat32x8(logC5_f32)
	zeroMask := x.Equal(zero)
	negMask := x.Less(zero)
	oneMask := x.Equal(one)
	e := x.AsInt32x8().ShiftAllRight(23).And(archsimd.BroadcastInt32x8(255)).Sub(archsimd.BroadcastInt32x8(127))
	m := x.AsInt32x8().And(archsimd.BroadcastInt32x8(8388607)).Or(archsimd.BroadcastInt32x8(1065353216)).AsFloat32x8()
	mLarge := m.Greater(archsimd.BroadcastFloat32x8(logSqrt2_f32))
	mAdjusted := m.Mul(archsimd.BroadcastFloat32x8(logHalf_f32)).Merge(m, mLarge)
	eFloat := e.ConvertToFloat32()
	eAdjusted := eFloat.Add(one).Merge(eFloat, mLarge)
	mMinus1 := mAdjusted.Sub(one)
	mPlus1 := mAdjusted.Add(one)
	y := mMinus1.Div(mPlus1)
	y2 := y.Mul(y)
	poly := c5.MulAdd(y2, c4)
	poly = poly.MulAdd(y2, c3)
	poly = poly.MulAdd(y2, c2)
	poly = poly.MulAdd(y2, c1)
	logM := two.Mul(y).Mul(poly)
	result := eAdjusted.MulAdd(ln2Hi, logM).Add(eAdjusted.Mul(ln2Lo))
	result = negInf.Merge(result, zeroMask)
	result = nan.Merge(result, negMask)
	result = zero.Merge(result, oneMask)
	return result
}

func BaseLogVec_avx2_Float64(x archsimd.Float64x4) archsimd.Float64x4 {
	one := archsimd.BroadcastFloat64x4(logOne_f64)
	two := archsimd.BroadcastFloat64x4(logTwo_f64)
	zero := archsimd.BroadcastFloat64x4(0.0)
	ln2Hi := archsimd.BroadcastFloat64x4(logLn2Hi_f64)
	ln2Lo := archsimd.BroadcastFloat64x4(logLn2Lo_f64)
	negInf := archsimd.BroadcastFloat64x4(logNegInf_f64)
	nan := archsimd.BroadcastFloat64x4(0.0)
	c1 := archsimd.BroadcastFloat64x4(logC1_f64)
	c2 := archsimd.BroadcastFloat64x4(logC2_f64)
	c3 := archsimd.BroadcastFloat64x4(logC3_f64)
	c4 := archsimd.BroadcastFloat64x4(logC4_f64)
	c5 := archsimd.BroadcastFloat64x4(logC5_f64)
	zeroMask := x.Equal(zero)
	negMask := x.Less(zero)
	oneMask := x.Equal(one)
	e := x.AsInt64x4().ShiftAllRight(52).And(archsimd.BroadcastInt64x4(2047)).Sub(archsimd.BroadcastInt64x4(1023))
	m := x.AsInt64x4().And(archsimd.BroadcastInt64x4(4503599627370495)).Or(archsimd.BroadcastInt64x4(4607182418800017408)).AsFloat64x4()
	mLarge := m.Greater(archsimd.BroadcastFloat64x4(logSqrt2_f64))
	mAdjusted := m.Mul(archsimd.BroadcastFloat64x4(logHalf_f64)).Merge(m, mLarge)
	eFloat := e.ConvertToFloat64()
	eAdjusted := eFloat.Add(one).Merge(eFloat, mLarge)
	mMinus1 := mAdjusted.Sub(one)
	mPlus1 := mAdjusted.Add(one)
	y := mMinus1.Div(mPlus1)
	y2 := y.Mul(y)
	poly := c5.MulAdd(y2, c4)
	poly = poly.MulAdd(y2, c3)
	poly = poly.MulAdd(y2, c2)
	poly = poly.MulAdd(y2, c1)
	logM := two.Mul(y).Mul(poly)
	result := eAdjusted.MulAdd(ln2Hi, logM).Add(eAdjusted.Mul(ln2Lo))
	result = negInf.Merge(result, zeroMask)
	result = nan.Merge(result, negMask)
	result = zero.Merge(result, oneMask)
	return result
}

func BaseSinVec_avx2_Float16(x hwy.Vec[hwy.Float16]) hwy.Vec[hwy.Float16] {
	twoOverPi := hwy.Set[hwy.Float16](trig2OverPi_f16)
	piOver2Hi := hwy.Set[hwy.Float16](trigPiOver2Hi_f16)
	piOver2Lo := hwy.Set[hwy.Float16](trigPiOver2Lo_f16)
	one := hwy.Set[hwy.Float16](trigOne_f16)
	s1 := hwy.Set[hwy.Float16](trigS1_f16)
	s2 := hwy.Set[hwy.Float16](trigS2_f16)
	s3 := hwy.Set[hwy.Float16](trigS3_f16)
	s4 := hwy.Set[hwy.Float16](trigS4_f16)
	c1 := hwy.Set[hwy.Float16](trigC1_f16)
	c2 := hwy.Set[hwy.Float16](trigC2_f16)
	c3 := hwy.Set[hwy.Float16](trigC3_f16)
	c4 := hwy.Set[hwy.Float16](trigC4_f16)
	intOne := hwy.Set[int32](1)
	intTwo := hwy.Set[int32](2)
	intThree := hwy.Set[int32](3)
	kFloat := hwy.RoundToEven(hwy.MulF16(x, twoOverPi))
	kInt := hwy.ConvertToInt32(kFloat)
	r := hwy.SubF16(x, hwy.MulF16(kFloat, piOver2Hi))
	r = hwy.SubF16(r, hwy.MulF16(kFloat, piOver2Lo))
	r2 := hwy.MulF16(r, r)
	sinPoly := hwy.FMAF16(s4, r2, s3)
	sinPoly = hwy.FMAF16(sinPoly, r2, s2)
	sinPoly = hwy.FMAF16(sinPoly, r2, s1)
	sinPoly = hwy.FMAF16(sinPoly, r2, one)
	sinR := hwy.MulF16(r, sinPoly)
	cosPoly := hwy.FMAF16(c4, r2, c3)
	cosPoly = hwy.FMAF16(cosPoly, r2, c2)
	cosPoly = hwy.FMAF16(cosPoly, r2, c1)
	cosR := hwy.FMAF16(cosPoly, r2, one)
	octant := hwy.And(kInt, intThree)
	useCosMask := hwy.Equal(hwy.And(octant, intOne), intOne)
	negateMask := hwy.Equal(hwy.And(octant, intTwo), intTwo)
	sinRData := func() []hwy.Float16 {
		var _simd_tmp [16]hwy.Float16
		hwy.Store(sinR, _simd_tmp[:])
		return _simd_tmp[:]
	}()
	cosRData := func() []hwy.Float16 {
		var _simd_tmp [16]hwy.Float16
		hwy.Store(cosR, _simd_tmp[:])
		return _simd_tmp[:]
	}()
	resultData := make([]hwy.Float16, len(sinRData))
	for i := range sinRData {
		if useCosMask.GetBit(i) {
			resultData[i] = cosRData[i]
		} else {
			resultData[i] = sinRData[i]
		}
	}
	result := hwy.Load(resultData)
	negResult := hwy.NegF16(result)
	negResultData := func() []hwy.Float16 {
		var _simd_tmp [16]hwy.Float16
		hwy.Store(negResult, _simd_tmp[:])
		return _simd_tmp[:]
	}()
	for i := range resultData {
		if negateMask.GetBit(i) {
			resultData[i] = negResultData[i]
		}
	}
	return hwy.Load(resultData)
}

func BaseSinVec_avx2_BFloat16(x hwy.Vec[hwy.BFloat16]) hwy.Vec[hwy.BFloat16] {
	twoOverPi := hwy.Set[hwy.BFloat16](trig2OverPi_bf16)
	piOver2Hi := hwy.Set[hwy.BFloat16](trigPiOver2Hi_bf16)
	piOver2Lo := hwy.Set[hwy.BFloat16](trigPiOver2Lo_bf16)
	one := hwy.Set[hwy.BFloat16](trigOne_bf16)
	s1 := hwy.Set[hwy.BFloat16](trigS1_bf16)
	s2 := hwy.Set[hwy.BFloat16](trigS2_bf16)
	s3 := hwy.Set[hwy.BFloat16](trigS3_bf16)
	s4 := hwy.Set[hwy.BFloat16](trigS4_bf16)
	c1 := hwy.Set[hwy.BFloat16](trigC1_bf16)
	c2 := hwy.Set[hwy.BFloat16](trigC2_bf16)
	c3 := hwy.Set[hwy.BFloat16](trigC3_bf16)
	c4 := hwy.Set[hwy.BFloat16](trigC4_bf16)
	intOne := hwy.Set[int32](1)
	intTwo := hwy.Set[int32](2)
	intThree := hwy.Set[int32](3)
	kFloat := hwy.RoundToEven(hwy.MulBF16(x, twoOverPi))
	kInt := hwy.ConvertToInt32(kFloat)
	r := hwy.SubBF16(x, hwy.MulBF16(kFloat, piOver2Hi))
	r = hwy.SubBF16(r, hwy.MulBF16(kFloat, piOver2Lo))
	r2 := hwy.MulBF16(r, r)
	sinPoly := hwy.FMABF16(s4, r2, s3)
	sinPoly = hwy.FMABF16(sinPoly, r2, s2)
	sinPoly = hwy.FMABF16(sinPoly, r2, s1)
	sinPoly = hwy.FMABF16(sinPoly, r2, one)
	sinR := hwy.MulBF16(r, sinPoly)
	cosPoly := hwy.FMABF16(c4, r2, c3)
	cosPoly = hwy.FMABF16(cosPoly, r2, c2)
	cosPoly = hwy.FMABF16(cosPoly, r2, c1)
	cosR := hwy.FMABF16(cosPoly, r2, one)
	octant := hwy.And(kInt, intThree)
	useCosMask := hwy.Equal(hwy.And(octant, intOne), intOne)
	negateMask := hwy.Equal(hwy.And(octant, intTwo), intTwo)
	sinRData := func() []hwy.BFloat16 {
		var _simd_tmp [16]hwy.BFloat16
		hwy.Store(sinR, _simd_tmp[:])
		return _simd_tmp[:]
	}()
	cosRData := func() []hwy.BFloat16 {
		var _simd_tmp [16]hwy.BFloat16
		hwy.Store(cosR, _simd_tmp[:])
		return _simd_tmp[:]
	}()
	resultData := make([]hwy.BFloat16, len(sinRData))
	for i := range sinRData {
		if useCosMask.GetBit(i) {
			resultData[i] = cosRData[i]
		} else {
			resultData[i] = sinRData[i]
		}
	}
	result := hwy.Load(resultData)
	negResult := hwy.NegBF16(result)
	negResultData := func() []hwy.BFloat16 {
		var _simd_tmp [16]hwy.BFloat16
		hwy.Store(negResult, _simd_tmp[:])
		return _simd_tmp[:]
	}()
	for i := range resultData {
		if negateMask.GetBit(i) {
			resultData[i] = negResultData[i]
		}
	}
	return hwy.Load(resultData)
}

func BaseSinVec_avx2(x archsimd.Float32x8) archsimd.Float32x8 {
	twoOverPi := archsimd.BroadcastFloat32x8(trig2OverPi_f32)
	piOver2Hi := archsimd.BroadcastFloat32x8(trigPiOver2Hi_f32)
	piOver2Lo := archsimd.BroadcastFloat32x8(trigPiOver2Lo_f32)
	one := archsimd.BroadcastFloat32x8(trigOne_f32)
	s1 := archsimd.BroadcastFloat32x8(trigS1_f32)
	s2 := archsimd.BroadcastFloat32x8(trigS2_f32)
	s3 := archsimd.BroadcastFloat32x8(trigS3_f32)
	s4 := archsimd.BroadcastFloat32x8(trigS4_f32)
	c1 := archsimd.BroadcastFloat32x8(trigC1_f32)
	c2 := archsimd.BroadcastFloat32x8(trigC2_f32)
	c3 := archsimd.BroadcastFloat32x8(trigC3_f32)
	c4 := archsimd.BroadcastFloat32x8(trigC4_f32)
	intOne := BaseSinVec_AVX2_intOne_i32_f32
	intTwo := BaseSinVec_AVX2_intTwo_i32_f32
	intThree := BaseSinVec_AVX2_intThree_i32_f32
	kFloat := x.Mul(twoOverPi).RoundToEven()
	kInt := kFloat.ConvertToInt32()
	r := x.Sub(kFloat.Mul(piOver2Hi))
	r = r.Sub(kFloat.Mul(piOver2Lo))
	r2 := r.Mul(r)
	sinPoly := s4.MulAdd(r2, s3)
	sinPoly = sinPoly.MulAdd(r2, s2)
	sinPoly = sinPoly.MulAdd(r2, s1)
	sinPoly = sinPoly.MulAdd(r2, one)
	sinR := r.Mul(sinPoly)
	cosPoly := c4.MulAdd(r2, c3)
	cosPoly = cosPoly.MulAdd(r2, c2)
	cosPoly = cosPoly.MulAdd(r2, c1)
	cosR := cosPoly.MulAdd(r2, one)
	octant := kInt.And(intThree)
	useCosMask := octant.And(intOne).Equal(intOne)
	negateMask := octant.And(intTwo).Equal(intTwo)
	sinRData := func() []float32 {
		var _simd_tmp [8]float32
		sinR.StoreSlice(_simd_tmp[:])
		return _simd_tmp[:]
	}()
	cosRData := func() []float32 {
		var _simd_tmp [8]float32
		cosR.StoreSlice(_simd_tmp[:])
		return _simd_tmp[:]
	}()
	resultData := make([]float32, len(sinRData))
	for i := range sinRData {
		if func() bool {
			_vOne := archsimd.BroadcastInt32x8(1)
			_vZero := archsimd.BroadcastInt32x8(0)
			_vMasked := _vOne.Merge(_vZero, useCosMask)
			var _simd_mask_tmp [8]int32
			_vMasked.StoreSlice(_simd_mask_tmp[:])
			return _simd_mask_tmp[i] != 0
		}() {
			resultData[i] = cosRData[i]
		} else {
			resultData[i] = sinRData[i]
		}
	}
	result := archsimd.LoadFloat32x8Slice(resultData)
	negResult := archsimd.BroadcastFloat32x8(0).Sub(result)
	negResultData := func() []float32 {
		var _simd_tmp [8]float32
		negResult.StoreSlice(_simd_tmp[:])
		return _simd_tmp[:]
	}()
	for i := range resultData {
		if func() bool {
			_vOne := archsimd.BroadcastInt32x8(1)
			_vZero := archsimd.BroadcastInt32x8(0)
			_vMasked := _vOne.Merge(_vZero, negateMask)
			var _simd_mask_tmp [8]int32
			_vMasked.StoreSlice(_simd_mask_tmp[:])
			return _simd_mask_tmp[i] != 0
		}() {
			resultData[i] = negResultData[i]
		}
	}
	return archsimd.LoadFloat32x8Slice(resultData)
}

func BaseSinVec_avx2_Float64(x archsimd.Float64x4) archsimd.Float64x4 {
	twoOverPi := archsimd.BroadcastFloat64x4(trig2OverPi_f64)
	piOver2Hi := archsimd.BroadcastFloat64x4(trigPiOver2Hi_f64)
	piOver2Lo := archsimd.BroadcastFloat64x4(trigPiOver2Lo_f64)
	one := archsimd.BroadcastFloat64x4(trigOne_f64)
	s1 := archsimd.BroadcastFloat64x4(trigS1_f64)
	s2 := archsimd.BroadcastFloat64x4(trigS2_f64)
	s3 := archsimd.BroadcastFloat64x4(trigS3_f64)
	s4 := archsimd.BroadcastFloat64x4(trigS4_f64)
	c1 := archsimd.BroadcastFloat64x4(trigC1_f64)
	c2 := archsimd.BroadcastFloat64x4(trigC2_f64)
	c3 := archsimd.BroadcastFloat64x4(trigC3_f64)
	c4 := archsimd.BroadcastFloat64x4(trigC4_f64)
	intOne := BaseSinVec_AVX2_intOne_i32_f64
	intTwo := BaseSinVec_AVX2_intTwo_i32_f64
	intThree := BaseSinVec_AVX2_intThree_i32_f64
	kFloat := x.Mul(twoOverPi).RoundToEven()
	kInt := kFloat.ConvertToInt32()
	r := x.Sub(kFloat.Mul(piOver2Hi))
	r = r.Sub(kFloat.Mul(piOver2Lo))
	r2 := r.Mul(r)
	sinPoly := s4.MulAdd(r2, s3)
	sinPoly = sinPoly.MulAdd(r2, s2)
	sinPoly = sinPoly.MulAdd(r2, s1)
	sinPoly = sinPoly.MulAdd(r2, one)
	sinR := r.Mul(sinPoly)
	cosPoly := c4.MulAdd(r2, c3)
	cosPoly = cosPoly.MulAdd(r2, c2)
	cosPoly = cosPoly.MulAdd(r2, c1)
	cosR := cosPoly.MulAdd(r2, one)
	octant := kInt.And(intThree)
	useCosMask := octant.And(intOne).Equal(intOne)
	negateMask := octant.And(intTwo).Equal(intTwo)
	sinRData := func() []float64 {
		var _simd_tmp [4]float64
		sinR.StoreSlice(_simd_tmp[:])
		return _simd_tmp[:]
	}()
	cosRData := func() []float64 {
		var _simd_tmp [4]float64
		cosR.StoreSlice(_simd_tmp[:])
		return _simd_tmp[:]
	}()
	resultData := make([]float64, len(sinRData))
	for i := range sinRData {
		if func() bool {
			_vOne := archsimd.BroadcastInt32x4(1)
			_vZero := archsimd.BroadcastInt32x4(0)
			_vMasked := _vOne.Merge(_vZero, useCosMask)
			var _simd_mask_tmp [4]int32
			_vMasked.StoreSlice(_simd_mask_tmp[:])
			return _simd_mask_tmp[i] != 0
		}() {
			resultData[i] = cosRData[i]
		} else {
			resultData[i] = sinRData[i]
		}
	}
	result := archsimd.LoadFloat64x4Slice(resultData)
	negResult := archsimd.BroadcastFloat64x4(0).Sub(result)
	negResultData := func() []float64 {
		var _simd_tmp [4]float64
		negResult.StoreSlice(_simd_tmp[:])
		return _simd_tmp[:]
	}()
	for i := range resultData {
		if func() bool {
			_vOne := archsimd.BroadcastInt32x4(1)
			_vZero := archsimd.BroadcastInt32x4(0)
			_vMasked := _vOne.Merge(_vZero, negateMask)
			var _simd_mask_tmp [4]int32
			_vMasked.StoreSlice(_simd_mask_tmp[:])
			return _simd_mask_tmp[i] != 0
		}() {
			resultData[i] = negResultData[i]
		}
	}
	return archsimd.LoadFloat64x4Slice(resultData)
}

func BaseCosVec_avx2_Float16(x hwy.Vec[hwy.Float16]) hwy.Vec[hwy.Float16] {
	twoOverPi := hwy.Set[hwy.Float16](trig2OverPi_f16)
	piOver2Hi := hwy.Set[hwy.Float16](trigPiOver2Hi_f16)
	piOver2Lo := hwy.Set[hwy.Float16](trigPiOver2Lo_f16)
	one := hwy.Set[hwy.Float16](trigOne_f16)
	s1 := hwy.Set[hwy.Float16](trigS1_f16)
	s2 := hwy.Set[hwy.Float16](trigS2_f16)
	s3 := hwy.Set[hwy.Float16](trigS3_f16)
	s4 := hwy.Set[hwy.Float16](trigS4_f16)
	c1 := hwy.Set[hwy.Float16](trigC1_f16)
	c2 := hwy.Set[hwy.Float16](trigC2_f16)
	c3 := hwy.Set[hwy.Float16](trigC3_f16)
	c4 := hwy.Set[hwy.Float16](trigC4_f16)
	intOne := hwy.Set[int32](1)
	intTwo := hwy.Set[int32](2)
	intThree := hwy.Set[int32](3)
	kFloat := hwy.RoundToEven(hwy.MulF16(x, twoOverPi))
	kInt := hwy.ConvertToInt32(kFloat)
	r := hwy.SubF16(x, hwy.MulF16(kFloat, piOver2Hi))
	r = hwy.SubF16(r, hwy.MulF16(kFloat, piOver2Lo))
	r2 := hwy.MulF16(r, r)
	sinPoly := hwy.FMAF16(s4, r2, s3)
	sinPoly = hwy.FMAF16(sinPoly, r2, s2)
	sinPoly = hwy.FMAF16(sinPoly, r2, s1)
	sinPoly = hwy.FMAF16(sinPoly, r2, one)
	sinR := hwy.MulF16(r, sinPoly)
	cosPoly := hwy.FMAF16(c4, r2, c3)
	cosPoly = hwy.FMAF16(cosPoly, r2, c2)
	cosPoly = hwy.FMAF16(cosPoly, r2, c1)
	cosR := hwy.FMAF16(cosPoly, r2, one)
	cosOctant := hwy.And(hwy.Add(kInt, intOne), intThree)
	useCosMask := hwy.Equal(hwy.And(cosOctant, intOne), intOne)
	negateMask := hwy.Equal(hwy.And(cosOctant, intTwo), intTwo)
	sinRData := func() []hwy.Float16 {
		var _simd_tmp [16]hwy.Float16
		hwy.Store(sinR, _simd_tmp[:])
		return _simd_tmp[:]
	}()
	cosRData := func() []hwy.Float16 {
		var _simd_tmp [16]hwy.Float16
		hwy.Store(cosR, _simd_tmp[:])
		return _simd_tmp[:]
	}()
	resultData := make([]hwy.Float16, len(sinRData))
	for i := range sinRData {
		if useCosMask.GetBit(i) {
			resultData[i] = cosRData[i]
		} else {
			resultData[i] = sinRData[i]
		}
	}
	result := hwy.Load(resultData)
	negResult := hwy.NegF16(result)
	negResultData := func() []hwy.Float16 {
		var _simd_tmp [16]hwy.Float16
		hwy.Store(negResult, _simd_tmp[:])
		return _simd_tmp[:]
	}()
	for i := range resultData {
		if negateMask.GetBit(i) {
			resultData[i] = negResultData[i]
		}
	}
	return hwy.Load(resultData)
}

func BaseCosVec_avx2_BFloat16(x hwy.Vec[hwy.BFloat16]) hwy.Vec[hwy.BFloat16] {
	twoOverPi := hwy.Set[hwy.BFloat16](trig2OverPi_bf16)
	piOver2Hi := hwy.Set[hwy.BFloat16](trigPiOver2Hi_bf16)
	piOver2Lo := hwy.Set[hwy.BFloat16](trigPiOver2Lo_bf16)
	one := hwy.Set[hwy.BFloat16](trigOne_bf16)
	s1 := hwy.Set[hwy.BFloat16](trigS1_bf16)
	s2 := hwy.Set[hwy.BFloat16](trigS2_bf16)
	s3 := hwy.Set[hwy.BFloat16](trigS3_bf16)
	s4 := hwy.Set[hwy.BFloat16](trigS4_bf16)
	c1 := hwy.Set[hwy.BFloat16](trigC1_bf16)
	c2 := hwy.Set[hwy.BFloat16](trigC2_bf16)
	c3 := hwy.Set[hwy.BFloat16](trigC3_bf16)
	c4 := hwy.Set[hwy.BFloat16](trigC4_bf16)
	intOne := hwy.Set[int32](1)
	intTwo := hwy.Set[int32](2)
	intThree := hwy.Set[int32](3)
	kFloat := hwy.RoundToEven(hwy.MulBF16(x, twoOverPi))
	kInt := hwy.ConvertToInt32(kFloat)
	r := hwy.SubBF16(x, hwy.MulBF16(kFloat, piOver2Hi))
	r = hwy.SubBF16(r, hwy.MulBF16(kFloat, piOver2Lo))
	r2 := hwy.MulBF16(r, r)
	sinPoly := hwy.FMABF16(s4, r2, s3)
	sinPoly = hwy.FMABF16(sinPoly, r2, s2)
	sinPoly = hwy.FMABF16(sinPoly, r2, s1)
	sinPoly = hwy.FMABF16(sinPoly, r2, one)
	sinR := hwy.MulBF16(r, sinPoly)
	cosPoly := hwy.FMABF16(c4, r2, c3)
	cosPoly = hwy.FMABF16(cosPoly, r2, c2)
	cosPoly = hwy.FMABF16(cosPoly, r2, c1)
	cosR := hwy.FMABF16(cosPoly, r2, one)
	cosOctant := hwy.And(hwy.Add(kInt, intOne), intThree)
	useCosMask := hwy.Equal(hwy.And(cosOctant, intOne), intOne)
	negateMask := hwy.Equal(hwy.And(cosOctant, intTwo), intTwo)
	sinRData := func() []hwy.BFloat16 {
		var _simd_tmp [16]hwy.BFloat16
		hwy.Store(sinR, _simd_tmp[:])
		return _simd_tmp[:]
	}()
	cosRData := func() []hwy.BFloat16 {
		var _simd_tmp [16]hwy.BFloat16
		hwy.Store(cosR, _simd_tmp[:])
		return _simd_tmp[:]
	}()
	resultData := make([]hwy.BFloat16, len(sinRData))
	for i := range sinRData {
		if useCosMask.GetBit(i) {
			resultData[i] = cosRData[i]
		} else {
			resultData[i] = sinRData[i]
		}
	}
	result := hwy.Load(resultData)
	negResult := hwy.NegBF16(result)
	negResultData := func() []hwy.BFloat16 {
		var _simd_tmp [16]hwy.BFloat16
		hwy.Store(negResult, _simd_tmp[:])
		return _simd_tmp[:]
	}()
	for i := range resultData {
		if negateMask.GetBit(i) {
			resultData[i] = negResultData[i]
		}
	}
	return hwy.Load(resultData)
}

func BaseCosVec_avx2(x archsimd.Float32x8) archsimd.Float32x8 {
	twoOverPi := archsimd.BroadcastFloat32x8(trig2OverPi_f32)
	piOver2Hi := archsimd.BroadcastFloat32x8(trigPiOver2Hi_f32)
	piOver2Lo := archsimd.BroadcastFloat32x8(trigPiOver2Lo_f32)
	one := archsimd.BroadcastFloat32x8(trigOne_f32)
	s1 := archsimd.BroadcastFloat32x8(trigS1_f32)
	s2 := archsimd.BroadcastFloat32x8(trigS2_f32)
	s3 := archsimd.BroadcastFloat32x8(trigS3_f32)
	s4 := archsimd.BroadcastFloat32x8(trigS4_f32)
	c1 := archsimd.BroadcastFloat32x8(trigC1_f32)
	c2 := archsimd.BroadcastFloat32x8(trigC2_f32)
	c3 := archsimd.BroadcastFloat32x8(trigC3_f32)
	c4 := archsimd.BroadcastFloat32x8(trigC4_f32)
	intOne := BaseCosVec_AVX2_intOne_i32_f32
	intTwo := BaseCosVec_AVX2_intTwo_i32_f32
	intThree := BaseCosVec_AVX2_intThree_i32_f32
	kFloat := x.Mul(twoOverPi).RoundToEven()
	kInt := kFloat.ConvertToInt32()
	r := x.Sub(kFloat.Mul(piOver2Hi))
	r = r.Sub(kFloat.Mul(piOver2Lo))
	r2 := r.Mul(r)
	sinPoly := s4.MulAdd(r2, s3)
	sinPoly = sinPoly.MulAdd(r2, s2)
	sinPoly = sinPoly.MulAdd(r2, s1)
	sinPoly = sinPoly.MulAdd(r2, one)
	sinR := r.Mul(sinPoly)
	cosPoly := c4.MulAdd(r2, c3)
	cosPoly = cosPoly.MulAdd(r2, c2)
	cosPoly = cosPoly.MulAdd(r2, c1)
	cosR := cosPoly.MulAdd(r2, one)
	cosOctant := kInt.Add(intOne).And(intThree)
	useCosMask := cosOctant.And(intOne).Equal(intOne)
	negateMask := cosOctant.And(intTwo).Equal(intTwo)
	sinRData := func() []float32 {
		var _simd_tmp [8]float32
		sinR.StoreSlice(_simd_tmp[:])
		return _simd_tmp[:]
	}()
	cosRData := func() []float32 {
		var _simd_tmp [8]float32
		cosR.StoreSlice(_simd_tmp[:])
		return _simd_tmp[:]
	}()
	resultData := make([]float32, len(sinRData))
	for i := range sinRData {
		if func() bool {
			_vOne := archsimd.BroadcastInt32x8(1)
			_vZero := archsimd.BroadcastInt32x8(0)
			_vMasked := _vOne.Merge(_vZero, useCosMask)
			var _simd_mask_tmp [8]int32
			_vMasked.StoreSlice(_simd_mask_tmp[:])
			return _simd_mask_tmp[i] != 0
		}() {
			resultData[i] = cosRData[i]
		} else {
			resultData[i] = sinRData[i]
		}
	}
	result := archsimd.LoadFloat32x8Slice(resultData)
	negResult := archsimd.BroadcastFloat32x8(0).Sub(result)
	negResultData := func() []float32 {
		var _simd_tmp [8]float32
		negResult.StoreSlice(_simd_tmp[:])
		return _simd_tmp[:]
	}()
	for i := range resultData {
		if func() bool {
			_vOne := archsimd.BroadcastInt32x8(1)
			_vZero := archsimd.BroadcastInt32x8(0)
			_vMasked := _vOne.Merge(_vZero, negateMask)
			var _simd_mask_tmp [8]int32
			_vMasked.StoreSlice(_simd_mask_tmp[:])
			return _simd_mask_tmp[i] != 0
		}() {
			resultData[i] = negResultData[i]
		}
	}
	return archsimd.LoadFloat32x8Slice(resultData)
}

func BaseCosVec_avx2_Float64(x archsimd.Float64x4) archsimd.Float64x4 {
	twoOverPi := archsimd.BroadcastFloat64x4(trig2OverPi_f64)
	piOver2Hi := archsimd.BroadcastFloat64x4(trigPiOver2Hi_f64)
	piOver2Lo := archsimd.BroadcastFloat64x4(trigPiOver2Lo_f64)
	one := archsimd.BroadcastFloat64x4(trigOne_f64)
	s1 := archsimd.BroadcastFloat64x4(trigS1_f64)
	s2 := archsimd.BroadcastFloat64x4(trigS2_f64)
	s3 := archsimd.BroadcastFloat64x4(trigS3_f64)
	s4 := archsimd.BroadcastFloat64x4(trigS4_f64)
	c1 := archsimd.BroadcastFloat64x4(trigC1_f64)
	c2 := archsimd.BroadcastFloat64x4(trigC2_f64)
	c3 := archsimd.BroadcastFloat64x4(trigC3_f64)
	c4 := archsimd.BroadcastFloat64x4(trigC4_f64)
	intOne := BaseCosVec_AVX2_intOne_i32_f64
	intTwo := BaseCosVec_AVX2_intTwo_i32_f64
	intThree := BaseCosVec_AVX2_intThree_i32_f64
	kFloat := x.Mul(twoOverPi).RoundToEven()
	kInt := kFloat.ConvertToInt32()
	r := x.Sub(kFloat.Mul(piOver2Hi))
	r = r.Sub(kFloat.Mul(piOver2Lo))
	r2 := r.Mul(r)
	sinPoly := s4.MulAdd(r2, s3)
	sinPoly = sinPoly.MulAdd(r2, s2)
	sinPoly = sinPoly.MulAdd(r2, s1)
	sinPoly = sinPoly.MulAdd(r2, one)
	sinR := r.Mul(sinPoly)
	cosPoly := c4.MulAdd(r2, c3)
	cosPoly = cosPoly.MulAdd(r2, c2)
	cosPoly = cosPoly.MulAdd(r2, c1)
	cosR := cosPoly.MulAdd(r2, one)
	cosOctant := kInt.Add(intOne).And(intThree)
	useCosMask := cosOctant.And(intOne).Equal(intOne)
	negateMask := cosOctant.And(intTwo).Equal(intTwo)
	sinRData := func() []float64 {
		var _simd_tmp [4]float64
		sinR.StoreSlice(_simd_tmp[:])
		return _simd_tmp[:]
	}()
	cosRData := func() []float64 {
		var _simd_tmp [4]float64
		cosR.StoreSlice(_simd_tmp[:])
		return _simd_tmp[:]
	}()
	resultData := make([]float64, len(sinRData))
	for i := range sinRData {
		if func() bool {
			_vOne := archsimd.BroadcastInt32x4(1)
			_vZero := archsimd.BroadcastInt32x4(0)
			_vMasked := _vOne.Merge(_vZero, useCosMask)
			var _simd_mask_tmp [4]int32
			_vMasked.StoreSlice(_simd_mask_tmp[:])
			return _simd_mask_tmp[i] != 0
		}() {
			resultData[i] = cosRData[i]
		} else {
			resultData[i] = sinRData[i]
		}
	}
	result := archsimd.LoadFloat64x4Slice(resultData)
	negResult := archsimd.BroadcastFloat64x4(0).Sub(result)
	negResultData := func() []float64 {
		var _simd_tmp [4]float64
		negResult.StoreSlice(_simd_tmp[:])
		return _simd_tmp[:]
	}()
	for i := range resultData {
		if func() bool {
			_vOne := archsimd.BroadcastInt32x4(1)
			_vZero := archsimd.BroadcastInt32x4(0)
			_vMasked := _vOne.Merge(_vZero, negateMask)
			var _simd_mask_tmp [4]int32
			_vMasked.StoreSlice(_simd_mask_tmp[:])
			return _simd_mask_tmp[i] != 0
		}() {
			resultData[i] = negResultData[i]
		}
	}
	return archsimd.LoadFloat64x4Slice(resultData)
}

func BaseErfVec_avx2_Float16(x hwy.Vec[hwy.Float16]) hwy.Vec[hwy.Float16] {
	a1 := hwy.Set[hwy.Float16](erfA1_f16)
	a2 := hwy.Set[hwy.Float16](erfA2_f16)
	a3 := hwy.Set[hwy.Float16](erfA3_f16)
	a4 := hwy.Set[hwy.Float16](erfA4_f16)
	a5 := hwy.Set[hwy.Float16](erfA5_f16)
	p := hwy.Set[hwy.Float16](erfP_f16)
	one := hwy.Set[hwy.Float16](erfOne_f16)
	zero := hwy.Set[hwy.Float16](erfZero_f16)
	absX := hwy.AbsF16(x)
	signMask := hwy.LessThanF16(x, zero)
	t := hwy.DivF16(one, hwy.AddF16(one, hwy.MulF16(p, absX)))
	poly := hwy.FMAF16(a5, t, a4)
	poly = hwy.FMAF16(poly, t, a3)
	poly = hwy.FMAF16(poly, t, a2)
	poly = hwy.FMAF16(poly, t, a1)
	poly = hwy.MulF16(poly, t)
	x2 := hwy.MulF16(absX, absX)
	negX2 := hwy.NegF16(x2)
	expNegX2 := BaseExpVec_avx2_Float16(negX2)
	erfAbs := hwy.SubF16(one, hwy.MulF16(poly, expNegX2))
	erfAbs = hwy.MaxF16(hwy.MinF16(erfAbs, one), zero)
	negErfAbs := hwy.NegF16(erfAbs)
	result := hwy.IfThenElseF16(signMask, negErfAbs, erfAbs)
	return result
}

func BaseErfVec_avx2_BFloat16(x hwy.Vec[hwy.BFloat16]) hwy.Vec[hwy.BFloat16] {
	a1 := hwy.Set[hwy.BFloat16](erfA1_bf16)
	a2 := hwy.Set[hwy.BFloat16](erfA2_bf16)
	a3 := hwy.Set[hwy.BFloat16](erfA3_bf16)
	a4 := hwy.Set[hwy.BFloat16](erfA4_bf16)
	a5 := hwy.Set[hwy.BFloat16](erfA5_bf16)
	p := hwy.Set[hwy.BFloat16](erfP_bf16)
	one := hwy.Set[hwy.BFloat16](erfOne_bf16)
	zero := hwy.Set[hwy.BFloat16](erfZero_bf16)
	absX := hwy.AbsBF16(x)
	signMask := hwy.LessThanBF16(x, zero)
	t := hwy.DivBF16(one, hwy.AddBF16(one, hwy.MulBF16(p, absX)))
	poly := hwy.FMABF16(a5, t, a4)
	poly = hwy.FMABF16(poly, t, a3)
	poly = hwy.FMABF16(poly, t, a2)
	poly = hwy.FMABF16(poly, t, a1)
	poly = hwy.MulBF16(poly, t)
	x2 := hwy.MulBF16(absX, absX)
	negX2 := hwy.NegBF16(x2)
	expNegX2 := BaseExpVec_avx2_BFloat16(negX2)
	erfAbs := hwy.SubBF16(one, hwy.MulBF16(poly, expNegX2))
	erfAbs = hwy.MaxBF16(hwy.MinBF16(erfAbs, one), zero)
	negErfAbs := hwy.NegBF16(erfAbs)
	result := hwy.IfThenElseBF16(signMask, negErfAbs, erfAbs)
	return result
}

func BaseErfVec_avx2(x archsimd.Float32x8) archsimd.Float32x8 {
	a1 := archsimd.BroadcastFloat32x8(erfA1_f32)
	a2 := archsimd.BroadcastFloat32x8(erfA2_f32)
	a3 := archsimd.BroadcastFloat32x8(erfA3_f32)
	a4 := archsimd.BroadcastFloat32x8(erfA4_f32)
	a5 := archsimd.BroadcastFloat32x8(erfA5_f32)
	p := archsimd.BroadcastFloat32x8(erfP_f32)
	one := archsimd.BroadcastFloat32x8(erfOne_f32)
	zero := archsimd.BroadcastFloat32x8(erfZero_f32)
	absX := x.Max(archsimd.BroadcastFloat32x8(0).Sub(x))
	signMask := x.Less(zero)
	t := one.Div(one.Add(p.Mul(absX)))
	poly := a5.MulAdd(t, a4)
	poly = poly.MulAdd(t, a3)
	poly = poly.MulAdd(t, a2)
	poly = poly.MulAdd(t, a1)
	poly = poly.Mul(t)
	x2 := absX.Mul(absX)
	negX2 := archsimd.BroadcastFloat32x8(0).Sub(x2)
	expNegX2 := BaseExpVec_avx2(negX2)
	erfAbs := one.Sub(poly.Mul(expNegX2))
	erfAbs = erfAbs.Min(one).Max(zero)
	negErfAbs := archsimd.BroadcastFloat32x8(0).Sub(erfAbs)
	result := negErfAbs.Merge(erfAbs, signMask)
	return result
}

func BaseErfVec_avx2_Float64(x archsimd.Float64x4) archsimd.Float64x4 {
	a1 := archsimd.BroadcastFloat64x4(erfA1_f64)
	a2 := archsimd.BroadcastFloat64x4(erfA2_f64)
	a3 := archsimd.BroadcastFloat64x4(erfA3_f64)
	a4 := archsimd.BroadcastFloat64x4(erfA4_f64)
	a5 := archsimd.BroadcastFloat64x4(erfA5_f64)
	p := archsimd.BroadcastFloat64x4(erfP_f64)
	one := archsimd.BroadcastFloat64x4(erfOne_f64)
	zero := archsimd.BroadcastFloat64x4(erfZero_f64)
	absX := x.Max(archsimd.BroadcastFloat64x4(0).Sub(x))
	signMask := x.Less(zero)
	t := one.Div(one.Add(p.Mul(absX)))
	poly := a5.MulAdd(t, a4)
	poly = poly.MulAdd(t, a3)
	poly = poly.MulAdd(t, a2)
	poly = poly.MulAdd(t, a1)
	poly = poly.Mul(t)
	x2 := absX.Mul(absX)
	negX2 := archsimd.BroadcastFloat64x4(0).Sub(x2)
	expNegX2 := BaseExpVec_avx2_Float64(negX2)
	erfAbs := one.Sub(poly.Mul(expNegX2))
	erfAbs = erfAbs.Min(one).Max(zero)
	negErfAbs := archsimd.BroadcastFloat64x4(0).Sub(erfAbs)
	result := negErfAbs.Merge(erfAbs, signMask)
	return result
}

func BaseLog2Vec_avx2_Float16(x hwy.Vec[hwy.Float16]) hwy.Vec[hwy.Float16] {
	log2E := hwy.Set[hwy.Float16](log2E_f16)
	lnX := BaseLogVec_avx2_Float16(x)
	return hwy.MulF16(lnX, log2E)
}

func BaseLog2Vec_avx2_BFloat16(x hwy.Vec[hwy.BFloat16]) hwy.Vec[hwy.BFloat16] {
	log2E := hwy.Set[hwy.BFloat16](log2E_bf16)
	lnX := BaseLogVec_avx2_BFloat16(x)
	return hwy.MulBF16(lnX, log2E)
}

func BaseLog2Vec_avx2(x archsimd.Float32x8) archsimd.Float32x8 {
	log2E := archsimd.BroadcastFloat32x8(log2E_f32)
	lnX := BaseLogVec_avx2(x)
	return lnX.Mul(log2E)
}

func BaseLog2Vec_avx2_Float64(x archsimd.Float64x4) archsimd.Float64x4 {
	log2E := archsimd.BroadcastFloat64x4(log2E_f64)
	lnX := BaseLogVec_avx2_Float64(x)
	return lnX.Mul(log2E)
}

func BaseLog10Vec_avx2_Float16(x hwy.Vec[hwy.Float16]) hwy.Vec[hwy.Float16] {
	log10E := hwy.Set[hwy.Float16](log10E_f16)
	lnX := BaseLogVec_avx2_Float16(x)
	return hwy.MulF16(lnX, log10E)
}

func BaseLog10Vec_avx2_BFloat16(x hwy.Vec[hwy.BFloat16]) hwy.Vec[hwy.BFloat16] {
	log10E := hwy.Set[hwy.BFloat16](log10E_bf16)
	lnX := BaseLogVec_avx2_BFloat16(x)
	return hwy.MulBF16(lnX, log10E)
}

func BaseLog10Vec_avx2(x archsimd.Float32x8) archsimd.Float32x8 {
	log10E := archsimd.BroadcastFloat32x8(log10E_f32)
	lnX := BaseLogVec_avx2(x)
	return lnX.Mul(log10E)
}

func BaseLog10Vec_avx2_Float64(x archsimd.Float64x4) archsimd.Float64x4 {
	log10E := archsimd.BroadcastFloat64x4(log10E_f64)
	lnX := BaseLogVec_avx2_Float64(x)
	return lnX.Mul(log10E)
}

func BaseExp2Vec_avx2_Float16(x hwy.Vec[hwy.Float16]) hwy.Vec[hwy.Float16] {
	ln2 := hwy.Set[hwy.Float16](ln2_f16)
	xLn2 := hwy.MulF16(x, ln2)
	return BaseExpVec_avx2_Float16(xLn2)
}

func BaseExp2Vec_avx2_BFloat16(x hwy.Vec[hwy.BFloat16]) hwy.Vec[hwy.BFloat16] {
	ln2 := hwy.Set[hwy.BFloat16](ln2_bf16)
	xLn2 := hwy.MulBF16(x, ln2)
	return BaseExpVec_avx2_BFloat16(xLn2)
}

func BaseExp2Vec_avx2(x archsimd.Float32x8) archsimd.Float32x8 {
	ln2 := archsimd.BroadcastFloat32x8(ln2_f32)
	xLn2 := x.Mul(ln2)
	return BaseExpVec_avx2(xLn2)
}

func BaseExp2Vec_avx2_Float64(x archsimd.Float64x4) archsimd.Float64x4 {
	ln2 := archsimd.BroadcastFloat64x4(ln2_f64)
	xLn2 := x.Mul(ln2)
	return BaseExpVec_avx2_Float64(xLn2)
}

func BaseSinhVec_avx2_Float16(x hwy.Vec[hwy.Float16]) hwy.Vec[hwy.Float16] {
	one := hwy.Set[hwy.Float16](sinhOne_f16)
	c3 := hwy.Set[hwy.Float16](sinhC3_f16)
	c5 := hwy.Set[hwy.Float16](sinhC5_f16)
	c7 := hwy.Set[hwy.Float16](sinhC7_f16)
	x2 := hwy.MulF16(x, x)
	poly := hwy.FMAF16(c7, x2, c5)
	poly = hwy.FMAF16(poly, x2, c3)
	poly = hwy.FMAF16(poly, x2, one)
	return hwy.MulF16(x, poly)
}

func BaseSinhVec_avx2_BFloat16(x hwy.Vec[hwy.BFloat16]) hwy.Vec[hwy.BFloat16] {
	one := hwy.Set[hwy.BFloat16](sinhOne_bf16)
	c3 := hwy.Set[hwy.BFloat16](sinhC3_bf16)
	c5 := hwy.Set[hwy.BFloat16](sinhC5_bf16)
	c7 := hwy.Set[hwy.BFloat16](sinhC7_bf16)
	x2 := hwy.MulBF16(x, x)
	poly := hwy.FMABF16(c7, x2, c5)
	poly = hwy.FMABF16(poly, x2, c3)
	poly = hwy.FMABF16(poly, x2, one)
	return hwy.MulBF16(x, poly)
}

func BaseSinhVec_avx2(x archsimd.Float32x8) archsimd.Float32x8 {
	one := archsimd.BroadcastFloat32x8(sinhOne_f32)
	c3 := archsimd.BroadcastFloat32x8(sinhC3_f32)
	c5 := archsimd.BroadcastFloat32x8(sinhC5_f32)
	c7 := archsimd.BroadcastFloat32x8(sinhC7_f32)
	x2 := x.Mul(x)
	poly := c7.MulAdd(x2, c5)
	poly = poly.MulAdd(x2, c3)
	poly = poly.MulAdd(x2, one)
	return x.Mul(poly)
}

func BaseSinhVec_avx2_Float64(x archsimd.Float64x4) archsimd.Float64x4 {
	one := archsimd.BroadcastFloat64x4(sinhOne_f64)
	c3 := archsimd.BroadcastFloat64x4(sinhC3_f64)
	c5 := archsimd.BroadcastFloat64x4(sinhC5_f64)
	c7 := archsimd.BroadcastFloat64x4(sinhC7_f64)
	x2 := x.Mul(x)
	poly := c7.MulAdd(x2, c5)
	poly = poly.MulAdd(x2, c3)
	poly = poly.MulAdd(x2, one)
	return x.Mul(poly)
}

func BaseCoshVec_avx2_Float16(x hwy.Vec[hwy.Float16]) hwy.Vec[hwy.Float16] {
	one := hwy.Const[hwy.Float16](1.0)
	c2 := hwy.Const[hwy.Float16](0.5)
	c4 := hwy.Const[hwy.Float16](0.041666666666666664)
	c6 := hwy.Const[hwy.Float16](0.001388888888888889)
	x2 := hwy.MulF16(x, x)
	poly := hwy.FMAF16(c6, x2, c4)
	poly = hwy.FMAF16(poly, x2, c2)
	return hwy.FMAF16(poly, x2, one)
}

func BaseCoshVec_avx2_BFloat16(x hwy.Vec[hwy.BFloat16]) hwy.Vec[hwy.BFloat16] {
	one := hwy.Const[hwy.BFloat16](1.0)
	c2 := hwy.Const[hwy.BFloat16](0.5)
	c4 := hwy.Const[hwy.BFloat16](0.041666666666666664)
	c6 := hwy.Const[hwy.BFloat16](0.001388888888888889)
	x2 := hwy.MulBF16(x, x)
	poly := hwy.FMABF16(c6, x2, c4)
	poly = hwy.FMABF16(poly, x2, c2)
	return hwy.FMABF16(poly, x2, one)
}

func BaseCoshVec_avx2(x archsimd.Float32x8) archsimd.Float32x8 {
	one := archsimd.BroadcastFloat32x8(1.0)
	c2 := archsimd.BroadcastFloat32x8(0.5)
	c4 := archsimd.BroadcastFloat32x8(0.041666666666666664)
	c6 := archsimd.BroadcastFloat32x8(0.001388888888888889)
	x2 := x.Mul(x)
	poly := c6.MulAdd(x2, c4)
	poly = poly.MulAdd(x2, c2)
	return poly.MulAdd(x2, one)
}

func BaseCoshVec_avx2_Float64(x archsimd.Float64x4) archsimd.Float64x4 {
	one := archsimd.BroadcastFloat64x4(1.0)
	c2 := archsimd.BroadcastFloat64x4(0.5)
	c4 := archsimd.BroadcastFloat64x4(0.041666666666666664)
	c6 := archsimd.BroadcastFloat64x4(0.001388888888888889)
	x2 := x.Mul(x)
	poly := c6.MulAdd(x2, c4)
	poly = poly.MulAdd(x2, c2)
	return poly.MulAdd(x2, one)
}

func BaseAsinhVec_avx2_Float16(x hwy.Vec[hwy.Float16]) hwy.Vec[hwy.Float16] {
	one := hwy.Const[hwy.Float16](1.0)
	x2 := hwy.MulF16(x, x)
	x2Plus1 := hwy.AddF16(x2, one)
	sqrtPart := hwy.SqrtF16(x2Plus1)
	arg := hwy.AddF16(x, sqrtPart)
	return BaseLogVec_avx2_Float16(arg)
}

func BaseAsinhVec_avx2_BFloat16(x hwy.Vec[hwy.BFloat16]) hwy.Vec[hwy.BFloat16] {
	one := hwy.Const[hwy.BFloat16](1.0)
	x2 := hwy.MulBF16(x, x)
	x2Plus1 := hwy.AddBF16(x2, one)
	sqrtPart := hwy.SqrtBF16(x2Plus1)
	arg := hwy.AddBF16(x, sqrtPart)
	return BaseLogVec_avx2_BFloat16(arg)
}

func BaseAsinhVec_avx2(x archsimd.Float32x8) archsimd.Float32x8 {
	one := archsimd.BroadcastFloat32x8(1.0)
	x2 := x.Mul(x)
	x2Plus1 := x2.Add(one)
	sqrtPart := x2Plus1.Sqrt()
	arg := x.Add(sqrtPart)
	return BaseLogVec_avx2(arg)
}

func BaseAsinhVec_avx2_Float64(x archsimd.Float64x4) archsimd.Float64x4 {
	one := archsimd.BroadcastFloat64x4(1.0)
	x2 := x.Mul(x)
	x2Plus1 := x2.Add(one)
	sqrtPart := x2Plus1.Sqrt()
	arg := x.Add(sqrtPart)
	return BaseLogVec_avx2_Float64(arg)
}

func BaseAcoshVec_avx2_Float16(x hwy.Vec[hwy.Float16]) hwy.Vec[hwy.Float16] {
	one := hwy.Const[hwy.Float16](1.0)
	zero := hwy.Const[hwy.Float16](0.0)
	x2 := hwy.MulF16(x, x)
	x2Minus1 := hwy.SubF16(x2, one)
	sqrtPart := hwy.SqrtF16(x2Minus1)
	arg := hwy.AddF16(x, sqrtPart)
	result := BaseLogVec_avx2_Float16(arg)
	oneMask := hwy.EqualF16(x, one)
	result = hwy.IfThenElseF16(oneMask, zero, result)
	return result
}

func BaseAcoshVec_avx2_BFloat16(x hwy.Vec[hwy.BFloat16]) hwy.Vec[hwy.BFloat16] {
	one := hwy.Const[hwy.BFloat16](1.0)
	zero := hwy.Const[hwy.BFloat16](0.0)
	x2 := hwy.MulBF16(x, x)
	x2Minus1 := hwy.SubBF16(x2, one)
	sqrtPart := hwy.SqrtBF16(x2Minus1)
	arg := hwy.AddBF16(x, sqrtPart)
	result := BaseLogVec_avx2_BFloat16(arg)
	oneMask := hwy.EqualBF16(x, one)
	result = hwy.IfThenElseBF16(oneMask, zero, result)
	return result
}

func BaseAcoshVec_avx2(x archsimd.Float32x8) archsimd.Float32x8 {
	one := archsimd.BroadcastFloat32x8(1.0)
	zero := archsimd.BroadcastFloat32x8(0.0)
	x2 := x.Mul(x)
	x2Minus1 := x2.Sub(one)
	sqrtPart := x2Minus1.Sqrt()
	arg := x.Add(sqrtPart)
	result := BaseLogVec_avx2(arg)
	oneMask := x.Equal(one)
	result = zero.Merge(result, oneMask)
	return result
}

func BaseAcoshVec_avx2_Float64(x archsimd.Float64x4) archsimd.Float64x4 {
	one := archsimd.BroadcastFloat64x4(1.0)
	zero := archsimd.BroadcastFloat64x4(0.0)
	x2 := x.Mul(x)
	x2Minus1 := x2.Sub(one)
	sqrtPart := x2Minus1.Sqrt()
	arg := x.Add(sqrtPart)
	result := BaseLogVec_avx2_Float64(arg)
	oneMask := x.Equal(one)
	result = zero.Merge(result, oneMask)
	return result
}

func BaseAtanhVec_avx2_Float16(x hwy.Vec[hwy.Float16]) hwy.Vec[hwy.Float16] {
	one := hwy.Const[hwy.Float16](1.0)
	half := hwy.Const[hwy.Float16](0.5)
	zero := hwy.Const[hwy.Float16](0.0)
	onePlusX := hwy.AddF16(one, x)
	oneMinusX := hwy.SubF16(one, x)
	ratio := hwy.DivF16(onePlusX, oneMinusX)
	logRatio := BaseLogVec_avx2_Float16(ratio)
	result := hwy.MulF16(half, logRatio)
	zeroMask := hwy.EqualF16(x, zero)
	result = hwy.IfThenElseF16(zeroMask, zero, result)
	return result
}

func BaseAtanhVec_avx2_BFloat16(x hwy.Vec[hwy.BFloat16]) hwy.Vec[hwy.BFloat16] {
	one := hwy.Const[hwy.BFloat16](1.0)
	half := hwy.Const[hwy.BFloat16](0.5)
	zero := hwy.Const[hwy.BFloat16](0.0)
	onePlusX := hwy.AddBF16(one, x)
	oneMinusX := hwy.SubBF16(one, x)
	ratio := hwy.DivBF16(onePlusX, oneMinusX)
	logRatio := BaseLogVec_avx2_BFloat16(ratio)
	result := hwy.MulBF16(half, logRatio)
	zeroMask := hwy.EqualBF16(x, zero)
	result = hwy.IfThenElseBF16(zeroMask, zero, result)
	return result
}

func BaseAtanhVec_avx2(x archsimd.Float32x8) archsimd.Float32x8 {
	one := archsimd.BroadcastFloat32x8(1.0)
	half := archsimd.BroadcastFloat32x8(0.5)
	zero := archsimd.BroadcastFloat32x8(0.0)
	onePlusX := one.Add(x)
	oneMinusX := one.Sub(x)
	ratio := onePlusX.Div(oneMinusX)
	logRatio := BaseLogVec_avx2(ratio)
	result := half.Mul(logRatio)
	zeroMask := x.Equal(zero)
	result = zero.Merge(result, zeroMask)
	return result
}

func BaseAtanhVec_avx2_Float64(x archsimd.Float64x4) archsimd.Float64x4 {
	one := archsimd.BroadcastFloat64x4(1.0)
	half := archsimd.BroadcastFloat64x4(0.5)
	zero := archsimd.BroadcastFloat64x4(0.0)
	onePlusX := one.Add(x)
	oneMinusX := one.Sub(x)
	ratio := onePlusX.Div(oneMinusX)
	logRatio := BaseLogVec_avx2_Float64(ratio)
	result := half.Mul(logRatio)
	zeroMask := x.Equal(zero)
	result = zero.Merge(result, zeroMask)
	return result
}

func BasePowVec_avx2_Float16(base hwy.Vec[hwy.Float16], exp hwy.Vec[hwy.Float16]) hwy.Vec[hwy.Float16] {
	one := hwy.Const[hwy.Float16](1.0)
	zero := hwy.Const[hwy.Float16](0.0)
	logBase := BaseLogVec_avx2_Float16(base)
	expTimesLog := hwy.MulF16(exp, logBase)
	result := BaseExpVec_avx2_Float16(expTimesLog)
	expZeroMask := hwy.EqualF16(exp, zero)
	result = hwy.IfThenElseF16(expZeroMask, one, result)
	baseOneMask := hwy.EqualF16(base, one)
	result = hwy.IfThenElseF16(baseOneMask, one, result)
	baseZeroMask := hwy.EqualF16(base, zero)
	expPosMask := hwy.GreaterThanF16(exp, zero)
	baseZeroExpPosMask := hwy.MaskAnd(baseZeroMask, expPosMask)
	result = hwy.IfThenElseF16(baseZeroExpPosMask, zero, result)
	return result
}

func BasePowVec_avx2_BFloat16(base hwy.Vec[hwy.BFloat16], exp hwy.Vec[hwy.BFloat16]) hwy.Vec[hwy.BFloat16] {
	one := hwy.Const[hwy.BFloat16](1.0)
	zero := hwy.Const[hwy.BFloat16](0.0)
	logBase := BaseLogVec_avx2_BFloat16(base)
	expTimesLog := hwy.MulBF16(exp, logBase)
	result := BaseExpVec_avx2_BFloat16(expTimesLog)
	expZeroMask := hwy.EqualBF16(exp, zero)
	result = hwy.IfThenElseBF16(expZeroMask, one, result)
	baseOneMask := hwy.EqualBF16(base, one)
	result = hwy.IfThenElseBF16(baseOneMask, one, result)
	baseZeroMask := hwy.EqualBF16(base, zero)
	expPosMask := hwy.GreaterThanBF16(exp, zero)
	baseZeroExpPosMask := hwy.MaskAnd(baseZeroMask, expPosMask)
	result = hwy.IfThenElseBF16(baseZeroExpPosMask, zero, result)
	return result
}

func BasePowVec_avx2(base archsimd.Float32x8, exp archsimd.Float32x8) archsimd.Float32x8 {
	one := archsimd.BroadcastFloat32x8(1.0)
	zero := archsimd.BroadcastFloat32x8(0.0)
	logBase := BaseLogVec_avx2(base)
	expTimesLog := exp.Mul(logBase)
	result := BaseExpVec_avx2(expTimesLog)
	expZeroMask := exp.Equal(zero)
	result = one.Merge(result, expZeroMask)
	baseOneMask := base.Equal(one)
	result = one.Merge(result, baseOneMask)
	baseZeroMask := base.Equal(zero)
	expPosMask := exp.Greater(zero)
	baseZeroExpPosMask := baseZeroMask.And(expPosMask)
	result = zero.Merge(result, baseZeroExpPosMask)
	return result
}

func BasePowVec_avx2_Float64(base archsimd.Float64x4, exp archsimd.Float64x4) archsimd.Float64x4 {
	one := archsimd.BroadcastFloat64x4(1.0)
	zero := archsimd.BroadcastFloat64x4(0.0)
	logBase := BaseLogVec_avx2_Float64(base)
	expTimesLog := exp.Mul(logBase)
	result := BaseExpVec_avx2_Float64(expTimesLog)
	expZeroMask := exp.Equal(zero)
	result = one.Merge(result, expZeroMask)
	baseOneMask := base.Equal(one)
	result = one.Merge(result, baseOneMask)
	baseZeroMask := base.Equal(zero)
	expPosMask := exp.Greater(zero)
	baseZeroExpPosMask := baseZeroMask.And(expPosMask)
	result = zero.Merge(result, baseZeroExpPosMask)
	return result
}
