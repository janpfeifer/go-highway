// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

//go:build amd64 && goexperiment.simd

package math

import (
	"simd/archsimd"
	"unsafe"

	"github.com/ajroetker/go-highway/hwy"
	"github.com/ajroetker/go-highway/hwy/asm"
)

// Hoisted constants - pre-broadcasted at package init time
var (
	BaseCosVec_AVX2_intOne_i32_f32   = archsimd.BroadcastInt32x8(1)
	BaseCosVec_AVX2_intOne_i32_f64   = archsimd.BroadcastInt32x4(1)
	BaseCosVec_AVX2_intThree_i32_f32 = archsimd.BroadcastInt32x8(3)
	BaseCosVec_AVX2_intThree_i32_f64 = archsimd.BroadcastInt32x4(3)
	BaseCosVec_AVX2_intTwo_i32_f32   = archsimd.BroadcastInt32x8(2)
	BaseCosVec_AVX2_intTwo_i32_f64   = archsimd.BroadcastInt32x4(2)
	BaseSinVec_AVX2_intOne_i32_f32   = archsimd.BroadcastInt32x8(1)
	BaseSinVec_AVX2_intOne_i32_f64   = archsimd.BroadcastInt32x4(1)
	BaseSinVec_AVX2_intThree_i32_f32 = archsimd.BroadcastInt32x8(3)
	BaseSinVec_AVX2_intThree_i32_f64 = archsimd.BroadcastInt32x4(3)
	BaseSinVec_AVX2_intTwo_i32_f32   = archsimd.BroadcastInt32x8(2)
	BaseSinVec_AVX2_intTwo_i32_f64   = archsimd.BroadcastInt32x4(2)
)

func BaseExpVec_avx2_Float16(x asm.Float16x8AVX2) asm.Float16x8AVX2 {
	overflow := asm.BroadcastFloat16x8AVX2(uint16(expOverflow_f16))
	underflow := asm.BroadcastFloat16x8AVX2(uint16(expUnderflow_f16))
	one := asm.BroadcastFloat16x8AVX2(uint16(expOne_f16))
	zero := asm.BroadcastFloat16x8AVX2(uint16(expZero_f16))
	inf := asm.BroadcastFloat16x8AVX2(uint16(expOverflow_f16 * 2))
	invLn2 := asm.BroadcastFloat16x8AVX2(uint16(expInvLn2_f16))
	ln2Hi := asm.BroadcastFloat16x8AVX2(uint16(expLn2Hi_f16))
	ln2Lo := asm.BroadcastFloat16x8AVX2(uint16(expLn2Lo_f16))
	c1 := asm.BroadcastFloat16x8AVX2(uint16(expC1_f16))
	c2 := asm.BroadcastFloat16x8AVX2(uint16(expC2_f16))
	c3 := asm.BroadcastFloat16x8AVX2(uint16(expC3_f16))
	c4 := asm.BroadcastFloat16x8AVX2(uint16(expC4_f16))
	c5 := asm.BroadcastFloat16x8AVX2(uint16(expC5_f16))
	c6 := asm.BroadcastFloat16x8AVX2(uint16(expC6_f16))
	overflowMask := x.Greater(overflow)
	underflowMask := x.Less(underflow)
	kFloat := x.Mul(invLn2).RoundToEven()
	r := x.Sub(kFloat.Mul(ln2Hi))
	r = r.Sub(kFloat.Mul(ln2Lo))
	p := c6.MulAdd(r, c5)
	p = p.MulAdd(r, c4)
	p = p.MulAdd(r, c3)
	p = p.MulAdd(r, c2)
	p = p.MulAdd(r, c1)
	p = p.MulAdd(r, one)
	kInt := kFloat.ConvertToInt32()
	scale := asm.Float16x8AVX2FromFloat32x8(hwy.Pow2_AVX2_F32x8(kInt))
	result := p.Mul(scale)
	result = inf.Merge(result, overflowMask)
	result = zero.Merge(result, underflowMask)
	return result
}

func BaseExpVec_avx2_BFloat16(x asm.BFloat16x8AVX2) asm.BFloat16x8AVX2 {
	overflow := asm.BroadcastBFloat16x8AVX2(uint16(expOverflow_bf16))
	underflow := asm.BroadcastBFloat16x8AVX2(uint16(expUnderflow_bf16))
	one := asm.BroadcastBFloat16x8AVX2(uint16(expOne_bf16))
	zero := asm.BroadcastBFloat16x8AVX2(uint16(expZero_bf16))
	inf := asm.BroadcastBFloat16x8AVX2(uint16(expOverflow_bf16 * 2))
	invLn2 := asm.BroadcastBFloat16x8AVX2(uint16(expInvLn2_bf16))
	ln2Hi := asm.BroadcastBFloat16x8AVX2(uint16(expLn2Hi_bf16))
	ln2Lo := asm.BroadcastBFloat16x8AVX2(uint16(expLn2Lo_bf16))
	c1 := asm.BroadcastBFloat16x8AVX2(uint16(expC1_bf16))
	c2 := asm.BroadcastBFloat16x8AVX2(uint16(expC2_bf16))
	c3 := asm.BroadcastBFloat16x8AVX2(uint16(expC3_bf16))
	c4 := asm.BroadcastBFloat16x8AVX2(uint16(expC4_bf16))
	c5 := asm.BroadcastBFloat16x8AVX2(uint16(expC5_bf16))
	c6 := asm.BroadcastBFloat16x8AVX2(uint16(expC6_bf16))
	overflowMask := x.Greater(overflow)
	underflowMask := x.Less(underflow)
	kFloat := x.Mul(invLn2).RoundToEven()
	r := x.Sub(kFloat.Mul(ln2Hi))
	r = r.Sub(kFloat.Mul(ln2Lo))
	p := c6.MulAdd(r, c5)
	p = p.MulAdd(r, c4)
	p = p.MulAdd(r, c3)
	p = p.MulAdd(r, c2)
	p = p.MulAdd(r, c1)
	p = p.MulAdd(r, one)
	kInt := kFloat.ConvertToInt32()
	scale := asm.BFloat16x8AVX2FromFloat32x8(hwy.Pow2_AVX2_F32x8(kInt))
	result := p.Mul(scale)
	result = inf.Merge(result, overflowMask)
	result = zero.Merge(result, underflowMask)
	return result
}

func BaseExpVec_avx2(x archsimd.Float32x8) archsimd.Float32x8 {
	overflow := archsimd.BroadcastFloat32x8(expOverflow_f32)
	underflow := archsimd.BroadcastFloat32x8(expUnderflow_f32)
	one := archsimd.BroadcastFloat32x8(expOne_f32)
	zero := archsimd.BroadcastFloat32x8(expZero_f32)
	inf := archsimd.BroadcastFloat32x8(expOverflow_f32 * 2)
	invLn2 := archsimd.BroadcastFloat32x8(expInvLn2_f32)
	ln2Hi := archsimd.BroadcastFloat32x8(expLn2Hi_f32)
	ln2Lo := archsimd.BroadcastFloat32x8(expLn2Lo_f32)
	c1 := archsimd.BroadcastFloat32x8(expC1_f32)
	c2 := archsimd.BroadcastFloat32x8(expC2_f32)
	c3 := archsimd.BroadcastFloat32x8(expC3_f32)
	c4 := archsimd.BroadcastFloat32x8(expC4_f32)
	c5 := archsimd.BroadcastFloat32x8(expC5_f32)
	c6 := archsimd.BroadcastFloat32x8(expC6_f32)
	overflowMask := x.Greater(overflow)
	underflowMask := x.Less(underflow)
	kFloat := x.Mul(invLn2).RoundToEven()
	r := x.Sub(kFloat.Mul(ln2Hi))
	r = r.Sub(kFloat.Mul(ln2Lo))
	p := c6.MulAdd(r, c5)
	p = p.MulAdd(r, c4)
	p = p.MulAdd(r, c3)
	p = p.MulAdd(r, c2)
	p = p.MulAdd(r, c1)
	p = p.MulAdd(r, one)
	kInt := kFloat.ConvertToInt32()
	scale := hwy.Pow2_AVX2_F32x8(kInt)
	result := p.Mul(scale)
	result = inf.Merge(result, overflowMask)
	result = zero.Merge(result, underflowMask)
	return result
}

func BaseExpVec_avx2_Float64(x archsimd.Float64x4) archsimd.Float64x4 {
	overflow := archsimd.BroadcastFloat64x4(expOverflow_f64)
	underflow := archsimd.BroadcastFloat64x4(expUnderflow_f64)
	one := archsimd.BroadcastFloat64x4(expOne_f64)
	zero := archsimd.BroadcastFloat64x4(expZero_f64)
	inf := archsimd.BroadcastFloat64x4(expOverflow_f64 * 2)
	invLn2 := archsimd.BroadcastFloat64x4(expInvLn2_f64)
	ln2Hi := archsimd.BroadcastFloat64x4(expLn2Hi_f64)
	ln2Lo := archsimd.BroadcastFloat64x4(expLn2Lo_f64)
	c1 := archsimd.BroadcastFloat64x4(expC1_f64)
	c2 := archsimd.BroadcastFloat64x4(expC2_f64)
	c3 := archsimd.BroadcastFloat64x4(expC3_f64)
	c4 := archsimd.BroadcastFloat64x4(expC4_f64)
	c5 := archsimd.BroadcastFloat64x4(expC5_f64)
	c6 := archsimd.BroadcastFloat64x4(expC6_f64)
	overflowMask := x.Greater(overflow)
	underflowMask := x.Less(underflow)
	kFloat := x.Mul(invLn2).RoundToEven()
	r := x.Sub(kFloat.Mul(ln2Hi))
	r = r.Sub(kFloat.Mul(ln2Lo))
	p := c6.MulAdd(r, c5)
	p = p.MulAdd(r, c4)
	p = p.MulAdd(r, c3)
	p = p.MulAdd(r, c2)
	p = p.MulAdd(r, c1)
	p = p.MulAdd(r, one)
	kInt := kFloat.ConvertToInt32()
	scale := hwy.Pow2_AVX2_F64x4(kInt)
	result := p.Mul(scale)
	result = inf.Merge(result, overflowMask)
	result = zero.Merge(result, underflowMask)
	return result
}

func BaseSigmoidVec_avx2_Float16(x asm.Float16x8AVX2) asm.Float16x8AVX2 {
	one := asm.BroadcastFloat16x8AVX2(uint16(sigmoidOne_f16))
	zero := asm.BroadcastFloat16x8AVX2(uint16(sigmoidZero_f16))
	satHi := asm.BroadcastFloat16x8AVX2(uint16(sigmoidSatHi_f16))
	satLo := asm.BroadcastFloat16x8AVX2(uint16(sigmoidSatLo_f16))
	clampedX := x.Min(satHi).Max(satLo)
	negX := clampedX.Neg()
	expNegX := BaseExpVec_avx2_Float16(negX)
	result := one.Div(one.Add(expNegX))
	result = one.Merge(result, x.Greater(satHi))
	result = zero.Merge(result, x.Less(satLo))
	return result
}

func BaseSigmoidVec_avx2_BFloat16(x asm.BFloat16x8AVX2) asm.BFloat16x8AVX2 {
	one := asm.BroadcastBFloat16x8AVX2(uint16(sigmoidOne_bf16))
	zero := asm.BroadcastBFloat16x8AVX2(uint16(sigmoidZero_bf16))
	satHi := asm.BroadcastBFloat16x8AVX2(uint16(sigmoidSatHi_bf16))
	satLo := asm.BroadcastBFloat16x8AVX2(uint16(sigmoidSatLo_bf16))
	clampedX := x.Min(satHi).Max(satLo)
	negX := clampedX.Neg()
	expNegX := BaseExpVec_avx2_BFloat16(negX)
	result := one.Div(one.Add(expNegX))
	result = one.Merge(result, x.Greater(satHi))
	result = zero.Merge(result, x.Less(satLo))
	return result
}

func BaseSigmoidVec_avx2(x archsimd.Float32x8) archsimd.Float32x8 {
	one := archsimd.BroadcastFloat32x8(sigmoidOne_f32)
	zero := archsimd.BroadcastFloat32x8(sigmoidZero_f32)
	satHi := archsimd.BroadcastFloat32x8(sigmoidSatHi_f32)
	satLo := archsimd.BroadcastFloat32x8(sigmoidSatLo_f32)
	clampedX := x.Min(satHi).Max(satLo)
	negX := archsimd.BroadcastFloat32x8(0).Sub(clampedX)
	expNegX := BaseExpVec_avx2(negX)
	result := one.Div(one.Add(expNegX))
	result = one.Merge(result, x.Greater(satHi))
	result = zero.Merge(result, x.Less(satLo))
	return result
}

func BaseSigmoidVec_avx2_Float64(x archsimd.Float64x4) archsimd.Float64x4 {
	one := archsimd.BroadcastFloat64x4(sigmoidOne_f64)
	zero := archsimd.BroadcastFloat64x4(sigmoidZero_f64)
	satHi := archsimd.BroadcastFloat64x4(sigmoidSatHi_f64)
	satLo := archsimd.BroadcastFloat64x4(sigmoidSatLo_f64)
	clampedX := x.Min(satHi).Max(satLo)
	negX := archsimd.BroadcastFloat64x4(0).Sub(clampedX)
	expNegX := BaseExpVec_avx2_Float64(negX)
	result := one.Div(one.Add(expNegX))
	result = one.Merge(result, x.Greater(satHi))
	result = zero.Merge(result, x.Less(satLo))
	return result
}

func BaseTanhVec_avx2_Float16(x asm.Float16x8AVX2) asm.Float16x8AVX2 {
	two := asm.BroadcastFloat16x8AVX2(uint16(hwy.Float32ToFloat16(float32(2.0))))
	one := asm.BroadcastFloat16x8AVX2(uint16(tanhOne_f16))
	negOne := asm.BroadcastFloat16x8AVX2(uint16(tanhNegOne_f16))
	threshold := asm.BroadcastFloat16x8AVX2(uint16(tanhClamp_f16))
	negThreshold := threshold.Neg()
	twoX := two.Mul(x)
	sigTwoX := BaseSigmoidVec_avx2_Float16(twoX)
	result := two.Mul(sigTwoX).Sub(one)
	result = one.Merge(result, x.Greater(threshold))
	result = negOne.Merge(result, x.Less(negThreshold))
	return result
}

func BaseTanhVec_avx2_BFloat16(x asm.BFloat16x8AVX2) asm.BFloat16x8AVX2 {
	two := asm.BroadcastBFloat16x8AVX2(uint16(hwy.Float32ToBFloat16(float32(2.0))))
	one := asm.BroadcastBFloat16x8AVX2(uint16(tanhOne_bf16))
	negOne := asm.BroadcastBFloat16x8AVX2(uint16(tanhNegOne_bf16))
	threshold := asm.BroadcastBFloat16x8AVX2(uint16(tanhClamp_bf16))
	negThreshold := threshold.Neg()
	twoX := two.Mul(x)
	sigTwoX := BaseSigmoidVec_avx2_BFloat16(twoX)
	result := two.Mul(sigTwoX).Sub(one)
	result = one.Merge(result, x.Greater(threshold))
	result = negOne.Merge(result, x.Less(negThreshold))
	return result
}

func BaseTanhVec_avx2(x archsimd.Float32x8) archsimd.Float32x8 {
	two := archsimd.BroadcastFloat32x8(2.0)
	one := archsimd.BroadcastFloat32x8(tanhOne_f32)
	negOne := archsimd.BroadcastFloat32x8(tanhNegOne_f32)
	threshold := archsimd.BroadcastFloat32x8(tanhClamp_f32)
	negThreshold := archsimd.BroadcastFloat32x8(0).Sub(threshold)
	twoX := two.Mul(x)
	sigTwoX := BaseSigmoidVec_avx2(twoX)
	result := two.Mul(sigTwoX).Sub(one)
	result = one.Merge(result, x.Greater(threshold))
	result = negOne.Merge(result, x.Less(negThreshold))
	return result
}

func BaseTanhVec_avx2_Float64(x archsimd.Float64x4) archsimd.Float64x4 {
	two := archsimd.BroadcastFloat64x4(2.0)
	one := archsimd.BroadcastFloat64x4(tanhOne_f64)
	negOne := archsimd.BroadcastFloat64x4(tanhNegOne_f64)
	threshold := archsimd.BroadcastFloat64x4(tanhClamp_f64)
	negThreshold := archsimd.BroadcastFloat64x4(0).Sub(threshold)
	twoX := two.Mul(x)
	sigTwoX := BaseSigmoidVec_avx2_Float64(twoX)
	result := two.Mul(sigTwoX).Sub(one)
	result = one.Merge(result, x.Greater(threshold))
	result = negOne.Merge(result, x.Less(negThreshold))
	return result
}

func BaseLogVec_avx2_Float16(x asm.Float16x8AVX2) asm.Float16x8AVX2 {
	one := asm.BroadcastFloat16x8AVX2(uint16(logOne_f16))
	two := asm.BroadcastFloat16x8AVX2(uint16(logTwo_f16))
	zero := asm.BroadcastFloat16x8AVX2(uint16(hwy.Float32ToFloat16(float32(0.0))))
	ln2Hi := asm.BroadcastFloat16x8AVX2(uint16(logLn2Hi_f16))
	ln2Lo := asm.BroadcastFloat16x8AVX2(uint16(logLn2Lo_f16))
	negInf := asm.BroadcastFloat16x8AVX2(uint16(logNegInf_f16))
	nan := asm.BroadcastFloat16x8AVX2(uint16(hwy.Float32ToFloat16(float32(0.0))))
	c1 := asm.BroadcastFloat16x8AVX2(uint16(logC1_f16))
	c2 := asm.BroadcastFloat16x8AVX2(uint16(logC2_f16))
	c3 := asm.BroadcastFloat16x8AVX2(uint16(logC3_f16))
	c4 := asm.BroadcastFloat16x8AVX2(uint16(logC4_f16))
	c5 := asm.BroadcastFloat16x8AVX2(uint16(logC5_f16))
	zeroMask := x.Equal(zero)
	negMask := x.Less(zero)
	oneMask := x.Equal(one)
	e := x.AsInt32x8().ShiftAllRight(23).And(archsimd.BroadcastInt32x8(255)).Sub(archsimd.BroadcastInt32x8(127))
	m := asm.Float16x8AVX2FromFloat32x8(x.AsInt32x8().And(archsimd.BroadcastInt32x8(8388607)).Or(archsimd.BroadcastInt32x8(1065353216)).AsFloat32x8())
	mLarge := m.Greater(asm.BroadcastFloat16x8AVX2(uint16(logSqrt2_f16)))
	mAdjusted := m.Mul(asm.BroadcastFloat16x8AVX2(uint16(logHalf_f16))).Merge(m, mLarge)
	eFloat := asm.Float16x8AVX2FromFloat32x8(e.ConvertToFloat32())
	eAdjusted := eFloat.Add(one).Merge(eFloat, mLarge)
	mMinus1 := mAdjusted.Sub(one)
	mPlus1 := mAdjusted.Add(one)
	y := mMinus1.Div(mPlus1)
	y2 := y.Mul(y)
	poly := c5.MulAdd(y2, c4)
	poly = poly.MulAdd(y2, c3)
	poly = poly.MulAdd(y2, c2)
	poly = poly.MulAdd(y2, c1)
	logM := two.Mul(y).Mul(poly)
	result := eAdjusted.MulAdd(ln2Hi, logM).Add(eAdjusted.Mul(ln2Lo))
	result = negInf.Merge(result, zeroMask)
	result = nan.Merge(result, negMask)
	result = zero.Merge(result, oneMask)
	return result
}

func BaseLogVec_avx2_BFloat16(x asm.BFloat16x8AVX2) asm.BFloat16x8AVX2 {
	one := asm.BroadcastBFloat16x8AVX2(uint16(logOne_bf16))
	two := asm.BroadcastBFloat16x8AVX2(uint16(logTwo_bf16))
	zero := asm.BroadcastBFloat16x8AVX2(uint16(hwy.Float32ToBFloat16(float32(0.0))))
	ln2Hi := asm.BroadcastBFloat16x8AVX2(uint16(logLn2Hi_bf16))
	ln2Lo := asm.BroadcastBFloat16x8AVX2(uint16(logLn2Lo_bf16))
	negInf := asm.BroadcastBFloat16x8AVX2(uint16(logNegInf_bf16))
	nan := asm.BroadcastBFloat16x8AVX2(uint16(hwy.Float32ToBFloat16(float32(0.0))))
	c1 := asm.BroadcastBFloat16x8AVX2(uint16(logC1_bf16))
	c2 := asm.BroadcastBFloat16x8AVX2(uint16(logC2_bf16))
	c3 := asm.BroadcastBFloat16x8AVX2(uint16(logC3_bf16))
	c4 := asm.BroadcastBFloat16x8AVX2(uint16(logC4_bf16))
	c5 := asm.BroadcastBFloat16x8AVX2(uint16(logC5_bf16))
	zeroMask := x.Equal(zero)
	negMask := x.Less(zero)
	oneMask := x.Equal(one)
	e := x.AsInt32x8().ShiftAllRight(23).And(archsimd.BroadcastInt32x8(255)).Sub(archsimd.BroadcastInt32x8(127))
	m := asm.BFloat16x8AVX2FromFloat32x8(x.AsInt32x8().And(archsimd.BroadcastInt32x8(8388607)).Or(archsimd.BroadcastInt32x8(1065353216)).AsFloat32x8())
	mLarge := m.Greater(asm.BroadcastBFloat16x8AVX2(uint16(logSqrt2_bf16)))
	mAdjusted := m.Mul(asm.BroadcastBFloat16x8AVX2(uint16(logHalf_bf16))).Merge(m, mLarge)
	eFloat := asm.BFloat16x8AVX2FromFloat32x8(e.ConvertToFloat32())
	eAdjusted := eFloat.Add(one).Merge(eFloat, mLarge)
	mMinus1 := mAdjusted.Sub(one)
	mPlus1 := mAdjusted.Add(one)
	y := mMinus1.Div(mPlus1)
	y2 := y.Mul(y)
	poly := c5.MulAdd(y2, c4)
	poly = poly.MulAdd(y2, c3)
	poly = poly.MulAdd(y2, c2)
	poly = poly.MulAdd(y2, c1)
	logM := two.Mul(y).Mul(poly)
	result := eAdjusted.MulAdd(ln2Hi, logM).Add(eAdjusted.Mul(ln2Lo))
	result = negInf.Merge(result, zeroMask)
	result = nan.Merge(result, negMask)
	result = zero.Merge(result, oneMask)
	return result
}

func BaseLogVec_avx2(x archsimd.Float32x8) archsimd.Float32x8 {
	one := archsimd.BroadcastFloat32x8(logOne_f32)
	two := archsimd.BroadcastFloat32x8(logTwo_f32)
	zero := archsimd.BroadcastFloat32x8(0.0)
	ln2Hi := archsimd.BroadcastFloat32x8(logLn2Hi_f32)
	ln2Lo := archsimd.BroadcastFloat32x8(logLn2Lo_f32)
	negInf := archsimd.BroadcastFloat32x8(logNegInf_f32)
	nan := archsimd.BroadcastFloat32x8(0.0)
	c1 := archsimd.BroadcastFloat32x8(logC1_f32)
	c2 := archsimd.BroadcastFloat32x8(logC2_f32)
	c3 := archsimd.BroadcastFloat32x8(logC3_f32)
	c4 := archsimd.BroadcastFloat32x8(logC4_f32)
	c5 := archsimd.BroadcastFloat32x8(logC5_f32)
	zeroMask := x.Equal(zero)
	negMask := x.Less(zero)
	oneMask := x.Equal(one)
	e := x.AsInt32x8().ShiftAllRight(23).And(archsimd.BroadcastInt32x8(255)).Sub(archsimd.BroadcastInt32x8(127))
	m := x.AsInt32x8().And(archsimd.BroadcastInt32x8(8388607)).Or(archsimd.BroadcastInt32x8(1065353216)).AsFloat32x8()
	mLarge := m.Greater(archsimd.BroadcastFloat32x8(logSqrt2_f32))
	mAdjusted := m.Mul(archsimd.BroadcastFloat32x8(logHalf_f32)).Merge(m, mLarge)
	eFloat := e.ConvertToFloat32()
	eAdjusted := eFloat.Add(one).Merge(eFloat, mLarge)
	mMinus1 := mAdjusted.Sub(one)
	mPlus1 := mAdjusted.Add(one)
	y := mMinus1.Div(mPlus1)
	y2 := y.Mul(y)
	poly := c5.MulAdd(y2, c4)
	poly = poly.MulAdd(y2, c3)
	poly = poly.MulAdd(y2, c2)
	poly = poly.MulAdd(y2, c1)
	logM := two.Mul(y).Mul(poly)
	result := eAdjusted.MulAdd(ln2Hi, logM).Add(eAdjusted.Mul(ln2Lo))
	result = negInf.Merge(result, zeroMask)
	result = nan.Merge(result, negMask)
	result = zero.Merge(result, oneMask)
	return result
}

func BaseLogVec_avx2_Float64(x archsimd.Float64x4) archsimd.Float64x4 {
	one := archsimd.BroadcastFloat64x4(logOne_f64)
	two := archsimd.BroadcastFloat64x4(logTwo_f64)
	zero := archsimd.BroadcastFloat64x4(0.0)
	ln2Hi := archsimd.BroadcastFloat64x4(logLn2Hi_f64)
	ln2Lo := archsimd.BroadcastFloat64x4(logLn2Lo_f64)
	negInf := archsimd.BroadcastFloat64x4(logNegInf_f64)
	nan := archsimd.BroadcastFloat64x4(0.0)
	c1 := archsimd.BroadcastFloat64x4(logC1_f64)
	c2 := archsimd.BroadcastFloat64x4(logC2_f64)
	c3 := archsimd.BroadcastFloat64x4(logC3_f64)
	c4 := archsimd.BroadcastFloat64x4(logC4_f64)
	c5 := archsimd.BroadcastFloat64x4(logC5_f64)
	zeroMask := x.Equal(zero)
	negMask := x.Less(zero)
	oneMask := x.Equal(one)
	e := x.AsInt64x4().ShiftAllRight(52).And(archsimd.BroadcastInt64x4(2047)).Sub(archsimd.BroadcastInt64x4(1023))
	m := x.AsInt64x4().And(archsimd.BroadcastInt64x4(4503599627370495)).Or(archsimd.BroadcastInt64x4(4607182418800017408)).AsFloat64x4()
	mLarge := m.Greater(archsimd.BroadcastFloat64x4(logSqrt2_f64))
	mAdjusted := m.Mul(archsimd.BroadcastFloat64x4(logHalf_f64)).Merge(m, mLarge)
	eFloat := e.ConvertToFloat64()
	eAdjusted := eFloat.Add(one).Merge(eFloat, mLarge)
	mMinus1 := mAdjusted.Sub(one)
	mPlus1 := mAdjusted.Add(one)
	y := mMinus1.Div(mPlus1)
	y2 := y.Mul(y)
	poly := c5.MulAdd(y2, c4)
	poly = poly.MulAdd(y2, c3)
	poly = poly.MulAdd(y2, c2)
	poly = poly.MulAdd(y2, c1)
	logM := two.Mul(y).Mul(poly)
	result := eAdjusted.MulAdd(ln2Hi, logM).Add(eAdjusted.Mul(ln2Lo))
	result = negInf.Merge(result, zeroMask)
	result = nan.Merge(result, negMask)
	result = zero.Merge(result, oneMask)
	return result
}

func BaseSinVec_avx2_Float16(x asm.Float16x8AVX2) asm.Float16x8AVX2 {
	twoOverPi := asm.BroadcastFloat16x8AVX2(uint16(trig2OverPi_f16))
	piOver2Hi := asm.BroadcastFloat16x8AVX2(uint16(trigPiOver2Hi_f16))
	piOver2Lo := asm.BroadcastFloat16x8AVX2(uint16(trigPiOver2Lo_f16))
	one := asm.BroadcastFloat16x8AVX2(uint16(trigOne_f16))
	s1 := asm.BroadcastFloat16x8AVX2(uint16(trigS1_f16))
	s2 := asm.BroadcastFloat16x8AVX2(uint16(trigS2_f16))
	s3 := asm.BroadcastFloat16x8AVX2(uint16(trigS3_f16))
	s4 := asm.BroadcastFloat16x8AVX2(uint16(trigS4_f16))
	c1 := asm.BroadcastFloat16x8AVX2(uint16(trigC1_f16))
	c2 := asm.BroadcastFloat16x8AVX2(uint16(trigC2_f16))
	c3 := asm.BroadcastFloat16x8AVX2(uint16(trigC3_f16))
	c4 := asm.BroadcastFloat16x8AVX2(uint16(trigC4_f16))
	intOne := BaseSinVec_AVX2_intOne_i32_f32
	intTwo := BaseSinVec_AVX2_intTwo_i32_f32
	intThree := BaseSinVec_AVX2_intThree_i32_f32
	kFloat := x.Mul(twoOverPi).RoundToEven()
	kInt := kFloat.ConvertToInt32()
	r := x.Sub(kFloat.Mul(piOver2Hi))
	r = r.Sub(kFloat.Mul(piOver2Lo))
	r2 := r.Mul(r)
	sinPoly := s4.MulAdd(r2, s3)
	sinPoly = sinPoly.MulAdd(r2, s2)
	sinPoly = sinPoly.MulAdd(r2, s1)
	sinPoly = sinPoly.MulAdd(r2, one)
	sinR := r.Mul(sinPoly)
	cosPoly := c4.MulAdd(r2, c3)
	cosPoly = cosPoly.MulAdd(r2, c2)
	cosPoly = cosPoly.MulAdd(r2, c1)
	cosR := cosPoly.MulAdd(r2, one)
	octant := kInt.And(intThree)
	useCosMask := octant.And(intOne).Equal(intOne)
	negateMask := octant.And(intTwo).Equal(intTwo)
	sinRData := func() []hwy.Float16 {
		var _simd_tmp [8]hwy.Float16
		sinR.StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(_simd_tmp[:]))), len(_simd_tmp[:])))
		return _simd_tmp[:]
	}()
	cosRData := func() []hwy.Float16 {
		var _simd_tmp [8]hwy.Float16
		cosR.StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(_simd_tmp[:]))), len(_simd_tmp[:])))
		return _simd_tmp[:]
	}()
	resultData := make([]hwy.Float16, len(sinRData))
	for i := range sinRData {
		if func() bool {
			_vOne := archsimd.BroadcastInt32x8(1)
			_vZero := archsimd.BroadcastInt32x8(0)
			_vMasked := _vOne.Merge(_vZero, useCosMask)
			var _simd_mask_tmp [8]int32
			_vMasked.StoreSlice(_simd_mask_tmp[:])
			return _simd_mask_tmp[i] != 0
		}() {
			resultData[i] = cosRData[i]
		} else {
			resultData[i] = sinRData[i]
		}
	}
	result := asm.LoadFloat16x8AVX2Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(resultData))), len(resultData)))
	negResult := result.Neg()
	negResultData := func() []hwy.Float16 {
		var _simd_tmp [8]hwy.Float16
		negResult.StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(_simd_tmp[:]))), len(_simd_tmp[:])))
		return _simd_tmp[:]
	}()
	for i := range resultData {
		if func() bool {
			_vOne := archsimd.BroadcastInt32x8(1)
			_vZero := archsimd.BroadcastInt32x8(0)
			_vMasked := _vOne.Merge(_vZero, negateMask)
			var _simd_mask_tmp [8]int32
			_vMasked.StoreSlice(_simd_mask_tmp[:])
			return _simd_mask_tmp[i] != 0
		}() {
			resultData[i] = negResultData[i]
		}
	}
	return asm.LoadFloat16x8AVX2Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(resultData))), len(resultData)))
}

func BaseSinVec_avx2_BFloat16(x asm.BFloat16x8AVX2) asm.BFloat16x8AVX2 {
	twoOverPi := asm.BroadcastBFloat16x8AVX2(uint16(trig2OverPi_bf16))
	piOver2Hi := asm.BroadcastBFloat16x8AVX2(uint16(trigPiOver2Hi_bf16))
	piOver2Lo := asm.BroadcastBFloat16x8AVX2(uint16(trigPiOver2Lo_bf16))
	one := asm.BroadcastBFloat16x8AVX2(uint16(trigOne_bf16))
	s1 := asm.BroadcastBFloat16x8AVX2(uint16(trigS1_bf16))
	s2 := asm.BroadcastBFloat16x8AVX2(uint16(trigS2_bf16))
	s3 := asm.BroadcastBFloat16x8AVX2(uint16(trigS3_bf16))
	s4 := asm.BroadcastBFloat16x8AVX2(uint16(trigS4_bf16))
	c1 := asm.BroadcastBFloat16x8AVX2(uint16(trigC1_bf16))
	c2 := asm.BroadcastBFloat16x8AVX2(uint16(trigC2_bf16))
	c3 := asm.BroadcastBFloat16x8AVX2(uint16(trigC3_bf16))
	c4 := asm.BroadcastBFloat16x8AVX2(uint16(trigC4_bf16))
	intOne := BaseSinVec_AVX2_intOne_i32_f32
	intTwo := BaseSinVec_AVX2_intTwo_i32_f32
	intThree := BaseSinVec_AVX2_intThree_i32_f32
	kFloat := x.Mul(twoOverPi).RoundToEven()
	kInt := kFloat.ConvertToInt32()
	r := x.Sub(kFloat.Mul(piOver2Hi))
	r = r.Sub(kFloat.Mul(piOver2Lo))
	r2 := r.Mul(r)
	sinPoly := s4.MulAdd(r2, s3)
	sinPoly = sinPoly.MulAdd(r2, s2)
	sinPoly = sinPoly.MulAdd(r2, s1)
	sinPoly = sinPoly.MulAdd(r2, one)
	sinR := r.Mul(sinPoly)
	cosPoly := c4.MulAdd(r2, c3)
	cosPoly = cosPoly.MulAdd(r2, c2)
	cosPoly = cosPoly.MulAdd(r2, c1)
	cosR := cosPoly.MulAdd(r2, one)
	octant := kInt.And(intThree)
	useCosMask := octant.And(intOne).Equal(intOne)
	negateMask := octant.And(intTwo).Equal(intTwo)
	sinRData := func() []hwy.BFloat16 {
		var _simd_tmp [8]hwy.BFloat16
		sinR.StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(_simd_tmp[:]))), len(_simd_tmp[:])))
		return _simd_tmp[:]
	}()
	cosRData := func() []hwy.BFloat16 {
		var _simd_tmp [8]hwy.BFloat16
		cosR.StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(_simd_tmp[:]))), len(_simd_tmp[:])))
		return _simd_tmp[:]
	}()
	resultData := make([]hwy.BFloat16, len(sinRData))
	for i := range sinRData {
		if func() bool {
			_vOne := archsimd.BroadcastInt32x8(1)
			_vZero := archsimd.BroadcastInt32x8(0)
			_vMasked := _vOne.Merge(_vZero, useCosMask)
			var _simd_mask_tmp [8]int32
			_vMasked.StoreSlice(_simd_mask_tmp[:])
			return _simd_mask_tmp[i] != 0
		}() {
			resultData[i] = cosRData[i]
		} else {
			resultData[i] = sinRData[i]
		}
	}
	result := asm.LoadBFloat16x8AVX2Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(resultData))), len(resultData)))
	negResult := result.Neg()
	negResultData := func() []hwy.BFloat16 {
		var _simd_tmp [8]hwy.BFloat16
		negResult.StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(_simd_tmp[:]))), len(_simd_tmp[:])))
		return _simd_tmp[:]
	}()
	for i := range resultData {
		if func() bool {
			_vOne := archsimd.BroadcastInt32x8(1)
			_vZero := archsimd.BroadcastInt32x8(0)
			_vMasked := _vOne.Merge(_vZero, negateMask)
			var _simd_mask_tmp [8]int32
			_vMasked.StoreSlice(_simd_mask_tmp[:])
			return _simd_mask_tmp[i] != 0
		}() {
			resultData[i] = negResultData[i]
		}
	}
	return asm.LoadBFloat16x8AVX2Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(resultData))), len(resultData)))
}

func BaseSinVec_avx2(x archsimd.Float32x8) archsimd.Float32x8 {
	twoOverPi := archsimd.BroadcastFloat32x8(trig2OverPi_f32)
	piOver2Hi := archsimd.BroadcastFloat32x8(trigPiOver2Hi_f32)
	piOver2Lo := archsimd.BroadcastFloat32x8(trigPiOver2Lo_f32)
	one := archsimd.BroadcastFloat32x8(trigOne_f32)
	s1 := archsimd.BroadcastFloat32x8(trigS1_f32)
	s2 := archsimd.BroadcastFloat32x8(trigS2_f32)
	s3 := archsimd.BroadcastFloat32x8(trigS3_f32)
	s4 := archsimd.BroadcastFloat32x8(trigS4_f32)
	c1 := archsimd.BroadcastFloat32x8(trigC1_f32)
	c2 := archsimd.BroadcastFloat32x8(trigC2_f32)
	c3 := archsimd.BroadcastFloat32x8(trigC3_f32)
	c4 := archsimd.BroadcastFloat32x8(trigC4_f32)
	intOne := BaseSinVec_AVX2_intOne_i32_f32
	intTwo := BaseSinVec_AVX2_intTwo_i32_f32
	intThree := BaseSinVec_AVX2_intThree_i32_f32
	kFloat := x.Mul(twoOverPi).RoundToEven()
	kInt := kFloat.ConvertToInt32()
	r := x.Sub(kFloat.Mul(piOver2Hi))
	r = r.Sub(kFloat.Mul(piOver2Lo))
	r2 := r.Mul(r)
	sinPoly := s4.MulAdd(r2, s3)
	sinPoly = sinPoly.MulAdd(r2, s2)
	sinPoly = sinPoly.MulAdd(r2, s1)
	sinPoly = sinPoly.MulAdd(r2, one)
	sinR := r.Mul(sinPoly)
	cosPoly := c4.MulAdd(r2, c3)
	cosPoly = cosPoly.MulAdd(r2, c2)
	cosPoly = cosPoly.MulAdd(r2, c1)
	cosR := cosPoly.MulAdd(r2, one)
	octant := kInt.And(intThree)
	useCosMask := octant.And(intOne).Equal(intOne)
	negateMask := octant.And(intTwo).Equal(intTwo)
	sinRData := func() []float32 {
		var _simd_tmp [8]float32
		sinR.StoreSlice(_simd_tmp[:])
		return _simd_tmp[:]
	}()
	cosRData := func() []float32 {
		var _simd_tmp [8]float32
		cosR.StoreSlice(_simd_tmp[:])
		return _simd_tmp[:]
	}()
	resultData := make([]float32, len(sinRData))
	for i := range sinRData {
		if func() bool {
			_vOne := archsimd.BroadcastInt32x8(1)
			_vZero := archsimd.BroadcastInt32x8(0)
			_vMasked := _vOne.Merge(_vZero, useCosMask)
			var _simd_mask_tmp [8]int32
			_vMasked.StoreSlice(_simd_mask_tmp[:])
			return _simd_mask_tmp[i] != 0
		}() {
			resultData[i] = cosRData[i]
		} else {
			resultData[i] = sinRData[i]
		}
	}
	result := archsimd.LoadFloat32x8Slice(resultData)
	negResult := archsimd.BroadcastFloat32x8(0).Sub(result)
	negResultData := func() []float32 {
		var _simd_tmp [8]float32
		negResult.StoreSlice(_simd_tmp[:])
		return _simd_tmp[:]
	}()
	for i := range resultData {
		if func() bool {
			_vOne := archsimd.BroadcastInt32x8(1)
			_vZero := archsimd.BroadcastInt32x8(0)
			_vMasked := _vOne.Merge(_vZero, negateMask)
			var _simd_mask_tmp [8]int32
			_vMasked.StoreSlice(_simd_mask_tmp[:])
			return _simd_mask_tmp[i] != 0
		}() {
			resultData[i] = negResultData[i]
		}
	}
	return archsimd.LoadFloat32x8Slice(resultData)
}

func BaseSinVec_avx2_Float64(x archsimd.Float64x4) archsimd.Float64x4 {
	twoOverPi := archsimd.BroadcastFloat64x4(trig2OverPi_f64)
	piOver2Hi := archsimd.BroadcastFloat64x4(trigPiOver2Hi_f64)
	piOver2Lo := archsimd.BroadcastFloat64x4(trigPiOver2Lo_f64)
	one := archsimd.BroadcastFloat64x4(trigOne_f64)
	s1 := archsimd.BroadcastFloat64x4(trigS1_f64)
	s2 := archsimd.BroadcastFloat64x4(trigS2_f64)
	s3 := archsimd.BroadcastFloat64x4(trigS3_f64)
	s4 := archsimd.BroadcastFloat64x4(trigS4_f64)
	c1 := archsimd.BroadcastFloat64x4(trigC1_f64)
	c2 := archsimd.BroadcastFloat64x4(trigC2_f64)
	c3 := archsimd.BroadcastFloat64x4(trigC3_f64)
	c4 := archsimd.BroadcastFloat64x4(trigC4_f64)
	intOne := BaseSinVec_AVX2_intOne_i32_f64
	intTwo := BaseSinVec_AVX2_intTwo_i32_f64
	intThree := BaseSinVec_AVX2_intThree_i32_f64
	kFloat := x.Mul(twoOverPi).RoundToEven()
	kInt := kFloat.ConvertToInt32()
	r := x.Sub(kFloat.Mul(piOver2Hi))
	r = r.Sub(kFloat.Mul(piOver2Lo))
	r2 := r.Mul(r)
	sinPoly := s4.MulAdd(r2, s3)
	sinPoly = sinPoly.MulAdd(r2, s2)
	sinPoly = sinPoly.MulAdd(r2, s1)
	sinPoly = sinPoly.MulAdd(r2, one)
	sinR := r.Mul(sinPoly)
	cosPoly := c4.MulAdd(r2, c3)
	cosPoly = cosPoly.MulAdd(r2, c2)
	cosPoly = cosPoly.MulAdd(r2, c1)
	cosR := cosPoly.MulAdd(r2, one)
	octant := kInt.And(intThree)
	useCosMask := octant.And(intOne).Equal(intOne)
	negateMask := octant.And(intTwo).Equal(intTwo)
	sinRData := func() []float64 {
		var _simd_tmp [4]float64
		sinR.StoreSlice(_simd_tmp[:])
		return _simd_tmp[:]
	}()
	cosRData := func() []float64 {
		var _simd_tmp [4]float64
		cosR.StoreSlice(_simd_tmp[:])
		return _simd_tmp[:]
	}()
	resultData := make([]float64, len(sinRData))
	for i := range sinRData {
		if func() bool {
			_vOne := archsimd.BroadcastInt32x4(1)
			_vZero := archsimd.BroadcastInt32x4(0)
			_vMasked := _vOne.Merge(_vZero, useCosMask)
			var _simd_mask_tmp [4]int32
			_vMasked.StoreSlice(_simd_mask_tmp[:])
			return _simd_mask_tmp[i] != 0
		}() {
			resultData[i] = cosRData[i]
		} else {
			resultData[i] = sinRData[i]
		}
	}
	result := archsimd.LoadFloat64x4Slice(resultData)
	negResult := archsimd.BroadcastFloat64x4(0).Sub(result)
	negResultData := func() []float64 {
		var _simd_tmp [4]float64
		negResult.StoreSlice(_simd_tmp[:])
		return _simd_tmp[:]
	}()
	for i := range resultData {
		if func() bool {
			_vOne := archsimd.BroadcastInt32x4(1)
			_vZero := archsimd.BroadcastInt32x4(0)
			_vMasked := _vOne.Merge(_vZero, negateMask)
			var _simd_mask_tmp [4]int32
			_vMasked.StoreSlice(_simd_mask_tmp[:])
			return _simd_mask_tmp[i] != 0
		}() {
			resultData[i] = negResultData[i]
		}
	}
	return archsimd.LoadFloat64x4Slice(resultData)
}

func BaseCosVec_avx2_Float16(x asm.Float16x8AVX2) asm.Float16x8AVX2 {
	twoOverPi := asm.BroadcastFloat16x8AVX2(uint16(trig2OverPi_f16))
	piOver2Hi := asm.BroadcastFloat16x8AVX2(uint16(trigPiOver2Hi_f16))
	piOver2Lo := asm.BroadcastFloat16x8AVX2(uint16(trigPiOver2Lo_f16))
	one := asm.BroadcastFloat16x8AVX2(uint16(trigOne_f16))
	s1 := asm.BroadcastFloat16x8AVX2(uint16(trigS1_f16))
	s2 := asm.BroadcastFloat16x8AVX2(uint16(trigS2_f16))
	s3 := asm.BroadcastFloat16x8AVX2(uint16(trigS3_f16))
	s4 := asm.BroadcastFloat16x8AVX2(uint16(trigS4_f16))
	c1 := asm.BroadcastFloat16x8AVX2(uint16(trigC1_f16))
	c2 := asm.BroadcastFloat16x8AVX2(uint16(trigC2_f16))
	c3 := asm.BroadcastFloat16x8AVX2(uint16(trigC3_f16))
	c4 := asm.BroadcastFloat16x8AVX2(uint16(trigC4_f16))
	intOne := BaseCosVec_AVX2_intOne_i32_f32
	intTwo := BaseCosVec_AVX2_intTwo_i32_f32
	intThree := BaseCosVec_AVX2_intThree_i32_f32
	kFloat := x.Mul(twoOverPi).RoundToEven()
	kInt := kFloat.ConvertToInt32()
	r := x.Sub(kFloat.Mul(piOver2Hi))
	r = r.Sub(kFloat.Mul(piOver2Lo))
	r2 := r.Mul(r)
	sinPoly := s4.MulAdd(r2, s3)
	sinPoly = sinPoly.MulAdd(r2, s2)
	sinPoly = sinPoly.MulAdd(r2, s1)
	sinPoly = sinPoly.MulAdd(r2, one)
	sinR := r.Mul(sinPoly)
	cosPoly := c4.MulAdd(r2, c3)
	cosPoly = cosPoly.MulAdd(r2, c2)
	cosPoly = cosPoly.MulAdd(r2, c1)
	cosR := cosPoly.MulAdd(r2, one)
	cosOctant := kInt.Add(intOne).And(intThree)
	useCosMask := cosOctant.And(intOne).Equal(intOne)
	negateMask := cosOctant.And(intTwo).Equal(intTwo)
	sinRData := func() []hwy.Float16 {
		var _simd_tmp [8]hwy.Float16
		sinR.StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(_simd_tmp[:]))), len(_simd_tmp[:])))
		return _simd_tmp[:]
	}()
	cosRData := func() []hwy.Float16 {
		var _simd_tmp [8]hwy.Float16
		cosR.StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(_simd_tmp[:]))), len(_simd_tmp[:])))
		return _simd_tmp[:]
	}()
	resultData := make([]hwy.Float16, len(sinRData))
	for i := range sinRData {
		if func() bool {
			_vOne := archsimd.BroadcastInt32x8(1)
			_vZero := archsimd.BroadcastInt32x8(0)
			_vMasked := _vOne.Merge(_vZero, useCosMask)
			var _simd_mask_tmp [8]int32
			_vMasked.StoreSlice(_simd_mask_tmp[:])
			return _simd_mask_tmp[i] != 0
		}() {
			resultData[i] = cosRData[i]
		} else {
			resultData[i] = sinRData[i]
		}
	}
	result := asm.LoadFloat16x8AVX2Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(resultData))), len(resultData)))
	negResult := result.Neg()
	negResultData := func() []hwy.Float16 {
		var _simd_tmp [8]hwy.Float16
		negResult.StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(_simd_tmp[:]))), len(_simd_tmp[:])))
		return _simd_tmp[:]
	}()
	for i := range resultData {
		if func() bool {
			_vOne := archsimd.BroadcastInt32x8(1)
			_vZero := archsimd.BroadcastInt32x8(0)
			_vMasked := _vOne.Merge(_vZero, negateMask)
			var _simd_mask_tmp [8]int32
			_vMasked.StoreSlice(_simd_mask_tmp[:])
			return _simd_mask_tmp[i] != 0
		}() {
			resultData[i] = negResultData[i]
		}
	}
	return asm.LoadFloat16x8AVX2Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(resultData))), len(resultData)))
}

func BaseCosVec_avx2_BFloat16(x asm.BFloat16x8AVX2) asm.BFloat16x8AVX2 {
	twoOverPi := asm.BroadcastBFloat16x8AVX2(uint16(trig2OverPi_bf16))
	piOver2Hi := asm.BroadcastBFloat16x8AVX2(uint16(trigPiOver2Hi_bf16))
	piOver2Lo := asm.BroadcastBFloat16x8AVX2(uint16(trigPiOver2Lo_bf16))
	one := asm.BroadcastBFloat16x8AVX2(uint16(trigOne_bf16))
	s1 := asm.BroadcastBFloat16x8AVX2(uint16(trigS1_bf16))
	s2 := asm.BroadcastBFloat16x8AVX2(uint16(trigS2_bf16))
	s3 := asm.BroadcastBFloat16x8AVX2(uint16(trigS3_bf16))
	s4 := asm.BroadcastBFloat16x8AVX2(uint16(trigS4_bf16))
	c1 := asm.BroadcastBFloat16x8AVX2(uint16(trigC1_bf16))
	c2 := asm.BroadcastBFloat16x8AVX2(uint16(trigC2_bf16))
	c3 := asm.BroadcastBFloat16x8AVX2(uint16(trigC3_bf16))
	c4 := asm.BroadcastBFloat16x8AVX2(uint16(trigC4_bf16))
	intOne := BaseCosVec_AVX2_intOne_i32_f32
	intTwo := BaseCosVec_AVX2_intTwo_i32_f32
	intThree := BaseCosVec_AVX2_intThree_i32_f32
	kFloat := x.Mul(twoOverPi).RoundToEven()
	kInt := kFloat.ConvertToInt32()
	r := x.Sub(kFloat.Mul(piOver2Hi))
	r = r.Sub(kFloat.Mul(piOver2Lo))
	r2 := r.Mul(r)
	sinPoly := s4.MulAdd(r2, s3)
	sinPoly = sinPoly.MulAdd(r2, s2)
	sinPoly = sinPoly.MulAdd(r2, s1)
	sinPoly = sinPoly.MulAdd(r2, one)
	sinR := r.Mul(sinPoly)
	cosPoly := c4.MulAdd(r2, c3)
	cosPoly = cosPoly.MulAdd(r2, c2)
	cosPoly = cosPoly.MulAdd(r2, c1)
	cosR := cosPoly.MulAdd(r2, one)
	cosOctant := kInt.Add(intOne).And(intThree)
	useCosMask := cosOctant.And(intOne).Equal(intOne)
	negateMask := cosOctant.And(intTwo).Equal(intTwo)
	sinRData := func() []hwy.BFloat16 {
		var _simd_tmp [8]hwy.BFloat16
		sinR.StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(_simd_tmp[:]))), len(_simd_tmp[:])))
		return _simd_tmp[:]
	}()
	cosRData := func() []hwy.BFloat16 {
		var _simd_tmp [8]hwy.BFloat16
		cosR.StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(_simd_tmp[:]))), len(_simd_tmp[:])))
		return _simd_tmp[:]
	}()
	resultData := make([]hwy.BFloat16, len(sinRData))
	for i := range sinRData {
		if func() bool {
			_vOne := archsimd.BroadcastInt32x8(1)
			_vZero := archsimd.BroadcastInt32x8(0)
			_vMasked := _vOne.Merge(_vZero, useCosMask)
			var _simd_mask_tmp [8]int32
			_vMasked.StoreSlice(_simd_mask_tmp[:])
			return _simd_mask_tmp[i] != 0
		}() {
			resultData[i] = cosRData[i]
		} else {
			resultData[i] = sinRData[i]
		}
	}
	result := asm.LoadBFloat16x8AVX2Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(resultData))), len(resultData)))
	negResult := result.Neg()
	negResultData := func() []hwy.BFloat16 {
		var _simd_tmp [8]hwy.BFloat16
		negResult.StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(_simd_tmp[:]))), len(_simd_tmp[:])))
		return _simd_tmp[:]
	}()
	for i := range resultData {
		if func() bool {
			_vOne := archsimd.BroadcastInt32x8(1)
			_vZero := archsimd.BroadcastInt32x8(0)
			_vMasked := _vOne.Merge(_vZero, negateMask)
			var _simd_mask_tmp [8]int32
			_vMasked.StoreSlice(_simd_mask_tmp[:])
			return _simd_mask_tmp[i] != 0
		}() {
			resultData[i] = negResultData[i]
		}
	}
	return asm.LoadBFloat16x8AVX2Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(resultData))), len(resultData)))
}

func BaseCosVec_avx2(x archsimd.Float32x8) archsimd.Float32x8 {
	twoOverPi := archsimd.BroadcastFloat32x8(trig2OverPi_f32)
	piOver2Hi := archsimd.BroadcastFloat32x8(trigPiOver2Hi_f32)
	piOver2Lo := archsimd.BroadcastFloat32x8(trigPiOver2Lo_f32)
	one := archsimd.BroadcastFloat32x8(trigOne_f32)
	s1 := archsimd.BroadcastFloat32x8(trigS1_f32)
	s2 := archsimd.BroadcastFloat32x8(trigS2_f32)
	s3 := archsimd.BroadcastFloat32x8(trigS3_f32)
	s4 := archsimd.BroadcastFloat32x8(trigS4_f32)
	c1 := archsimd.BroadcastFloat32x8(trigC1_f32)
	c2 := archsimd.BroadcastFloat32x8(trigC2_f32)
	c3 := archsimd.BroadcastFloat32x8(trigC3_f32)
	c4 := archsimd.BroadcastFloat32x8(trigC4_f32)
	intOne := BaseCosVec_AVX2_intOne_i32_f32
	intTwo := BaseCosVec_AVX2_intTwo_i32_f32
	intThree := BaseCosVec_AVX2_intThree_i32_f32
	kFloat := x.Mul(twoOverPi).RoundToEven()
	kInt := kFloat.ConvertToInt32()
	r := x.Sub(kFloat.Mul(piOver2Hi))
	r = r.Sub(kFloat.Mul(piOver2Lo))
	r2 := r.Mul(r)
	sinPoly := s4.MulAdd(r2, s3)
	sinPoly = sinPoly.MulAdd(r2, s2)
	sinPoly = sinPoly.MulAdd(r2, s1)
	sinPoly = sinPoly.MulAdd(r2, one)
	sinR := r.Mul(sinPoly)
	cosPoly := c4.MulAdd(r2, c3)
	cosPoly = cosPoly.MulAdd(r2, c2)
	cosPoly = cosPoly.MulAdd(r2, c1)
	cosR := cosPoly.MulAdd(r2, one)
	cosOctant := kInt.Add(intOne).And(intThree)
	useCosMask := cosOctant.And(intOne).Equal(intOne)
	negateMask := cosOctant.And(intTwo).Equal(intTwo)
	sinRData := func() []float32 {
		var _simd_tmp [8]float32
		sinR.StoreSlice(_simd_tmp[:])
		return _simd_tmp[:]
	}()
	cosRData := func() []float32 {
		var _simd_tmp [8]float32
		cosR.StoreSlice(_simd_tmp[:])
		return _simd_tmp[:]
	}()
	resultData := make([]float32, len(sinRData))
	for i := range sinRData {
		if func() bool {
			_vOne := archsimd.BroadcastInt32x8(1)
			_vZero := archsimd.BroadcastInt32x8(0)
			_vMasked := _vOne.Merge(_vZero, useCosMask)
			var _simd_mask_tmp [8]int32
			_vMasked.StoreSlice(_simd_mask_tmp[:])
			return _simd_mask_tmp[i] != 0
		}() {
			resultData[i] = cosRData[i]
		} else {
			resultData[i] = sinRData[i]
		}
	}
	result := archsimd.LoadFloat32x8Slice(resultData)
	negResult := archsimd.BroadcastFloat32x8(0).Sub(result)
	negResultData := func() []float32 {
		var _simd_tmp [8]float32
		negResult.StoreSlice(_simd_tmp[:])
		return _simd_tmp[:]
	}()
	for i := range resultData {
		if func() bool {
			_vOne := archsimd.BroadcastInt32x8(1)
			_vZero := archsimd.BroadcastInt32x8(0)
			_vMasked := _vOne.Merge(_vZero, negateMask)
			var _simd_mask_tmp [8]int32
			_vMasked.StoreSlice(_simd_mask_tmp[:])
			return _simd_mask_tmp[i] != 0
		}() {
			resultData[i] = negResultData[i]
		}
	}
	return archsimd.LoadFloat32x8Slice(resultData)
}

func BaseCosVec_avx2_Float64(x archsimd.Float64x4) archsimd.Float64x4 {
	twoOverPi := archsimd.BroadcastFloat64x4(trig2OverPi_f64)
	piOver2Hi := archsimd.BroadcastFloat64x4(trigPiOver2Hi_f64)
	piOver2Lo := archsimd.BroadcastFloat64x4(trigPiOver2Lo_f64)
	one := archsimd.BroadcastFloat64x4(trigOne_f64)
	s1 := archsimd.BroadcastFloat64x4(trigS1_f64)
	s2 := archsimd.BroadcastFloat64x4(trigS2_f64)
	s3 := archsimd.BroadcastFloat64x4(trigS3_f64)
	s4 := archsimd.BroadcastFloat64x4(trigS4_f64)
	c1 := archsimd.BroadcastFloat64x4(trigC1_f64)
	c2 := archsimd.BroadcastFloat64x4(trigC2_f64)
	c3 := archsimd.BroadcastFloat64x4(trigC3_f64)
	c4 := archsimd.BroadcastFloat64x4(trigC4_f64)
	intOne := BaseCosVec_AVX2_intOne_i32_f64
	intTwo := BaseCosVec_AVX2_intTwo_i32_f64
	intThree := BaseCosVec_AVX2_intThree_i32_f64
	kFloat := x.Mul(twoOverPi).RoundToEven()
	kInt := kFloat.ConvertToInt32()
	r := x.Sub(kFloat.Mul(piOver2Hi))
	r = r.Sub(kFloat.Mul(piOver2Lo))
	r2 := r.Mul(r)
	sinPoly := s4.MulAdd(r2, s3)
	sinPoly = sinPoly.MulAdd(r2, s2)
	sinPoly = sinPoly.MulAdd(r2, s1)
	sinPoly = sinPoly.MulAdd(r2, one)
	sinR := r.Mul(sinPoly)
	cosPoly := c4.MulAdd(r2, c3)
	cosPoly = cosPoly.MulAdd(r2, c2)
	cosPoly = cosPoly.MulAdd(r2, c1)
	cosR := cosPoly.MulAdd(r2, one)
	cosOctant := kInt.Add(intOne).And(intThree)
	useCosMask := cosOctant.And(intOne).Equal(intOne)
	negateMask := cosOctant.And(intTwo).Equal(intTwo)
	sinRData := func() []float64 {
		var _simd_tmp [4]float64
		sinR.StoreSlice(_simd_tmp[:])
		return _simd_tmp[:]
	}()
	cosRData := func() []float64 {
		var _simd_tmp [4]float64
		cosR.StoreSlice(_simd_tmp[:])
		return _simd_tmp[:]
	}()
	resultData := make([]float64, len(sinRData))
	for i := range sinRData {
		if func() bool {
			_vOne := archsimd.BroadcastInt32x4(1)
			_vZero := archsimd.BroadcastInt32x4(0)
			_vMasked := _vOne.Merge(_vZero, useCosMask)
			var _simd_mask_tmp [4]int32
			_vMasked.StoreSlice(_simd_mask_tmp[:])
			return _simd_mask_tmp[i] != 0
		}() {
			resultData[i] = cosRData[i]
		} else {
			resultData[i] = sinRData[i]
		}
	}
	result := archsimd.LoadFloat64x4Slice(resultData)
	negResult := archsimd.BroadcastFloat64x4(0).Sub(result)
	negResultData := func() []float64 {
		var _simd_tmp [4]float64
		negResult.StoreSlice(_simd_tmp[:])
		return _simd_tmp[:]
	}()
	for i := range resultData {
		if func() bool {
			_vOne := archsimd.BroadcastInt32x4(1)
			_vZero := archsimd.BroadcastInt32x4(0)
			_vMasked := _vOne.Merge(_vZero, negateMask)
			var _simd_mask_tmp [4]int32
			_vMasked.StoreSlice(_simd_mask_tmp[:])
			return _simd_mask_tmp[i] != 0
		}() {
			resultData[i] = negResultData[i]
		}
	}
	return archsimd.LoadFloat64x4Slice(resultData)
}

func BaseErfVec_avx2_Float16(x asm.Float16x8AVX2) asm.Float16x8AVX2 {
	a1 := asm.BroadcastFloat16x8AVX2(uint16(erfA1_f16))
	a2 := asm.BroadcastFloat16x8AVX2(uint16(erfA2_f16))
	a3 := asm.BroadcastFloat16x8AVX2(uint16(erfA3_f16))
	a4 := asm.BroadcastFloat16x8AVX2(uint16(erfA4_f16))
	a5 := asm.BroadcastFloat16x8AVX2(uint16(erfA5_f16))
	p := asm.BroadcastFloat16x8AVX2(uint16(erfP_f16))
	one := asm.BroadcastFloat16x8AVX2(uint16(erfOne_f16))
	zero := asm.BroadcastFloat16x8AVX2(uint16(erfZero_f16))
	absX := x.Abs()
	signMask := x.Less(zero)
	t := one.Div(one.Add(p.Mul(absX)))
	poly := a5.MulAdd(t, a4)
	poly = poly.MulAdd(t, a3)
	poly = poly.MulAdd(t, a2)
	poly = poly.MulAdd(t, a1)
	poly = poly.Mul(t)
	x2 := absX.Mul(absX)
	negX2 := x2.Neg()
	expNegX2 := BaseExpVec_avx2_Float16(negX2)
	erfAbs := one.Sub(poly.Mul(expNegX2))
	erfAbs = erfAbs.Min(one).Max(zero)
	negErfAbs := erfAbs.Neg()
	result := negErfAbs.Merge(erfAbs, signMask)
	return result
}

func BaseErfVec_avx2_BFloat16(x asm.BFloat16x8AVX2) asm.BFloat16x8AVX2 {
	a1 := asm.BroadcastBFloat16x8AVX2(uint16(erfA1_bf16))
	a2 := asm.BroadcastBFloat16x8AVX2(uint16(erfA2_bf16))
	a3 := asm.BroadcastBFloat16x8AVX2(uint16(erfA3_bf16))
	a4 := asm.BroadcastBFloat16x8AVX2(uint16(erfA4_bf16))
	a5 := asm.BroadcastBFloat16x8AVX2(uint16(erfA5_bf16))
	p := asm.BroadcastBFloat16x8AVX2(uint16(erfP_bf16))
	one := asm.BroadcastBFloat16x8AVX2(uint16(erfOne_bf16))
	zero := asm.BroadcastBFloat16x8AVX2(uint16(erfZero_bf16))
	absX := x.Abs()
	signMask := x.Less(zero)
	t := one.Div(one.Add(p.Mul(absX)))
	poly := a5.MulAdd(t, a4)
	poly = poly.MulAdd(t, a3)
	poly = poly.MulAdd(t, a2)
	poly = poly.MulAdd(t, a1)
	poly = poly.Mul(t)
	x2 := absX.Mul(absX)
	negX2 := x2.Neg()
	expNegX2 := BaseExpVec_avx2_BFloat16(negX2)
	erfAbs := one.Sub(poly.Mul(expNegX2))
	erfAbs = erfAbs.Min(one).Max(zero)
	negErfAbs := erfAbs.Neg()
	result := negErfAbs.Merge(erfAbs, signMask)
	return result
}

func BaseErfVec_avx2(x archsimd.Float32x8) archsimd.Float32x8 {
	a1 := archsimd.BroadcastFloat32x8(erfA1_f32)
	a2 := archsimd.BroadcastFloat32x8(erfA2_f32)
	a3 := archsimd.BroadcastFloat32x8(erfA3_f32)
	a4 := archsimd.BroadcastFloat32x8(erfA4_f32)
	a5 := archsimd.BroadcastFloat32x8(erfA5_f32)
	p := archsimd.BroadcastFloat32x8(erfP_f32)
	one := archsimd.BroadcastFloat32x8(erfOne_f32)
	zero := archsimd.BroadcastFloat32x8(erfZero_f32)
	absX := x.Max(archsimd.BroadcastFloat32x8(0).Sub(x))
	signMask := x.Less(zero)
	t := one.Div(one.Add(p.Mul(absX)))
	poly := a5.MulAdd(t, a4)
	poly = poly.MulAdd(t, a3)
	poly = poly.MulAdd(t, a2)
	poly = poly.MulAdd(t, a1)
	poly = poly.Mul(t)
	x2 := absX.Mul(absX)
	negX2 := archsimd.BroadcastFloat32x8(0).Sub(x2)
	expNegX2 := BaseExpVec_avx2(negX2)
	erfAbs := one.Sub(poly.Mul(expNegX2))
	erfAbs = erfAbs.Min(one).Max(zero)
	negErfAbs := archsimd.BroadcastFloat32x8(0).Sub(erfAbs)
	result := negErfAbs.Merge(erfAbs, signMask)
	return result
}

func BaseErfVec_avx2_Float64(x archsimd.Float64x4) archsimd.Float64x4 {
	a1 := archsimd.BroadcastFloat64x4(erfA1_f64)
	a2 := archsimd.BroadcastFloat64x4(erfA2_f64)
	a3 := archsimd.BroadcastFloat64x4(erfA3_f64)
	a4 := archsimd.BroadcastFloat64x4(erfA4_f64)
	a5 := archsimd.BroadcastFloat64x4(erfA5_f64)
	p := archsimd.BroadcastFloat64x4(erfP_f64)
	one := archsimd.BroadcastFloat64x4(erfOne_f64)
	zero := archsimd.BroadcastFloat64x4(erfZero_f64)
	absX := x.Max(archsimd.BroadcastFloat64x4(0).Sub(x))
	signMask := x.Less(zero)
	t := one.Div(one.Add(p.Mul(absX)))
	poly := a5.MulAdd(t, a4)
	poly = poly.MulAdd(t, a3)
	poly = poly.MulAdd(t, a2)
	poly = poly.MulAdd(t, a1)
	poly = poly.Mul(t)
	x2 := absX.Mul(absX)
	negX2 := archsimd.BroadcastFloat64x4(0).Sub(x2)
	expNegX2 := BaseExpVec_avx2_Float64(negX2)
	erfAbs := one.Sub(poly.Mul(expNegX2))
	erfAbs = erfAbs.Min(one).Max(zero)
	negErfAbs := archsimd.BroadcastFloat64x4(0).Sub(erfAbs)
	result := negErfAbs.Merge(erfAbs, signMask)
	return result
}

func BaseLog2Vec_avx2_Float16(x asm.Float16x8AVX2) asm.Float16x8AVX2 {
	log2E := asm.BroadcastFloat16x8AVX2(uint16(log2E_f16))
	lnX := BaseLogVec_avx2_Float16(x)
	return lnX.Mul(log2E)
}

func BaseLog2Vec_avx2_BFloat16(x asm.BFloat16x8AVX2) asm.BFloat16x8AVX2 {
	log2E := asm.BroadcastBFloat16x8AVX2(uint16(log2E_bf16))
	lnX := BaseLogVec_avx2_BFloat16(x)
	return lnX.Mul(log2E)
}

func BaseLog2Vec_avx2(x archsimd.Float32x8) archsimd.Float32x8 {
	log2E := archsimd.BroadcastFloat32x8(log2E_f32)
	lnX := BaseLogVec_avx2(x)
	return lnX.Mul(log2E)
}

func BaseLog2Vec_avx2_Float64(x archsimd.Float64x4) archsimd.Float64x4 {
	log2E := archsimd.BroadcastFloat64x4(log2E_f64)
	lnX := BaseLogVec_avx2_Float64(x)
	return lnX.Mul(log2E)
}

func BaseLog10Vec_avx2_Float16(x asm.Float16x8AVX2) asm.Float16x8AVX2 {
	log10E := asm.BroadcastFloat16x8AVX2(uint16(log10E_f16))
	lnX := BaseLogVec_avx2_Float16(x)
	return lnX.Mul(log10E)
}

func BaseLog10Vec_avx2_BFloat16(x asm.BFloat16x8AVX2) asm.BFloat16x8AVX2 {
	log10E := asm.BroadcastBFloat16x8AVX2(uint16(log10E_bf16))
	lnX := BaseLogVec_avx2_BFloat16(x)
	return lnX.Mul(log10E)
}

func BaseLog10Vec_avx2(x archsimd.Float32x8) archsimd.Float32x8 {
	log10E := archsimd.BroadcastFloat32x8(log10E_f32)
	lnX := BaseLogVec_avx2(x)
	return lnX.Mul(log10E)
}

func BaseLog10Vec_avx2_Float64(x archsimd.Float64x4) archsimd.Float64x4 {
	log10E := archsimd.BroadcastFloat64x4(log10E_f64)
	lnX := BaseLogVec_avx2_Float64(x)
	return lnX.Mul(log10E)
}

func BaseExp2Vec_avx2_Float16(x asm.Float16x8AVX2) asm.Float16x8AVX2 {
	ln2 := asm.BroadcastFloat16x8AVX2(uint16(ln2_f16))
	xLn2 := x.Mul(ln2)
	return BaseExpVec_avx2_Float16(xLn2)
}

func BaseExp2Vec_avx2_BFloat16(x asm.BFloat16x8AVX2) asm.BFloat16x8AVX2 {
	ln2 := asm.BroadcastBFloat16x8AVX2(uint16(ln2_bf16))
	xLn2 := x.Mul(ln2)
	return BaseExpVec_avx2_BFloat16(xLn2)
}

func BaseExp2Vec_avx2(x archsimd.Float32x8) archsimd.Float32x8 {
	ln2 := archsimd.BroadcastFloat32x8(ln2_f32)
	xLn2 := x.Mul(ln2)
	return BaseExpVec_avx2(xLn2)
}

func BaseExp2Vec_avx2_Float64(x archsimd.Float64x4) archsimd.Float64x4 {
	ln2 := archsimd.BroadcastFloat64x4(ln2_f64)
	xLn2 := x.Mul(ln2)
	return BaseExpVec_avx2_Float64(xLn2)
}

func BaseSinhVec_avx2_Float16(x asm.Float16x8AVX2) asm.Float16x8AVX2 {
	one := asm.BroadcastFloat16x8AVX2(uint16(sinhOne_f16))
	c3 := asm.BroadcastFloat16x8AVX2(uint16(sinhC3_f16))
	c5 := asm.BroadcastFloat16x8AVX2(uint16(sinhC5_f16))
	c7 := asm.BroadcastFloat16x8AVX2(uint16(sinhC7_f16))
	x2 := x.Mul(x)
	poly := c7.MulAdd(x2, c5)
	poly = poly.MulAdd(x2, c3)
	poly = poly.MulAdd(x2, one)
	return x.Mul(poly)
}

func BaseSinhVec_avx2_BFloat16(x asm.BFloat16x8AVX2) asm.BFloat16x8AVX2 {
	one := asm.BroadcastBFloat16x8AVX2(uint16(sinhOne_bf16))
	c3 := asm.BroadcastBFloat16x8AVX2(uint16(sinhC3_bf16))
	c5 := asm.BroadcastBFloat16x8AVX2(uint16(sinhC5_bf16))
	c7 := asm.BroadcastBFloat16x8AVX2(uint16(sinhC7_bf16))
	x2 := x.Mul(x)
	poly := c7.MulAdd(x2, c5)
	poly = poly.MulAdd(x2, c3)
	poly = poly.MulAdd(x2, one)
	return x.Mul(poly)
}

func BaseSinhVec_avx2(x archsimd.Float32x8) archsimd.Float32x8 {
	one := archsimd.BroadcastFloat32x8(sinhOne_f32)
	c3 := archsimd.BroadcastFloat32x8(sinhC3_f32)
	c5 := archsimd.BroadcastFloat32x8(sinhC5_f32)
	c7 := archsimd.BroadcastFloat32x8(sinhC7_f32)
	x2 := x.Mul(x)
	poly := c7.MulAdd(x2, c5)
	poly = poly.MulAdd(x2, c3)
	poly = poly.MulAdd(x2, one)
	return x.Mul(poly)
}

func BaseSinhVec_avx2_Float64(x archsimd.Float64x4) archsimd.Float64x4 {
	one := archsimd.BroadcastFloat64x4(sinhOne_f64)
	c3 := archsimd.BroadcastFloat64x4(sinhC3_f64)
	c5 := archsimd.BroadcastFloat64x4(sinhC5_f64)
	c7 := archsimd.BroadcastFloat64x4(sinhC7_f64)
	x2 := x.Mul(x)
	poly := c7.MulAdd(x2, c5)
	poly = poly.MulAdd(x2, c3)
	poly = poly.MulAdd(x2, one)
	return x.Mul(poly)
}

func BaseCoshVec_avx2_Float16(x asm.Float16x8AVX2) asm.Float16x8AVX2 {
	one := asm.BroadcastFloat16x8AVX2(uint16(hwy.Float32ToFloat16(float32(1.0))))
	c2 := asm.BroadcastFloat16x8AVX2(uint16(hwy.Float32ToFloat16(float32(0.5))))
	c4 := asm.BroadcastFloat16x8AVX2(uint16(hwy.Float32ToFloat16(float32(0.041666666666666664))))
	c6 := asm.BroadcastFloat16x8AVX2(uint16(hwy.Float32ToFloat16(float32(0.001388888888888889))))
	x2 := x.Mul(x)
	poly := c6.MulAdd(x2, c4)
	poly = poly.MulAdd(x2, c2)
	return poly.MulAdd(x2, one)
}

func BaseCoshVec_avx2_BFloat16(x asm.BFloat16x8AVX2) asm.BFloat16x8AVX2 {
	one := asm.BroadcastBFloat16x8AVX2(uint16(hwy.Float32ToBFloat16(float32(1.0))))
	c2 := asm.BroadcastBFloat16x8AVX2(uint16(hwy.Float32ToBFloat16(float32(0.5))))
	c4 := asm.BroadcastBFloat16x8AVX2(uint16(hwy.Float32ToBFloat16(float32(0.041666666666666664))))
	c6 := asm.BroadcastBFloat16x8AVX2(uint16(hwy.Float32ToBFloat16(float32(0.001388888888888889))))
	x2 := x.Mul(x)
	poly := c6.MulAdd(x2, c4)
	poly = poly.MulAdd(x2, c2)
	return poly.MulAdd(x2, one)
}

func BaseCoshVec_avx2(x archsimd.Float32x8) archsimd.Float32x8 {
	one := archsimd.BroadcastFloat32x8(1.0)
	c2 := archsimd.BroadcastFloat32x8(0.5)
	c4 := archsimd.BroadcastFloat32x8(0.041666666666666664)
	c6 := archsimd.BroadcastFloat32x8(0.001388888888888889)
	x2 := x.Mul(x)
	poly := c6.MulAdd(x2, c4)
	poly = poly.MulAdd(x2, c2)
	return poly.MulAdd(x2, one)
}

func BaseCoshVec_avx2_Float64(x archsimd.Float64x4) archsimd.Float64x4 {
	one := archsimd.BroadcastFloat64x4(1.0)
	c2 := archsimd.BroadcastFloat64x4(0.5)
	c4 := archsimd.BroadcastFloat64x4(0.041666666666666664)
	c6 := archsimd.BroadcastFloat64x4(0.001388888888888889)
	x2 := x.Mul(x)
	poly := c6.MulAdd(x2, c4)
	poly = poly.MulAdd(x2, c2)
	return poly.MulAdd(x2, one)
}

func BaseAsinhVec_avx2_Float16(x asm.Float16x8AVX2) asm.Float16x8AVX2 {
	one := asm.BroadcastFloat16x8AVX2(uint16(hwy.Float32ToFloat16(float32(1.0))))
	x2 := x.Mul(x)
	x2Plus1 := x2.Add(one)
	sqrtPart := x2Plus1.Sqrt()
	arg := x.Add(sqrtPart)
	return BaseLogVec_avx2_Float16(arg)
}

func BaseAsinhVec_avx2_BFloat16(x asm.BFloat16x8AVX2) asm.BFloat16x8AVX2 {
	one := asm.BroadcastBFloat16x8AVX2(uint16(hwy.Float32ToBFloat16(float32(1.0))))
	x2 := x.Mul(x)
	x2Plus1 := x2.Add(one)
	sqrtPart := x2Plus1.Sqrt()
	arg := x.Add(sqrtPart)
	return BaseLogVec_avx2_BFloat16(arg)
}

func BaseAsinhVec_avx2(x archsimd.Float32x8) archsimd.Float32x8 {
	one := archsimd.BroadcastFloat32x8(1.0)
	x2 := x.Mul(x)
	x2Plus1 := x2.Add(one)
	sqrtPart := x2Plus1.Sqrt()
	arg := x.Add(sqrtPart)
	return BaseLogVec_avx2(arg)
}

func BaseAsinhVec_avx2_Float64(x archsimd.Float64x4) archsimd.Float64x4 {
	one := archsimd.BroadcastFloat64x4(1.0)
	x2 := x.Mul(x)
	x2Plus1 := x2.Add(one)
	sqrtPart := x2Plus1.Sqrt()
	arg := x.Add(sqrtPart)
	return BaseLogVec_avx2_Float64(arg)
}

func BaseAcoshVec_avx2_Float16(x asm.Float16x8AVX2) asm.Float16x8AVX2 {
	one := asm.BroadcastFloat16x8AVX2(uint16(hwy.Float32ToFloat16(float32(1.0))))
	zero := asm.BroadcastFloat16x8AVX2(uint16(hwy.Float32ToFloat16(float32(0.0))))
	x2 := x.Mul(x)
	x2Minus1 := x2.Sub(one)
	sqrtPart := x2Minus1.Sqrt()
	arg := x.Add(sqrtPart)
	result := BaseLogVec_avx2_Float16(arg)
	oneMask := x.Equal(one)
	result = zero.Merge(result, oneMask)
	return result
}

func BaseAcoshVec_avx2_BFloat16(x asm.BFloat16x8AVX2) asm.BFloat16x8AVX2 {
	one := asm.BroadcastBFloat16x8AVX2(uint16(hwy.Float32ToBFloat16(float32(1.0))))
	zero := asm.BroadcastBFloat16x8AVX2(uint16(hwy.Float32ToBFloat16(float32(0.0))))
	x2 := x.Mul(x)
	x2Minus1 := x2.Sub(one)
	sqrtPart := x2Minus1.Sqrt()
	arg := x.Add(sqrtPart)
	result := BaseLogVec_avx2_BFloat16(arg)
	oneMask := x.Equal(one)
	result = zero.Merge(result, oneMask)
	return result
}

func BaseAcoshVec_avx2(x archsimd.Float32x8) archsimd.Float32x8 {
	one := archsimd.BroadcastFloat32x8(1.0)
	zero := archsimd.BroadcastFloat32x8(0.0)
	x2 := x.Mul(x)
	x2Minus1 := x2.Sub(one)
	sqrtPart := x2Minus1.Sqrt()
	arg := x.Add(sqrtPart)
	result := BaseLogVec_avx2(arg)
	oneMask := x.Equal(one)
	result = zero.Merge(result, oneMask)
	return result
}

func BaseAcoshVec_avx2_Float64(x archsimd.Float64x4) archsimd.Float64x4 {
	one := archsimd.BroadcastFloat64x4(1.0)
	zero := archsimd.BroadcastFloat64x4(0.0)
	x2 := x.Mul(x)
	x2Minus1 := x2.Sub(one)
	sqrtPart := x2Minus1.Sqrt()
	arg := x.Add(sqrtPart)
	result := BaseLogVec_avx2_Float64(arg)
	oneMask := x.Equal(one)
	result = zero.Merge(result, oneMask)
	return result
}

func BaseAtanhVec_avx2_Float16(x asm.Float16x8AVX2) asm.Float16x8AVX2 {
	one := asm.BroadcastFloat16x8AVX2(uint16(hwy.Float32ToFloat16(float32(1.0))))
	half := asm.BroadcastFloat16x8AVX2(uint16(hwy.Float32ToFloat16(float32(0.5))))
	zero := asm.BroadcastFloat16x8AVX2(uint16(hwy.Float32ToFloat16(float32(0.0))))
	onePlusX := one.Add(x)
	oneMinusX := one.Sub(x)
	ratio := onePlusX.Div(oneMinusX)
	logRatio := BaseLogVec_avx2_Float16(ratio)
	result := half.Mul(logRatio)
	zeroMask := x.Equal(zero)
	result = zero.Merge(result, zeroMask)
	return result
}

func BaseAtanhVec_avx2_BFloat16(x asm.BFloat16x8AVX2) asm.BFloat16x8AVX2 {
	one := asm.BroadcastBFloat16x8AVX2(uint16(hwy.Float32ToBFloat16(float32(1.0))))
	half := asm.BroadcastBFloat16x8AVX2(uint16(hwy.Float32ToBFloat16(float32(0.5))))
	zero := asm.BroadcastBFloat16x8AVX2(uint16(hwy.Float32ToBFloat16(float32(0.0))))
	onePlusX := one.Add(x)
	oneMinusX := one.Sub(x)
	ratio := onePlusX.Div(oneMinusX)
	logRatio := BaseLogVec_avx2_BFloat16(ratio)
	result := half.Mul(logRatio)
	zeroMask := x.Equal(zero)
	result = zero.Merge(result, zeroMask)
	return result
}

func BaseAtanhVec_avx2(x archsimd.Float32x8) archsimd.Float32x8 {
	one := archsimd.BroadcastFloat32x8(1.0)
	half := archsimd.BroadcastFloat32x8(0.5)
	zero := archsimd.BroadcastFloat32x8(0.0)
	onePlusX := one.Add(x)
	oneMinusX := one.Sub(x)
	ratio := onePlusX.Div(oneMinusX)
	logRatio := BaseLogVec_avx2(ratio)
	result := half.Mul(logRatio)
	zeroMask := x.Equal(zero)
	result = zero.Merge(result, zeroMask)
	return result
}

func BaseAtanhVec_avx2_Float64(x archsimd.Float64x4) archsimd.Float64x4 {
	one := archsimd.BroadcastFloat64x4(1.0)
	half := archsimd.BroadcastFloat64x4(0.5)
	zero := archsimd.BroadcastFloat64x4(0.0)
	onePlusX := one.Add(x)
	oneMinusX := one.Sub(x)
	ratio := onePlusX.Div(oneMinusX)
	logRatio := BaseLogVec_avx2_Float64(ratio)
	result := half.Mul(logRatio)
	zeroMask := x.Equal(zero)
	result = zero.Merge(result, zeroMask)
	return result
}

func BasePowVec_avx2_Float16(base asm.Float16x8AVX2, exp asm.Float16x8AVX2) asm.Float16x8AVX2 {
	one := asm.BroadcastFloat16x8AVX2(uint16(hwy.Float32ToFloat16(float32(1.0))))
	zero := asm.BroadcastFloat16x8AVX2(uint16(hwy.Float32ToFloat16(float32(0.0))))
	logBase := BaseLogVec_avx2_Float16(base)
	expTimesLog := exp.Mul(logBase)
	result := BaseExpVec_avx2_Float16(expTimesLog)
	expZeroMask := exp.Equal(zero)
	result = one.Merge(result, expZeroMask)
	baseOneMask := base.Equal(one)
	result = one.Merge(result, baseOneMask)
	baseZeroMask := base.Equal(zero)
	expPosMask := exp.Greater(zero)
	baseZeroExpPosMask := baseZeroMask.And(expPosMask)
	result = zero.Merge(result, baseZeroExpPosMask)
	return result
}

func BasePowVec_avx2_BFloat16(base asm.BFloat16x8AVX2, exp asm.BFloat16x8AVX2) asm.BFloat16x8AVX2 {
	one := asm.BroadcastBFloat16x8AVX2(uint16(hwy.Float32ToBFloat16(float32(1.0))))
	zero := asm.BroadcastBFloat16x8AVX2(uint16(hwy.Float32ToBFloat16(float32(0.0))))
	logBase := BaseLogVec_avx2_BFloat16(base)
	expTimesLog := exp.Mul(logBase)
	result := BaseExpVec_avx2_BFloat16(expTimesLog)
	expZeroMask := exp.Equal(zero)
	result = one.Merge(result, expZeroMask)
	baseOneMask := base.Equal(one)
	result = one.Merge(result, baseOneMask)
	baseZeroMask := base.Equal(zero)
	expPosMask := exp.Greater(zero)
	baseZeroExpPosMask := baseZeroMask.And(expPosMask)
	result = zero.Merge(result, baseZeroExpPosMask)
	return result
}

func BasePowVec_avx2(base archsimd.Float32x8, exp archsimd.Float32x8) archsimd.Float32x8 {
	one := archsimd.BroadcastFloat32x8(1.0)
	zero := archsimd.BroadcastFloat32x8(0.0)
	logBase := BaseLogVec_avx2(base)
	expTimesLog := exp.Mul(logBase)
	result := BaseExpVec_avx2(expTimesLog)
	expZeroMask := exp.Equal(zero)
	result = one.Merge(result, expZeroMask)
	baseOneMask := base.Equal(one)
	result = one.Merge(result, baseOneMask)
	baseZeroMask := base.Equal(zero)
	expPosMask := exp.Greater(zero)
	baseZeroExpPosMask := baseZeroMask.And(expPosMask)
	result = zero.Merge(result, baseZeroExpPosMask)
	return result
}

func BasePowVec_avx2_Float64(base archsimd.Float64x4, exp archsimd.Float64x4) archsimd.Float64x4 {
	one := archsimd.BroadcastFloat64x4(1.0)
	zero := archsimd.BroadcastFloat64x4(0.0)
	logBase := BaseLogVec_avx2_Float64(base)
	expTimesLog := exp.Mul(logBase)
	result := BaseExpVec_avx2_Float64(expTimesLog)
	expZeroMask := exp.Equal(zero)
	result = one.Merge(result, expZeroMask)
	baseOneMask := base.Equal(one)
	result = one.Merge(result, baseOneMask)
	baseZeroMask := base.Equal(zero)
	expPosMask := exp.Greater(zero)
	baseZeroExpPosMask := baseZeroMask.And(expPosMask)
	result = zero.Merge(result, baseZeroExpPosMask)
	return result
}
