// Code generated by hwygen. DO NOT EDIT.
//go:build arm64

package math

import (
	"os"

	"github.com/ajroetker/go-highway/hwy"
)

var ExpPolyFloat32 func(input []float32, output []float32)
var ExpPolyFloat64 func(input []float64, output []float64)
var TanhPolyFloat32 func(input []float32, output []float32)
var TanhPolyFloat64 func(input []float64, output []float64)
var SigmoidPolyFloat32 func(input []float32, output []float32)
var SigmoidPolyFloat64 func(input []float64, output []float64)
var SinPolyFloat32 func(input []float32, output []float32)
var SinPolyFloat64 func(input []float64, output []float64)
var CosPolyFloat32 func(input []float32, output []float32)
var CosPolyFloat64 func(input []float64, output []float64)
var AtanPolyFloat32 func(input []float32, output []float32)
var AtanPolyFloat64 func(input []float64, output []float64)
var AsinPolyFloat32 func(input []float32, output []float32)
var AsinPolyFloat64 func(input []float64, output []float64)
var AcosPolyFloat32 func(input []float32, output []float32)
var AcosPolyFloat64 func(input []float64, output []float64)
var SinhPolyFloat32 func(input []float32, output []float32)
var SinhPolyFloat64 func(input []float64, output []float64)
var CoshPolyFloat32 func(input []float32, output []float32)
var CoshPolyFloat64 func(input []float64, output []float64)
var ErfPolyFloat32 func(input []float32, output []float32)
var ErfPolyFloat64 func(input []float64, output []float64)
var Expm1PolyFloat32 func(input []float32, output []float32)
var Expm1PolyFloat64 func(input []float64, output []float64)
var Log1pPolyFloat32 func(input []float32, output []float32)
var Log1pPolyFloat64 func(input []float64, output []float64)
var LogPolyFloat32 func(input []float32, output []float32)
var LogPolyFloat64 func(input []float64, output []float64)
var Log2PolyFloat32 func(input []float32, output []float32)
var Log2PolyFloat64 func(input []float64, output []float64)
var Log10PolyFloat32 func(input []float32, output []float32)
var Log10PolyFloat64 func(input []float64, output []float64)
var TanPolyFloat32 func(input []float32, output []float32)
var TanPolyFloat64 func(input []float64, output []float64)
var Atan2PolyFloat32 func(inputY []float32, inputX []float32, output []float32)
var Atan2PolyFloat64 func(inputY []float64, inputX []float64, output []float64)
var SinCosPolyFloat32 func(input []float32, sinOutput []float32, cosOutput []float32)
var SinCosPolyFloat64 func(input []float64, sinOutput []float64, cosOutput []float64)
var PowPolyFloat32 func(inputX []float32, inputY []float32, output []float32)
var PowPolyFloat64 func(inputX []float64, inputY []float64, output []float64)
var Exp2PolyFloat32 func(input []float32, output []float32)
var Exp2PolyFloat64 func(input []float64, output []float64)
var Exp10PolyFloat32 func(input []float32, output []float32)
var Exp10PolyFloat64 func(input []float64, output []float64)
var AsinhPolyFloat32 func(input []float32, output []float32)
var AsinhPolyFloat64 func(input []float64, output []float64)
var AcoshPolyFloat32 func(input []float32, output []float32)
var AcoshPolyFloat64 func(input []float64, output []float64)
var AtanhPolyFloat32 func(input []float32, output []float32)
var AtanhPolyFloat64 func(input []float64, output []float64)
var CbrtPolyFloat32 func(input []float32, output []float32)
var CbrtPolyFloat64 func(input []float64, output []float64)
var HypotPolyFloat32 func(inputX []float32, inputY []float32, output []float32)
var HypotPolyFloat64 func(inputX []float64, inputY []float64, output []float64)

// ExpPoly is the generic API that dispatches to the appropriate SIMD implementation.
func ExpPoly[T hwy.Floats](input []T, output []T) {
	switch any(input).(type) {
	case []float32:
		ExpPolyFloat32(any(input).([]float32), any(output).([]float32))
	case []float64:
		ExpPolyFloat64(any(input).([]float64), any(output).([]float64))
	}
}

// TanhPoly is the generic API that dispatches to the appropriate SIMD implementation.
func TanhPoly[T hwy.Floats](input []T, output []T) {
	switch any(input).(type) {
	case []float32:
		TanhPolyFloat32(any(input).([]float32), any(output).([]float32))
	case []float64:
		TanhPolyFloat64(any(input).([]float64), any(output).([]float64))
	}
}

// SigmoidPoly is the generic API that dispatches to the appropriate SIMD implementation.
func SigmoidPoly[T hwy.Floats](input []T, output []T) {
	switch any(input).(type) {
	case []float32:
		SigmoidPolyFloat32(any(input).([]float32), any(output).([]float32))
	case []float64:
		SigmoidPolyFloat64(any(input).([]float64), any(output).([]float64))
	}
}

// SinPoly is the generic API that dispatches to the appropriate SIMD implementation.
func SinPoly[T hwy.Floats](input []T, output []T) {
	switch any(input).(type) {
	case []float32:
		SinPolyFloat32(any(input).([]float32), any(output).([]float32))
	case []float64:
		SinPolyFloat64(any(input).([]float64), any(output).([]float64))
	}
}

// CosPoly is the generic API that dispatches to the appropriate SIMD implementation.
func CosPoly[T hwy.Floats](input []T, output []T) {
	switch any(input).(type) {
	case []float32:
		CosPolyFloat32(any(input).([]float32), any(output).([]float32))
	case []float64:
		CosPolyFloat64(any(input).([]float64), any(output).([]float64))
	}
}

// AtanPoly is the generic API that dispatches to the appropriate SIMD implementation.
func AtanPoly[T hwy.Floats](input []T, output []T) {
	switch any(input).(type) {
	case []float32:
		AtanPolyFloat32(any(input).([]float32), any(output).([]float32))
	case []float64:
		AtanPolyFloat64(any(input).([]float64), any(output).([]float64))
	}
}

// AsinPoly is the generic API that dispatches to the appropriate SIMD implementation.
func AsinPoly[T hwy.Floats](input []T, output []T) {
	switch any(input).(type) {
	case []float32:
		AsinPolyFloat32(any(input).([]float32), any(output).([]float32))
	case []float64:
		AsinPolyFloat64(any(input).([]float64), any(output).([]float64))
	}
}

// AcosPoly is the generic API that dispatches to the appropriate SIMD implementation.
func AcosPoly[T hwy.Floats](input []T, output []T) {
	switch any(input).(type) {
	case []float32:
		AcosPolyFloat32(any(input).([]float32), any(output).([]float32))
	case []float64:
		AcosPolyFloat64(any(input).([]float64), any(output).([]float64))
	}
}

// SinhPoly is the generic API that dispatches to the appropriate SIMD implementation.
func SinhPoly[T hwy.Floats](input []T, output []T) {
	switch any(input).(type) {
	case []float32:
		SinhPolyFloat32(any(input).([]float32), any(output).([]float32))
	case []float64:
		SinhPolyFloat64(any(input).([]float64), any(output).([]float64))
	}
}

// CoshPoly is the generic API that dispatches to the appropriate SIMD implementation.
func CoshPoly[T hwy.Floats](input []T, output []T) {
	switch any(input).(type) {
	case []float32:
		CoshPolyFloat32(any(input).([]float32), any(output).([]float32))
	case []float64:
		CoshPolyFloat64(any(input).([]float64), any(output).([]float64))
	}
}

// ErfPoly is the generic API that dispatches to the appropriate SIMD implementation.
func ErfPoly[T hwy.Floats](input []T, output []T) {
	switch any(input).(type) {
	case []float32:
		ErfPolyFloat32(any(input).([]float32), any(output).([]float32))
	case []float64:
		ErfPolyFloat64(any(input).([]float64), any(output).([]float64))
	}
}

// Expm1Poly is the generic API that dispatches to the appropriate SIMD implementation.
func Expm1Poly[T hwy.Floats](input []T, output []T) {
	switch any(input).(type) {
	case []float32:
		Expm1PolyFloat32(any(input).([]float32), any(output).([]float32))
	case []float64:
		Expm1PolyFloat64(any(input).([]float64), any(output).([]float64))
	}
}

// Log1pPoly is the generic API that dispatches to the appropriate SIMD implementation.
func Log1pPoly[T hwy.Floats](input []T, output []T) {
	switch any(input).(type) {
	case []float32:
		Log1pPolyFloat32(any(input).([]float32), any(output).([]float32))
	case []float64:
		Log1pPolyFloat64(any(input).([]float64), any(output).([]float64))
	}
}

// LogPoly is the generic API that dispatches to the appropriate SIMD implementation.
func LogPoly[T hwy.Floats](input []T, output []T) {
	switch any(input).(type) {
	case []float32:
		LogPolyFloat32(any(input).([]float32), any(output).([]float32))
	case []float64:
		LogPolyFloat64(any(input).([]float64), any(output).([]float64))
	}
}

// Log2Poly is the generic API that dispatches to the appropriate SIMD implementation.
func Log2Poly[T hwy.Floats](input []T, output []T) {
	switch any(input).(type) {
	case []float32:
		Log2PolyFloat32(any(input).([]float32), any(output).([]float32))
	case []float64:
		Log2PolyFloat64(any(input).([]float64), any(output).([]float64))
	}
}

// Log10Poly is the generic API that dispatches to the appropriate SIMD implementation.
func Log10Poly[T hwy.Floats](input []T, output []T) {
	switch any(input).(type) {
	case []float32:
		Log10PolyFloat32(any(input).([]float32), any(output).([]float32))
	case []float64:
		Log10PolyFloat64(any(input).([]float64), any(output).([]float64))
	}
}

// TanPoly is the generic API that dispatches to the appropriate SIMD implementation.
func TanPoly[T hwy.Floats](input []T, output []T) {
	switch any(input).(type) {
	case []float32:
		TanPolyFloat32(any(input).([]float32), any(output).([]float32))
	case []float64:
		TanPolyFloat64(any(input).([]float64), any(output).([]float64))
	}
}

// Atan2Poly is the generic API that dispatches to the appropriate SIMD implementation.
func Atan2Poly[T hwy.Floats](inputY []T, inputX []T, output []T) {
	switch any(inputY).(type) {
	case []float32:
		Atan2PolyFloat32(any(inputY).([]float32), any(inputX).([]float32), any(output).([]float32))
	case []float64:
		Atan2PolyFloat64(any(inputY).([]float64), any(inputX).([]float64), any(output).([]float64))
	}
}

// SinCosPoly is the generic API that dispatches to the appropriate SIMD implementation.
func SinCosPoly[T hwy.Floats](input []T, sinOutput []T, cosOutput []T) {
	switch any(input).(type) {
	case []float32:
		SinCosPolyFloat32(any(input).([]float32), any(sinOutput).([]float32), any(cosOutput).([]float32))
	case []float64:
		SinCosPolyFloat64(any(input).([]float64), any(sinOutput).([]float64), any(cosOutput).([]float64))
	}
}

// PowPoly is the generic API that dispatches to the appropriate SIMD implementation.
func PowPoly[T hwy.Floats](inputX []T, inputY []T, output []T) {
	switch any(inputX).(type) {
	case []float32:
		PowPolyFloat32(any(inputX).([]float32), any(inputY).([]float32), any(output).([]float32))
	case []float64:
		PowPolyFloat64(any(inputX).([]float64), any(inputY).([]float64), any(output).([]float64))
	}
}

// Exp2Poly is the generic API that dispatches to the appropriate SIMD implementation.
func Exp2Poly[T hwy.Floats](input []T, output []T) {
	switch any(input).(type) {
	case []float32:
		Exp2PolyFloat32(any(input).([]float32), any(output).([]float32))
	case []float64:
		Exp2PolyFloat64(any(input).([]float64), any(output).([]float64))
	}
}

// Exp10Poly is the generic API that dispatches to the appropriate SIMD implementation.
func Exp10Poly[T hwy.Floats](input []T, output []T) {
	switch any(input).(type) {
	case []float32:
		Exp10PolyFloat32(any(input).([]float32), any(output).([]float32))
	case []float64:
		Exp10PolyFloat64(any(input).([]float64), any(output).([]float64))
	}
}

// AsinhPoly is the generic API that dispatches to the appropriate SIMD implementation.
func AsinhPoly[T hwy.Floats](input []T, output []T) {
	switch any(input).(type) {
	case []float32:
		AsinhPolyFloat32(any(input).([]float32), any(output).([]float32))
	case []float64:
		AsinhPolyFloat64(any(input).([]float64), any(output).([]float64))
	}
}

// AcoshPoly is the generic API that dispatches to the appropriate SIMD implementation.
func AcoshPoly[T hwy.Floats](input []T, output []T) {
	switch any(input).(type) {
	case []float32:
		AcoshPolyFloat32(any(input).([]float32), any(output).([]float32))
	case []float64:
		AcoshPolyFloat64(any(input).([]float64), any(output).([]float64))
	}
}

// AtanhPoly is the generic API that dispatches to the appropriate SIMD implementation.
func AtanhPoly[T hwy.Floats](input []T, output []T) {
	switch any(input).(type) {
	case []float32:
		AtanhPolyFloat32(any(input).([]float32), any(output).([]float32))
	case []float64:
		AtanhPolyFloat64(any(input).([]float64), any(output).([]float64))
	}
}

// CbrtPoly is the generic API that dispatches to the appropriate SIMD implementation.
func CbrtPoly[T hwy.Floats](input []T, output []T) {
	switch any(input).(type) {
	case []float32:
		CbrtPolyFloat32(any(input).([]float32), any(output).([]float32))
	case []float64:
		CbrtPolyFloat64(any(input).([]float64), any(output).([]float64))
	}
}

// HypotPoly is the generic API that dispatches to the appropriate SIMD implementation.
func HypotPoly[T hwy.Floats](inputX []T, inputY []T, output []T) {
	switch any(inputX).(type) {
	case []float32:
		HypotPolyFloat32(any(inputX).([]float32), any(inputY).([]float32), any(output).([]float32))
	case []float64:
		HypotPolyFloat64(any(inputX).([]float64), any(inputY).([]float64), any(output).([]float64))
	}
}

func init() {
	if os.Getenv("HWY_NO_SIMD") != "" {
		initFallback()
		return
	}
	initNEON()
	return
}

func initNEON() {
	ExpPolyFloat32 = BaseExpPoly_neon
	ExpPolyFloat64 = BaseExpPoly_neon_Float64
	TanhPolyFloat32 = BaseTanhPoly_neon
	TanhPolyFloat64 = BaseTanhPoly_neon_Float64
	SigmoidPolyFloat32 = BaseSigmoidPoly_neon
	SigmoidPolyFloat64 = BaseSigmoidPoly_neon_Float64
	SinPolyFloat32 = BaseSinPoly_neon
	SinPolyFloat64 = BaseSinPoly_neon_Float64
	CosPolyFloat32 = BaseCosPoly_neon
	CosPolyFloat64 = BaseCosPoly_neon_Float64
	AtanPolyFloat32 = BaseAtanPoly_neon
	AtanPolyFloat64 = BaseAtanPoly_neon_Float64
	AsinPolyFloat32 = BaseAsinPoly_neon
	AsinPolyFloat64 = BaseAsinPoly_neon_Float64
	AcosPolyFloat32 = BaseAcosPoly_neon
	AcosPolyFloat64 = BaseAcosPoly_neon_Float64
	SinhPolyFloat32 = BaseSinhPoly_neon
	SinhPolyFloat64 = BaseSinhPoly_neon_Float64
	CoshPolyFloat32 = BaseCoshPoly_neon
	CoshPolyFloat64 = BaseCoshPoly_neon_Float64
	ErfPolyFloat32 = BaseErfPoly_neon
	ErfPolyFloat64 = BaseErfPoly_neon_Float64
	Expm1PolyFloat32 = BaseExpm1Poly_neon
	Expm1PolyFloat64 = BaseExpm1Poly_neon_Float64
	Log1pPolyFloat32 = BaseLog1pPoly_neon
	Log1pPolyFloat64 = BaseLog1pPoly_neon_Float64
	LogPolyFloat32 = BaseLogPoly_neon
	LogPolyFloat64 = BaseLogPoly_neon_Float64
	Log2PolyFloat32 = BaseLog2Poly_neon
	Log2PolyFloat64 = BaseLog2Poly_neon_Float64
	Log10PolyFloat32 = BaseLog10Poly_neon
	Log10PolyFloat64 = BaseLog10Poly_neon_Float64
	TanPolyFloat32 = BaseTanPoly_neon
	TanPolyFloat64 = BaseTanPoly_neon_Float64
	Atan2PolyFloat32 = BaseAtan2Poly_neon
	Atan2PolyFloat64 = BaseAtan2Poly_neon_Float64
	SinCosPolyFloat32 = BaseSinCosPoly_neon
	SinCosPolyFloat64 = BaseSinCosPoly_neon_Float64
	PowPolyFloat32 = BasePowPoly_neon
	PowPolyFloat64 = BasePowPoly_neon_Float64
	Exp2PolyFloat32 = BaseExp2Poly_neon
	Exp2PolyFloat64 = BaseExp2Poly_neon_Float64
	Exp10PolyFloat32 = BaseExp10Poly_neon
	Exp10PolyFloat64 = BaseExp10Poly_neon_Float64
	AsinhPolyFloat32 = BaseAsinhPoly_neon
	AsinhPolyFloat64 = BaseAsinhPoly_neon_Float64
	AcoshPolyFloat32 = BaseAcoshPoly_neon
	AcoshPolyFloat64 = BaseAcoshPoly_neon_Float64
	AtanhPolyFloat32 = BaseAtanhPoly_neon
	AtanhPolyFloat64 = BaseAtanhPoly_neon_Float64
	CbrtPolyFloat32 = BaseCbrtPoly_neon
	CbrtPolyFloat64 = BaseCbrtPoly_neon_Float64
	HypotPolyFloat32 = BaseHypotPoly_neon
	HypotPolyFloat64 = BaseHypotPoly_neon_Float64
}

func initFallback() {
	ExpPolyFloat32 = BaseExpPoly_fallback
	ExpPolyFloat64 = BaseExpPoly_fallback_Float64
	TanhPolyFloat32 = BaseTanhPoly_fallback
	TanhPolyFloat64 = BaseTanhPoly_fallback_Float64
	SigmoidPolyFloat32 = BaseSigmoidPoly_fallback
	SigmoidPolyFloat64 = BaseSigmoidPoly_fallback_Float64
	SinPolyFloat32 = BaseSinPoly_fallback
	SinPolyFloat64 = BaseSinPoly_fallback_Float64
	CosPolyFloat32 = BaseCosPoly_fallback
	CosPolyFloat64 = BaseCosPoly_fallback_Float64
	AtanPolyFloat32 = BaseAtanPoly_fallback
	AtanPolyFloat64 = BaseAtanPoly_fallback_Float64
	AsinPolyFloat32 = BaseAsinPoly_fallback
	AsinPolyFloat64 = BaseAsinPoly_fallback_Float64
	AcosPolyFloat32 = BaseAcosPoly_fallback
	AcosPolyFloat64 = BaseAcosPoly_fallback_Float64
	SinhPolyFloat32 = BaseSinhPoly_fallback
	SinhPolyFloat64 = BaseSinhPoly_fallback_Float64
	CoshPolyFloat32 = BaseCoshPoly_fallback
	CoshPolyFloat64 = BaseCoshPoly_fallback_Float64
	ErfPolyFloat32 = BaseErfPoly_fallback
	ErfPolyFloat64 = BaseErfPoly_fallback_Float64
	Expm1PolyFloat32 = BaseExpm1Poly_fallback
	Expm1PolyFloat64 = BaseExpm1Poly_fallback_Float64
	Log1pPolyFloat32 = BaseLog1pPoly_fallback
	Log1pPolyFloat64 = BaseLog1pPoly_fallback_Float64
	LogPolyFloat32 = BaseLogPoly_fallback
	LogPolyFloat64 = BaseLogPoly_fallback_Float64
	Log2PolyFloat32 = BaseLog2Poly_fallback
	Log2PolyFloat64 = BaseLog2Poly_fallback_Float64
	Log10PolyFloat32 = BaseLog10Poly_fallback
	Log10PolyFloat64 = BaseLog10Poly_fallback_Float64
	TanPolyFloat32 = BaseTanPoly_fallback
	TanPolyFloat64 = BaseTanPoly_fallback_Float64
	Atan2PolyFloat32 = BaseAtan2Poly_fallback
	Atan2PolyFloat64 = BaseAtan2Poly_fallback_Float64
	SinCosPolyFloat32 = BaseSinCosPoly_fallback
	SinCosPolyFloat64 = BaseSinCosPoly_fallback_Float64
	PowPolyFloat32 = BasePowPoly_fallback
	PowPolyFloat64 = BasePowPoly_fallback_Float64
	Exp2PolyFloat32 = BaseExp2Poly_fallback
	Exp2PolyFloat64 = BaseExp2Poly_fallback_Float64
	Exp10PolyFloat32 = BaseExp10Poly_fallback
	Exp10PolyFloat64 = BaseExp10Poly_fallback_Float64
	AsinhPolyFloat32 = BaseAsinhPoly_fallback
	AsinhPolyFloat64 = BaseAsinhPoly_fallback_Float64
	AcoshPolyFloat32 = BaseAcoshPoly_fallback
	AcoshPolyFloat64 = BaseAcoshPoly_fallback_Float64
	AtanhPolyFloat32 = BaseAtanhPoly_fallback
	AtanhPolyFloat64 = BaseAtanhPoly_fallback_Float64
	CbrtPolyFloat32 = BaseCbrtPoly_fallback
	CbrtPolyFloat64 = BaseCbrtPoly_fallback_Float64
	HypotPolyFloat32 = BaseHypotPoly_fallback
	HypotPolyFloat64 = BaseHypotPoly_fallback_Float64
}
