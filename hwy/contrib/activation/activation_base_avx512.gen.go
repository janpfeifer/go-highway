// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

//go:build amd64 && goexperiment.simd

package activation

import (
	"github.com/ajroetker/go-highway/hwy"
	"github.com/ajroetker/go-highway/hwy/contrib/math"
	stdmath "math"
	"simd/archsimd"
)

func BaseGELU_avx512_Float16(input []hwy.Float16, output []hwy.Float16) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	vHalf := hwy.Const[hwy.Float16](0.5)
	vOne := hwy.Const[hwy.Float16](1.0)
	vInvSqrt2 := hwy.Const[hwy.Float16](0.7071067811865476)
	lanes := 32
	ii := 0
	for ; ii+lanes <= size; ii += lanes {
		x := hwy.Load(input[ii:])
		xScaled := hwy.MulF16(x, vInvSqrt2)
		erfX := math.BaseErfVec_avx512_Float16(xScaled)
		onePlusErf := hwy.AddF16(vOne, erfX)
		halfOnePlusErf := hwy.MulF16(vHalf, onePlusErf)
		result := hwy.MulF16(x, halfOnePlusErf)
		hwy.Store(result, output[ii:])
	}
	for i := ii; i < size; i++ {
		x := float64(input[i].Float32())
		output[i] = hwy.Float32ToFloat16(float32(x * 0.5 * (1.0 + stdmath.Erf(x*0.7071067811865476))))
	}
}

func BaseGELU_avx512_BFloat16(input []hwy.BFloat16, output []hwy.BFloat16) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	vHalf := hwy.Const[hwy.BFloat16](0.5)
	vOne := hwy.Const[hwy.BFloat16](1.0)
	vInvSqrt2 := hwy.Const[hwy.BFloat16](0.7071067811865476)
	lanes := 32
	ii := 0
	for ; ii+lanes <= size; ii += lanes {
		x := hwy.Load(input[ii:])
		xScaled := hwy.MulBF16(x, vInvSqrt2)
		erfX := math.BaseErfVec_avx512_BFloat16(xScaled)
		onePlusErf := hwy.AddBF16(vOne, erfX)
		halfOnePlusErf := hwy.MulBF16(vHalf, onePlusErf)
		result := hwy.MulBF16(x, halfOnePlusErf)
		hwy.Store(result, output[ii:])
	}
	for i := ii; i < size; i++ {
		x := float64(input[i].Float32())
		output[i] = hwy.Float32ToBFloat16(float32(x * 0.5 * (1.0 + stdmath.Erf(x*0.7071067811865476))))
	}
}

func BaseGELU_avx512(input []float32, output []float32) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	vHalf := archsimd.BroadcastFloat32x16(0.5)
	vOne := archsimd.BroadcastFloat32x16(1.0)
	vInvSqrt2 := archsimd.BroadcastFloat32x16(0.7071067811865476)
	lanes := 16
	ii := 0
	for ; ii+lanes <= size; ii += lanes {
		x := archsimd.LoadFloat32x16Slice(input[ii:])
		xScaled := x.Mul(vInvSqrt2)
		erfX := math.BaseErfVec_avx512(xScaled)
		onePlusErf := vOne.Add(erfX)
		halfOnePlusErf := vHalf.Mul(onePlusErf)
		result := x.Mul(halfOnePlusErf)
		result.StoreSlice(output[ii:])
	}
	for i := ii; i < size; i++ {
		x := float64(input[i])
		output[i] = float32(x * 0.5 * (1.0 + stdmath.Erf(x*0.7071067811865476)))
	}
}

func BaseGELU_avx512_Float64(input []float64, output []float64) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	vHalf := archsimd.BroadcastFloat64x8(0.5)
	vOne := archsimd.BroadcastFloat64x8(1.0)
	vInvSqrt2 := archsimd.BroadcastFloat64x8(0.7071067811865476)
	lanes := 8
	ii := 0
	for ; ii+lanes <= size; ii += lanes {
		x := archsimd.LoadFloat64x8Slice(input[ii:])
		xScaled := x.Mul(vInvSqrt2)
		erfX := math.BaseErfVec_avx512_Float64(xScaled)
		onePlusErf := vOne.Add(erfX)
		halfOnePlusErf := vHalf.Mul(onePlusErf)
		result := x.Mul(halfOnePlusErf)
		result.StoreSlice(output[ii:])
	}
	for i := ii; i < size; i++ {
		x := float64(input[i])
		output[i] = float64(x * 0.5 * (1.0 + stdmath.Erf(x*0.7071067811865476)))
	}
}

func BaseGELUApprox_avx512_Float16(input []hwy.Float16, output []hwy.Float16) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	vCoeff := hwy.Const[hwy.Float16](1.702)
	lanes := 32
	ii := 0
	for ; ii+lanes <= size; ii += lanes {
		x := hwy.Load(input[ii:])
		xScaled := hwy.MulF16(x, vCoeff)
		sigmoidX := math.BaseSigmoidVec_avx512_Float16(xScaled)
		result := hwy.MulF16(x, sigmoidX)
		hwy.Store(result, output[ii:])
	}
	for i := ii; i < size; i++ {
		x := float64(input[i].Float32())
		sigmoid := 1.0 / (1.0 + stdmath.Exp(-1.702*x))
		output[i] = hwy.Float32ToFloat16(float32(x * sigmoid))
	}
}

func BaseGELUApprox_avx512_BFloat16(input []hwy.BFloat16, output []hwy.BFloat16) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	vCoeff := hwy.Const[hwy.BFloat16](1.702)
	lanes := 32
	ii := 0
	for ; ii+lanes <= size; ii += lanes {
		x := hwy.Load(input[ii:])
		xScaled := hwy.MulBF16(x, vCoeff)
		sigmoidX := math.BaseSigmoidVec_avx512_BFloat16(xScaled)
		result := hwy.MulBF16(x, sigmoidX)
		hwy.Store(result, output[ii:])
	}
	for i := ii; i < size; i++ {
		x := float64(input[i].Float32())
		sigmoid := 1.0 / (1.0 + stdmath.Exp(-1.702*x))
		output[i] = hwy.Float32ToBFloat16(float32(x * sigmoid))
	}
}

func BaseGELUApprox_avx512(input []float32, output []float32) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	vCoeff := archsimd.BroadcastFloat32x16(1.702)
	lanes := 16
	ii := 0
	for ; ii+lanes <= size; ii += lanes {
		x := archsimd.LoadFloat32x16Slice(input[ii:])
		xScaled := x.Mul(vCoeff)
		sigmoidX := math.BaseSigmoidVec_avx512(xScaled)
		result := x.Mul(sigmoidX)
		result.StoreSlice(output[ii:])
	}
	for i := ii; i < size; i++ {
		x := float64(input[i])
		sigmoid := 1.0 / (1.0 + stdmath.Exp(-1.702*x))
		output[i] = float32(x * sigmoid)
	}
}

func BaseGELUApprox_avx512_Float64(input []float64, output []float64) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	vCoeff := archsimd.BroadcastFloat64x8(1.702)
	lanes := 8
	ii := 0
	for ; ii+lanes <= size; ii += lanes {
		x := archsimd.LoadFloat64x8Slice(input[ii:])
		xScaled := x.Mul(vCoeff)
		sigmoidX := math.BaseSigmoidVec_avx512_Float64(xScaled)
		result := x.Mul(sigmoidX)
		result.StoreSlice(output[ii:])
	}
	for i := ii; i < size; i++ {
		x := float64(input[i])
		sigmoid := 1.0 / (1.0 + stdmath.Exp(-1.702*x))
		output[i] = float64(x * sigmoid)
	}
}

func BaseReLU_avx512_Float16(input []hwy.Float16, output []hwy.Float16) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	vZero := hwy.Const[hwy.Float16](0.0)
	lanes := 32
	ii := 0
	for ; ii+lanes <= size; ii += lanes {
		x := hwy.Load(input[ii:])
		result := hwy.MaxF16(x, vZero)
		hwy.Store(result, output[ii:])
	}
	for i := ii; i < size; i++ {
		if input[i].Float32() > 0 {
			output[i] = hwy.Float32ToFloat16(input[i].Float32())
		} else {
			output[i] = hwy.Float32ToFloat16(0)
		}
	}
}

func BaseReLU_avx512_BFloat16(input []hwy.BFloat16, output []hwy.BFloat16) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	vZero := hwy.Const[hwy.BFloat16](0.0)
	lanes := 32
	ii := 0
	for ; ii+lanes <= size; ii += lanes {
		x := hwy.Load(input[ii:])
		result := hwy.MaxBF16(x, vZero)
		hwy.Store(result, output[ii:])
	}
	for i := ii; i < size; i++ {
		if input[i].Float32() > 0 {
			output[i] = hwy.Float32ToBFloat16(input[i].Float32())
		} else {
			output[i] = hwy.Float32ToBFloat16(0)
		}
	}
}

func BaseReLU_avx512(input []float32, output []float32) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	vZero := archsimd.BroadcastFloat32x16(0.0)
	lanes := 16
	ii := 0
	for ; ii+lanes <= size; ii += lanes {
		x := archsimd.LoadFloat32x16Slice(input[ii:])
		result := x.Max(vZero)
		result.StoreSlice(output[ii:])
	}
	for i := ii; i < size; i++ {
		if input[i] > 0 {
			output[i] = input[i]
		} else {
			output[i] = 0
		}
	}
}

func BaseReLU_avx512_Float64(input []float64, output []float64) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	vZero := archsimd.BroadcastFloat64x8(0.0)
	lanes := 8
	ii := 0
	for ; ii+lanes <= size; ii += lanes {
		x := archsimd.LoadFloat64x8Slice(input[ii:])
		result := x.Max(vZero)
		result.StoreSlice(output[ii:])
	}
	for i := ii; i < size; i++ {
		if input[i] > 0 {
			output[i] = input[i]
		} else {
			output[i] = 0
		}
	}
}

func BaseSiLU_avx512_Float16(input []hwy.Float16, output []hwy.Float16) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	lanes := 32
	ii := 0
	for ; ii+lanes <= size; ii += lanes {
		x := hwy.Load(input[ii:])
		sigmoidX := math.BaseSigmoidVec_avx512_Float16(x)
		result := hwy.MulF16(x, sigmoidX)
		hwy.Store(result, output[ii:])
	}
	for i := ii; i < size; i++ {
		x := float64(input[i].Float32())
		sigmoid := 1.0 / (1.0 + stdmath.Exp(-x))
		output[i] = hwy.Float32ToFloat16(float32(x * sigmoid))
	}
}

func BaseSiLU_avx512_BFloat16(input []hwy.BFloat16, output []hwy.BFloat16) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	lanes := 32
	ii := 0
	for ; ii+lanes <= size; ii += lanes {
		x := hwy.Load(input[ii:])
		sigmoidX := math.BaseSigmoidVec_avx512_BFloat16(x)
		result := hwy.MulBF16(x, sigmoidX)
		hwy.Store(result, output[ii:])
	}
	for i := ii; i < size; i++ {
		x := float64(input[i].Float32())
		sigmoid := 1.0 / (1.0 + stdmath.Exp(-x))
		output[i] = hwy.Float32ToBFloat16(float32(x * sigmoid))
	}
}

func BaseSiLU_avx512(input []float32, output []float32) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	lanes := 16
	ii := 0
	for ; ii+lanes <= size; ii += lanes {
		x := archsimd.LoadFloat32x16Slice(input[ii:])
		sigmoidX := math.BaseSigmoidVec_avx512(x)
		result := x.Mul(sigmoidX)
		result.StoreSlice(output[ii:])
	}
	for i := ii; i < size; i++ {
		x := float64(input[i])
		sigmoid := 1.0 / (1.0 + stdmath.Exp(-x))
		output[i] = float32(x * sigmoid)
	}
}

func BaseSiLU_avx512_Float64(input []float64, output []float64) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	lanes := 8
	ii := 0
	for ; ii+lanes <= size; ii += lanes {
		x := archsimd.LoadFloat64x8Slice(input[ii:])
		sigmoidX := math.BaseSigmoidVec_avx512_Float64(x)
		result := x.Mul(sigmoidX)
		result.StoreSlice(output[ii:])
	}
	for i := ii; i < size; i++ {
		x := float64(input[i])
		sigmoid := 1.0 / (1.0 + stdmath.Exp(-x))
		output[i] = float64(x * sigmoid)
	}
}

func BaseLeakyReLU_avx512_Float16(input []hwy.Float16, output []hwy.Float16, alpha hwy.Float16) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	vAlpha := hwy.Set(alpha)
	lanes := 32
	ii := 0
	for ; ii+lanes <= size; ii += lanes {
		x := hwy.Load(input[ii:])
		negPart := hwy.MulF16(x, vAlpha)
		result := hwy.MaxF16(x, negPart)
		hwy.Store(result, output[ii:])
	}
	for i := ii; i < size; i++ {
		if input[i].Float32() > 0 {
			output[i] = hwy.Float32ToFloat16(input[i].Float32())
		} else {
			output[i] = hwy.Float32ToFloat16(alpha.Float32() * input[i].Float32())
		}
	}
}

func BaseLeakyReLU_avx512_BFloat16(input []hwy.BFloat16, output []hwy.BFloat16, alpha hwy.BFloat16) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	vAlpha := hwy.Set(alpha)
	lanes := 32
	ii := 0
	for ; ii+lanes <= size; ii += lanes {
		x := hwy.Load(input[ii:])
		negPart := hwy.MulBF16(x, vAlpha)
		result := hwy.MaxBF16(x, negPart)
		hwy.Store(result, output[ii:])
	}
	for i := ii; i < size; i++ {
		if input[i].Float32() > 0 {
			output[i] = hwy.Float32ToBFloat16(input[i].Float32())
		} else {
			output[i] = hwy.Float32ToBFloat16(alpha.Float32() * input[i].Float32())
		}
	}
}

func BaseLeakyReLU_avx512(input []float32, output []float32, alpha float32) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	vAlpha := archsimd.BroadcastFloat32x16(alpha)
	lanes := 16
	ii := 0
	for ; ii+lanes <= size; ii += lanes {
		x := archsimd.LoadFloat32x16Slice(input[ii:])
		negPart := x.Mul(vAlpha)
		result := x.Max(negPart)
		result.StoreSlice(output[ii:])
	}
	for i := ii; i < size; i++ {
		if input[i] > 0 {
			output[i] = input[i]
		} else {
			output[i] = alpha * input[i]
		}
	}
}

func BaseLeakyReLU_avx512_Float64(input []float64, output []float64, alpha float64) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	vAlpha := archsimd.BroadcastFloat64x8(alpha)
	lanes := 8
	ii := 0
	for ; ii+lanes <= size; ii += lanes {
		x := archsimd.LoadFloat64x8Slice(input[ii:])
		negPart := x.Mul(vAlpha)
		result := x.Max(negPart)
		result.StoreSlice(output[ii:])
	}
	for i := ii; i < size; i++ {
		if input[i] > 0 {
			output[i] = input[i]
		} else {
			output[i] = alpha * input[i]
		}
	}
}

func BaseELU_avx512_Float16(input []hwy.Float16, output []hwy.Float16, alpha hwy.Float16) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	vZero := hwy.Const[hwy.Float16](0.0)
	vOne := hwy.Const[hwy.Float16](1.0)
	vAlpha := hwy.Set(alpha)
	lanes := 32
	ii := 0
	for ; ii+lanes <= size; ii += lanes {
		x := hwy.Load(input[ii:])
		expX := math.BaseExpVec_avx512_Float16(x)
		expM1 := hwy.SubF16(expX, vOne)
		negPart := hwy.MulF16(vAlpha, expM1)
		isPositive := hwy.GreaterThanF16(x, vZero)
		result := hwy.IfThenElseF16(isPositive, x, negPart)
		hwy.Store(result, output[ii:])
	}
	for i := ii; i < size; i++ {
		if input[i].Float32() > 0 {
			output[i] = hwy.Float32ToFloat16(input[i].Float32())
		} else {
			x := float64(input[i].Float32())
			output[i] = hwy.Float32ToFloat16(float32(float64(alpha) * (stdmath.Exp(x) - 1.0)))
		}
	}
}

func BaseELU_avx512_BFloat16(input []hwy.BFloat16, output []hwy.BFloat16, alpha hwy.BFloat16) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	vZero := hwy.Const[hwy.BFloat16](0.0)
	vOne := hwy.Const[hwy.BFloat16](1.0)
	vAlpha := hwy.Set(alpha)
	lanes := 32
	ii := 0
	for ; ii+lanes <= size; ii += lanes {
		x := hwy.Load(input[ii:])
		expX := math.BaseExpVec_avx512_BFloat16(x)
		expM1 := hwy.SubBF16(expX, vOne)
		negPart := hwy.MulBF16(vAlpha, expM1)
		isPositive := hwy.GreaterThanBF16(x, vZero)
		result := hwy.IfThenElseBF16(isPositive, x, negPart)
		hwy.Store(result, output[ii:])
	}
	for i := ii; i < size; i++ {
		if input[i].Float32() > 0 {
			output[i] = hwy.Float32ToBFloat16(input[i].Float32())
		} else {
			x := float64(input[i].Float32())
			output[i] = hwy.Float32ToBFloat16(float32(float64(alpha) * (stdmath.Exp(x) - 1.0)))
		}
	}
}

func BaseELU_avx512(input []float32, output []float32, alpha float32) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	vZero := archsimd.BroadcastFloat32x16(0.0)
	vOne := archsimd.BroadcastFloat32x16(1.0)
	vAlpha := archsimd.BroadcastFloat32x16(alpha)
	lanes := 16
	ii := 0
	for ; ii+lanes <= size; ii += lanes {
		x := archsimd.LoadFloat32x16Slice(input[ii:])
		expX := math.BaseExpVec_avx512(x)
		expM1 := expX.Sub(vOne)
		negPart := vAlpha.Mul(expM1)
		isPositive := x.Greater(vZero)
		result := x.Merge(negPart, isPositive)
		result.StoreSlice(output[ii:])
	}
	for i := ii; i < size; i++ {
		if input[i] > 0 {
			output[i] = input[i]
		} else {
			x := float64(input[i])
			output[i] = float32(float64(alpha) * (stdmath.Exp(x) - 1.0))
		}
	}
}

func BaseELU_avx512_Float64(input []float64, output []float64, alpha float64) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	vZero := archsimd.BroadcastFloat64x8(0.0)
	vOne := archsimd.BroadcastFloat64x8(1.0)
	vAlpha := archsimd.BroadcastFloat64x8(alpha)
	lanes := 8
	ii := 0
	for ; ii+lanes <= size; ii += lanes {
		x := archsimd.LoadFloat64x8Slice(input[ii:])
		expX := math.BaseExpVec_avx512_Float64(x)
		expM1 := expX.Sub(vOne)
		negPart := vAlpha.Mul(expM1)
		isPositive := x.Greater(vZero)
		result := x.Merge(negPart, isPositive)
		result.StoreSlice(output[ii:])
	}
	for i := ii; i < size; i++ {
		if input[i] > 0 {
			output[i] = input[i]
		} else {
			x := float64(input[i])
			output[i] = float64(float64(alpha) * (stdmath.Exp(x) - 1.0))
		}
	}
}
