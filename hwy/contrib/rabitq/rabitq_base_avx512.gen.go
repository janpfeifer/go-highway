// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

//go:build amd64 && goexperiment.simd

package rabitq

import (
	"math/bits"
	"simd/archsimd"

	"github.com/ajroetker/go-highway/hwy"
)

func BaseBitProduct_avx512(code []uint64, q1 []uint64, q2 []uint64, q3 []uint64, q4 []uint64) uint32 {
	if len(code) == 0 {
		return 0
	}
	var sum1, sum2, sum4, sum8 uint64
	lanes := 8
	n := len(code)
	stride := lanes * 4
	var i int
	for i = 0; i+stride <= n; i += stride {
		codeVec0, codeVec1, codeVec2, codeVec3 := hwy.Load4_AVX512_Uint64x8(code[i:])
		q1Vec0, q1Vec1, q1Vec2, q1Vec3 := hwy.Load4_AVX512_Uint64x8(q1[i:])
		q2Vec0, q2Vec1, q2Vec2, q2Vec3 := hwy.Load4_AVX512_Uint64x8(q2[i:])
		q3Vec0, q3Vec1, q3Vec2, q3Vec3 := hwy.Load4_AVX512_Uint64x8(q3[i:])
		q4Vec0, q4Vec1, q4Vec2, q4Vec3 := hwy.Load4_AVX512_Uint64x8(q4[i:])
		sum1 += uint64(hwy.ReduceSum_AVX512_Uint64x8(hwy.PopCount_AVX512_Uint64x8(codeVec0.And(q1Vec0))))
		sum1 += uint64(hwy.ReduceSum_AVX512_Uint64x8(hwy.PopCount_AVX512_Uint64x8(codeVec1.And(q1Vec1))))
		sum1 += uint64(hwy.ReduceSum_AVX512_Uint64x8(hwy.PopCount_AVX512_Uint64x8(codeVec2.And(q1Vec2))))
		sum1 += uint64(hwy.ReduceSum_AVX512_Uint64x8(hwy.PopCount_AVX512_Uint64x8(codeVec3.And(q1Vec3))))
		sum2 += uint64(hwy.ReduceSum_AVX512_Uint64x8(hwy.PopCount_AVX512_Uint64x8(codeVec0.And(q2Vec0))))
		sum2 += uint64(hwy.ReduceSum_AVX512_Uint64x8(hwy.PopCount_AVX512_Uint64x8(codeVec1.And(q2Vec1))))
		sum2 += uint64(hwy.ReduceSum_AVX512_Uint64x8(hwy.PopCount_AVX512_Uint64x8(codeVec2.And(q2Vec2))))
		sum2 += uint64(hwy.ReduceSum_AVX512_Uint64x8(hwy.PopCount_AVX512_Uint64x8(codeVec3.And(q2Vec3))))
		sum4 += uint64(hwy.ReduceSum_AVX512_Uint64x8(hwy.PopCount_AVX512_Uint64x8(codeVec0.And(q3Vec0))))
		sum4 += uint64(hwy.ReduceSum_AVX512_Uint64x8(hwy.PopCount_AVX512_Uint64x8(codeVec1.And(q3Vec1))))
		sum4 += uint64(hwy.ReduceSum_AVX512_Uint64x8(hwy.PopCount_AVX512_Uint64x8(codeVec2.And(q3Vec2))))
		sum4 += uint64(hwy.ReduceSum_AVX512_Uint64x8(hwy.PopCount_AVX512_Uint64x8(codeVec3.And(q3Vec3))))
		sum8 += uint64(hwy.ReduceSum_AVX512_Uint64x8(hwy.PopCount_AVX512_Uint64x8(codeVec0.And(q4Vec0))))
		sum8 += uint64(hwy.ReduceSum_AVX512_Uint64x8(hwy.PopCount_AVX512_Uint64x8(codeVec1.And(q4Vec1))))
		sum8 += uint64(hwy.ReduceSum_AVX512_Uint64x8(hwy.PopCount_AVX512_Uint64x8(codeVec2.And(q4Vec2))))
		sum8 += uint64(hwy.ReduceSum_AVX512_Uint64x8(hwy.PopCount_AVX512_Uint64x8(codeVec3.And(q4Vec3))))
	}
	for i+lanes <= n {
		codeVec := archsimd.LoadUint64x8Slice(code[i:])
		q1Vec := archsimd.LoadUint64x8Slice(q1[i:])
		q2Vec := archsimd.LoadUint64x8Slice(q2[i:])
		q3Vec := archsimd.LoadUint64x8Slice(q3[i:])
		q4Vec := archsimd.LoadUint64x8Slice(q4[i:])
		sum1 += uint64(hwy.ReduceSum_AVX512_Uint64x8(hwy.PopCount_AVX512_Uint64x8(codeVec.And(q1Vec))))
		sum2 += uint64(hwy.ReduceSum_AVX512_Uint64x8(hwy.PopCount_AVX512_Uint64x8(codeVec.And(q2Vec))))
		sum4 += uint64(hwy.ReduceSum_AVX512_Uint64x8(hwy.PopCount_AVX512_Uint64x8(codeVec.And(q3Vec))))
		sum8 += uint64(hwy.ReduceSum_AVX512_Uint64x8(hwy.PopCount_AVX512_Uint64x8(codeVec.And(q4Vec))))
		i += lanes
	}
	for ; i < n; i++ {
		sum1 += uint64(bits.OnesCount64(code[i] & q1[i]))
		sum2 += uint64(bits.OnesCount64(code[i] & q2[i]))
		sum4 += uint64(bits.OnesCount64(code[i] & q3[i]))
		sum8 += uint64(bits.OnesCount64(code[i] & q4[i]))
	}
	return uint32(sum1 + (sum2 << 1) + (sum4 << 2) + (sum8 << 3))
}

func BaseQuantizeVectors_avx512(unitVectors []float32, codes []uint64, dotProducts []float32, codeCounts []uint32, sqrtDimsInv float32, count int, dims int, width int) {
	negSqrtDimsInv := -sqrtDimsInv
	for i := range count {
		vec := unitVectors[i*dims : (i+1)*dims]
		code := codes[i*width : (i+1)*width]
		var dotProduct float64
		var codeBits uint64
		var codeCount uint32
		codeIdx := 0
		bitPos := 0
		lanes := 16
		dim := 0
		for dim+lanes <= dims {
			vecData := archsimd.LoadFloat32x16Slice(vec[dim:])
			zeroVec := archsimd.BroadcastFloat32x16(0)
			negMask := vecData.Less(zeroVec)
			posMultVec := archsimd.BroadcastFloat32x16(sqrtDimsInv)
			negMultVec := archsimd.BroadcastFloat32x16(negSqrtDimsInv)
			multVec := hwy.IfThenElse_AVX512_F32x16(negMask, negMultVec, posMultVec)
			prodVec := vecData.Mul(multVec)
			dotProduct += float64(hwy.ReduceSum_AVX512_F32x16(prodVec))
			for j := range lanes {
				element := hwy.GetLane_AVX512_F32x16(vecData, j)
				signBit := getSignBit(element)
				codeBits = (codeBits << 1) | uint64(1-signBit)
				bitPos++
				if bitPos == 64 {
					code[codeIdx] = codeBits
					codeCount += uint32(bits.OnesCount64(codeBits))
					codeIdx++
					codeBits = 0
					bitPos = 0
				}
			}
			dim += lanes
		}
		for ; dim < dims; dim++ {
			element := vec[dim]
			signBit := getSignBit(element)
			var mult float32
			if signBit == 1 {
				mult = negSqrtDimsInv
			} else {
				mult = sqrtDimsInv
			}
			dotProduct += float64(element) * float64(mult)
			codeBits = (codeBits << 1) | uint64(1-signBit)
			bitPos++
			if bitPos == 64 {
				code[codeIdx] = codeBits
				codeCount += uint32(bits.OnesCount64(codeBits))
				codeIdx++
				codeBits = 0
				bitPos = 0
			}
		}
		if bitPos > 0 {
			codeBits = codeBits << (64 - bitPos)
			code[codeIdx] = codeBits
			codeCount += uint32(bits.OnesCount64(codeBits))
		}
		codeCounts[i] = codeCount
		if dotProduct != 0 {
			dotProducts[i] = 1.0 / float32(dotProduct)
		} else {
			dotProducts[i] = 0
		}
	}
}
