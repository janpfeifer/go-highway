//go:build !noasm && arm64
// Code generated by hwygen -c. DO NOT EDIT.

package asm

import (
	"unsafe"

	"github.com/ajroetker/go-highway/hwy"
)

// Public wrapper functions
// InterleaveCF32 computes BaseInterleave for entire arrays using NEON SIMD.
func InterleaveCF32(input []float32) []float32 {
	result := make([]float32, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	interleave_c_f32_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// InterleaveCF64 computes BaseInterleave for entire arrays using NEON SIMD.
func InterleaveCF64(input []float64) []float64 {
	result := make([]float64, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	interleave_c_f64_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// InterleaveCS32 computes BaseInterleave for entire arrays using NEON SIMD.
func InterleaveCS32(input []float32) []float32 {
	result := make([]float32, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	interleave_c_s32_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// InterleaveCS64 computes BaseInterleave for entire arrays using NEON SIMD.
func InterleaveCS64(input []float32) []float32 {
	result := make([]float32, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	interleave_c_s64_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// InterleaveCU32 computes BaseInterleave for entire arrays using NEON SIMD.
func InterleaveCU32(input []float32) []float32 {
	result := make([]float32, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	interleave_c_u32_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// InterleaveCU64 computes BaseInterleave for entire arrays using NEON SIMD.
func InterleaveCU64(input []float32) []float32 {
	result := make([]float32, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	interleave_c_u64_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// DeinterleaveCF32 computes BaseDeinterleave for entire arrays using NEON SIMD.
func DeinterleaveCF32(input []float32) []float32 {
	result := make([]float32, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	deinterleave_c_f32_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// DeinterleaveCF64 computes BaseDeinterleave for entire arrays using NEON SIMD.
func DeinterleaveCF64(input []float64) []float64 {
	result := make([]float64, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	deinterleave_c_f64_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// DeinterleaveCS32 computes BaseDeinterleave for entire arrays using NEON SIMD.
func DeinterleaveCS32(input []float32) []float32 {
	result := make([]float32, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	deinterleave_c_s32_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// DeinterleaveCS64 computes BaseDeinterleave for entire arrays using NEON SIMD.
func DeinterleaveCS64(input []float32) []float32 {
	result := make([]float32, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	deinterleave_c_s64_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// DeinterleaveCU32 computes BaseDeinterleave for entire arrays using NEON SIMD.
func DeinterleaveCU32(input []float32) []float32 {
	result := make([]float32, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	deinterleave_c_u32_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// DeinterleaveCU64 computes BaseDeinterleave for entire arrays using NEON SIMD.
func DeinterleaveCU64(input []float32) []float32 {
	result := make([]float32, len(input))
	if len(input) == 0 {
		return result
	}
	n := int64(len(input))
	deinterleave_c_u64_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&result[0]), unsafe.Pointer(&n))
	return result
}

// LiftUpdate53CS32 computes LiftUpdate53 using NEON SIMD assembly.
func LiftUpdate53CS32(target []int32, tLen int, neighbor []int32, nLen, phase int) {
	if len(target) == 0 || len(neighbor) == 0 {
		return
	}
	tLenVal := int64(tLen)
	nLenVal := int64(nLen)
	phaseVal := int64(phase)
	liftupdate53_c_s32_neon(
		unsafe.Pointer(&target[0]),
		unsafe.Pointer(&tLenVal),
		unsafe.Pointer(&neighbor[0]),
		unsafe.Pointer(&nLenVal),
		unsafe.Pointer(&phaseVal),
	)
}

// LiftUpdate53CS64 computes LiftUpdate53 using NEON SIMD assembly.
func LiftUpdate53CS64(target []int64, tLen int, neighbor []int64, nLen, phase int) {
	if len(target) == 0 || len(neighbor) == 0 {
		return
	}
	tLenVal := int64(tLen)
	nLenVal := int64(nLen)
	phaseVal := int64(phase)
	liftupdate53_c_s64_neon(
		unsafe.Pointer(&target[0]),
		unsafe.Pointer(&tLenVal),
		unsafe.Pointer(&neighbor[0]),
		unsafe.Pointer(&nLenVal),
		unsafe.Pointer(&phaseVal),
	)
}

// LiftPredict53CS32 computes LiftPredict53 using NEON SIMD assembly.
func LiftPredict53CS32(target []int32, tLen int, neighbor []int32, nLen, phase int) {
	if len(target) == 0 || len(neighbor) == 0 {
		return
	}
	tLenVal := int64(tLen)
	nLenVal := int64(nLen)
	phaseVal := int64(phase)
	liftpredict53_c_s32_neon(
		unsafe.Pointer(&target[0]),
		unsafe.Pointer(&tLenVal),
		unsafe.Pointer(&neighbor[0]),
		unsafe.Pointer(&nLenVal),
		unsafe.Pointer(&phaseVal),
	)
}

// LiftPredict53CS64 computes LiftPredict53 using NEON SIMD assembly.
func LiftPredict53CS64(target []int64, tLen int, neighbor []int64, nLen, phase int) {
	if len(target) == 0 || len(neighbor) == 0 {
		return
	}
	tLenVal := int64(tLen)
	nLenVal := int64(nLen)
	phaseVal := int64(phase)
	liftpredict53_c_s64_neon(
		unsafe.Pointer(&target[0]),
		unsafe.Pointer(&tLenVal),
		unsafe.Pointer(&neighbor[0]),
		unsafe.Pointer(&nLenVal),
		unsafe.Pointer(&phaseVal),
	)
}

// LiftStep97CF16 computes LiftStep97 using NEON SIMD assembly.
func LiftStep97CF16(target []hwy.Float16, tLen int, neighbor []hwy.Float16, nLen int, coeff hwy.Float16, phase int) {
	if len(target) == 0 || len(neighbor) == 0 {
		return
	}
	tLenVal := int64(tLen)
	nLenVal := int64(nLen)
	phaseVal := int64(phase)
	liftstep97_c_f16_neon(
		unsafe.Pointer(&target[0]),
		unsafe.Pointer(&tLenVal),
		unsafe.Pointer(&neighbor[0]),
		unsafe.Pointer(&nLenVal),
		uint16(coeff),
		unsafe.Pointer(&phaseVal),
	)
}

// LiftStep97CF32 computes LiftStep97 using NEON SIMD assembly.
func LiftStep97CF32(target []float32, tLen int, neighbor []float32, nLen int, coeff float32, phase int) {
	if len(target) == 0 || len(neighbor) == 0 {
		return
	}
	tLenVal := int64(tLen)
	nLenVal := int64(nLen)
	phaseVal := int64(phase)
	liftstep97_c_f32_neon(
		unsafe.Pointer(&target[0]),
		unsafe.Pointer(&tLenVal),
		unsafe.Pointer(&neighbor[0]),
		unsafe.Pointer(&nLenVal),
		coeff,
		unsafe.Pointer(&phaseVal),
	)
}

// LiftStep97CF64 computes LiftStep97 using NEON SIMD assembly.
func LiftStep97CF64(target []float64, tLen int, neighbor []float64, nLen int, coeff float64, phase int) {
	if len(target) == 0 || len(neighbor) == 0 {
		return
	}
	tLenVal := int64(tLen)
	nLenVal := int64(nLen)
	phaseVal := int64(phase)
	liftstep97_c_f64_neon(
		unsafe.Pointer(&target[0]),
		unsafe.Pointer(&tLenVal),
		unsafe.Pointer(&neighbor[0]),
		unsafe.Pointer(&nLenVal),
		coeff,
		unsafe.Pointer(&phaseVal),
	)
}

// ScaleSliceCF16 computes ScaleSlice using NEON SIMD assembly.
func ScaleSliceCF16(data []hwy.Float16, n int, scale hwy.Float16) {
	if len(data) == 0 {
		return
	}
	nVal := int64(n)
	scaleslice_c_f16_neon(
		unsafe.Pointer(&data[0]),
		unsafe.Pointer(&nVal),
		uint16(scale),
	)
}

// ScaleSliceCF32 computes ScaleSlice using NEON SIMD assembly.
func ScaleSliceCF32(data []float32, n int, scale float32) {
	if len(data) == 0 {
		return
	}
	nVal := int64(n)
	scaleslice_c_f32_neon(
		unsafe.Pointer(&data[0]),
		unsafe.Pointer(&nVal),
		scale,
	)
}

// ScaleSliceCF64 computes ScaleSlice using NEON SIMD assembly.
func ScaleSliceCF64(data []float64, n int, scale float64) {
	if len(data) == 0 {
		return
	}
	nVal := int64(n)
	scaleslice_c_f64_neon(
		unsafe.Pointer(&data[0]),
		unsafe.Pointer(&nVal),
		scale,
	)
}

// Synthesize53CoreCS32 computes Synthesize53Core using NEON SIMD assembly.
func Synthesize53CoreCS32(data []int32, n int, low []int32, sn int, high []int32, dn, phase int) {
	if len(data) == 0 || len(low) == 0 || len(high) == 0 {
		return
	}
	nVal := int64(n)
	snVal := int64(sn)
	dnVal := int64(dn)
	phaseVal := int64(phase)
	synthesize53core_c_s32_neon(
		unsafe.Pointer(&data[0]),
		unsafe.Pointer(&nVal),
		unsafe.Pointer(&low[0]),
		unsafe.Pointer(&snVal),
		unsafe.Pointer(&high[0]),
		unsafe.Pointer(&dnVal),
		unsafe.Pointer(&phaseVal),
	)
}

// Synthesize53CoreCS64 computes Synthesize53Core using NEON SIMD assembly.
func Synthesize53CoreCS64(data []int64, n int, low []int64, sn int, high []int64, dn, phase int) {
	if len(data) == 0 || len(low) == 0 || len(high) == 0 {
		return
	}
	nVal := int64(n)
	snVal := int64(sn)
	dnVal := int64(dn)
	phaseVal := int64(phase)
	synthesize53core_c_s64_neon(
		unsafe.Pointer(&data[0]),
		unsafe.Pointer(&nVal),
		unsafe.Pointer(&low[0]),
		unsafe.Pointer(&snVal),
		unsafe.Pointer(&high[0]),
		unsafe.Pointer(&dnVal),
		unsafe.Pointer(&phaseVal),
	)
}

// Synthesize53CoreColsCS32 computes Synthesize53CoreCols using NEON SIMD assembly.
func Synthesize53CoreColsCS32(colBuf []int32, height int, lowBuf []int32, sn int, highBuf []int32, dn, phase int) {
	if len(colBuf) == 0 || len(lowBuf) == 0 || len(highBuf) == 0 {
		return
	}
	heightVal := int64(height)
	snVal := int64(sn)
	dnVal := int64(dn)
	phaseVal := int64(phase)
	synthesize53corecols_c_s32_neon(
		unsafe.Pointer(&colBuf[0]),
		unsafe.Pointer(&heightVal),
		unsafe.Pointer(&lowBuf[0]),
		unsafe.Pointer(&snVal),
		unsafe.Pointer(&highBuf[0]),
		unsafe.Pointer(&dnVal),
		unsafe.Pointer(&phaseVal),
	)
}

// Synthesize53CoreColsCS64 computes Synthesize53CoreCols using NEON SIMD assembly.
func Synthesize53CoreColsCS64(colBuf []int64, height int, lowBuf []int64, sn int, highBuf []int64, dn, phase int) {
	if len(colBuf) == 0 || len(lowBuf) == 0 || len(highBuf) == 0 {
		return
	}
	heightVal := int64(height)
	snVal := int64(sn)
	dnVal := int64(dn)
	phaseVal := int64(phase)
	synthesize53corecols_c_s64_neon(
		unsafe.Pointer(&colBuf[0]),
		unsafe.Pointer(&heightVal),
		unsafe.Pointer(&lowBuf[0]),
		unsafe.Pointer(&snVal),
		unsafe.Pointer(&highBuf[0]),
		unsafe.Pointer(&dnVal),
		unsafe.Pointer(&phaseVal),
	)
}

