// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

package wavelet

import (
	"github.com/ajroetker/go-highway/hwy"
)

func BaseLiftUpdate53_fallback_Int32(target []int32, tLen int, neighbor []int32, nLen int, phase int) {
	if tLen == 0 || nLen == 0 {
		return
	}
	twoVec := hwy.Set(int32(2))
	lanes := hwy.MaxLanes[int32]()
	start := 0
	if phase == 0 {
		target[0] -= (neighbor[0] + neighbor[0] + 2) >> 2
		start = 1
	}
	safeEnd := tLen
	if phase == 0 {
		if nLen < safeEnd {
			safeEnd = nLen
		}
	} else {
		if nLen-1 < safeEnd {
			safeEnd = nLen - 1
		}
	}
	i := start
	for ; i+lanes <= safeEnd; i += lanes {
		var n1, n2 hwy.Vec[int32]
		if phase == 0 {
			n1 = hwy.Load(neighbor[i-1:])
			n2 = hwy.Load(neighbor[i:])
		} else {
			n1 = hwy.Load(neighbor[i:])
			n2 = hwy.Load(neighbor[i+1:])
		}
		sum := hwy.Add(hwy.Add(n1, n2), twoVec)
		update := hwy.ShiftRight(sum, 2)
		t := hwy.Load(target[i:])
		hwy.Store(hwy.Sub(t, update), target[i:])
	}
	for ; i < safeEnd; i++ {
		var n1Idx, n2Idx int
		if phase == 0 {
			n1Idx = i - 1
			n2Idx = i
		} else {
			n1Idx = i
			n2Idx = i + 1
		}
		target[i] -= (neighbor[n1Idx] + neighbor[n2Idx] + 2) >> 2
	}
	for ; i < tLen; i++ {
		var n1Idx, n2Idx int
		if phase == 0 {
			n1Idx = i - 1
			n2Idx = i
		} else {
			n1Idx = i
			n2Idx = i + 1
		}
		if n1Idx >= nLen {
			n1Idx = nLen - 1
		}
		if n2Idx >= nLen {
			n2Idx = nLen - 1
		}
		target[i] -= (neighbor[n1Idx] + neighbor[n2Idx] + 2) >> 2
	}
	_ = lanes
}

func BaseLiftUpdate53_fallback_Int64(target []int64, tLen int, neighbor []int64, nLen int, phase int) {
	if tLen == 0 || nLen == 0 {
		return
	}
	twoVec := hwy.Set(int64(2))
	lanes := hwy.MaxLanes[int64]()
	start := 0
	if phase == 0 {
		target[0] -= (neighbor[0] + neighbor[0] + 2) >> 2
		start = 1
	}
	safeEnd := tLen
	if phase == 0 {
		if nLen < safeEnd {
			safeEnd = nLen
		}
	} else {
		if nLen-1 < safeEnd {
			safeEnd = nLen - 1
		}
	}
	i := start
	for ; i+lanes <= safeEnd; i += lanes {
		var n1, n2 hwy.Vec[int64]
		if phase == 0 {
			n1 = hwy.Load(neighbor[i-1:])
			n2 = hwy.Load(neighbor[i:])
		} else {
			n1 = hwy.Load(neighbor[i:])
			n2 = hwy.Load(neighbor[i+1:])
		}
		sum := hwy.Add(hwy.Add(n1, n2), twoVec)
		update := hwy.ShiftRight(sum, 2)
		t := hwy.Load(target[i:])
		hwy.Store(hwy.Sub(t, update), target[i:])
	}
	for ; i < safeEnd; i++ {
		var n1Idx, n2Idx int
		if phase == 0 {
			n1Idx = i - 1
			n2Idx = i
		} else {
			n1Idx = i
			n2Idx = i + 1
		}
		target[i] -= (neighbor[n1Idx] + neighbor[n2Idx] + 2) >> 2
	}
	for ; i < tLen; i++ {
		var n1Idx, n2Idx int
		if phase == 0 {
			n1Idx = i - 1
			n2Idx = i
		} else {
			n1Idx = i
			n2Idx = i + 1
		}
		if n1Idx >= nLen {
			n1Idx = nLen - 1
		}
		if n2Idx >= nLen {
			n2Idx = nLen - 1
		}
		target[i] -= (neighbor[n1Idx] + neighbor[n2Idx] + 2) >> 2
	}
	_ = lanes
}

func BaseLiftPredict53_fallback_Int32(target []int32, tLen int, neighbor []int32, nLen int, phase int) {
	if tLen == 0 || nLen == 0 {
		return
	}
	lanes := hwy.MaxLanes[int32]()
	start := 0
	if phase == 1 {
		target[0] += (neighbor[0] + neighbor[0]) >> 1
		start = 1
	}
	safeEnd := tLen
	if phase == 0 {
		if nLen-1 < safeEnd {
			safeEnd = nLen - 1
		}
	} else {
		if nLen < safeEnd {
			safeEnd = nLen
		}
	}
	i := start
	for ; i+lanes <= safeEnd; i += lanes {
		var n1, n2 hwy.Vec[int32]
		if phase == 0 {
			n1 = hwy.Load(neighbor[i:])
			n2 = hwy.Load(neighbor[i+1:])
		} else {
			n1 = hwy.Load(neighbor[i-1:])
			n2 = hwy.Load(neighbor[i:])
		}
		update := hwy.ShiftRight(hwy.Add(n1, n2), 1)
		t := hwy.Load(target[i:])
		hwy.Store(hwy.Add(t, update), target[i:])
	}
	for ; i < safeEnd; i++ {
		var n1Idx, n2Idx int
		if phase == 0 {
			n1Idx = i
			n2Idx = i + 1
		} else {
			n1Idx = i - 1
			n2Idx = i
		}
		target[i] += (neighbor[n1Idx] + neighbor[n2Idx]) >> 1
	}
	for ; i < tLen; i++ {
		var n1Idx, n2Idx int
		if phase == 0 {
			n1Idx = i
			n2Idx = i + 1
		} else {
			n1Idx = i - 1
			n2Idx = i
		}
		if n1Idx < 0 {
			n1Idx = 0
		}
		if n1Idx >= nLen {
			n1Idx = nLen - 1
		}
		if n2Idx >= nLen {
			n2Idx = nLen - 1
		}
		target[i] += (neighbor[n1Idx] + neighbor[n2Idx]) >> 1
	}
	_ = lanes
}

func BaseLiftPredict53_fallback_Int64(target []int64, tLen int, neighbor []int64, nLen int, phase int) {
	if tLen == 0 || nLen == 0 {
		return
	}
	lanes := hwy.MaxLanes[int64]()
	start := 0
	if phase == 1 {
		target[0] += (neighbor[0] + neighbor[0]) >> 1
		start = 1
	}
	safeEnd := tLen
	if phase == 0 {
		if nLen-1 < safeEnd {
			safeEnd = nLen - 1
		}
	} else {
		if nLen < safeEnd {
			safeEnd = nLen
		}
	}
	i := start
	for ; i+lanes <= safeEnd; i += lanes {
		var n1, n2 hwy.Vec[int64]
		if phase == 0 {
			n1 = hwy.Load(neighbor[i:])
			n2 = hwy.Load(neighbor[i+1:])
		} else {
			n1 = hwy.Load(neighbor[i-1:])
			n2 = hwy.Load(neighbor[i:])
		}
		update := hwy.ShiftRight(hwy.Add(n1, n2), 1)
		t := hwy.Load(target[i:])
		hwy.Store(hwy.Add(t, update), target[i:])
	}
	for ; i < safeEnd; i++ {
		var n1Idx, n2Idx int
		if phase == 0 {
			n1Idx = i
			n2Idx = i + 1
		} else {
			n1Idx = i - 1
			n2Idx = i
		}
		target[i] += (neighbor[n1Idx] + neighbor[n2Idx]) >> 1
	}
	for ; i < tLen; i++ {
		var n1Idx, n2Idx int
		if phase == 0 {
			n1Idx = i
			n2Idx = i + 1
		} else {
			n1Idx = i - 1
			n2Idx = i
		}
		if n1Idx < 0 {
			n1Idx = 0
		}
		if n1Idx >= nLen {
			n1Idx = nLen - 1
		}
		if n2Idx >= nLen {
			n2Idx = nLen - 1
		}
		target[i] += (neighbor[n1Idx] + neighbor[n2Idx]) >> 1
	}
	_ = lanes
}

func BaseLiftStep97_fallback_Float16(target []hwy.Float16, tLen int, neighbor []hwy.Float16, nLen int, coeff hwy.Float16, phase int) {
	if tLen == 0 || nLen == 0 {
		return
	}
	coeffVec := hwy.Set(coeff)
	lanes := hwy.MaxLanes[hwy.Float16]()
	start := 0
	if phase == 1 {
		target[0] = hwy.Float32ToFloat16(target[0].Float32() - coeff.Float32()*(neighbor[0].Float32()+neighbor[0].Float32()))
		start = 1
	}
	safeEnd := tLen
	if phase == 0 {
		if nLen-1 < safeEnd {
			safeEnd = nLen - 1
		}
	} else {
		if nLen < safeEnd {
			safeEnd = nLen
		}
	}
	i := start
	for ; i+lanes <= safeEnd; i += lanes {
		var n1, n2 hwy.Vec[hwy.Float16]
		if phase == 0 {
			n1 = hwy.Load(neighbor[i:])
			n2 = hwy.Load(neighbor[i+1:])
		} else {
			n1 = hwy.Load(neighbor[i-1:])
			n2 = hwy.Load(neighbor[i:])
		}
		sum := hwy.Add(n1, n2)
		update := hwy.Mul(coeffVec, sum)
		t := hwy.Load(target[i:])
		hwy.Store(hwy.Sub(t, update), target[i:])
	}
	for ; i < safeEnd; i++ {
		var n1Idx, n2Idx int
		if phase == 0 {
			n1Idx = i
			n2Idx = i + 1
		} else {
			n1Idx = i - 1
			n2Idx = i
		}
		target[i] = hwy.Float32ToFloat16(target[i].Float32() - coeff.Float32()*(neighbor[n1Idx].Float32()+neighbor[n2Idx].Float32()))
	}
	for ; i < tLen; i++ {
		var n1Idx, n2Idx int
		if phase == 0 {
			n1Idx = i
			n2Idx = i + 1
		} else {
			n1Idx = i - 1
			n2Idx = i
		}
		if n1Idx < 0 {
			n1Idx = 0
		}
		if n1Idx >= nLen {
			n1Idx = nLen - 1
		}
		if n2Idx >= nLen {
			n2Idx = nLen - 1
		}
		target[i] = hwy.Float32ToFloat16(target[i].Float32() - coeff.Float32()*(neighbor[n1Idx].Float32()+neighbor[n2Idx].Float32()))
	}
	_ = coeffVec
	_ = lanes
}

func BaseLiftStep97_fallback_BFloat16(target []hwy.BFloat16, tLen int, neighbor []hwy.BFloat16, nLen int, coeff hwy.BFloat16, phase int) {
	if tLen == 0 || nLen == 0 {
		return
	}
	coeffVec := hwy.Set(coeff)
	lanes := hwy.MaxLanes[hwy.BFloat16]()
	start := 0
	if phase == 1 {
		target[0] = hwy.Float32ToBFloat16(target[0].Float32() - coeff.Float32()*(neighbor[0].Float32()+neighbor[0].Float32()))
		start = 1
	}
	safeEnd := tLen
	if phase == 0 {
		if nLen-1 < safeEnd {
			safeEnd = nLen - 1
		}
	} else {
		if nLen < safeEnd {
			safeEnd = nLen
		}
	}
	i := start
	for ; i+lanes <= safeEnd; i += lanes {
		var n1, n2 hwy.Vec[hwy.BFloat16]
		if phase == 0 {
			n1 = hwy.Load(neighbor[i:])
			n2 = hwy.Load(neighbor[i+1:])
		} else {
			n1 = hwy.Load(neighbor[i-1:])
			n2 = hwy.Load(neighbor[i:])
		}
		sum := hwy.Add(n1, n2)
		update := hwy.Mul(coeffVec, sum)
		t := hwy.Load(target[i:])
		hwy.Store(hwy.Sub(t, update), target[i:])
	}
	for ; i < safeEnd; i++ {
		var n1Idx, n2Idx int
		if phase == 0 {
			n1Idx = i
			n2Idx = i + 1
		} else {
			n1Idx = i - 1
			n2Idx = i
		}
		target[i] = hwy.Float32ToBFloat16(target[i].Float32() - coeff.Float32()*(neighbor[n1Idx].Float32()+neighbor[n2Idx].Float32()))
	}
	for ; i < tLen; i++ {
		var n1Idx, n2Idx int
		if phase == 0 {
			n1Idx = i
			n2Idx = i + 1
		} else {
			n1Idx = i - 1
			n2Idx = i
		}
		if n1Idx < 0 {
			n1Idx = 0
		}
		if n1Idx >= nLen {
			n1Idx = nLen - 1
		}
		if n2Idx >= nLen {
			n2Idx = nLen - 1
		}
		target[i] = hwy.Float32ToBFloat16(target[i].Float32() - coeff.Float32()*(neighbor[n1Idx].Float32()+neighbor[n2Idx].Float32()))
	}
	_ = coeffVec
	_ = lanes
}

func BaseLiftStep97_fallback(target []float32, tLen int, neighbor []float32, nLen int, coeff float32, phase int) {
	if tLen == 0 || nLen == 0 {
		return
	}
	coeffVec := float32(coeff)
	start := 0
	if phase == 1 {
		target[0] -= coeff * (neighbor[0] + neighbor[0])
		start = 1
	}
	safeEnd := tLen
	if phase == 0 {
		if nLen-1 < safeEnd {
			safeEnd = nLen - 1
		}
	} else {
		if nLen < safeEnd {
			safeEnd = nLen
		}
	}
	i := start
	for ; i < safeEnd; i++ {
		var n1, n2 float32
		if phase == 0 {
			n1 = neighbor[i]
			n2 = neighbor[i+1]
		} else {
			n1 = neighbor[i-1]
			n2 = neighbor[i]
		}
		sum := n1 + n2
		update := coeffVec * sum
		t := target[i]
		target[i] = t - update
	}
	for ; i < safeEnd; i++ {
		var n1Idx, n2Idx int
		if phase == 0 {
			n1Idx = i
			n2Idx = i + 1
		} else {
			n1Idx = i - 1
			n2Idx = i
		}
		target[i] -= coeff * (neighbor[n1Idx] + neighbor[n2Idx])
	}
	for ; i < tLen; i++ {
		var n1Idx, n2Idx int
		if phase == 0 {
			n1Idx = i
			n2Idx = i + 1
		} else {
			n1Idx = i - 1
			n2Idx = i
		}
		if n1Idx < 0 {
			n1Idx = 0
		}
		if n1Idx >= nLen {
			n1Idx = nLen - 1
		}
		if n2Idx >= nLen {
			n2Idx = nLen - 1
		}
		target[i] -= coeff * (neighbor[n1Idx] + neighbor[n2Idx])
	}
	_ = coeffVec
	_ = 1
}

func BaseLiftStep97_fallback_Float64(target []float64, tLen int, neighbor []float64, nLen int, coeff float64, phase int) {
	if tLen == 0 || nLen == 0 {
		return
	}
	coeffVec := float64(coeff)
	start := 0
	if phase == 1 {
		target[0] -= coeff * (neighbor[0] + neighbor[0])
		start = 1
	}
	safeEnd := tLen
	if phase == 0 {
		if nLen-1 < safeEnd {
			safeEnd = nLen - 1
		}
	} else {
		if nLen < safeEnd {
			safeEnd = nLen
		}
	}
	i := start
	for ; i < safeEnd; i++ {
		var n1, n2 float64
		if phase == 0 {
			n1 = neighbor[i]
			n2 = neighbor[i+1]
		} else {
			n1 = neighbor[i-1]
			n2 = neighbor[i]
		}
		sum := n1 + n2
		update := coeffVec * sum
		t := target[i]
		target[i] = t - update
	}
	for ; i < safeEnd; i++ {
		var n1Idx, n2Idx int
		if phase == 0 {
			n1Idx = i
			n2Idx = i + 1
		} else {
			n1Idx = i - 1
			n2Idx = i
		}
		target[i] -= coeff * (neighbor[n1Idx] + neighbor[n2Idx])
	}
	for ; i < tLen; i++ {
		var n1Idx, n2Idx int
		if phase == 0 {
			n1Idx = i
			n2Idx = i + 1
		} else {
			n1Idx = i - 1
			n2Idx = i
		}
		if n1Idx < 0 {
			n1Idx = 0
		}
		if n1Idx >= nLen {
			n1Idx = nLen - 1
		}
		if n2Idx >= nLen {
			n2Idx = nLen - 1
		}
		target[i] -= coeff * (neighbor[n1Idx] + neighbor[n2Idx])
	}
	_ = coeffVec
	_ = 1
}

func BaseScaleSlice_fallback_Float16(data []hwy.Float16, n int, scale hwy.Float16) {
	if n == 0 || data == nil {
		return
	}
	scaleVec := hwy.Set(scale)
	lanes := hwy.MaxLanes[hwy.Float16]()
	i := 0
	for ; i+lanes <= n; i += lanes {
		v := hwy.Load(data[i:])
		result := hwy.Mul(v, scaleVec)
		hwy.Store(result, data[i:])
	}
	for ; i < n; i++ {
		data[i] = hwy.Float32ToFloat16(data[i].Float32() * scale.Float32())
	}
}

func BaseScaleSlice_fallback_BFloat16(data []hwy.BFloat16, n int, scale hwy.BFloat16) {
	if n == 0 || data == nil {
		return
	}
	scaleVec := hwy.Set(scale)
	lanes := hwy.MaxLanes[hwy.BFloat16]()
	i := 0
	for ; i+lanes <= n; i += lanes {
		v := hwy.Load(data[i:])
		result := hwy.Mul(v, scaleVec)
		hwy.Store(result, data[i:])
	}
	for ; i < n; i++ {
		data[i] = hwy.Float32ToBFloat16(data[i].Float32() * scale.Float32())
	}
}

func BaseScaleSlice_fallback(data []float32, n int, scale float32) {
	if n == 0 || data == nil {
		return
	}
	scaleVec := float32(scale)
	i := 0
	for ; i < n; i++ {
		v := data[i]
		result := v * scaleVec
		data[i] = result
	}
	for ; i < n; i++ {
		data[i] *= scale
	}
}

func BaseScaleSlice_fallback_Float64(data []float64, n int, scale float64) {
	if n == 0 || data == nil {
		return
	}
	scaleVec := float64(scale)
	i := 0
	for ; i < n; i++ {
		v := data[i]
		result := v * scaleVec
		data[i] = result
	}
	for ; i < n; i++ {
		data[i] *= scale
	}
}

func BaseInterleave_fallback(dst []float32, low []float32, sn int, high []float32, dn int, phase int) {
	if phase == 0 {
		for i := 0; i < sn && i < dn; i++ {
			dst[2*i] = low[i]
			dst[2*i+1] = high[i]
		}
		for i := dn; i < sn; i++ {
			dst[2*i] = low[i]
		}
		for i := sn; i < dn; i++ {
			dst[2*i+1] = high[i]
		}
	} else {
		for i := 0; i < sn && i < dn; i++ {
			dst[2*i] = high[i]
			dst[2*i+1] = low[i]
		}
		for i := dn; i < sn; i++ {
			dst[2*i+1] = low[i]
		}
		for i := sn; i < dn; i++ {
			dst[2*i] = high[i]
		}
	}
}

func BaseInterleave_fallback_Float64(dst []float64, low []float64, sn int, high []float64, dn int, phase int) {
	if phase == 0 {
		for i := 0; i < sn && i < dn; i++ {
			dst[2*i] = low[i]
			dst[2*i+1] = high[i]
		}
		for i := dn; i < sn; i++ {
			dst[2*i] = low[i]
		}
		for i := sn; i < dn; i++ {
			dst[2*i+1] = high[i]
		}
	} else {
		for i := 0; i < sn && i < dn; i++ {
			dst[2*i] = high[i]
			dst[2*i+1] = low[i]
		}
		for i := dn; i < sn; i++ {
			dst[2*i+1] = low[i]
		}
		for i := sn; i < dn; i++ {
			dst[2*i] = high[i]
		}
	}
}

func BaseInterleave_fallback_Int32(dst []int32, low []int32, sn int, high []int32, dn int, phase int) {
	if phase == 0 {
		for i := 0; i < sn && i < dn; i++ {
			dst[2*i] = low[i]
			dst[2*i+1] = high[i]
		}
		for i := dn; i < sn; i++ {
			dst[2*i] = low[i]
		}
		for i := sn; i < dn; i++ {
			dst[2*i+1] = high[i]
		}
	} else {
		for i := 0; i < sn && i < dn; i++ {
			dst[2*i] = high[i]
			dst[2*i+1] = low[i]
		}
		for i := dn; i < sn; i++ {
			dst[2*i+1] = low[i]
		}
		for i := sn; i < dn; i++ {
			dst[2*i] = high[i]
		}
	}
}

func BaseInterleave_fallback_Int64(dst []int64, low []int64, sn int, high []int64, dn int, phase int) {
	if phase == 0 {
		for i := 0; i < sn && i < dn; i++ {
			dst[2*i] = low[i]
			dst[2*i+1] = high[i]
		}
		for i := dn; i < sn; i++ {
			dst[2*i] = low[i]
		}
		for i := sn; i < dn; i++ {
			dst[2*i+1] = high[i]
		}
	} else {
		for i := 0; i < sn && i < dn; i++ {
			dst[2*i] = high[i]
			dst[2*i+1] = low[i]
		}
		for i := dn; i < sn; i++ {
			dst[2*i+1] = low[i]
		}
		for i := sn; i < dn; i++ {
			dst[2*i] = high[i]
		}
	}
}

func BaseInterleave_fallback_Uint32(dst []uint32, low []uint32, sn int, high []uint32, dn int, phase int) {
	if phase == 0 {
		for i := 0; i < sn && i < dn; i++ {
			dst[2*i] = low[i]
			dst[2*i+1] = high[i]
		}
		for i := dn; i < sn; i++ {
			dst[2*i] = low[i]
		}
		for i := sn; i < dn; i++ {
			dst[2*i+1] = high[i]
		}
	} else {
		for i := 0; i < sn && i < dn; i++ {
			dst[2*i] = high[i]
			dst[2*i+1] = low[i]
		}
		for i := dn; i < sn; i++ {
			dst[2*i+1] = low[i]
		}
		for i := sn; i < dn; i++ {
			dst[2*i] = high[i]
		}
	}
}

func BaseInterleave_fallback_Uint64(dst []uint64, low []uint64, sn int, high []uint64, dn int, phase int) {
	if phase == 0 {
		for i := 0; i < sn && i < dn; i++ {
			dst[2*i] = low[i]
			dst[2*i+1] = high[i]
		}
		for i := dn; i < sn; i++ {
			dst[2*i] = low[i]
		}
		for i := sn; i < dn; i++ {
			dst[2*i+1] = high[i]
		}
	} else {
		for i := 0; i < sn && i < dn; i++ {
			dst[2*i] = high[i]
			dst[2*i+1] = low[i]
		}
		for i := dn; i < sn; i++ {
			dst[2*i+1] = low[i]
		}
		for i := sn; i < dn; i++ {
			dst[2*i] = high[i]
		}
	}
}

func BaseSynthesize53Core_fallback_Int32(data []int32, n int, low []int32, sn int, high []int32, dn int, phase int) {
	for ci := 0; ci < sn; ci++ {
		low[ci] = data[ci]
	}
	for ci := 0; ci < dn; ci++ {
		high[ci] = data[sn+ci]
	}
	{
		twoVec := hwy.Set(int32(2))
		lanes := hwy.MaxLanes[int32]()
		start := 0
		if phase == 0 {
			low[0] -= (high[0] + high[0] + 2) >> 2
			start = 1
		}
		safeEnd := sn
		if phase == 0 {
			if dn < safeEnd {
				safeEnd = dn
			}
		} else {
			if dn-1 < safeEnd {
				safeEnd = dn - 1
			}
		}
		i := start
		for ; i+lanes <= safeEnd; i += lanes {
			var n1, n2 hwy.Vec[int32]
			if phase == 0 {
				n1 = hwy.Load(high[i-1:])
				n2 = hwy.Load(high[i:])
			} else {
				n1 = hwy.Load(high[i:])
				n2 = hwy.Load(high[i+1:])
			}
			sum := hwy.Add(hwy.Add(n1, n2), twoVec)
			update := hwy.ShiftRight(sum, 2)
			t := hwy.Load(low[i:])
			hwy.Store(hwy.Sub(t, update), low[i:])
		}
		for ; i < safeEnd; i++ {
			var n1Idx, n2Idx int
			if phase == 0 {
				n1Idx = i - 1
				n2Idx = i
			} else {
				n1Idx = i
				n2Idx = i + 1
			}
			low[i] -= (high[n1Idx] + high[n2Idx] + 2) >> 2
		}
		for ; i < sn; i++ {
			var n1Idx, n2Idx int
			if phase == 0 {
				n1Idx = i - 1
				n2Idx = i
			} else {
				n1Idx = i
				n2Idx = i + 1
			}
			if n1Idx >= dn {
				n1Idx = dn - 1
			}
			if n2Idx >= dn {
				n2Idx = dn - 1
			}
			low[i] -= (high[n1Idx] + high[n2Idx] + 2) >> 2
		}
		_ = twoVec
		_ = lanes
	}
	{
		lanes := hwy.MaxLanes[int32]()
		start := 0
		if phase == 1 {
			high[0] += (low[0] + low[0]) >> 1
			start = 1
		}
		safeEnd := dn
		if phase == 0 {
			if sn-1 < safeEnd {
				safeEnd = sn - 1
			}
		} else {
			if sn < safeEnd {
				safeEnd = sn
			}
		}
		i := start
		for ; i+lanes <= safeEnd; i += lanes {
			var n1, n2 hwy.Vec[int32]
			if phase == 0 {
				n1 = hwy.Load(low[i:])
				n2 = hwy.Load(low[i+1:])
			} else {
				n1 = hwy.Load(low[i-1:])
				n2 = hwy.Load(low[i:])
			}
			update := hwy.ShiftRight(hwy.Add(n1, n2), 1)
			t := hwy.Load(high[i:])
			hwy.Store(hwy.Add(t, update), high[i:])
		}
		for ; i < safeEnd; i++ {
			var n1Idx, n2Idx int
			if phase == 0 {
				n1Idx = i
				n2Idx = i + 1
			} else {
				n1Idx = i - 1
				n2Idx = i
			}
			high[i] += (low[n1Idx] + low[n2Idx]) >> 1
		}
		for ; i < dn; i++ {
			var n1Idx, n2Idx int
			if phase == 0 {
				n1Idx = i
				n2Idx = i + 1
			} else {
				n1Idx = i - 1
				n2Idx = i
			}
			if n1Idx < 0 {
				n1Idx = 0
			}
			if n1Idx >= sn {
				n1Idx = sn - 1
			}
			if n2Idx >= sn {
				n2Idx = sn - 1
			}
			high[i] += (low[n1Idx] + low[n2Idx]) >> 1
		}
		_ = lanes
	}
	if phase == 0 {
		lanes := hwy.MaxLanes[int32]()
		minN := min(sn, dn)
		i := 0
		for ; i+lanes <= minN; i += lanes {
			lo := hwy.Load(low[i:])
			hi := hwy.Load(high[i:])
			z0 := hwy.InterleaveLower(lo, hi)
			z1 := hwy.InterleaveUpper(lo, hi)
			hwy.Store(z0, data[2*i:])
			hwy.Store(z1, data[2*i+lanes:])
		}
		for ; i < minN; i++ {
			data[2*i] = low[i]
			data[2*i+1] = high[i]
		}
		for i := dn; i < sn; i++ {
			data[2*i] = low[i]
		}
		_ = lanes
	} else {
		minN := min(sn, dn)
		for i := range minN {
			data[2*i] = high[i]
			data[2*i+1] = low[i]
		}
		for i := dn; i < sn; i++ {
			data[2*i+1] = low[i]
		}
		for i := sn; i < dn; i++ {
			data[2*i] = high[i]
		}
	}
}

func BaseSynthesize53Core_fallback_Int64(data []int64, n int, low []int64, sn int, high []int64, dn int, phase int) {
	for ci := 0; ci < sn; ci++ {
		low[ci] = data[ci]
	}
	for ci := 0; ci < dn; ci++ {
		high[ci] = data[sn+ci]
	}
	{
		twoVec := hwy.Set(int64(2))
		lanes := hwy.MaxLanes[int64]()
		start := 0
		if phase == 0 {
			low[0] -= (high[0] + high[0] + 2) >> 2
			start = 1
		}
		safeEnd := sn
		if phase == 0 {
			if dn < safeEnd {
				safeEnd = dn
			}
		} else {
			if dn-1 < safeEnd {
				safeEnd = dn - 1
			}
		}
		i := start
		for ; i+lanes <= safeEnd; i += lanes {
			var n1, n2 hwy.Vec[int64]
			if phase == 0 {
				n1 = hwy.Load(high[i-1:])
				n2 = hwy.Load(high[i:])
			} else {
				n1 = hwy.Load(high[i:])
				n2 = hwy.Load(high[i+1:])
			}
			sum := hwy.Add(hwy.Add(n1, n2), twoVec)
			update := hwy.ShiftRight(sum, 2)
			t := hwy.Load(low[i:])
			hwy.Store(hwy.Sub(t, update), low[i:])
		}
		for ; i < safeEnd; i++ {
			var n1Idx, n2Idx int
			if phase == 0 {
				n1Idx = i - 1
				n2Idx = i
			} else {
				n1Idx = i
				n2Idx = i + 1
			}
			low[i] -= (high[n1Idx] + high[n2Idx] + 2) >> 2
		}
		for ; i < sn; i++ {
			var n1Idx, n2Idx int
			if phase == 0 {
				n1Idx = i - 1
				n2Idx = i
			} else {
				n1Idx = i
				n2Idx = i + 1
			}
			if n1Idx >= dn {
				n1Idx = dn - 1
			}
			if n2Idx >= dn {
				n2Idx = dn - 1
			}
			low[i] -= (high[n1Idx] + high[n2Idx] + 2) >> 2
		}
		_ = twoVec
		_ = lanes
	}
	{
		lanes := hwy.MaxLanes[int64]()
		start := 0
		if phase == 1 {
			high[0] += (low[0] + low[0]) >> 1
			start = 1
		}
		safeEnd := dn
		if phase == 0 {
			if sn-1 < safeEnd {
				safeEnd = sn - 1
			}
		} else {
			if sn < safeEnd {
				safeEnd = sn
			}
		}
		i := start
		for ; i+lanes <= safeEnd; i += lanes {
			var n1, n2 hwy.Vec[int64]
			if phase == 0 {
				n1 = hwy.Load(low[i:])
				n2 = hwy.Load(low[i+1:])
			} else {
				n1 = hwy.Load(low[i-1:])
				n2 = hwy.Load(low[i:])
			}
			update := hwy.ShiftRight(hwy.Add(n1, n2), 1)
			t := hwy.Load(high[i:])
			hwy.Store(hwy.Add(t, update), high[i:])
		}
		for ; i < safeEnd; i++ {
			var n1Idx, n2Idx int
			if phase == 0 {
				n1Idx = i
				n2Idx = i + 1
			} else {
				n1Idx = i - 1
				n2Idx = i
			}
			high[i] += (low[n1Idx] + low[n2Idx]) >> 1
		}
		for ; i < dn; i++ {
			var n1Idx, n2Idx int
			if phase == 0 {
				n1Idx = i
				n2Idx = i + 1
			} else {
				n1Idx = i - 1
				n2Idx = i
			}
			if n1Idx < 0 {
				n1Idx = 0
			}
			if n1Idx >= sn {
				n1Idx = sn - 1
			}
			if n2Idx >= sn {
				n2Idx = sn - 1
			}
			high[i] += (low[n1Idx] + low[n2Idx]) >> 1
		}
		_ = lanes
	}
	if phase == 0 {
		lanes := hwy.MaxLanes[int64]()
		minN := min(sn, dn)
		i := 0
		for ; i+lanes <= minN; i += lanes {
			lo := hwy.Load(low[i:])
			hi := hwy.Load(high[i:])
			z0 := hwy.InterleaveLower(lo, hi)
			z1 := hwy.InterleaveUpper(lo, hi)
			hwy.Store(z0, data[2*i:])
			hwy.Store(z1, data[2*i+lanes:])
		}
		for ; i < minN; i++ {
			data[2*i] = low[i]
			data[2*i+1] = high[i]
		}
		for i := dn; i < sn; i++ {
			data[2*i] = low[i]
		}
		_ = lanes
	} else {
		minN := min(sn, dn)
		for i := range minN {
			data[2*i] = high[i]
			data[2*i+1] = low[i]
		}
		for i := dn; i < sn; i++ {
			data[2*i+1] = low[i]
		}
		for i := sn; i < dn; i++ {
			data[2*i] = high[i]
		}
	}
}

func BaseSynthesize53CoreCols_fallback_Int32(colBuf []int32, height int, lowBuf []int32, sn int, highBuf []int32, dn int, phase int) {
	lanes := hwy.MaxLanes[int32]()
	for y := 0; y < sn; y++ {
		copy(lowBuf[y*lanes:y*lanes+lanes], colBuf[y*lanes:y*lanes+lanes])
	}
	for y := 0; y < dn; y++ {
		copy(highBuf[y*lanes:y*lanes+lanes], colBuf[(sn+y)*lanes:(sn+y)*lanes+lanes])
	}
	{
		twoVec := hwy.Set(int32(2))
		start := 0
		if phase == 0 {
			h0 := hwy.Load(highBuf[0:])
			l0 := hwy.Load(lowBuf[0:])
			hwy.Store(hwy.Sub(l0, hwy.ShiftRight(hwy.Add(hwy.Add(h0, h0), twoVec), 2)), lowBuf[0:])
			start = 1
		}
		safeEnd := sn
		if phase == 0 {
			if dn < safeEnd {
				safeEnd = dn
			}
		} else {
			if dn-1 < safeEnd {
				safeEnd = dn - 1
			}
		}
		for y := start; y < safeEnd; y++ {
			var n1, n2 hwy.Vec[int32]
			if phase == 0 {
				n1 = hwy.Load(highBuf[(y-1)*lanes:])
				n2 = hwy.Load(highBuf[y*lanes:])
			} else {
				n1 = hwy.Load(highBuf[y*lanes:])
				n2 = hwy.Load(highBuf[(y+1)*lanes:])
			}
			sum := hwy.Add(hwy.Add(n1, n2), twoVec)
			update := hwy.ShiftRight(sum, 2)
			t := hwy.Load(lowBuf[y*lanes:])
			hwy.Store(hwy.Sub(t, update), lowBuf[y*lanes:])
		}
		for y := safeEnd; y < sn; y++ {
			var n1Idx, n2Idx int
			if phase == 0 {
				n1Idx = y - 1
				n2Idx = y
			} else {
				n1Idx = y
				n2Idx = y + 1
			}
			if n1Idx >= dn {
				n1Idx = dn - 1
			}
			if n2Idx >= dn {
				n2Idx = dn - 1
			}
			n1 := hwy.Load(highBuf[n1Idx*lanes:])
			n2 := hwy.Load(highBuf[n2Idx*lanes:])
			sum := hwy.Add(hwy.Add(n1, n2), twoVec)
			update := hwy.ShiftRight(sum, 2)
			t := hwy.Load(lowBuf[y*lanes:])
			hwy.Store(hwy.Sub(t, update), lowBuf[y*lanes:])
		}
		_ = twoVec
	}
	{
		start := 0
		if phase == 1 {
			l0 := hwy.Load(lowBuf[0:])
			h0 := hwy.Load(highBuf[0:])
			hwy.Store(hwy.Add(h0, hwy.ShiftRight(hwy.Add(l0, l0), 1)), highBuf[0:])
			start = 1
		}
		safeEnd := dn
		if phase == 0 {
			if sn-1 < safeEnd {
				safeEnd = sn - 1
			}
		} else {
			if sn < safeEnd {
				safeEnd = sn
			}
		}
		for y := start; y < safeEnd; y++ {
			var n1, n2 hwy.Vec[int32]
			if phase == 0 {
				n1 = hwy.Load(lowBuf[y*lanes:])
				n2 = hwy.Load(lowBuf[(y+1)*lanes:])
			} else {
				n1 = hwy.Load(lowBuf[(y-1)*lanes:])
				n2 = hwy.Load(lowBuf[y*lanes:])
			}
			update := hwy.ShiftRight(hwy.Add(n1, n2), 1)
			t := hwy.Load(highBuf[y*lanes:])
			hwy.Store(hwy.Add(t, update), highBuf[y*lanes:])
		}
		for y := safeEnd; y < dn; y++ {
			var n1Idx, n2Idx int
			if phase == 0 {
				n1Idx = y
				n2Idx = y + 1
			} else {
				n1Idx = y - 1
				n2Idx = y
			}
			if n1Idx < 0 {
				n1Idx = 0
			}
			if n1Idx >= sn {
				n1Idx = sn - 1
			}
			if n2Idx >= sn {
				n2Idx = sn - 1
			}
			n1 := hwy.Load(lowBuf[n1Idx*lanes:])
			n2 := hwy.Load(lowBuf[n2Idx*lanes:])
			update := hwy.ShiftRight(hwy.Add(n1, n2), 1)
			t := hwy.Load(highBuf[y*lanes:])
			hwy.Store(hwy.Add(t, update), highBuf[y*lanes:])
		}
	}
	if phase == 0 {
		minN := min(sn, dn)
		for y := 0; y < minN; y++ {
			copy(colBuf[2*y*lanes:2*y*lanes+lanes], lowBuf[y*lanes:y*lanes+lanes])
			copy(colBuf[(2*y+1)*lanes:(2*y+1)*lanes+lanes], highBuf[y*lanes:y*lanes+lanes])
		}
		for y := dn; y < sn; y++ {
			copy(colBuf[2*y*lanes:2*y*lanes+lanes], lowBuf[y*lanes:y*lanes+lanes])
		}
	} else {
		minN := min(sn, dn)
		for y := 0; y < minN; y++ {
			copy(colBuf[2*y*lanes:2*y*lanes+lanes], highBuf[y*lanes:y*lanes+lanes])
			copy(colBuf[(2*y+1)*lanes:(2*y+1)*lanes+lanes], lowBuf[y*lanes:y*lanes+lanes])
		}
		for y := dn; y < sn; y++ {
			copy(colBuf[(2*y+1)*lanes:(2*y+1)*lanes+lanes], lowBuf[y*lanes:y*lanes+lanes])
		}
		for y := sn; y < dn; y++ {
			copy(colBuf[2*y*lanes:2*y*lanes+lanes], highBuf[y*lanes:y*lanes+lanes])
		}
	}
	_ = lanes
}

func BaseSynthesize53CoreCols_fallback_Int64(colBuf []int64, height int, lowBuf []int64, sn int, highBuf []int64, dn int, phase int) {
	lanes := hwy.MaxLanes[int64]()
	for y := 0; y < sn; y++ {
		copy(lowBuf[y*lanes:y*lanes+lanes], colBuf[y*lanes:y*lanes+lanes])
	}
	for y := 0; y < dn; y++ {
		copy(highBuf[y*lanes:y*lanes+lanes], colBuf[(sn+y)*lanes:(sn+y)*lanes+lanes])
	}
	{
		twoVec := hwy.Set(int64(2))
		start := 0
		if phase == 0 {
			h0 := hwy.Load(highBuf[0:])
			l0 := hwy.Load(lowBuf[0:])
			hwy.Store(hwy.Sub(l0, hwy.ShiftRight(hwy.Add(hwy.Add(h0, h0), twoVec), 2)), lowBuf[0:])
			start = 1
		}
		safeEnd := sn
		if phase == 0 {
			if dn < safeEnd {
				safeEnd = dn
			}
		} else {
			if dn-1 < safeEnd {
				safeEnd = dn - 1
			}
		}
		for y := start; y < safeEnd; y++ {
			var n1, n2 hwy.Vec[int64]
			if phase == 0 {
				n1 = hwy.Load(highBuf[(y-1)*lanes:])
				n2 = hwy.Load(highBuf[y*lanes:])
			} else {
				n1 = hwy.Load(highBuf[y*lanes:])
				n2 = hwy.Load(highBuf[(y+1)*lanes:])
			}
			sum := hwy.Add(hwy.Add(n1, n2), twoVec)
			update := hwy.ShiftRight(sum, 2)
			t := hwy.Load(lowBuf[y*lanes:])
			hwy.Store(hwy.Sub(t, update), lowBuf[y*lanes:])
		}
		for y := safeEnd; y < sn; y++ {
			var n1Idx, n2Idx int
			if phase == 0 {
				n1Idx = y - 1
				n2Idx = y
			} else {
				n1Idx = y
				n2Idx = y + 1
			}
			if n1Idx >= dn {
				n1Idx = dn - 1
			}
			if n2Idx >= dn {
				n2Idx = dn - 1
			}
			n1 := hwy.Load(highBuf[n1Idx*lanes:])
			n2 := hwy.Load(highBuf[n2Idx*lanes:])
			sum := hwy.Add(hwy.Add(n1, n2), twoVec)
			update := hwy.ShiftRight(sum, 2)
			t := hwy.Load(lowBuf[y*lanes:])
			hwy.Store(hwy.Sub(t, update), lowBuf[y*lanes:])
		}
		_ = twoVec
	}
	{
		start := 0
		if phase == 1 {
			l0 := hwy.Load(lowBuf[0:])
			h0 := hwy.Load(highBuf[0:])
			hwy.Store(hwy.Add(h0, hwy.ShiftRight(hwy.Add(l0, l0), 1)), highBuf[0:])
			start = 1
		}
		safeEnd := dn
		if phase == 0 {
			if sn-1 < safeEnd {
				safeEnd = sn - 1
			}
		} else {
			if sn < safeEnd {
				safeEnd = sn
			}
		}
		for y := start; y < safeEnd; y++ {
			var n1, n2 hwy.Vec[int64]
			if phase == 0 {
				n1 = hwy.Load(lowBuf[y*lanes:])
				n2 = hwy.Load(lowBuf[(y+1)*lanes:])
			} else {
				n1 = hwy.Load(lowBuf[(y-1)*lanes:])
				n2 = hwy.Load(lowBuf[y*lanes:])
			}
			update := hwy.ShiftRight(hwy.Add(n1, n2), 1)
			t := hwy.Load(highBuf[y*lanes:])
			hwy.Store(hwy.Add(t, update), highBuf[y*lanes:])
		}
		for y := safeEnd; y < dn; y++ {
			var n1Idx, n2Idx int
			if phase == 0 {
				n1Idx = y
				n2Idx = y + 1
			} else {
				n1Idx = y - 1
				n2Idx = y
			}
			if n1Idx < 0 {
				n1Idx = 0
			}
			if n1Idx >= sn {
				n1Idx = sn - 1
			}
			if n2Idx >= sn {
				n2Idx = sn - 1
			}
			n1 := hwy.Load(lowBuf[n1Idx*lanes:])
			n2 := hwy.Load(lowBuf[n2Idx*lanes:])
			update := hwy.ShiftRight(hwy.Add(n1, n2), 1)
			t := hwy.Load(highBuf[y*lanes:])
			hwy.Store(hwy.Add(t, update), highBuf[y*lanes:])
		}
	}
	if phase == 0 {
		minN := min(sn, dn)
		for y := 0; y < minN; y++ {
			copy(colBuf[2*y*lanes:2*y*lanes+lanes], lowBuf[y*lanes:y*lanes+lanes])
			copy(colBuf[(2*y+1)*lanes:(2*y+1)*lanes+lanes], highBuf[y*lanes:y*lanes+lanes])
		}
		for y := dn; y < sn; y++ {
			copy(colBuf[2*y*lanes:2*y*lanes+lanes], lowBuf[y*lanes:y*lanes+lanes])
		}
	} else {
		minN := min(sn, dn)
		for y := 0; y < minN; y++ {
			copy(colBuf[2*y*lanes:2*y*lanes+lanes], highBuf[y*lanes:y*lanes+lanes])
			copy(colBuf[(2*y+1)*lanes:(2*y+1)*lanes+lanes], lowBuf[y*lanes:y*lanes+lanes])
		}
		for y := dn; y < sn; y++ {
			copy(colBuf[(2*y+1)*lanes:(2*y+1)*lanes+lanes], lowBuf[y*lanes:y*lanes+lanes])
		}
		for y := sn; y < dn; y++ {
			copy(colBuf[2*y*lanes:2*y*lanes+lanes], highBuf[y*lanes:y*lanes+lanes])
		}
	}
	_ = lanes
}

func BaseDeinterleave_fallback(src []float32, low []float32, sn int, high []float32, dn int, phase int) {
	if phase == 0 {
		for i := range sn {
			low[i] = src[2*i]
		}
		for i := range dn {
			high[i] = src[2*i+1]
		}
	} else {
		for i := range dn {
			high[i] = src[2*i]
		}
		for i := range sn {
			low[i] = src[2*i+1]
		}
	}
}

func BaseDeinterleave_fallback_Float64(src []float64, low []float64, sn int, high []float64, dn int, phase int) {
	if phase == 0 {
		for i := range sn {
			low[i] = src[2*i]
		}
		for i := range dn {
			high[i] = src[2*i+1]
		}
	} else {
		for i := range dn {
			high[i] = src[2*i]
		}
		for i := range sn {
			low[i] = src[2*i+1]
		}
	}
}

func BaseDeinterleave_fallback_Int32(src []int32, low []int32, sn int, high []int32, dn int, phase int) {
	if phase == 0 {
		for i := range sn {
			low[i] = src[2*i]
		}
		for i := range dn {
			high[i] = src[2*i+1]
		}
	} else {
		for i := range dn {
			high[i] = src[2*i]
		}
		for i := range sn {
			low[i] = src[2*i+1]
		}
	}
}

func BaseDeinterleave_fallback_Int64(src []int64, low []int64, sn int, high []int64, dn int, phase int) {
	if phase == 0 {
		for i := range sn {
			low[i] = src[2*i]
		}
		for i := range dn {
			high[i] = src[2*i+1]
		}
	} else {
		for i := range dn {
			high[i] = src[2*i]
		}
		for i := range sn {
			low[i] = src[2*i+1]
		}
	}
}

func BaseDeinterleave_fallback_Uint32(src []uint32, low []uint32, sn int, high []uint32, dn int, phase int) {
	if phase == 0 {
		for i := range sn {
			low[i] = src[2*i]
		}
		for i := range dn {
			high[i] = src[2*i+1]
		}
	} else {
		for i := range dn {
			high[i] = src[2*i]
		}
		for i := range sn {
			low[i] = src[2*i+1]
		}
	}
}

func BaseDeinterleave_fallback_Uint64(src []uint64, low []uint64, sn int, high []uint64, dn int, phase int) {
	if phase == 0 {
		for i := range sn {
			low[i] = src[2*i]
		}
		for i := range dn {
			high[i] = src[2*i+1]
		}
	} else {
		for i := range dn {
			high[i] = src[2*i]
		}
		for i := range sn {
			low[i] = src[2*i+1]
		}
	}
}
