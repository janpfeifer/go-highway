// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

//go:build amd64 && goexperiment.simd

package algo

import (
	"simd/archsimd"
	"unsafe"

	"github.com/ajroetker/go-highway/hwy"
)

func BaseFind_avx2(slice []float32, value float32) int {
	n := len(slice)
	if n == 0 {
		return -1
	}
	target := archsimd.BroadcastFloat32x8(value)
	lanes := 8
	i := 0
	for ; i+lanes*2 <= n; i += lanes * 2 {
		v := archsimd.LoadFloat32x8((*[8]float32)(unsafe.Pointer(&slice[i])))
		mask := v.Equal(target)
		if idx := hwy.FindFirstTrue_AVX2_F32x8(mask); idx >= 0 {
			return i + idx
		}
		v1 := archsimd.LoadFloat32x8((*[8]float32)(unsafe.Pointer(&slice[i+8])))
		mask1 := v1.Equal(target)
		if idx1 := hwy.FindFirstTrue_AVX2_F32x8(mask1); idx1 >= 0 {
			return i + idx1
		}
	}
	for ; i < n; i++ {
		if slice[i] == value {
			return i
		}
	}
	return -1
}

func BaseFind_avx2_Float64(slice []float64, value float64) int {
	n := len(slice)
	if n == 0 {
		return -1
	}
	target := archsimd.BroadcastFloat64x4(value)
	lanes := 4
	i := 0
	for ; i+lanes*2 <= n; i += lanes * 2 {
		v := archsimd.LoadFloat64x4((*[4]float64)(unsafe.Pointer(&slice[i])))
		mask := v.Equal(target)
		if idx := hwy.FindFirstTrue_AVX2_F64x4(mask); idx >= 0 {
			return i + idx
		}
		v1 := archsimd.LoadFloat64x4((*[4]float64)(unsafe.Pointer(&slice[i+4])))
		mask1 := v1.Equal(target)
		if idx1 := hwy.FindFirstTrue_AVX2_F64x4(mask1); idx1 >= 0 {
			return i + idx1
		}
	}
	for ; i < n; i++ {
		if slice[i] == value {
			return i
		}
	}
	return -1
}

func BaseFind_avx2_Int32(slice []int32, value int32) int {
	n := len(slice)
	if n == 0 {
		return -1
	}
	target := archsimd.BroadcastInt32x8(value)
	lanes := 8
	i := 0
	for ; i+lanes*2 <= n; i += lanes * 2 {
		v := archsimd.LoadInt32x8((*[8]int32)(unsafe.Pointer(&slice[i])))
		mask := v.Equal(target)
		if idx := hwy.FindFirstTrue_AVX2_I32x8(mask); idx >= 0 {
			return i + idx
		}
		v1 := archsimd.LoadInt32x8((*[8]int32)(unsafe.Pointer(&slice[i+8])))
		mask1 := v1.Equal(target)
		if idx1 := hwy.FindFirstTrue_AVX2_I32x8(mask1); idx1 >= 0 {
			return i + idx1
		}
	}
	for ; i < n; i++ {
		if slice[i] == value {
			return i
		}
	}
	return -1
}

func BaseFind_avx2_Int64(slice []int64, value int64) int {
	n := len(slice)
	if n == 0 {
		return -1
	}
	target := archsimd.BroadcastInt64x4(value)
	lanes := 4
	i := 0
	for ; i+lanes*2 <= n; i += lanes * 2 {
		v := archsimd.LoadInt64x4((*[4]int64)(unsafe.Pointer(&slice[i])))
		mask := v.Equal(target)
		if idx := hwy.FindFirstTrue_AVX2_I64x4(mask); idx >= 0 {
			return i + idx
		}
		v1 := archsimd.LoadInt64x4((*[4]int64)(unsafe.Pointer(&slice[i+4])))
		mask1 := v1.Equal(target)
		if idx1 := hwy.FindFirstTrue_AVX2_I64x4(mask1); idx1 >= 0 {
			return i + idx1
		}
	}
	for ; i < n; i++ {
		if slice[i] == value {
			return i
		}
	}
	return -1
}

func BaseFind_avx2_Uint32(slice []uint32, value uint32) int {
	n := len(slice)
	if n == 0 {
		return -1
	}
	target := archsimd.BroadcastUint32x8(value)
	lanes := 8
	i := 0
	for ; i+lanes*2 <= n; i += lanes * 2 {
		v := archsimd.LoadUint32x8((*[8]uint32)(unsafe.Pointer(&slice[i])))
		mask := v.Equal(target)
		if idx := hwy.FindFirstTrue_AVX2_Uint32x8(mask); idx >= 0 {
			return i + idx
		}
		v1 := archsimd.LoadUint32x8((*[8]uint32)(unsafe.Pointer(&slice[i+8])))
		mask1 := v1.Equal(target)
		if idx1 := hwy.FindFirstTrue_AVX2_Uint32x8(mask1); idx1 >= 0 {
			return i + idx1
		}
	}
	for ; i < n; i++ {
		if slice[i] == value {
			return i
		}
	}
	return -1
}

func BaseFind_avx2_Uint64(slice []uint64, value uint64) int {
	n := len(slice)
	if n == 0 {
		return -1
	}
	target := archsimd.BroadcastUint64x4(value)
	lanes := 4
	i := 0
	for ; i+lanes*2 <= n; i += lanes * 2 {
		v := archsimd.LoadUint64x4((*[4]uint64)(unsafe.Pointer(&slice[i])))
		mask := v.Equal(target)
		if idx := hwy.FindFirstTrue_AVX2_Uint64x4(mask); idx >= 0 {
			return i + idx
		}
		v1 := archsimd.LoadUint64x4((*[4]uint64)(unsafe.Pointer(&slice[i+4])))
		mask1 := v1.Equal(target)
		if idx1 := hwy.FindFirstTrue_AVX2_Uint64x4(mask1); idx1 >= 0 {
			return i + idx1
		}
	}
	for ; i < n; i++ {
		if slice[i] == value {
			return i
		}
	}
	return -1
}

func BaseCount_avx2(slice []float32, value float32) int {
	n := len(slice)
	if n == 0 {
		return 0
	}
	target := archsimd.BroadcastFloat32x8(value)
	lanes := 8
	count := 0
	i := 0
	for ; i+lanes*2 <= n; i += lanes * 2 {
		v := archsimd.LoadFloat32x8((*[8]float32)(unsafe.Pointer(&slice[i])))
		mask := v.Equal(target)
		count += hwy.CountTrue_AVX2_F32x8(mask)
		v1 := archsimd.LoadFloat32x8((*[8]float32)(unsafe.Pointer(&slice[i+8])))
		mask1 := v1.Equal(target)
		count += hwy.CountTrue_AVX2_F32x8(mask1)
	}
	for ; i < n; i++ {
		if slice[i] == value {
			count++
		}
	}
	return count
}

func BaseCount_avx2_Float64(slice []float64, value float64) int {
	n := len(slice)
	if n == 0 {
		return 0
	}
	target := archsimd.BroadcastFloat64x4(value)
	lanes := 4
	count := 0
	i := 0
	for ; i+lanes*2 <= n; i += lanes * 2 {
		v := archsimd.LoadFloat64x4((*[4]float64)(unsafe.Pointer(&slice[i])))
		mask := v.Equal(target)
		count += hwy.CountTrue_AVX2_F64x4(mask)
		v1 := archsimd.LoadFloat64x4((*[4]float64)(unsafe.Pointer(&slice[i+4])))
		mask1 := v1.Equal(target)
		count += hwy.CountTrue_AVX2_F64x4(mask1)
	}
	for ; i < n; i++ {
		if slice[i] == value {
			count++
		}
	}
	return count
}

func BaseCount_avx2_Int32(slice []int32, value int32) int {
	n := len(slice)
	if n == 0 {
		return 0
	}
	target := archsimd.BroadcastInt32x8(value)
	lanes := 8
	count := 0
	i := 0
	for ; i+lanes*2 <= n; i += lanes * 2 {
		v := archsimd.LoadInt32x8((*[8]int32)(unsafe.Pointer(&slice[i])))
		mask := v.Equal(target)
		count += hwy.CountTrue_AVX2_I32x8(mask)
		v1 := archsimd.LoadInt32x8((*[8]int32)(unsafe.Pointer(&slice[i+8])))
		mask1 := v1.Equal(target)
		count += hwy.CountTrue_AVX2_I32x8(mask1)
	}
	for ; i < n; i++ {
		if slice[i] == value {
			count++
		}
	}
	return count
}

func BaseCount_avx2_Int64(slice []int64, value int64) int {
	n := len(slice)
	if n == 0 {
		return 0
	}
	target := archsimd.BroadcastInt64x4(value)
	lanes := 4
	count := 0
	i := 0
	for ; i+lanes*2 <= n; i += lanes * 2 {
		v := archsimd.LoadInt64x4((*[4]int64)(unsafe.Pointer(&slice[i])))
		mask := v.Equal(target)
		count += hwy.CountTrue_AVX2_I64x4(mask)
		v1 := archsimd.LoadInt64x4((*[4]int64)(unsafe.Pointer(&slice[i+4])))
		mask1 := v1.Equal(target)
		count += hwy.CountTrue_AVX2_I64x4(mask1)
	}
	for ; i < n; i++ {
		if slice[i] == value {
			count++
		}
	}
	return count
}

func BaseCount_avx2_Uint32(slice []uint32, value uint32) int {
	n := len(slice)
	if n == 0 {
		return 0
	}
	target := archsimd.BroadcastUint32x8(value)
	lanes := 8
	count := 0
	i := 0
	for ; i+lanes*2 <= n; i += lanes * 2 {
		v := archsimd.LoadUint32x8((*[8]uint32)(unsafe.Pointer(&slice[i])))
		mask := v.Equal(target)
		count += hwy.CountTrue_AVX2_Uint32x8(mask)
		v1 := archsimd.LoadUint32x8((*[8]uint32)(unsafe.Pointer(&slice[i+8])))
		mask1 := v1.Equal(target)
		count += hwy.CountTrue_AVX2_Uint32x8(mask1)
	}
	for ; i < n; i++ {
		if slice[i] == value {
			count++
		}
	}
	return count
}

func BaseCount_avx2_Uint64(slice []uint64, value uint64) int {
	n := len(slice)
	if n == 0 {
		return 0
	}
	target := archsimd.BroadcastUint64x4(value)
	lanes := 4
	count := 0
	i := 0
	for ; i+lanes*2 <= n; i += lanes * 2 {
		v := archsimd.LoadUint64x4((*[4]uint64)(unsafe.Pointer(&slice[i])))
		mask := v.Equal(target)
		count += hwy.CountTrue_AVX2_Uint64x4(mask)
		v1 := archsimd.LoadUint64x4((*[4]uint64)(unsafe.Pointer(&slice[i+4])))
		mask1 := v1.Equal(target)
		count += hwy.CountTrue_AVX2_Uint64x4(mask1)
	}
	for ; i < n; i++ {
		if slice[i] == value {
			count++
		}
	}
	return count
}

func BaseContains_avx2(slice []float32, value float32) bool {
	return BaseFind_avx2(slice, value) >= 0
}

func BaseContains_avx2_Float64(slice []float64, value float64) bool {
	return BaseFind_avx2_Float64(slice, value) >= 0
}

func BaseContains_avx2_Int32(slice []int32, value int32) bool {
	return BaseFind_avx2_Int32(slice, value) >= 0
}

func BaseContains_avx2_Int64(slice []int64, value int64) bool {
	return BaseFind_avx2_Int64(slice, value) >= 0
}

func BaseContains_avx2_Uint32(slice []uint32, value uint32) bool {
	return BaseFind_avx2_Uint32(slice, value) >= 0
}

func BaseContains_avx2_Uint64(slice []uint64, value uint64) bool {
	return BaseFind_avx2_Uint64(slice, value) >= 0
}
