// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

package algo

import (
	"github.com/ajroetker/go-highway/hwy"
)

func BaseCopyIf_fallback(src []float32, dst []float32, pred func(hwy.Vec[float32]) hwy.Mask[float32]) int {
	n := len(src)
	dstLen := len(dst)
	if n == 0 || dstLen == 0 {
		return 0
	}
	lanes := hwy.MaxLanes[float32]()
	dstIdx := 0
	i := 0
	for ; i+lanes <= n && dstIdx < dstLen; i += lanes {
		v := hwy.LoadFull(src[i:])
		mask := pred(v)
		remaining := dstLen - dstIdx
		count := min(hwy.CompressStore(v, mask, dst[dstIdx:]), remaining)
		dstIdx += count
		if dstIdx >= dstLen {
			break
		}
	}
	if remaining := n - i; remaining > 0 && dstIdx < dstLen {
		buf := make([]float32, lanes)
		copy(buf, src[i:i+remaining])
		v := hwy.Load(buf)
		mask := pred(v)
		tailMask := hwy.FirstN[float32](remaining)
		mask = hwy.MaskAnd(mask, tailMask)
		dstRemaining := dstLen - dstIdx
		count := min(hwy.CompressStore(v, mask, dst[dstIdx:]), dstRemaining)
		dstIdx += count
	}
	return dstIdx
}

func BaseCopyIf_fallback_Float64(src []float64, dst []float64, pred func(hwy.Vec[float64]) hwy.Mask[float64]) int {
	n := len(src)
	dstLen := len(dst)
	if n == 0 || dstLen == 0 {
		return 0
	}
	lanes := hwy.MaxLanes[float64]()
	dstIdx := 0
	i := 0
	for ; i+lanes <= n && dstIdx < dstLen; i += lanes {
		v := hwy.LoadFull(src[i:])
		mask := pred(v)
		remaining := dstLen - dstIdx
		count := min(hwy.CompressStore(v, mask, dst[dstIdx:]), remaining)
		dstIdx += count
		if dstIdx >= dstLen {
			break
		}
	}
	if remaining := n - i; remaining > 0 && dstIdx < dstLen {
		buf := make([]float64, lanes)
		copy(buf, src[i:i+remaining])
		v := hwy.Load(buf)
		mask := pred(v)
		tailMask := hwy.FirstN[float64](remaining)
		mask = hwy.MaskAnd(mask, tailMask)
		dstRemaining := dstLen - dstIdx
		count := min(hwy.CompressStore(v, mask, dst[dstIdx:]), dstRemaining)
		dstIdx += count
	}
	return dstIdx
}

func BaseCopyIf_fallback_Int32(src []int32, dst []int32, pred func(hwy.Vec[int32]) hwy.Mask[int32]) int {
	n := len(src)
	dstLen := len(dst)
	if n == 0 || dstLen == 0 {
		return 0
	}
	lanes := hwy.MaxLanes[int32]()
	dstIdx := 0
	i := 0
	for ; i+lanes <= n && dstIdx < dstLen; i += lanes {
		v := hwy.LoadFull(src[i:])
		mask := pred(v)
		remaining := dstLen - dstIdx
		count := min(hwy.CompressStore(v, mask, dst[dstIdx:]), remaining)
		dstIdx += count
		if dstIdx >= dstLen {
			break
		}
	}
	if remaining := n - i; remaining > 0 && dstIdx < dstLen {
		buf := make([]int32, lanes)
		copy(buf, src[i:i+remaining])
		v := hwy.Load(buf)
		mask := pred(v)
		tailMask := hwy.FirstN[int32](remaining)
		mask = hwy.MaskAnd(mask, tailMask)
		dstRemaining := dstLen - dstIdx
		count := min(hwy.CompressStore(v, mask, dst[dstIdx:]), dstRemaining)
		dstIdx += count
	}
	return dstIdx
}

func BaseCopyIf_fallback_Int64(src []int64, dst []int64, pred func(hwy.Vec[int64]) hwy.Mask[int64]) int {
	n := len(src)
	dstLen := len(dst)
	if n == 0 || dstLen == 0 {
		return 0
	}
	lanes := hwy.MaxLanes[int64]()
	dstIdx := 0
	i := 0
	for ; i+lanes <= n && dstIdx < dstLen; i += lanes {
		v := hwy.LoadFull(src[i:])
		mask := pred(v)
		remaining := dstLen - dstIdx
		count := min(hwy.CompressStore(v, mask, dst[dstIdx:]), remaining)
		dstIdx += count
		if dstIdx >= dstLen {
			break
		}
	}
	if remaining := n - i; remaining > 0 && dstIdx < dstLen {
		buf := make([]int64, lanes)
		copy(buf, src[i:i+remaining])
		v := hwy.Load(buf)
		mask := pred(v)
		tailMask := hwy.FirstN[int64](remaining)
		mask = hwy.MaskAnd(mask, tailMask)
		dstRemaining := dstLen - dstIdx
		count := min(hwy.CompressStore(v, mask, dst[dstIdx:]), dstRemaining)
		dstIdx += count
	}
	return dstIdx
}

func BaseCopyIf_fallback_Uint32(src []uint32, dst []uint32, pred func(hwy.Vec[uint32]) hwy.Mask[uint32]) int {
	n := len(src)
	dstLen := len(dst)
	if n == 0 || dstLen == 0 {
		return 0
	}
	lanes := hwy.MaxLanes[uint32]()
	dstIdx := 0
	i := 0
	for ; i+lanes <= n && dstIdx < dstLen; i += lanes {
		v := hwy.LoadFull(src[i:])
		mask := pred(v)
		remaining := dstLen - dstIdx
		count := min(hwy.CompressStore(v, mask, dst[dstIdx:]), remaining)
		dstIdx += count
		if dstIdx >= dstLen {
			break
		}
	}
	if remaining := n - i; remaining > 0 && dstIdx < dstLen {
		buf := make([]uint32, lanes)
		copy(buf, src[i:i+remaining])
		v := hwy.Load(buf)
		mask := pred(v)
		tailMask := hwy.FirstN[uint32](remaining)
		mask = hwy.MaskAnd(mask, tailMask)
		dstRemaining := dstLen - dstIdx
		count := min(hwy.CompressStore(v, mask, dst[dstIdx:]), dstRemaining)
		dstIdx += count
	}
	return dstIdx
}

func BaseCopyIf_fallback_Uint64(src []uint64, dst []uint64, pred func(hwy.Vec[uint64]) hwy.Mask[uint64]) int {
	n := len(src)
	dstLen := len(dst)
	if n == 0 || dstLen == 0 {
		return 0
	}
	lanes := hwy.MaxLanes[uint64]()
	dstIdx := 0
	i := 0
	for ; i+lanes <= n && dstIdx < dstLen; i += lanes {
		v := hwy.LoadFull(src[i:])
		mask := pred(v)
		remaining := dstLen - dstIdx
		count := min(hwy.CompressStore(v, mask, dst[dstIdx:]), remaining)
		dstIdx += count
		if dstIdx >= dstLen {
			break
		}
	}
	if remaining := n - i; remaining > 0 && dstIdx < dstLen {
		buf := make([]uint64, lanes)
		copy(buf, src[i:i+remaining])
		v := hwy.Load(buf)
		mask := pred(v)
		tailMask := hwy.FirstN[uint64](remaining)
		mask = hwy.MaskAnd(mask, tailMask)
		dstRemaining := dstLen - dstIdx
		count := min(hwy.CompressStore(v, mask, dst[dstIdx:]), dstRemaining)
		dstIdx += count
	}
	return dstIdx
}
