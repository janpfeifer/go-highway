// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

package algo

import (
	"github.com/ajroetker/go-highway/hwy"
)

func BaseFind_fallback(slice []float32, value float32) int {
	n := len(slice)
	if n == 0 {
		return -1
	}
	target := hwy.Set(value)
	lanes := hwy.MaxLanes[float32]()
	i := 0
	for ; i+lanes <= n; i += lanes {
		v := hwy.LoadFull(slice[i:])
		mask := hwy.Equal(v, target)
		if idx := hwy.FindFirstTrue(mask); idx >= 0 {
			return i + idx
		}
	}
	for ; i < n; i++ {
		if slice[i] == value {
			return i
		}
	}
	return -1
}

func BaseFind_fallback_Float64(slice []float64, value float64) int {
	n := len(slice)
	if n == 0 {
		return -1
	}
	target := hwy.Set(value)
	lanes := hwy.MaxLanes[float64]()
	i := 0
	for ; i+lanes <= n; i += lanes {
		v := hwy.LoadFull(slice[i:])
		mask := hwy.Equal(v, target)
		if idx := hwy.FindFirstTrue(mask); idx >= 0 {
			return i + idx
		}
	}
	for ; i < n; i++ {
		if slice[i] == value {
			return i
		}
	}
	return -1
}

func BaseFind_fallback_Int32(slice []int32, value int32) int {
	n := len(slice)
	if n == 0 {
		return -1
	}
	target := hwy.Set(value)
	lanes := hwy.MaxLanes[int32]()
	i := 0
	for ; i+lanes <= n; i += lanes {
		v := hwy.LoadFull(slice[i:])
		mask := hwy.Equal(v, target)
		if idx := hwy.FindFirstTrue(mask); idx >= 0 {
			return i + idx
		}
	}
	for ; i < n; i++ {
		if slice[i] == value {
			return i
		}
	}
	return -1
}

func BaseFind_fallback_Int64(slice []int64, value int64) int {
	n := len(slice)
	if n == 0 {
		return -1
	}
	target := hwy.Set(value)
	lanes := hwy.MaxLanes[int64]()
	i := 0
	for ; i+lanes <= n; i += lanes {
		v := hwy.LoadFull(slice[i:])
		mask := hwy.Equal(v, target)
		if idx := hwy.FindFirstTrue(mask); idx >= 0 {
			return i + idx
		}
	}
	for ; i < n; i++ {
		if slice[i] == value {
			return i
		}
	}
	return -1
}

func BaseFind_fallback_Uint32(slice []uint32, value uint32) int {
	n := len(slice)
	if n == 0 {
		return -1
	}
	target := hwy.Set(value)
	lanes := hwy.MaxLanes[uint32]()
	i := 0
	for ; i+lanes <= n; i += lanes {
		v := hwy.LoadFull(slice[i:])
		mask := hwy.Equal(v, target)
		if idx := hwy.FindFirstTrue(mask); idx >= 0 {
			return i + idx
		}
	}
	for ; i < n; i++ {
		if slice[i] == value {
			return i
		}
	}
	return -1
}

func BaseFind_fallback_Uint64(slice []uint64, value uint64) int {
	n := len(slice)
	if n == 0 {
		return -1
	}
	target := hwy.Set(value)
	lanes := hwy.MaxLanes[uint64]()
	i := 0
	for ; i+lanes <= n; i += lanes {
		v := hwy.LoadFull(slice[i:])
		mask := hwy.Equal(v, target)
		if idx := hwy.FindFirstTrue(mask); idx >= 0 {
			return i + idx
		}
	}
	for ; i < n; i++ {
		if slice[i] == value {
			return i
		}
	}
	return -1
}

func BaseCount_fallback(slice []float32, value float32) int {
	n := len(slice)
	if n == 0 {
		return 0
	}
	target := hwy.Set(value)
	lanes := hwy.MaxLanes[float32]()
	count := 0
	i := 0
	for ; i+lanes <= n; i += lanes {
		v := hwy.LoadFull(slice[i:])
		mask := hwy.Equal(v, target)
		count += hwy.CountTrue(mask)
	}
	for ; i < n; i++ {
		if slice[i] == value {
			count++
		}
	}
	return count
}

func BaseCount_fallback_Float64(slice []float64, value float64) int {
	n := len(slice)
	if n == 0 {
		return 0
	}
	target := hwy.Set(value)
	lanes := hwy.MaxLanes[float64]()
	count := 0
	i := 0
	for ; i+lanes <= n; i += lanes {
		v := hwy.LoadFull(slice[i:])
		mask := hwy.Equal(v, target)
		count += hwy.CountTrue(mask)
	}
	for ; i < n; i++ {
		if slice[i] == value {
			count++
		}
	}
	return count
}

func BaseCount_fallback_Int32(slice []int32, value int32) int {
	n := len(slice)
	if n == 0 {
		return 0
	}
	target := hwy.Set(value)
	lanes := hwy.MaxLanes[int32]()
	count := 0
	i := 0
	for ; i+lanes <= n; i += lanes {
		v := hwy.LoadFull(slice[i:])
		mask := hwy.Equal(v, target)
		count += hwy.CountTrue(mask)
	}
	for ; i < n; i++ {
		if slice[i] == value {
			count++
		}
	}
	return count
}

func BaseCount_fallback_Int64(slice []int64, value int64) int {
	n := len(slice)
	if n == 0 {
		return 0
	}
	target := hwy.Set(value)
	lanes := hwy.MaxLanes[int64]()
	count := 0
	i := 0
	for ; i+lanes <= n; i += lanes {
		v := hwy.LoadFull(slice[i:])
		mask := hwy.Equal(v, target)
		count += hwy.CountTrue(mask)
	}
	for ; i < n; i++ {
		if slice[i] == value {
			count++
		}
	}
	return count
}

func BaseCount_fallback_Uint32(slice []uint32, value uint32) int {
	n := len(slice)
	if n == 0 {
		return 0
	}
	target := hwy.Set(value)
	lanes := hwy.MaxLanes[uint32]()
	count := 0
	i := 0
	for ; i+lanes <= n; i += lanes {
		v := hwy.LoadFull(slice[i:])
		mask := hwy.Equal(v, target)
		count += hwy.CountTrue(mask)
	}
	for ; i < n; i++ {
		if slice[i] == value {
			count++
		}
	}
	return count
}

func BaseCount_fallback_Uint64(slice []uint64, value uint64) int {
	n := len(slice)
	if n == 0 {
		return 0
	}
	target := hwy.Set(value)
	lanes := hwy.MaxLanes[uint64]()
	count := 0
	i := 0
	for ; i+lanes <= n; i += lanes {
		v := hwy.LoadFull(slice[i:])
		mask := hwy.Equal(v, target)
		count += hwy.CountTrue(mask)
	}
	for ; i < n; i++ {
		if slice[i] == value {
			count++
		}
	}
	return count
}

func BaseContains_fallback(slice []float32, value float32) bool {
	return BaseFind_fallback(slice, value) >= 0
}

func BaseContains_fallback_Float64(slice []float64, value float64) bool {
	return BaseFind_fallback_Float64(slice, value) >= 0
}

func BaseContains_fallback_Int32(slice []int32, value int32) bool {
	return BaseFind_fallback_Int32(slice, value) >= 0
}

func BaseContains_fallback_Int64(slice []int64, value int64) bool {
	return BaseFind_fallback_Int64(slice, value) >= 0
}

func BaseContains_fallback_Uint32(slice []uint32, value uint32) bool {
	return BaseFind_fallback_Uint32(slice, value) >= 0
}

func BaseContains_fallback_Uint64(slice []uint64, value uint64) bool {
	return BaseFind_fallback_Uint64(slice, value) >= 0
}

func BaseAll_fallback(slice []float32, pred Predicate[float32]) bool {
	for _, v := range slice {
		if !pred.Test(v) {
			return false
		}
	}
	return true
}

func BaseAll_fallback_Float64(slice []float64, pred Predicate[float64]) bool {
	for _, v := range slice {
		if !pred.Test(v) {
			return false
		}
	}
	return true
}

func BaseAll_fallback_Int32(slice []int32, pred Predicate[int32]) bool {
	for _, v := range slice {
		if !pred.Test(v) {
			return false
		}
	}
	return true
}

func BaseAll_fallback_Int64(slice []int64, pred Predicate[int64]) bool {
	for _, v := range slice {
		if !pred.Test(v) {
			return false
		}
	}
	return true
}

func BaseAll_fallback_Uint32(slice []uint32, pred Predicate[uint32]) bool {
	for _, v := range slice {
		if !pred.Test(v) {
			return false
		}
	}
	return true
}

func BaseAll_fallback_Uint64(slice []uint64, pred Predicate[uint64]) bool {
	for _, v := range slice {
		if !pred.Test(v) {
			return false
		}
	}
	return true
}

func BaseAny_fallback(slice []float32, pred Predicate[float32]) bool {
	for _, v := range slice {
		if pred.Test(v) {
			return true
		}
	}
	return false
}

func BaseAny_fallback_Float64(slice []float64, pred Predicate[float64]) bool {
	for _, v := range slice {
		if pred.Test(v) {
			return true
		}
	}
	return false
}

func BaseAny_fallback_Int32(slice []int32, pred Predicate[int32]) bool {
	for _, v := range slice {
		if pred.Test(v) {
			return true
		}
	}
	return false
}

func BaseAny_fallback_Int64(slice []int64, pred Predicate[int64]) bool {
	for _, v := range slice {
		if pred.Test(v) {
			return true
		}
	}
	return false
}

func BaseAny_fallback_Uint32(slice []uint32, pred Predicate[uint32]) bool {
	for _, v := range slice {
		if pred.Test(v) {
			return true
		}
	}
	return false
}

func BaseAny_fallback_Uint64(slice []uint64, pred Predicate[uint64]) bool {
	for _, v := range slice {
		if pred.Test(v) {
			return true
		}
	}
	return false
}

func BaseNone_fallback(slice []float32, pred Predicate[float32]) bool {
	return !BaseAny_fallback(slice, pred)
}

func BaseNone_fallback_Float64(slice []float64, pred Predicate[float64]) bool {
	return !BaseAny_fallback_Float64(slice, pred)
}

func BaseNone_fallback_Int32(slice []int32, pred Predicate[int32]) bool {
	return !BaseAny_fallback_Int32(slice, pred)
}

func BaseNone_fallback_Int64(slice []int64, pred Predicate[int64]) bool {
	return !BaseAny_fallback_Int64(slice, pred)
}

func BaseNone_fallback_Uint32(slice []uint32, pred Predicate[uint32]) bool {
	return !BaseAny_fallback_Uint32(slice, pred)
}

func BaseNone_fallback_Uint64(slice []uint64, pred Predicate[uint64]) bool {
	return !BaseAny_fallback_Uint64(slice, pred)
}

func BaseFindIf_fallback(slice []float32, pred Predicate[float32]) int {
	for i, v := range slice {
		if pred.Test(v) {
			return i
		}
	}
	return -1
}

func BaseFindIf_fallback_Float64(slice []float64, pred Predicate[float64]) int {
	for i, v := range slice {
		if pred.Test(v) {
			return i
		}
	}
	return -1
}

func BaseFindIf_fallback_Int32(slice []int32, pred Predicate[int32]) int {
	for i, v := range slice {
		if pred.Test(v) {
			return i
		}
	}
	return -1
}

func BaseFindIf_fallback_Int64(slice []int64, pred Predicate[int64]) int {
	for i, v := range slice {
		if pred.Test(v) {
			return i
		}
	}
	return -1
}

func BaseFindIf_fallback_Uint32(slice []uint32, pred Predicate[uint32]) int {
	for i, v := range slice {
		if pred.Test(v) {
			return i
		}
	}
	return -1
}

func BaseFindIf_fallback_Uint64(slice []uint64, pred Predicate[uint64]) int {
	for i, v := range slice {
		if pred.Test(v) {
			return i
		}
	}
	return -1
}

func BaseCountIf_fallback(slice []float32, pred Predicate[float32]) int {
	count := 0
	for _, v := range slice {
		if pred.Test(v) {
			count++
		}
	}
	return count
}

func BaseCountIf_fallback_Float64(slice []float64, pred Predicate[float64]) int {
	count := 0
	for _, v := range slice {
		if pred.Test(v) {
			count++
		}
	}
	return count
}

func BaseCountIf_fallback_Int32(slice []int32, pred Predicate[int32]) int {
	count := 0
	for _, v := range slice {
		if pred.Test(v) {
			count++
		}
	}
	return count
}

func BaseCountIf_fallback_Int64(slice []int64, pred Predicate[int64]) int {
	count := 0
	for _, v := range slice {
		if pred.Test(v) {
			count++
		}
	}
	return count
}

func BaseCountIf_fallback_Uint32(slice []uint32, pred Predicate[uint32]) int {
	count := 0
	for _, v := range slice {
		if pred.Test(v) {
			count++
		}
	}
	return count
}

func BaseCountIf_fallback_Uint64(slice []uint64, pred Predicate[uint64]) int {
	count := 0
	for _, v := range slice {
		if pred.Test(v) {
			count++
		}
	}
	return count
}
