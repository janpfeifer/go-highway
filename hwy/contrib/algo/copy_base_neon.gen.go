// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

//go:build arm64

package algo

import (
	"github.com/ajroetker/go-highway/hwy/asm"
)

func BaseCopyIf_neon(src []float32, dst []float32, pred func(asm.Float32x4) asm.Int32x4) int {
	n := len(src)
	dstLen := len(dst)
	if n == 0 || dstLen == 0 {
		return 0
	}
	lanes := 4
	dstIdx := 0
	i := 0
	for ; i+lanes <= n && dstIdx < dstLen; i += lanes {
		v := asm.LoadFloat32x4Slice(src[i:])
		mask := pred(v)
		remaining := dstLen - dstIdx
		count := min(asm.CompressStore(v, mask, dst[dstIdx:]), remaining)
		dstIdx += count
		if dstIdx >= dstLen {
			break
		}
	}
	if remaining := n - i; remaining > 0 && dstIdx < dstLen {
		buf := [4]float32{}
		copy(buf[:], src[i:i+remaining])
		v := asm.LoadFloat32x4Slice(buf[:])
		mask := pred(v)
		tailMask := asm.FirstN(remaining)
		mask = mask.And(tailMask)
		dstRemaining := dstLen - dstIdx
		count := min(asm.CompressStore(v, mask, dst[dstIdx:]), dstRemaining)
		dstIdx += count
	}
	return dstIdx
}

func BaseCopyIf_neon_Float64(src []float64, dst []float64, pred func(asm.Float64x2) asm.Int64x2) int {
	n := len(src)
	dstLen := len(dst)
	if n == 0 || dstLen == 0 {
		return 0
	}
	lanes := 2
	dstIdx := 0
	i := 0
	for ; i+lanes <= n && dstIdx < dstLen; i += lanes {
		v := asm.LoadFloat64x2Slice(src[i:])
		mask := pred(v)
		remaining := dstLen - dstIdx
		count := min(asm.CompressStoreFloat64(v, mask, dst[dstIdx:]), remaining)
		dstIdx += count
		if dstIdx >= dstLen {
			break
		}
	}
	if remaining := n - i; remaining > 0 && dstIdx < dstLen {
		buf := [2]float64{}
		copy(buf[:], src[i:i+remaining])
		v := asm.LoadFloat64x2Slice(buf[:])
		mask := pred(v)
		tailMask := asm.FirstNFloat64(remaining)
		mask = mask.And(tailMask)
		dstRemaining := dstLen - dstIdx
		count := min(asm.CompressStoreFloat64(v, mask, dst[dstIdx:]), dstRemaining)
		dstIdx += count
	}
	return dstIdx
}

func BaseCopyIf_neon_Int32(src []int32, dst []int32, pred func(asm.Int32x4) asm.Int32x4) int {
	n := len(src)
	dstLen := len(dst)
	if n == 0 || dstLen == 0 {
		return 0
	}
	lanes := 4
	dstIdx := 0
	i := 0
	for ; i+lanes <= n && dstIdx < dstLen; i += lanes {
		v := asm.LoadInt32x4Slice(src[i:])
		mask := pred(v)
		remaining := dstLen - dstIdx
		count := min(asm.CompressStoreInt32(v, mask, dst[dstIdx:]), remaining)
		dstIdx += count
		if dstIdx >= dstLen {
			break
		}
	}
	if remaining := n - i; remaining > 0 && dstIdx < dstLen {
		buf := [4]int32{}
		copy(buf[:], src[i:i+remaining])
		v := asm.LoadInt32x4Slice(buf[:])
		mask := pred(v)
		tailMask := asm.FirstN(remaining)
		mask = mask.And(tailMask)
		dstRemaining := dstLen - dstIdx
		count := min(asm.CompressStoreInt32(v, mask, dst[dstIdx:]), dstRemaining)
		dstIdx += count
	}
	return dstIdx
}

func BaseCopyIf_neon_Int64(src []int64, dst []int64, pred func(asm.Int64x2) asm.Int64x2) int {
	n := len(src)
	dstLen := len(dst)
	if n == 0 || dstLen == 0 {
		return 0
	}
	lanes := 2
	dstIdx := 0
	i := 0
	for ; i+lanes <= n && dstIdx < dstLen; i += lanes {
		v := asm.LoadInt64x2Slice(src[i:])
		mask := pred(v)
		remaining := dstLen - dstIdx
		count := min(asm.CompressStoreInt64(v, mask, dst[dstIdx:]), remaining)
		dstIdx += count
		if dstIdx >= dstLen {
			break
		}
	}
	if remaining := n - i; remaining > 0 && dstIdx < dstLen {
		buf := [2]int64{}
		copy(buf[:], src[i:i+remaining])
		v := asm.LoadInt64x2Slice(buf[:])
		mask := pred(v)
		tailMask := asm.FirstNInt64(remaining)
		mask = mask.And(tailMask)
		dstRemaining := dstLen - dstIdx
		count := min(asm.CompressStoreInt64(v, mask, dst[dstIdx:]), dstRemaining)
		dstIdx += count
	}
	return dstIdx
}

func BaseCopyIf_neon_Uint32(src []uint32, dst []uint32, pred func(asm.Uint32x4) asm.Int32x4) int {
	n := len(src)
	dstLen := len(dst)
	if n == 0 || dstLen == 0 {
		return 0
	}
	lanes := 4
	dstIdx := 0
	i := 0
	for ; i+lanes <= n && dstIdx < dstLen; i += lanes {
		v := asm.LoadUint32x4Slice(src[i:])
		mask := pred(v)
		remaining := dstLen - dstIdx
		count := min(asm.CompressStoreUint32(v, mask, dst[dstIdx:]), remaining)
		dstIdx += count
		if dstIdx >= dstLen {
			break
		}
	}
	if remaining := n - i; remaining > 0 && dstIdx < dstLen {
		buf := [4]uint32{}
		copy(buf[:], src[i:i+remaining])
		v := asm.LoadUint32x4Slice(buf[:])
		mask := pred(v)
		tailMask := asm.FirstN(remaining)
		mask = mask.And(tailMask)
		dstRemaining := dstLen - dstIdx
		count := min(asm.CompressStoreUint32(v, mask, dst[dstIdx:]), dstRemaining)
		dstIdx += count
	}
	return dstIdx
}

func BaseCopyIf_neon_Uint64(src []uint64, dst []uint64, pred func(asm.Uint64x2) asm.Int64x2) int {
	n := len(src)
	dstLen := len(dst)
	if n == 0 || dstLen == 0 {
		return 0
	}
	lanes := 2
	dstIdx := 0
	i := 0
	for ; i+lanes <= n && dstIdx < dstLen; i += lanes {
		v := asm.LoadUint64x2Slice(src[i:])
		mask := pred(v)
		remaining := dstLen - dstIdx
		count := min(asm.CompressStoreUint64(v, mask, dst[dstIdx:]), remaining)
		dstIdx += count
		if dstIdx >= dstLen {
			break
		}
	}
	if remaining := n - i; remaining > 0 && dstIdx < dstLen {
		buf := [2]uint64{}
		copy(buf[:], src[i:i+remaining])
		v := asm.LoadUint64x2Slice(buf[:])
		mask := pred(v)
		tailMask := asm.FirstNInt64(remaining)
		mask = mask.And(tailMask)
		dstRemaining := dstLen - dstIdx
		count := min(asm.CompressStoreUint64(v, mask, dst[dstIdx:]), dstRemaining)
		dstIdx += count
	}
	return dstIdx
}
