// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

//go:build amd64 && goexperiment.simd

package algo

import (
	"simd/archsimd"
	"unsafe"

	"github.com/ajroetker/go-highway/hwy"
	"github.com/ajroetker/go-highway/hwy/asm"
)

func BaseApply_avx512_Float16(in []hwy.Float16, out []hwy.Float16, fn func(asm.Float16x16AVX512) asm.Float16x16AVX512) {
	n := min(len(in), len(out))
	lanes := 16
	i := 0
	for ; i+lanes*3 <= n; i += lanes * 3 {
		x := asm.LoadFloat16x16AVX512Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(in[i:]))), len(in[i:])))
		fn(x).StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(out[i:]))), len(out[i:])))
		x1 := asm.LoadFloat16x16AVX512Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(in[i+16:]))), len(in[i+16:])))
		fn(x1).StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(out[i+16:]))), len(out[i+16:])))
		x2 := asm.LoadFloat16x16AVX512Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(in[i+32:]))), len(in[i+32:])))
		fn(x2).StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(out[i+32:]))), len(out[i+32:])))
	}
	for ; i+lanes <= n; i += lanes {
		x := asm.LoadFloat16x16AVX512Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(in[i:]))), len(in[i:])))
		fn(x).StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(out[i:]))), len(out[i:])))
	}
	if remaining := n - i; remaining > 0 {
		buf := [16]hwy.Float16{}
		copy(buf[:], in[i:i+remaining])
		x := asm.LoadFloat16x16AVX512Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(buf[:]))), len(buf[:])))
		fn(x).StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(buf[:]))), len(buf[:])))
		copy(out[i:i+remaining], buf[:remaining])
	}
}

func BaseApply_avx512_BFloat16(in []hwy.BFloat16, out []hwy.BFloat16, fn func(asm.BFloat16x16AVX512) asm.BFloat16x16AVX512) {
	n := min(len(in), len(out))
	lanes := 16
	i := 0
	for ; i+lanes*3 <= n; i += lanes * 3 {
		x := asm.LoadBFloat16x16AVX512Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(in[i:]))), len(in[i:])))
		fn(x).StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(out[i:]))), len(out[i:])))
		x1 := asm.LoadBFloat16x16AVX512Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(in[i+16:]))), len(in[i+16:])))
		fn(x1).StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(out[i+16:]))), len(out[i+16:])))
		x2 := asm.LoadBFloat16x16AVX512Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(in[i+32:]))), len(in[i+32:])))
		fn(x2).StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(out[i+32:]))), len(out[i+32:])))
	}
	for ; i+lanes <= n; i += lanes {
		x := asm.LoadBFloat16x16AVX512Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(in[i:]))), len(in[i:])))
		fn(x).StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(out[i:]))), len(out[i:])))
	}
	if remaining := n - i; remaining > 0 {
		buf := [16]hwy.BFloat16{}
		copy(buf[:], in[i:i+remaining])
		x := asm.LoadBFloat16x16AVX512Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(buf[:]))), len(buf[:])))
		fn(x).StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(buf[:]))), len(buf[:])))
		copy(out[i:i+remaining], buf[:remaining])
	}
}

func BaseApply_avx512(in []float32, out []float32, fn func(archsimd.Float32x16) archsimd.Float32x16) {
	n := min(len(in), len(out))
	lanes := 16
	i := 0
	for ; i+lanes*3 <= n; i += lanes * 3 {
		x := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&in[i])))
		fn(x).Store((*[16]float32)(unsafe.Pointer(&out[i])))
		x1 := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&in[i+16])))
		fn(x1).Store((*[16]float32)(unsafe.Pointer(&out[i+16])))
		x2 := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&in[i+32])))
		fn(x2).Store((*[16]float32)(unsafe.Pointer(&out[i+32])))
	}
	for ; i+lanes <= n; i += lanes {
		x := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&in[i])))
		fn(x).Store((*[16]float32)(unsafe.Pointer(&out[i])))
	}
	if remaining := n - i; remaining > 0 {
		buf := [16]float32{}
		copy(buf[:], in[i:i+remaining])
		x := archsimd.LoadFloat32x16Slice(buf[:])
		fn(x).StoreSlice(buf[:])
		copy(out[i:i+remaining], buf[:remaining])
	}
}

func BaseApply_avx512_Float64(in []float64, out []float64, fn func(archsimd.Float64x8) archsimd.Float64x8) {
	n := min(len(in), len(out))
	lanes := 8
	i := 0
	for ; i+lanes*3 <= n; i += lanes * 3 {
		x := archsimd.LoadFloat64x8((*[8]float64)(unsafe.Pointer(&in[i])))
		fn(x).Store((*[8]float64)(unsafe.Pointer(&out[i])))
		x1 := archsimd.LoadFloat64x8((*[8]float64)(unsafe.Pointer(&in[i+8])))
		fn(x1).Store((*[8]float64)(unsafe.Pointer(&out[i+8])))
		x2 := archsimd.LoadFloat64x8((*[8]float64)(unsafe.Pointer(&in[i+16])))
		fn(x2).Store((*[8]float64)(unsafe.Pointer(&out[i+16])))
	}
	for ; i+lanes <= n; i += lanes {
		x := archsimd.LoadFloat64x8((*[8]float64)(unsafe.Pointer(&in[i])))
		fn(x).Store((*[8]float64)(unsafe.Pointer(&out[i])))
	}
	if remaining := n - i; remaining > 0 {
		buf := [8]float64{}
		copy(buf[:], in[i:i+remaining])
		x := archsimd.LoadFloat64x8Slice(buf[:])
		fn(x).StoreSlice(buf[:])
		copy(out[i:i+remaining], buf[:remaining])
	}
}
