// Copyright 2025 go-highway Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//go:build !noasm && arm64

// NEON in-place Prefix Sum and Delta Decode for ARM64
// Uses NEON SIMD instructions for efficient in-place operations.
package asm

import "unsafe"

//go:generate go tool goat ../c/prefix_sum_neon_arm64.c -O3 --target arm64 -e="-march=armv8-a+simd+fp"

// ============================================================================
// In-Place Prefix Sum Operations
// ============================================================================

// PrefixSumFloat32 computes the inclusive prefix sum in-place.
func PrefixSumFloat32(data []float32) {
	if len(data) == 0 {
		return
	}
	n := int64(len(data))
	prefix_sum_inplace_f32(unsafe.Pointer(&data[0]), n)
}

// PrefixSumFloat64 computes the inclusive prefix sum in-place.
func PrefixSumFloat64(data []float64) {
	if len(data) == 0 {
		return
	}
	n := int64(len(data))
	prefix_sum_inplace_f64(unsafe.Pointer(&data[0]), n)
}

// PrefixSumInt32 computes the inclusive prefix sum in-place.
func PrefixSumInt32(data []int32) {
	if len(data) == 0 {
		return
	}
	n := int64(len(data))
	prefix_sum_inplace_i32(unsafe.Pointer(&data[0]), n)
}

// PrefixSumInt64 computes the inclusive prefix sum in-place.
func PrefixSumInt64(data []int64) {
	if len(data) == 0 {
		return
	}
	n := int64(len(data))
	prefix_sum_inplace_i64(unsafe.Pointer(&data[0]), n)
}

// PrefixSumUint32 computes the inclusive prefix sum in-place.
func PrefixSumUint32(data []uint32) {
	if len(data) == 0 {
		return
	}
	n := int64(len(data))
	prefix_sum_inplace_u32(unsafe.Pointer(&data[0]), n)
}

// PrefixSumUint64 computes the inclusive prefix sum in-place.
func PrefixSumUint64(data []uint64) {
	if len(data) == 0 {
		return
	}
	n := int64(len(data))
	prefix_sum_inplace_u64(unsafe.Pointer(&data[0]), n)
}

// ============================================================================
// In-Place Delta Decode Operations
// ============================================================================

// DeltaDecodeInt32 decodes a delta-encoded int32 slice in-place.
func DeltaDecodeInt32(data []int32, base int32) {
	if len(data) == 0 {
		return
	}
	n := int64(len(data))
	delta_decode_inplace_i32(unsafe.Pointer(&data[0]), n, base)
}

// DeltaDecodeInt64 decodes a delta-encoded int64 slice in-place.
func DeltaDecodeInt64(data []int64, base int64) {
	if len(data) == 0 {
		return
	}
	n := int64(len(data))
	delta_decode_inplace_i64(unsafe.Pointer(&data[0]), n, base)
}

// DeltaDecodeUint32 decodes a delta-encoded uint32 slice in-place.
func DeltaDecodeUint32(data []uint32, base uint32) {
	if len(data) == 0 {
		return
	}
	n := int64(len(data))
	delta_decode_inplace_u32(unsafe.Pointer(&data[0]), n, int32(base))
}

// DeltaDecodeUint64 decodes a delta-encoded uint64 slice in-place.
func DeltaDecodeUint64(data []uint64, base uint64) {
	if len(data) == 0 {
		return
	}
	n := int64(len(data))
	delta_decode_inplace_u64(unsafe.Pointer(&data[0]), n, int64(base))
}

// Assembly function declarations are in prefix_sum_neon_arm64.go (generated by GoAT)
