// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

//go:build arm64

package algo

import (
	"github.com/ajroetker/go-highway/hwy/asm"
)

func BasePrefixSum_neon(data []float32) {
	n := len(data)
	if n == 0 {
		return
	}
	lanes := 4
	carry := float32(0)
	i := 0
	for ; i+lanes <= n; i += lanes {
		v := asm.LoadFloat32x4Slice(data[i:])
		prefixed := BasePrefixSumVec_neon(v)
		prefixed = prefixed.Add(asm.BroadcastFloat32x4(carry))
		prefixed.StoreSlice(data[i:])
		carry = prefixed.Get(lanes - 1)
	}
	for ; i < n; i++ {
		carry += data[i]
		data[i] = carry
	}
}

func BasePrefixSum_neon_Float64(data []float64) {
	n := len(data)
	if n == 0 {
		return
	}
	lanes := 2
	carry := float64(0)
	i := 0
	for ; i+lanes <= n; i += lanes {
		v := asm.LoadFloat64x2Slice(data[i:])
		prefixed := BasePrefixSumVec_neon_Float64(v)
		prefixed = prefixed.Add(asm.BroadcastFloat64x2(carry))
		prefixed.StoreSlice(data[i:])
		carry = prefixed.Get(lanes - 1)
	}
	for ; i < n; i++ {
		carry += data[i]
		data[i] = carry
	}
}

func BasePrefixSum_neon_Int32(data []int32) {
	n := len(data)
	if n == 0 {
		return
	}
	lanes := 4
	carry := int32(0)
	i := 0
	for ; i+lanes <= n; i += lanes {
		v := asm.LoadInt32x4Slice(data[i:])
		prefixed := BasePrefixSumVec_neon_Int32(v)
		prefixed = prefixed.Add(asm.BroadcastInt32x4(carry))
		prefixed.StoreSlice(data[i:])
		carry = prefixed.Get(lanes - 1)
	}
	for ; i < n; i++ {
		carry += data[i]
		data[i] = carry
	}
}

func BasePrefixSum_neon_Int64(data []int64) {
	n := len(data)
	if n == 0 {
		return
	}
	lanes := 2
	carry := int64(0)
	i := 0
	for ; i+lanes <= n; i += lanes {
		v := asm.LoadInt64x2Slice(data[i:])
		prefixed := BasePrefixSumVec_neon_Int64(v)
		prefixed = prefixed.Add(asm.BroadcastInt64x2(carry))
		prefixed.StoreSlice(data[i:])
		carry = prefixed.Get(lanes - 1)
	}
	for ; i < n; i++ {
		carry += data[i]
		data[i] = carry
	}
}

func BasePrefixSum_neon_Uint32(data []uint32) {
	n := len(data)
	if n == 0 {
		return
	}
	lanes := 4
	carry := uint32(0)
	i := 0
	for ; i+lanes <= n; i += lanes {
		v := asm.LoadUint32x4Slice(data[i:])
		prefixed := BasePrefixSumVec_neon_Uint32(v)
		prefixed = prefixed.Add(asm.BroadcastUint32x4(carry))
		prefixed.StoreSlice(data[i:])
		carry = prefixed.Get(lanes - 1)
	}
	for ; i < n; i++ {
		carry += data[i]
		data[i] = carry
	}
}

func BasePrefixSum_neon_Uint64(data []uint64) {
	n := len(data)
	if n == 0 {
		return
	}
	lanes := 2
	carry := uint64(0)
	i := 0
	for ; i+lanes <= n; i += lanes {
		v := asm.LoadUint64x2Slice(data[i:])
		prefixed := BasePrefixSumVec_neon_Uint64(v)
		prefixed = prefixed.Add(asm.BroadcastUint64x2(carry))
		prefixed.StoreSlice(data[i:])
		carry = prefixed.Get(lanes - 1)
	}
	for ; i < n; i++ {
		carry += data[i]
		data[i] = carry
	}
}

func BaseDeltaDecode_neon_Int32(data []int32, base int32) {
	n := len(data)
	if n == 0 {
		return
	}
	lanes := 4
	carry := base
	i := 0
	for ; i+lanes <= n; i += lanes {
		v := asm.LoadInt32x4Slice(data[i:])
		prefixed := BasePrefixSumVec_neon_Int32(v)
		prefixed = prefixed.Add(asm.BroadcastInt32x4(carry))
		prefixed.StoreSlice(data[i:])
		carry = prefixed.Get(lanes - 1)
	}
	for ; i < n; i++ {
		carry += data[i]
		data[i] = carry
	}
}

func BaseDeltaDecode_neon_Int64(data []int64, base int64) {
	n := len(data)
	if n == 0 {
		return
	}
	lanes := 2
	carry := base
	i := 0
	for ; i+lanes <= n; i += lanes {
		v := asm.LoadInt64x2Slice(data[i:])
		prefixed := BasePrefixSumVec_neon_Int64(v)
		prefixed = prefixed.Add(asm.BroadcastInt64x2(carry))
		prefixed.StoreSlice(data[i:])
		carry = prefixed.Get(lanes - 1)
	}
	for ; i < n; i++ {
		carry += data[i]
		data[i] = carry
	}
}

func BaseDeltaDecode_neon_Uint32(data []uint32, base uint32) {
	n := len(data)
	if n == 0 {
		return
	}
	lanes := 4
	carry := base
	i := 0
	for ; i+lanes <= n; i += lanes {
		v := asm.LoadUint32x4Slice(data[i:])
		prefixed := BasePrefixSumVec_neon_Uint32(v)
		prefixed = prefixed.Add(asm.BroadcastUint32x4(carry))
		prefixed.StoreSlice(data[i:])
		carry = prefixed.Get(lanes - 1)
	}
	for ; i < n; i++ {
		carry += data[i]
		data[i] = carry
	}
}

func BaseDeltaDecode_neon_Uint64(data []uint64, base uint64) {
	n := len(data)
	if n == 0 {
		return
	}
	lanes := 2
	carry := base
	i := 0
	for ; i+lanes <= n; i += lanes {
		v := asm.LoadUint64x2Slice(data[i:])
		prefixed := BasePrefixSumVec_neon_Uint64(v)
		prefixed = prefixed.Add(asm.BroadcastUint64x2(carry))
		prefixed.StoreSlice(data[i:])
		carry = prefixed.Get(lanes - 1)
	}
	for ; i < n; i++ {
		carry += data[i]
		data[i] = carry
	}
}

func BasePrefixSumVec_neon(v asm.Float32x4) asm.Float32x4 {
	n := 4
	if n >= 2 {
		v = v.Add(asm.SlideUpLanesFloat32x4(v, 1))
	}
	if n >= 4 {
		v = v.Add(asm.SlideUpLanesFloat32x4(v, 2))
	}
	if n >= 8 {
		v = v.Add(asm.SlideUpLanesFloat32x4(v, 4))
	}
	if n >= 16 {
		v = v.Add(asm.SlideUpLanesFloat32x4(v, 8))
	}
	return v
}

func BasePrefixSumVec_neon_Float64(v asm.Float64x2) asm.Float64x2 {
	n := 2
	if n >= 2 {
		v = v.Add(asm.SlideUpLanesFloat64x2(v, 1))
	}
	if n >= 4 {
		v = v.Add(asm.SlideUpLanesFloat64x2(v, 2))
	}
	if n >= 8 {
		v = v.Add(asm.SlideUpLanesFloat64x2(v, 4))
	}
	if n >= 16 {
		v = v.Add(asm.SlideUpLanesFloat64x2(v, 8))
	}
	return v
}

func BasePrefixSumVec_neon_Int32(v asm.Int32x4) asm.Int32x4 {
	n := 4
	if n >= 2 {
		v = v.Add(asm.SlideUpLanesInt32x4(v, 1))
	}
	if n >= 4 {
		v = v.Add(asm.SlideUpLanesInt32x4(v, 2))
	}
	if n >= 8 {
		v = v.Add(asm.SlideUpLanesInt32x4(v, 4))
	}
	if n >= 16 {
		v = v.Add(asm.SlideUpLanesInt32x4(v, 8))
	}
	return v
}

func BasePrefixSumVec_neon_Int64(v asm.Int64x2) asm.Int64x2 {
	n := 2
	if n >= 2 {
		v = v.Add(asm.SlideUpLanesInt64x2(v, 1))
	}
	if n >= 4 {
		v = v.Add(asm.SlideUpLanesInt64x2(v, 2))
	}
	if n >= 8 {
		v = v.Add(asm.SlideUpLanesInt64x2(v, 4))
	}
	if n >= 16 {
		v = v.Add(asm.SlideUpLanesInt64x2(v, 8))
	}
	return v
}

func BasePrefixSumVec_neon_Uint32(v asm.Uint32x4) asm.Uint32x4 {
	n := 4
	if n >= 2 {
		v = v.Add(asm.SlideUpLanesUint32x4(v, 1))
	}
	if n >= 4 {
		v = v.Add(asm.SlideUpLanesUint32x4(v, 2))
	}
	if n >= 8 {
		v = v.Add(asm.SlideUpLanesUint32x4(v, 4))
	}
	if n >= 16 {
		v = v.Add(asm.SlideUpLanesUint32x4(v, 8))
	}
	return v
}

func BasePrefixSumVec_neon_Uint64(v asm.Uint64x2) asm.Uint64x2 {
	n := 2
	if n >= 2 {
		v = v.Add(asm.SlideUpLanesUint64x2(v, 1))
	}
	if n >= 4 {
		v = v.Add(asm.SlideUpLanesUint64x2(v, 2))
	}
	if n >= 8 {
		v = v.Add(asm.SlideUpLanesUint64x2(v, 4))
	}
	if n >= 16 {
		v = v.Add(asm.SlideUpLanesUint64x2(v, 8))
	}
	return v
}
