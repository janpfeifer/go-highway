// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

//go:build amd64 && goexperiment.simd

package algo

import (
	"github.com/ajroetker/go-highway/hwy"
	"simd/archsimd"
)

func BaseFind_avx512(slice []float32, value float32) int {
	n := len(slice)
	if n == 0 {
		return -1
	}
	target := archsimd.BroadcastFloat32x16(value)
	lanes := 16
	i := 0
	for ; i+lanes <= n; i += lanes {
		v := archsimd.LoadFloat32x16Slice(slice[i:])
		mask := v.Equal(target)
		if idx := hwy.FindFirstTrue_AVX512_F32x16(mask); idx >= 0 {
			return i + idx
		}
	}
	for ; i < n; i++ {
		if slice[i] == value {
			return i
		}
	}
	return -1
}

func BaseFind_avx512_Float64(slice []float64, value float64) int {
	n := len(slice)
	if n == 0 {
		return -1
	}
	target := archsimd.BroadcastFloat64x8(value)
	lanes := 8
	i := 0
	for ; i+lanes <= n; i += lanes {
		v := archsimd.LoadFloat64x8Slice(slice[i:])
		mask := v.Equal(target)
		if idx := hwy.FindFirstTrue_AVX512_F64x8(mask); idx >= 0 {
			return i + idx
		}
	}
	for ; i < n; i++ {
		if slice[i] == value {
			return i
		}
	}
	return -1
}

func BaseFind_avx512_Int32(slice []int32, value int32) int {
	n := len(slice)
	if n == 0 {
		return -1
	}
	target := archsimd.BroadcastInt32x16(value)
	lanes := 16
	i := 0
	for ; i+lanes <= n; i += lanes {
		v := archsimd.LoadInt32x16Slice(slice[i:])
		mask := v.Equal(target)
		if idx := hwy.FindFirstTrue_AVX512_I32x16(mask); idx >= 0 {
			return i + idx
		}
	}
	for ; i < n; i++ {
		if slice[i] == value {
			return i
		}
	}
	return -1
}

func BaseFind_avx512_Int64(slice []int64, value int64) int {
	n := len(slice)
	if n == 0 {
		return -1
	}
	target := archsimd.BroadcastInt64x8(value)
	lanes := 8
	i := 0
	for ; i+lanes <= n; i += lanes {
		v := archsimd.LoadInt64x8Slice(slice[i:])
		mask := v.Equal(target)
		if idx := hwy.FindFirstTrue_AVX512_I64x8(mask); idx >= 0 {
			return i + idx
		}
	}
	for ; i < n; i++ {
		if slice[i] == value {
			return i
		}
	}
	return -1
}

func BaseFind_avx512_Uint32(slice []uint32, value uint32) int {
	n := len(slice)
	if n == 0 {
		return -1
	}
	target := archsimd.BroadcastUint32x16(value)
	lanes := 16
	i := 0
	for ; i+lanes <= n; i += lanes {
		v := archsimd.LoadUint32x16Slice(slice[i:])
		mask := v.Equal(target)
		if idx := hwy.FindFirstTrue_AVX512_Uint32x16(mask); idx >= 0 {
			return i + idx
		}
	}
	for ; i < n; i++ {
		if slice[i] == value {
			return i
		}
	}
	return -1
}

func BaseFind_avx512_Uint64(slice []uint64, value uint64) int {
	n := len(slice)
	if n == 0 {
		return -1
	}
	target := archsimd.BroadcastUint64x8(value)
	lanes := 8
	i := 0
	for ; i+lanes <= n; i += lanes {
		v := archsimd.LoadUint64x8Slice(slice[i:])
		mask := v.Equal(target)
		if idx := hwy.FindFirstTrue_AVX512_Uint64x8(mask); idx >= 0 {
			return i + idx
		}
	}
	for ; i < n; i++ {
		if slice[i] == value {
			return i
		}
	}
	return -1
}

func BaseCount_avx512(slice []float32, value float32) int {
	n := len(slice)
	if n == 0 {
		return 0
	}
	target := archsimd.BroadcastFloat32x16(value)
	lanes := 16
	count := 0
	i := 0
	for ; i+lanes <= n; i += lanes {
		v := archsimd.LoadFloat32x16Slice(slice[i:])
		mask := v.Equal(target)
		count += hwy.CountTrue_AVX512_F32x16(mask)
	}
	for ; i < n; i++ {
		if slice[i] == value {
			count++
		}
	}
	return count
}

func BaseCount_avx512_Float64(slice []float64, value float64) int {
	n := len(slice)
	if n == 0 {
		return 0
	}
	target := archsimd.BroadcastFloat64x8(value)
	lanes := 8
	count := 0
	i := 0
	for ; i+lanes <= n; i += lanes {
		v := archsimd.LoadFloat64x8Slice(slice[i:])
		mask := v.Equal(target)
		count += hwy.CountTrue_AVX512_F64x8(mask)
	}
	for ; i < n; i++ {
		if slice[i] == value {
			count++
		}
	}
	return count
}

func BaseCount_avx512_Int32(slice []int32, value int32) int {
	n := len(slice)
	if n == 0 {
		return 0
	}
	target := archsimd.BroadcastInt32x16(value)
	lanes := 16
	count := 0
	i := 0
	for ; i+lanes <= n; i += lanes {
		v := archsimd.LoadInt32x16Slice(slice[i:])
		mask := v.Equal(target)
		count += hwy.CountTrue_AVX512_I32x16(mask)
	}
	for ; i < n; i++ {
		if slice[i] == value {
			count++
		}
	}
	return count
}

func BaseCount_avx512_Int64(slice []int64, value int64) int {
	n := len(slice)
	if n == 0 {
		return 0
	}
	target := archsimd.BroadcastInt64x8(value)
	lanes := 8
	count := 0
	i := 0
	for ; i+lanes <= n; i += lanes {
		v := archsimd.LoadInt64x8Slice(slice[i:])
		mask := v.Equal(target)
		count += hwy.CountTrue_AVX512_I64x8(mask)
	}
	for ; i < n; i++ {
		if slice[i] == value {
			count++
		}
	}
	return count
}

func BaseCount_avx512_Uint32(slice []uint32, value uint32) int {
	n := len(slice)
	if n == 0 {
		return 0
	}
	target := archsimd.BroadcastUint32x16(value)
	lanes := 16
	count := 0
	i := 0
	for ; i+lanes <= n; i += lanes {
		v := archsimd.LoadUint32x16Slice(slice[i:])
		mask := v.Equal(target)
		count += hwy.CountTrue_AVX512_Uint32x16(mask)
	}
	for ; i < n; i++ {
		if slice[i] == value {
			count++
		}
	}
	return count
}

func BaseCount_avx512_Uint64(slice []uint64, value uint64) int {
	n := len(slice)
	if n == 0 {
		return 0
	}
	target := archsimd.BroadcastUint64x8(value)
	lanes := 8
	count := 0
	i := 0
	for ; i+lanes <= n; i += lanes {
		v := archsimd.LoadUint64x8Slice(slice[i:])
		mask := v.Equal(target)
		count += hwy.CountTrue_AVX512_Uint64x8(mask)
	}
	for ; i < n; i++ {
		if slice[i] == value {
			count++
		}
	}
	return count
}

func BaseContains_avx512(slice []float32, value float32) bool {
	return BaseFind_avx512(slice, value) >= 0
}

func BaseContains_avx512_Float64(slice []float64, value float64) bool {
	return BaseFind_avx512_Float64(slice, value) >= 0
}

func BaseContains_avx512_Int32(slice []int32, value int32) bool {
	return BaseFind_avx512_Int32(slice, value) >= 0
}

func BaseContains_avx512_Int64(slice []int64, value int64) bool {
	return BaseFind_avx512_Int64(slice, value) >= 0
}

func BaseContains_avx512_Uint32(slice []uint32, value uint32) bool {
	return BaseFind_avx512_Uint32(slice, value) >= 0
}

func BaseContains_avx512_Uint64(slice []uint64, value uint64) bool {
	return BaseFind_avx512_Uint64(slice, value) >= 0
}
