// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

//go:build amd64 && goexperiment.simd

package algo

import (
	"simd/archsimd"
	"unsafe"

	"github.com/ajroetker/go-highway/hwy"
)

func BaseFind_avx512(slice []float32, value float32) int {
	n := len(slice)
	if n == 0 {
		return -1
	}
	target := archsimd.BroadcastFloat32x16(value)
	lanes := 16
	i := 0
	for ; i+lanes*3 <= n; i += lanes * 3 {
		v := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&slice[i])))
		mask := v.Equal(target)
		if idx := hwy.FindFirstTrue_AVX512_F32x16(mask); idx >= 0 {
			return i + idx
		}
		v1 := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&slice[i+16])))
		mask1 := v1.Equal(target)
		if idx1 := hwy.FindFirstTrue_AVX512_F32x16(mask1); idx1 >= 0 {
			return i + idx1
		}
		v2 := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&slice[i+32])))
		mask2 := v2.Equal(target)
		if idx2 := hwy.FindFirstTrue_AVX512_F32x16(mask2); idx2 >= 0 {
			return i + idx2
		}
	}
	for ; i < n; i++ {
		if slice[i] == value {
			return i
		}
	}
	return -1
}

func BaseFind_avx512_Float64(slice []float64, value float64) int {
	n := len(slice)
	if n == 0 {
		return -1
	}
	target := archsimd.BroadcastFloat64x8(value)
	lanes := 8
	i := 0
	for ; i+lanes*3 <= n; i += lanes * 3 {
		v := archsimd.LoadFloat64x8((*[8]float64)(unsafe.Pointer(&slice[i])))
		mask := v.Equal(target)
		if idx := hwy.FindFirstTrue_AVX512_F64x8(mask); idx >= 0 {
			return i + idx
		}
		v1 := archsimd.LoadFloat64x8((*[8]float64)(unsafe.Pointer(&slice[i+8])))
		mask1 := v1.Equal(target)
		if idx1 := hwy.FindFirstTrue_AVX512_F64x8(mask1); idx1 >= 0 {
			return i + idx1
		}
		v2 := archsimd.LoadFloat64x8((*[8]float64)(unsafe.Pointer(&slice[i+16])))
		mask2 := v2.Equal(target)
		if idx2 := hwy.FindFirstTrue_AVX512_F64x8(mask2); idx2 >= 0 {
			return i + idx2
		}
	}
	for ; i < n; i++ {
		if slice[i] == value {
			return i
		}
	}
	return -1
}

func BaseFind_avx512_Int32(slice []int32, value int32) int {
	n := len(slice)
	if n == 0 {
		return -1
	}
	target := archsimd.BroadcastInt32x16(value)
	lanes := 16
	i := 0
	for ; i+lanes*3 <= n; i += lanes * 3 {
		v := archsimd.LoadInt32x16((*[16]int32)(unsafe.Pointer(&slice[i])))
		mask := v.Equal(target)
		if idx := hwy.FindFirstTrue_AVX512_I32x16(mask); idx >= 0 {
			return i + idx
		}
		v1 := archsimd.LoadInt32x16((*[16]int32)(unsafe.Pointer(&slice[i+16])))
		mask1 := v1.Equal(target)
		if idx1 := hwy.FindFirstTrue_AVX512_I32x16(mask1); idx1 >= 0 {
			return i + idx1
		}
		v2 := archsimd.LoadInt32x16((*[16]int32)(unsafe.Pointer(&slice[i+32])))
		mask2 := v2.Equal(target)
		if idx2 := hwy.FindFirstTrue_AVX512_I32x16(mask2); idx2 >= 0 {
			return i + idx2
		}
	}
	for ; i < n; i++ {
		if slice[i] == value {
			return i
		}
	}
	return -1
}

func BaseFind_avx512_Int64(slice []int64, value int64) int {
	n := len(slice)
	if n == 0 {
		return -1
	}
	target := archsimd.BroadcastInt64x8(value)
	lanes := 8
	i := 0
	for ; i+lanes*3 <= n; i += lanes * 3 {
		v := archsimd.LoadInt64x8((*[8]int64)(unsafe.Pointer(&slice[i])))
		mask := v.Equal(target)
		if idx := hwy.FindFirstTrue_AVX512_I64x8(mask); idx >= 0 {
			return i + idx
		}
		v1 := archsimd.LoadInt64x8((*[8]int64)(unsafe.Pointer(&slice[i+8])))
		mask1 := v1.Equal(target)
		if idx1 := hwy.FindFirstTrue_AVX512_I64x8(mask1); idx1 >= 0 {
			return i + idx1
		}
		v2 := archsimd.LoadInt64x8((*[8]int64)(unsafe.Pointer(&slice[i+16])))
		mask2 := v2.Equal(target)
		if idx2 := hwy.FindFirstTrue_AVX512_I64x8(mask2); idx2 >= 0 {
			return i + idx2
		}
	}
	for ; i < n; i++ {
		if slice[i] == value {
			return i
		}
	}
	return -1
}

func BaseFind_avx512_Uint32(slice []uint32, value uint32) int {
	n := len(slice)
	if n == 0 {
		return -1
	}
	target := archsimd.BroadcastUint32x16(value)
	lanes := 16
	i := 0
	for ; i+lanes*3 <= n; i += lanes * 3 {
		v := archsimd.LoadUint32x16((*[16]uint32)(unsafe.Pointer(&slice[i])))
		mask := v.Equal(target)
		if idx := hwy.FindFirstTrue_AVX512_Uint32x16(mask); idx >= 0 {
			return i + idx
		}
		v1 := archsimd.LoadUint32x16((*[16]uint32)(unsafe.Pointer(&slice[i+16])))
		mask1 := v1.Equal(target)
		if idx1 := hwy.FindFirstTrue_AVX512_Uint32x16(mask1); idx1 >= 0 {
			return i + idx1
		}
		v2 := archsimd.LoadUint32x16((*[16]uint32)(unsafe.Pointer(&slice[i+32])))
		mask2 := v2.Equal(target)
		if idx2 := hwy.FindFirstTrue_AVX512_Uint32x16(mask2); idx2 >= 0 {
			return i + idx2
		}
	}
	for ; i < n; i++ {
		if slice[i] == value {
			return i
		}
	}
	return -1
}

func BaseFind_avx512_Uint64(slice []uint64, value uint64) int {
	n := len(slice)
	if n == 0 {
		return -1
	}
	target := archsimd.BroadcastUint64x8(value)
	lanes := 8
	i := 0
	for ; i+lanes*3 <= n; i += lanes * 3 {
		v := archsimd.LoadUint64x8((*[8]uint64)(unsafe.Pointer(&slice[i])))
		mask := v.Equal(target)
		if idx := hwy.FindFirstTrue_AVX512_Uint64x8(mask); idx >= 0 {
			return i + idx
		}
		v1 := archsimd.LoadUint64x8((*[8]uint64)(unsafe.Pointer(&slice[i+8])))
		mask1 := v1.Equal(target)
		if idx1 := hwy.FindFirstTrue_AVX512_Uint64x8(mask1); idx1 >= 0 {
			return i + idx1
		}
		v2 := archsimd.LoadUint64x8((*[8]uint64)(unsafe.Pointer(&slice[i+16])))
		mask2 := v2.Equal(target)
		if idx2 := hwy.FindFirstTrue_AVX512_Uint64x8(mask2); idx2 >= 0 {
			return i + idx2
		}
	}
	for ; i < n; i++ {
		if slice[i] == value {
			return i
		}
	}
	return -1
}

func BaseCount_avx512(slice []float32, value float32) int {
	n := len(slice)
	if n == 0 {
		return 0
	}
	target := archsimd.BroadcastFloat32x16(value)
	lanes := 16
	count := 0
	i := 0
	for ; i+lanes*3 <= n; i += lanes * 3 {
		v := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&slice[i])))
		mask := v.Equal(target)
		count += hwy.CountTrue_AVX512_F32x16(mask)
		v1 := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&slice[i+16])))
		mask1 := v1.Equal(target)
		count += hwy.CountTrue_AVX512_F32x16(mask1)
		v2 := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&slice[i+32])))
		mask2 := v2.Equal(target)
		count += hwy.CountTrue_AVX512_F32x16(mask2)
	}
	for ; i < n; i++ {
		if slice[i] == value {
			count++
		}
	}
	return count
}

func BaseCount_avx512_Float64(slice []float64, value float64) int {
	n := len(slice)
	if n == 0 {
		return 0
	}
	target := archsimd.BroadcastFloat64x8(value)
	lanes := 8
	count := 0
	i := 0
	for ; i+lanes*3 <= n; i += lanes * 3 {
		v := archsimd.LoadFloat64x8((*[8]float64)(unsafe.Pointer(&slice[i])))
		mask := v.Equal(target)
		count += hwy.CountTrue_AVX512_F64x8(mask)
		v1 := archsimd.LoadFloat64x8((*[8]float64)(unsafe.Pointer(&slice[i+8])))
		mask1 := v1.Equal(target)
		count += hwy.CountTrue_AVX512_F64x8(mask1)
		v2 := archsimd.LoadFloat64x8((*[8]float64)(unsafe.Pointer(&slice[i+16])))
		mask2 := v2.Equal(target)
		count += hwy.CountTrue_AVX512_F64x8(mask2)
	}
	for ; i < n; i++ {
		if slice[i] == value {
			count++
		}
	}
	return count
}

func BaseCount_avx512_Int32(slice []int32, value int32) int {
	n := len(slice)
	if n == 0 {
		return 0
	}
	target := archsimd.BroadcastInt32x16(value)
	lanes := 16
	count := 0
	i := 0
	for ; i+lanes*3 <= n; i += lanes * 3 {
		v := archsimd.LoadInt32x16((*[16]int32)(unsafe.Pointer(&slice[i])))
		mask := v.Equal(target)
		count += hwy.CountTrue_AVX512_I32x16(mask)
		v1 := archsimd.LoadInt32x16((*[16]int32)(unsafe.Pointer(&slice[i+16])))
		mask1 := v1.Equal(target)
		count += hwy.CountTrue_AVX512_I32x16(mask1)
		v2 := archsimd.LoadInt32x16((*[16]int32)(unsafe.Pointer(&slice[i+32])))
		mask2 := v2.Equal(target)
		count += hwy.CountTrue_AVX512_I32x16(mask2)
	}
	for ; i < n; i++ {
		if slice[i] == value {
			count++
		}
	}
	return count
}

func BaseCount_avx512_Int64(slice []int64, value int64) int {
	n := len(slice)
	if n == 0 {
		return 0
	}
	target := archsimd.BroadcastInt64x8(value)
	lanes := 8
	count := 0
	i := 0
	for ; i+lanes*3 <= n; i += lanes * 3 {
		v := archsimd.LoadInt64x8((*[8]int64)(unsafe.Pointer(&slice[i])))
		mask := v.Equal(target)
		count += hwy.CountTrue_AVX512_I64x8(mask)
		v1 := archsimd.LoadInt64x8((*[8]int64)(unsafe.Pointer(&slice[i+8])))
		mask1 := v1.Equal(target)
		count += hwy.CountTrue_AVX512_I64x8(mask1)
		v2 := archsimd.LoadInt64x8((*[8]int64)(unsafe.Pointer(&slice[i+16])))
		mask2 := v2.Equal(target)
		count += hwy.CountTrue_AVX512_I64x8(mask2)
	}
	for ; i < n; i++ {
		if slice[i] == value {
			count++
		}
	}
	return count
}

func BaseCount_avx512_Uint32(slice []uint32, value uint32) int {
	n := len(slice)
	if n == 0 {
		return 0
	}
	target := archsimd.BroadcastUint32x16(value)
	lanes := 16
	count := 0
	i := 0
	for ; i+lanes*3 <= n; i += lanes * 3 {
		v := archsimd.LoadUint32x16((*[16]uint32)(unsafe.Pointer(&slice[i])))
		mask := v.Equal(target)
		count += hwy.CountTrue_AVX512_Uint32x16(mask)
		v1 := archsimd.LoadUint32x16((*[16]uint32)(unsafe.Pointer(&slice[i+16])))
		mask1 := v1.Equal(target)
		count += hwy.CountTrue_AVX512_Uint32x16(mask1)
		v2 := archsimd.LoadUint32x16((*[16]uint32)(unsafe.Pointer(&slice[i+32])))
		mask2 := v2.Equal(target)
		count += hwy.CountTrue_AVX512_Uint32x16(mask2)
	}
	for ; i < n; i++ {
		if slice[i] == value {
			count++
		}
	}
	return count
}

func BaseCount_avx512_Uint64(slice []uint64, value uint64) int {
	n := len(slice)
	if n == 0 {
		return 0
	}
	target := archsimd.BroadcastUint64x8(value)
	lanes := 8
	count := 0
	i := 0
	for ; i+lanes*3 <= n; i += lanes * 3 {
		v := archsimd.LoadUint64x8((*[8]uint64)(unsafe.Pointer(&slice[i])))
		mask := v.Equal(target)
		count += hwy.CountTrue_AVX512_Uint64x8(mask)
		v1 := archsimd.LoadUint64x8((*[8]uint64)(unsafe.Pointer(&slice[i+8])))
		mask1 := v1.Equal(target)
		count += hwy.CountTrue_AVX512_Uint64x8(mask1)
		v2 := archsimd.LoadUint64x8((*[8]uint64)(unsafe.Pointer(&slice[i+16])))
		mask2 := v2.Equal(target)
		count += hwy.CountTrue_AVX512_Uint64x8(mask2)
	}
	for ; i < n; i++ {
		if slice[i] == value {
			count++
		}
	}
	return count
}

func BaseContains_avx512(slice []float32, value float32) bool {
	return BaseFind_avx512(slice, value) >= 0
}

func BaseContains_avx512_Float64(slice []float64, value float64) bool {
	return BaseFind_avx512_Float64(slice, value) >= 0
}

func BaseContains_avx512_Int32(slice []int32, value int32) bool {
	return BaseFind_avx512_Int32(slice, value) >= 0
}

func BaseContains_avx512_Int64(slice []int64, value int64) bool {
	return BaseFind_avx512_Int64(slice, value) >= 0
}

func BaseContains_avx512_Uint32(slice []uint32, value uint32) bool {
	return BaseFind_avx512_Uint32(slice, value) >= 0
}

func BaseContains_avx512_Uint64(slice []uint64, value uint64) bool {
	return BaseFind_avx512_Uint64(slice, value) >= 0
}
