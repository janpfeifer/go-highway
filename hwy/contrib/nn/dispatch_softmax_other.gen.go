// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

//go:build !arm64 && !(amd64 && goexperiment.simd)

package nn

import (
	"github.com/ajroetker/go-highway/hwy"
)

var SoftmaxFloat16 func(input []hwy.Float16, output []hwy.Float16)
var SoftmaxBFloat16 func(input []hwy.BFloat16, output []hwy.BFloat16)
var SoftmaxFloat32 func(input []float32, output []float32)
var SoftmaxFloat64 func(input []float64, output []float64)
var SoftmaxInPlaceFloat16 func(x []hwy.Float16)
var SoftmaxInPlaceBFloat16 func(x []hwy.BFloat16)
var SoftmaxInPlaceFloat32 func(x []float32)
var SoftmaxInPlaceFloat64 func(x []float64)
var LogSoftmaxFloat16 func(input []hwy.Float16, output []hwy.Float16)
var LogSoftmaxBFloat16 func(input []hwy.BFloat16, output []hwy.BFloat16)
var LogSoftmaxFloat32 func(input []float32, output []float32)
var LogSoftmaxFloat64 func(input []float64, output []float64)
var LogSoftmaxInPlaceFloat16 func(x []hwy.Float16)
var LogSoftmaxInPlaceBFloat16 func(x []hwy.BFloat16)
var LogSoftmaxInPlaceFloat32 func(x []float32)
var LogSoftmaxInPlaceFloat64 func(x []float64)
var SoftmaxScalarFloat16 func(input []hwy.Float16, output []hwy.Float16)
var SoftmaxScalarBFloat16 func(input []hwy.BFloat16, output []hwy.BFloat16)
var SoftmaxScalarFloat32 func(input []float32, output []float32)
var SoftmaxScalarFloat64 func(input []float64, output []float64)
var SoftmaxWithTemperatureFloat16 func(input []hwy.Float16, output []hwy.Float16, temperature hwy.Float16)
var SoftmaxWithTemperatureBFloat16 func(input []hwy.BFloat16, output []hwy.BFloat16, temperature hwy.BFloat16)
var SoftmaxWithTemperatureFloat32 func(input []float32, output []float32, temperature float32)
var SoftmaxWithTemperatureFloat64 func(input []float64, output []float64, temperature float64)

// Softmax computes the softmax function over the input slice.
//
// softmax(x_i) = exp(x_i - max(x)) / sum(exp(x_j - max(x)))
//
// The max subtraction provides numerical stability by preventing overflow
// in the exponential computation.
//
// This function uses SIMD-accelerated exp for efficient processing.
//
// This function dispatches to the appropriate SIMD implementation at runtime.
func Softmax[T hwy.Floats](input []T, output []T) {
	switch any(input).(type) {
	case []hwy.Float16:
		SoftmaxFloat16(any(input).([]hwy.Float16), any(output).([]hwy.Float16))
	case []hwy.BFloat16:
		SoftmaxBFloat16(any(input).([]hwy.BFloat16), any(output).([]hwy.BFloat16))
	case []float32:
		SoftmaxFloat32(any(input).([]float32), any(output).([]float32))
	case []float64:
		SoftmaxFloat64(any(input).([]float64), any(output).([]float64))
	}
}

// SoftmaxInPlace applies softmax in-place, modifying the input slice.
//
// This function dispatches to the appropriate SIMD implementation at runtime.
func SoftmaxInPlace[T hwy.Floats](x []T) {
	switch any(x).(type) {
	case []hwy.Float16:
		SoftmaxInPlaceFloat16(any(x).([]hwy.Float16))
	case []hwy.BFloat16:
		SoftmaxInPlaceBFloat16(any(x).([]hwy.BFloat16))
	case []float32:
		SoftmaxInPlaceFloat32(any(x).([]float32))
	case []float64:
		SoftmaxInPlaceFloat64(any(x).([]float64))
	}
}

// LogSoftmax computes the log-softmax function over the input slice.
//
// log_softmax(x_i) = x_i - max(x) - log(sum(exp(x_j - max(x))))
//
// This is more numerically stable than computing log(softmax(x)) directly,
// and is commonly used for negative log-likelihood loss computation.
//
// This function dispatches to the appropriate SIMD implementation at runtime.
func LogSoftmax[T hwy.Floats](input []T, output []T) {
	switch any(input).(type) {
	case []hwy.Float16:
		LogSoftmaxFloat16(any(input).([]hwy.Float16), any(output).([]hwy.Float16))
	case []hwy.BFloat16:
		LogSoftmaxBFloat16(any(input).([]hwy.BFloat16), any(output).([]hwy.BFloat16))
	case []float32:
		LogSoftmaxFloat32(any(input).([]float32), any(output).([]float32))
	case []float64:
		LogSoftmaxFloat64(any(input).([]float64), any(output).([]float64))
	}
}

// LogSoftmaxInPlace applies log-softmax in-place, modifying the input slice.
//
// This function dispatches to the appropriate SIMD implementation at runtime.
func LogSoftmaxInPlace[T hwy.Floats](x []T) {
	switch any(x).(type) {
	case []hwy.Float16:
		LogSoftmaxInPlaceFloat16(any(x).([]hwy.Float16))
	case []hwy.BFloat16:
		LogSoftmaxInPlaceBFloat16(any(x).([]hwy.BFloat16))
	case []float32:
		LogSoftmaxInPlaceFloat32(any(x).([]float32))
	case []float64:
		LogSoftmaxInPlaceFloat64(any(x).([]float64))
	}
}

// SoftmaxScalar is a scalar reference implementation for comparison and testing.
//
// This function dispatches to the appropriate SIMD implementation at runtime.
func SoftmaxScalar[T hwy.Floats](input []T, output []T) {
	switch any(input).(type) {
	case []hwy.Float16:
		SoftmaxScalarFloat16(any(input).([]hwy.Float16), any(output).([]hwy.Float16))
	case []hwy.BFloat16:
		SoftmaxScalarBFloat16(any(input).([]hwy.BFloat16), any(output).([]hwy.BFloat16))
	case []float32:
		SoftmaxScalarFloat32(any(input).([]float32), any(output).([]float32))
	case []float64:
		SoftmaxScalarFloat64(any(input).([]float64), any(output).([]float64))
	}
}

// SoftmaxWithTemperature computes softmax with a temperature parameter.
//
// softmax(x_i / T) = exp((x_i - max(x)) / T) / sum(exp((x_j - max(x)) / T))
//
// Temperature controls the "sharpness" of the distribution:
//   - T < 1: sharper (more confident, closer to argmax)
//   - T = 1: standard softmax
//   - T > 1: softer (more uniform)
//
// This function dispatches to the appropriate SIMD implementation at runtime.
func SoftmaxWithTemperature[T hwy.Floats](input []T, output []T, temperature T) {
	switch any(input).(type) {
	case []hwy.Float16:
		SoftmaxWithTemperatureFloat16(any(input).([]hwy.Float16), any(output).([]hwy.Float16), any(temperature).(hwy.Float16))
	case []hwy.BFloat16:
		SoftmaxWithTemperatureBFloat16(any(input).([]hwy.BFloat16), any(output).([]hwy.BFloat16), any(temperature).(hwy.BFloat16))
	case []float32:
		SoftmaxWithTemperatureFloat32(any(input).([]float32), any(output).([]float32), any(temperature).(float32))
	case []float64:
		SoftmaxWithTemperatureFloat64(any(input).([]float64), any(output).([]float64), any(temperature).(float64))
	}
}

func init() {
	_ = hwy.NoSimdEnv // silence unused import
	initSoftmaxFallback()
}

func initSoftmaxFallback() {
	SoftmaxFloat16 = BaseSoftmax_fallback_Float16
	SoftmaxBFloat16 = BaseSoftmax_fallback_BFloat16
	SoftmaxFloat32 = BaseSoftmax_fallback
	SoftmaxFloat64 = BaseSoftmax_fallback_Float64
	SoftmaxInPlaceFloat16 = BaseSoftmaxInPlace_fallback_Float16
	SoftmaxInPlaceBFloat16 = BaseSoftmaxInPlace_fallback_BFloat16
	SoftmaxInPlaceFloat32 = BaseSoftmaxInPlace_fallback
	SoftmaxInPlaceFloat64 = BaseSoftmaxInPlace_fallback_Float64
	LogSoftmaxFloat16 = BaseLogSoftmax_fallback_Float16
	LogSoftmaxBFloat16 = BaseLogSoftmax_fallback_BFloat16
	LogSoftmaxFloat32 = BaseLogSoftmax_fallback
	LogSoftmaxFloat64 = BaseLogSoftmax_fallback_Float64
	LogSoftmaxInPlaceFloat16 = BaseLogSoftmaxInPlace_fallback_Float16
	LogSoftmaxInPlaceBFloat16 = BaseLogSoftmaxInPlace_fallback_BFloat16
	LogSoftmaxInPlaceFloat32 = BaseLogSoftmaxInPlace_fallback
	LogSoftmaxInPlaceFloat64 = BaseLogSoftmaxInPlace_fallback_Float64
	SoftmaxScalarFloat16 = BaseSoftmaxScalar_fallback_Float16
	SoftmaxScalarBFloat16 = BaseSoftmaxScalar_fallback_BFloat16
	SoftmaxScalarFloat32 = BaseSoftmaxScalar_fallback
	SoftmaxScalarFloat64 = BaseSoftmaxScalar_fallback_Float64
	SoftmaxWithTemperatureFloat16 = BaseSoftmaxWithTemperature_fallback_Float16
	SoftmaxWithTemperatureBFloat16 = BaseSoftmaxWithTemperature_fallback_BFloat16
	SoftmaxWithTemperatureFloat32 = BaseSoftmaxWithTemperature_fallback
	SoftmaxWithTemperatureFloat64 = BaseSoftmaxWithTemperature_fallback_Float64
}
