// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

package nn

import (
	stdmath "math"

	"github.com/ajroetker/go-highway/hwy"
)

func BaseLayerNorm_fallback_Float16(input []hwy.Float16, output []hwy.Float16, normSize int, gamma []hwy.Float16, beta []hwy.Float16, epsilon hwy.Float16) {
	size := min(len(input), len(output))
	if size == 0 || normSize <= 0 {
		return
	}
	numGroups := size / normSize
	invN := float32(1.0) / float32(normSize)
	lanes := hwy.MaxLanes[hwy.Float16]()
	for g := 0; g < numGroups; g++ {
		off := g * normSize
		sumAcc := hwy.Zero[hwy.Float16]()
		ii := 0
		for ; ii+lanes <= normSize; ii += lanes {
			x := hwy.Load(input[off+ii:])
			sumAcc = hwy.Add(sumAcc, x)
		}
		mean := hwy.ReduceSum(sumAcc).Float32()
		for i := ii; i < normSize; i++ {
			mean += input[off+i].Float32()
		}
		mean *= invN
		vMean := hwy.Set(hwy.Float32ToFloat16(mean))
		varAcc := hwy.Zero[hwy.Float16]()
		ii = 0
		for ; ii+lanes <= normSize; ii += lanes {
			x := hwy.Load(input[off+ii:])
			diff := hwy.Sub(x, vMean)
			varAcc = hwy.MulAdd(diff, diff, varAcc)
		}
		variance := hwy.ReduceSum(varAcc).Float32()
		for i := ii; i < normSize; i++ {
			diff := input[off+i].Float32() - mean
			variance += diff * diff
		}
		variance *= invN
		invStd := float32(1.0 / stdmath.Sqrt(float64(variance+epsilon.Float32())))
		vInvStd := hwy.Set(hwy.Float32ToFloat16(invStd))
		if gamma != nil && beta != nil {
			ii = 0
			for ; ii+lanes <= normSize; ii += lanes {
				x := hwy.Load(input[off+ii:])
				diff := hwy.Sub(x, vMean)
				normed := hwy.Mul(diff, vInvStd)
				g := hwy.Load(gamma[ii:])
				b := hwy.Load(beta[ii:])
				result := hwy.MulAdd(normed, g, b)
				hwy.Store(result, output[off+ii:])
			}
			for i := ii; i < normSize; i++ {
				normed := (input[off+i].Float32() - mean) * invStd
				output[off+i] = hwy.Float32ToFloat16(normed*gamma[i].Float32() + beta[i].Float32())
			}
		} else if gamma != nil {
			ii = 0
			for ; ii+lanes <= normSize; ii += lanes {
				x := hwy.Load(input[off+ii:])
				diff := hwy.Sub(x, vMean)
				normed := hwy.Mul(diff, vInvStd)
				g := hwy.Load(gamma[ii:])
				result := hwy.Mul(normed, g)
				hwy.Store(result, output[off+ii:])
			}
			for i := ii; i < normSize; i++ {
				normed := (input[off+i].Float32() - mean) * invStd
				output[off+i] = hwy.Float32ToFloat16(normed * gamma[i].Float32())
			}
		} else {
			ii = 0
			for ; ii+lanes <= normSize; ii += lanes {
				x := hwy.Load(input[off+ii:])
				diff := hwy.Sub(x, vMean)
				result := hwy.Mul(diff, vInvStd)
				hwy.Store(result, output[off+ii:])
			}
			for i := ii; i < normSize; i++ {
				output[off+i] = hwy.Float32ToFloat16((input[off+i].Float32() - mean) * invStd)
			}
		}
	}
}

func BaseLayerNorm_fallback_BFloat16(input []hwy.BFloat16, output []hwy.BFloat16, normSize int, gamma []hwy.BFloat16, beta []hwy.BFloat16, epsilon hwy.BFloat16) {
	size := min(len(input), len(output))
	if size == 0 || normSize <= 0 {
		return
	}
	numGroups := size / normSize
	invN := float32(1.0) / float32(normSize)
	lanes := hwy.MaxLanes[hwy.BFloat16]()
	for g := 0; g < numGroups; g++ {
		off := g * normSize
		sumAcc := hwy.Zero[hwy.BFloat16]()
		ii := 0
		for ; ii+lanes <= normSize; ii += lanes {
			x := hwy.Load(input[off+ii:])
			sumAcc = hwy.Add(sumAcc, x)
		}
		mean := hwy.ReduceSum(sumAcc).Float32()
		for i := ii; i < normSize; i++ {
			mean += input[off+i].Float32()
		}
		mean *= invN
		vMean := hwy.Set(hwy.Float32ToBFloat16(mean))
		varAcc := hwy.Zero[hwy.BFloat16]()
		ii = 0
		for ; ii+lanes <= normSize; ii += lanes {
			x := hwy.Load(input[off+ii:])
			diff := hwy.Sub(x, vMean)
			varAcc = hwy.MulAdd(diff, diff, varAcc)
		}
		variance := hwy.ReduceSum(varAcc).Float32()
		for i := ii; i < normSize; i++ {
			diff := input[off+i].Float32() - mean
			variance += diff * diff
		}
		variance *= invN
		invStd := float32(1.0 / stdmath.Sqrt(float64(variance+epsilon.Float32())))
		vInvStd := hwy.Set(hwy.Float32ToBFloat16(invStd))
		if gamma != nil && beta != nil {
			ii = 0
			for ; ii+lanes <= normSize; ii += lanes {
				x := hwy.Load(input[off+ii:])
				diff := hwy.Sub(x, vMean)
				normed := hwy.Mul(diff, vInvStd)
				g := hwy.Load(gamma[ii:])
				b := hwy.Load(beta[ii:])
				result := hwy.MulAdd(normed, g, b)
				hwy.Store(result, output[off+ii:])
			}
			for i := ii; i < normSize; i++ {
				normed := (input[off+i].Float32() - mean) * invStd
				output[off+i] = hwy.Float32ToBFloat16(normed*gamma[i].Float32() + beta[i].Float32())
			}
		} else if gamma != nil {
			ii = 0
			for ; ii+lanes <= normSize; ii += lanes {
				x := hwy.Load(input[off+ii:])
				diff := hwy.Sub(x, vMean)
				normed := hwy.Mul(diff, vInvStd)
				g := hwy.Load(gamma[ii:])
				result := hwy.Mul(normed, g)
				hwy.Store(result, output[off+ii:])
			}
			for i := ii; i < normSize; i++ {
				normed := (input[off+i].Float32() - mean) * invStd
				output[off+i] = hwy.Float32ToBFloat16(normed * gamma[i].Float32())
			}
		} else {
			ii = 0
			for ; ii+lanes <= normSize; ii += lanes {
				x := hwy.Load(input[off+ii:])
				diff := hwy.Sub(x, vMean)
				result := hwy.Mul(diff, vInvStd)
				hwy.Store(result, output[off+ii:])
			}
			for i := ii; i < normSize; i++ {
				output[off+i] = hwy.Float32ToBFloat16((input[off+i].Float32() - mean) * invStd)
			}
		}
	}
}

func BaseLayerNorm_fallback(input []float32, output []float32, normSize int, gamma []float32, beta []float32, epsilon float32) {
	size := min(len(input), len(output))
	if size == 0 || normSize <= 0 {
		return
	}
	numGroups := size / normSize
	invN := float32(1.0) / float32(normSize)
	for g := 0; g < numGroups; g++ {
		off := g * normSize
		sumAcc := float32(0)
		ii := 0
		for ; ii < normSize; ii++ {
			x := input[off+ii]
			sumAcc = sumAcc + x
		}
		mean := sumAcc
		for i := ii; i < normSize; i++ {
			mean += input[off+i]
		}
		mean *= invN
		vMean := float32(mean)
		varAcc := float32(0)
		ii = 0
		for ; ii < normSize; ii++ {
			x := input[off+ii]
			diff := x - vMean
			varAcc = diff*diff + varAcc
		}
		variance := varAcc
		for i := ii; i < normSize; i++ {
			diff := input[off+i] - mean
			variance += diff * diff
		}
		variance *= invN
		invStd := float32(1.0 / stdmath.Sqrt(float64(variance+epsilon)))
		vInvStd := float32(invStd)
		if gamma != nil && beta != nil {
			ii = 0
			for ; ii < normSize; ii++ {
				x := input[off+ii]
				diff := x - vMean
				normed := diff * vInvStd
				g := gamma[ii]
				b := beta[ii]
				result := normed*g + b
				output[off+ii] = result
			}
			for i := ii; i < normSize; i++ {
				normed := (input[off+i] - mean) * invStd
				output[off+i] = normed*gamma[i] + beta[i]
			}
		} else if gamma != nil {
			ii = 0
			for ; ii < normSize; ii++ {
				x := input[off+ii]
				diff := x - vMean
				normed := diff * vInvStd
				g := gamma[ii]
				result := normed * g
				output[off+ii] = result
			}
			for i := ii; i < normSize; i++ {
				normed := (input[off+i] - mean) * invStd
				output[off+i] = normed * gamma[i]
			}
		} else {
			ii = 0
			for ; ii < normSize; ii++ {
				x := input[off+ii]
				diff := x - vMean
				result := diff * vInvStd
				output[off+ii] = result
			}
			for i := ii; i < normSize; i++ {
				output[off+i] = (input[off+i] - mean) * invStd
			}
		}
	}
}

func BaseLayerNorm_fallback_Float64(input []float64, output []float64, normSize int, gamma []float64, beta []float64, epsilon float64) {
	size := min(len(input), len(output))
	if size == 0 || normSize <= 0 {
		return
	}
	numGroups := size / normSize
	invN := float64(1.0) / float64(normSize)
	for g := 0; g < numGroups; g++ {
		off := g * normSize
		sumAcc := float64(0)
		ii := 0
		for ; ii < normSize; ii++ {
			x := input[off+ii]
			sumAcc = sumAcc + x
		}
		mean := sumAcc
		for i := ii; i < normSize; i++ {
			mean += input[off+i]
		}
		mean *= invN
		vMean := float64(mean)
		varAcc := float64(0)
		ii = 0
		for ; ii < normSize; ii++ {
			x := input[off+ii]
			diff := x - vMean
			varAcc = diff*diff + varAcc
		}
		variance := varAcc
		for i := ii; i < normSize; i++ {
			diff := input[off+i] - mean
			variance += diff * diff
		}
		variance *= invN
		invStd := float64(1.0 / stdmath.Sqrt(float64(variance+epsilon)))
		vInvStd := float64(invStd)
		if gamma != nil && beta != nil {
			ii = 0
			for ; ii < normSize; ii++ {
				x := input[off+ii]
				diff := x - vMean
				normed := diff * vInvStd
				g := gamma[ii]
				b := beta[ii]
				result := normed*g + b
				output[off+ii] = result
			}
			for i := ii; i < normSize; i++ {
				normed := (input[off+i] - mean) * invStd
				output[off+i] = normed*gamma[i] + beta[i]
			}
		} else if gamma != nil {
			ii = 0
			for ; ii < normSize; ii++ {
				x := input[off+ii]
				diff := x - vMean
				normed := diff * vInvStd
				g := gamma[ii]
				result := normed * g
				output[off+ii] = result
			}
			for i := ii; i < normSize; i++ {
				normed := (input[off+i] - mean) * invStd
				output[off+i] = normed * gamma[i]
			}
		} else {
			ii = 0
			for ; ii < normSize; ii++ {
				x := input[off+ii]
				diff := x - vMean
				result := diff * vInvStd
				output[off+ii] = result
			}
			for i := ii; i < normSize; i++ {
				output[off+i] = (input[off+i] - mean) * invStd
			}
		}
	}
}
