// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

package nn

import (
	stdmath "math"

	"github.com/ajroetker/go-highway/hwy"
)

func BaseSDPA_fallback_Float16(q []hwy.Float16, k []hwy.Float16, v []hwy.Float16, mask []hwy.Float16, scores []hwy.Float16, output []hwy.Float16, seqLen int, kvLen int, headDim int, scale hwy.Float16) {
	if seqLen == 0 || kvLen == 0 || headDim == 0 {
		return
	}
	for i := range seqLen {
		qOff := i * headDim
		sOff := i * kvLen
		for j := range kvLen {
			kOff := j * headDim
			var sum float64
			for p := range headDim {
				sum += float64(q[qOff+p].Float32()) * float64(k[kOff+p].Float32())
			}
			scores[sOff+j] = hwy.Float32ToFloat16(float32(sum * float64(scale.Float32())))
		}
		if mask != nil {
			mOff := i * kvLen
			for j := range kvLen {
				scores[sOff+j] = hwy.Float32ToFloat16(scores[sOff+j].Float32() + mask[mOff+j].Float32())
			}
		}
		{
			sRow := scores[sOff : sOff+kvLen]
			maxVal := sRow[0]
			for si := 1; si < kvLen; si++ {
				if sRow[si].Float32() > maxVal.Float32() {
					maxVal = sRow[si]
				}
			}
			var expSum float64
			for si := range sRow {
				sRow[si] = hwy.Float32ToFloat16(float32(stdmath.Exp(float64(sRow[si].Float32() - maxVal.Float32()))))
				expSum += float64(sRow[si].Float32())
			}
			invSum := 1.0 / expSum
			for si := range sRow {
				sRow[si] = hwy.Float32ToFloat16(float32(float64(sRow[si].Float32()) * invSum))
			}
		}
	}
	for i := range seqLen {
		sOff := i * kvLen
		oOff := i * headDim
		for d := range headDim {
			var sum float64
			for j := range kvLen {
				sum += float64(scores[sOff+j].Float32()) * float64(v[j*headDim+d].Float32())
			}
			output[oOff+d] = hwy.Float32ToFloat16(float32(sum))
		}
	}
}

func BaseSDPA_fallback_BFloat16(q []hwy.BFloat16, k []hwy.BFloat16, v []hwy.BFloat16, mask []hwy.BFloat16, scores []hwy.BFloat16, output []hwy.BFloat16, seqLen int, kvLen int, headDim int, scale hwy.BFloat16) {
	if seqLen == 0 || kvLen == 0 || headDim == 0 {
		return
	}
	for i := range seqLen {
		qOff := i * headDim
		sOff := i * kvLen
		for j := range kvLen {
			kOff := j * headDim
			var sum float64
			for p := range headDim {
				sum += float64(q[qOff+p].Float32()) * float64(k[kOff+p].Float32())
			}
			scores[sOff+j] = hwy.Float32ToBFloat16(float32(sum * float64(scale.Float32())))
		}
		if mask != nil {
			mOff := i * kvLen
			for j := range kvLen {
				scores[sOff+j] = hwy.Float32ToBFloat16(scores[sOff+j].Float32() + mask[mOff+j].Float32())
			}
		}
		{
			sRow := scores[sOff : sOff+kvLen]
			maxVal := sRow[0]
			for si := 1; si < kvLen; si++ {
				if sRow[si].Float32() > maxVal.Float32() {
					maxVal = sRow[si]
				}
			}
			var expSum float64
			for si := range sRow {
				sRow[si] = hwy.Float32ToBFloat16(float32(stdmath.Exp(float64(sRow[si].Float32() - maxVal.Float32()))))
				expSum += float64(sRow[si].Float32())
			}
			invSum := 1.0 / expSum
			for si := range sRow {
				sRow[si] = hwy.Float32ToBFloat16(float32(float64(sRow[si].Float32()) * invSum))
			}
		}
	}
	for i := range seqLen {
		sOff := i * kvLen
		oOff := i * headDim
		for d := range headDim {
			var sum float64
			for j := range kvLen {
				sum += float64(scores[sOff+j].Float32()) * float64(v[j*headDim+d].Float32())
			}
			output[oOff+d] = hwy.Float32ToBFloat16(float32(sum))
		}
	}
}

func BaseSDPA_fallback(q []float32, k []float32, v []float32, mask []float32, scores []float32, output []float32, seqLen int, kvLen int, headDim int, scale float32) {
	if seqLen == 0 || kvLen == 0 || headDim == 0 {
		return
	}
	for i := range seqLen {
		qOff := i * headDim
		sOff := i * kvLen
		for j := range kvLen {
			kOff := j * headDim
			var sum float64
			for p := range headDim {
				sum += float64(q[qOff+p]) * float64(k[kOff+p])
			}
			scores[sOff+j] = float32(sum * float64(scale))
		}
		if mask != nil {
			mOff := i * kvLen
			for j := range kvLen {
				scores[sOff+j] += mask[mOff+j]
			}
		}
		{
			sRow := scores[sOff : sOff+kvLen]
			maxVal := sRow[0]
			for si := 1; si < kvLen; si++ {
				if sRow[si] > maxVal {
					maxVal = sRow[si]
				}
			}
			var expSum float64
			for si := range sRow {
				sRow[si] = float32(stdmath.Exp(float64(sRow[si] - maxVal)))
				expSum += float64(sRow[si])
			}
			invSum := 1.0 / expSum
			for si := range sRow {
				sRow[si] = float32(float64(sRow[si]) * invSum)
			}
		}
	}
	for i := range seqLen {
		sOff := i * kvLen
		oOff := i * headDim
		for d := range headDim {
			var sum float64
			for j := range kvLen {
				sum += float64(scores[sOff+j]) * float64(v[j*headDim+d])
			}
			output[oOff+d] = float32(sum)
		}
	}
}

func BaseSDPA_fallback_Float64(q []float64, k []float64, v []float64, mask []float64, scores []float64, output []float64, seqLen int, kvLen int, headDim int, scale float64) {
	if seqLen == 0 || kvLen == 0 || headDim == 0 {
		return
	}
	for i := range seqLen {
		qOff := i * headDim
		sOff := i * kvLen
		for j := range kvLen {
			kOff := j * headDim
			var sum float64
			for p := range headDim {
				sum += float64(q[qOff+p]) * float64(k[kOff+p])
			}
			scores[sOff+j] = float64(sum * float64(scale))
		}
		if mask != nil {
			mOff := i * kvLen
			for j := range kvLen {
				scores[sOff+j] += mask[mOff+j]
			}
		}
		{
			sRow := scores[sOff : sOff+kvLen]
			maxVal := sRow[0]
			for si := 1; si < kvLen; si++ {
				if sRow[si] > maxVal {
					maxVal = sRow[si]
				}
			}
			var expSum float64
			for si := range sRow {
				sRow[si] = float64(stdmath.Exp(float64(sRow[si] - maxVal)))
				expSum += float64(sRow[si])
			}
			invSum := 1.0 / expSum
			for si := range sRow {
				sRow[si] = float64(float64(sRow[si]) * invSum)
			}
		}
	}
	for i := range seqLen {
		sOff := i * kvLen
		oOff := i * headDim
		for d := range headDim {
			var sum float64
			for j := range kvLen {
				sum += float64(scores[sOff+j]) * float64(v[j*headDim+d])
			}
			output[oOff+d] = float64(sum)
		}
	}
}

func BaseSDPACausal_fallback_Float16(q []hwy.Float16, k []hwy.Float16, v []hwy.Float16, scores []hwy.Float16, output []hwy.Float16, seqLen int, kvLen int, headDim int, scale hwy.Float16) {
	if seqLen == 0 || kvLen == 0 || headDim == 0 {
		return
	}
	negInf := float32(stdmath.Inf(-1))
	offset := kvLen - seqLen
	for i := range seqLen {
		qOff := i * headDim
		sOff := i * kvLen
		causalEnd := i + offset + 1
		for j := range kvLen {
			if j >= causalEnd {
				scores[sOff+j] = hwy.Float32ToFloat16(negInf)
				continue
			}
			kOff := j * headDim
			var sum float64
			for p := range headDim {
				sum += float64(q[qOff+p].Float32()) * float64(k[kOff+p].Float32())
			}
			scores[sOff+j] = hwy.Float32ToFloat16(float32(sum * float64(scale.Float32())))
		}
		{
			sRow := scores[sOff : sOff+kvLen]
			maxVal := sRow[0]
			for si := 1; si < kvLen; si++ {
				if sRow[si].Float32() > maxVal.Float32() {
					maxVal = sRow[si]
				}
			}
			var expSum float64
			for si := range sRow {
				sRow[si] = hwy.Float32ToFloat16(float32(stdmath.Exp(float64(sRow[si].Float32() - maxVal.Float32()))))
				expSum += float64(sRow[si].Float32())
			}
			invSum := 1.0 / expSum
			for si := range sRow {
				sRow[si] = hwy.Float32ToFloat16(float32(float64(sRow[si].Float32()) * invSum))
			}
		}
	}
	for i := range seqLen {
		sOff := i * kvLen
		oOff := i * headDim
		for d := range headDim {
			var sum float64
			for j := range kvLen {
				sum += float64(scores[sOff+j].Float32()) * float64(v[j*headDim+d].Float32())
			}
			output[oOff+d] = hwy.Float32ToFloat16(float32(sum))
		}
	}
}

func BaseSDPACausal_fallback_BFloat16(q []hwy.BFloat16, k []hwy.BFloat16, v []hwy.BFloat16, scores []hwy.BFloat16, output []hwy.BFloat16, seqLen int, kvLen int, headDim int, scale hwy.BFloat16) {
	if seqLen == 0 || kvLen == 0 || headDim == 0 {
		return
	}
	negInf := float32(stdmath.Inf(-1))
	offset := kvLen - seqLen
	for i := range seqLen {
		qOff := i * headDim
		sOff := i * kvLen
		causalEnd := i + offset + 1
		for j := range kvLen {
			if j >= causalEnd {
				scores[sOff+j] = hwy.Float32ToBFloat16(negInf)
				continue
			}
			kOff := j * headDim
			var sum float64
			for p := range headDim {
				sum += float64(q[qOff+p].Float32()) * float64(k[kOff+p].Float32())
			}
			scores[sOff+j] = hwy.Float32ToBFloat16(float32(sum * float64(scale.Float32())))
		}
		{
			sRow := scores[sOff : sOff+kvLen]
			maxVal := sRow[0]
			for si := 1; si < kvLen; si++ {
				if sRow[si].Float32() > maxVal.Float32() {
					maxVal = sRow[si]
				}
			}
			var expSum float64
			for si := range sRow {
				sRow[si] = hwy.Float32ToBFloat16(float32(stdmath.Exp(float64(sRow[si].Float32() - maxVal.Float32()))))
				expSum += float64(sRow[si].Float32())
			}
			invSum := 1.0 / expSum
			for si := range sRow {
				sRow[si] = hwy.Float32ToBFloat16(float32(float64(sRow[si].Float32()) * invSum))
			}
		}
	}
	for i := range seqLen {
		sOff := i * kvLen
		oOff := i * headDim
		for d := range headDim {
			var sum float64
			for j := range kvLen {
				sum += float64(scores[sOff+j].Float32()) * float64(v[j*headDim+d].Float32())
			}
			output[oOff+d] = hwy.Float32ToBFloat16(float32(sum))
		}
	}
}

func BaseSDPACausal_fallback(q []float32, k []float32, v []float32, scores []float32, output []float32, seqLen int, kvLen int, headDim int, scale float32) {
	if seqLen == 0 || kvLen == 0 || headDim == 0 {
		return
	}
	negInf := float32(stdmath.Inf(-1))
	offset := kvLen - seqLen
	for i := range seqLen {
		qOff := i * headDim
		sOff := i * kvLen
		causalEnd := i + offset + 1
		for j := range kvLen {
			if j >= causalEnd {
				scores[sOff+j] = negInf
				continue
			}
			kOff := j * headDim
			var sum float64
			for p := range headDim {
				sum += float64(q[qOff+p]) * float64(k[kOff+p])
			}
			scores[sOff+j] = float32(sum * float64(scale))
		}
		{
			sRow := scores[sOff : sOff+kvLen]
			maxVal := sRow[0]
			for si := 1; si < kvLen; si++ {
				if sRow[si] > maxVal {
					maxVal = sRow[si]
				}
			}
			var expSum float64
			for si := range sRow {
				sRow[si] = float32(stdmath.Exp(float64(sRow[si] - maxVal)))
				expSum += float64(sRow[si])
			}
			invSum := 1.0 / expSum
			for si := range sRow {
				sRow[si] = float32(float64(sRow[si]) * invSum)
			}
		}
	}
	for i := range seqLen {
		sOff := i * kvLen
		oOff := i * headDim
		for d := range headDim {
			var sum float64
			for j := range kvLen {
				sum += float64(scores[sOff+j]) * float64(v[j*headDim+d])
			}
			output[oOff+d] = float32(sum)
		}
	}
}

func BaseSDPACausal_fallback_Float64(q []float64, k []float64, v []float64, scores []float64, output []float64, seqLen int, kvLen int, headDim int, scale float64) {
	if seqLen == 0 || kvLen == 0 || headDim == 0 {
		return
	}
	negInf := float64(stdmath.Inf(-1))
	offset := kvLen - seqLen
	for i := range seqLen {
		qOff := i * headDim
		sOff := i * kvLen
		causalEnd := i + offset + 1
		for j := range kvLen {
			if j >= causalEnd {
				scores[sOff+j] = negInf
				continue
			}
			kOff := j * headDim
			var sum float64
			for p := range headDim {
				sum += float64(q[qOff+p]) * float64(k[kOff+p])
			}
			scores[sOff+j] = float64(sum * float64(scale))
		}
		{
			sRow := scores[sOff : sOff+kvLen]
			maxVal := sRow[0]
			for si := 1; si < kvLen; si++ {
				if sRow[si] > maxVal {
					maxVal = sRow[si]
				}
			}
			var expSum float64
			for si := range sRow {
				sRow[si] = float64(stdmath.Exp(float64(sRow[si] - maxVal)))
				expSum += float64(sRow[si])
			}
			invSum := 1.0 / expSum
			for si := range sRow {
				sRow[si] = float64(float64(sRow[si]) * invSum)
			}
		}
	}
	for i := range seqLen {
		sOff := i * kvLen
		oOff := i * headDim
		for d := range headDim {
			var sum float64
			for j := range kvLen {
				sum += float64(scores[sOff+j]) * float64(v[j*headDim+d])
			}
			output[oOff+d] = float64(sum)
		}
	}
}
