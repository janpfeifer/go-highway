// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

//go:build amd64 && goexperiment.simd

package nn

import (
	"simd/archsimd"
	"unsafe"

	"github.com/ajroetker/go-highway/hwy"
	"github.com/ajroetker/go-highway/hwy/asm"
)

func BaseQKVDense_avx2_Float16(x []hwy.Float16, wQKV []hwy.Float16, biasQ []hwy.Float16, biasK []hwy.Float16, biasV []hwy.Float16, q []hwy.Float16, k []hwy.Float16, v []hwy.Float16, batchSize int, inFeatures int, qDim int, kvDim int) {
	totalOut := qDim + 2*kvDim
	if len(x) < batchSize*inFeatures {
		panic("qkvdense: x slice too short")
	}
	if len(wQKV) < totalOut*inFeatures {
		panic("qkvdense: wQKV slice too short")
	}
	if len(q) < batchSize*qDim {
		panic("qkvdense: q slice too short")
	}
	if len(k) < batchSize*kvDim {
		panic("qkvdense: k slice too short")
	}
	if len(v) < batchSize*kvDim {
		panic("qkvdense: v slice too short")
	}
	lanes := 8
	var i int
	for i = 0; i+3 < batchSize; i += 4 {
		xRow0 := i * inFeatures
		xRow1 := (i + 1) * inFeatures
		xRow2 := (i + 2) * inFeatures
		xRow3 := (i + 3) * inFeatures
		for j := range totalOut {
			wRow := j * inFeatures
			acc0 := asm.ZeroFloat16x8AVX2()
			acc1 := asm.ZeroFloat16x8AVX2()
			acc2 := asm.ZeroFloat16x8AVX2()
			acc3 := asm.ZeroFloat16x8AVX2()
			var p int
			for p = 0; p+lanes <= inFeatures; p += lanes {
				vW := asm.LoadFloat16x8AVX2Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(wQKV[wRow+p:]))), len(wQKV[wRow+p:])))
				vX0 := asm.LoadFloat16x8AVX2Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(x[xRow0+p:]))), len(x[xRow0+p:])))
				vX1 := asm.LoadFloat16x8AVX2Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(x[xRow1+p:]))), len(x[xRow1+p:])))
				vX2 := asm.LoadFloat16x8AVX2Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(x[xRow2+p:]))), len(x[xRow2+p:])))
				vX3 := asm.LoadFloat16x8AVX2Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(x[xRow3+p:]))), len(x[xRow3+p:])))
				acc0 = vX0.MulAdd(vW, acc0)
				acc1 = vX1.MulAdd(vW, acc1)
				acc2 = vX2.MulAdd(vW, acc2)
				acc3 = vX3.MulAdd(vW, acc3)
			}
			sum0 := acc0.ReduceSum()
			sum1 := acc1.ReduceSum()
			sum2 := acc2.ReduceSum()
			sum3 := acc3.ReduceSum()
			for ; p < inFeatures; p++ {
				sum0 += x[xRow0+p].Float32() * wQKV[wRow+p].Float32()
				sum1 += x[xRow1+p].Float32() * wQKV[wRow+p].Float32()
				sum2 += x[xRow2+p].Float32() * wQKV[wRow+p].Float32()
				sum3 += x[xRow3+p].Float32() * wQKV[wRow+p].Float32()
			}
			if j < qDim {
				if biasQ != nil {
					b := biasQ[j]
					sum0 += b.Float32()
					sum1 += b.Float32()
					sum2 += b.Float32()
					sum3 += b.Float32()
				}
				q[i*qDim+j] = hwy.Float32ToFloat16(sum0)
				q[(i+1)*qDim+j] = hwy.Float32ToFloat16(sum1)
				q[(i+2)*qDim+j] = hwy.Float32ToFloat16(sum2)
				q[(i+3)*qDim+j] = hwy.Float32ToFloat16(sum3)
			} else if j < qDim+kvDim {
				kj := j - qDim
				if biasK != nil {
					b := biasK[kj]
					sum0 += b.Float32()
					sum1 += b.Float32()
					sum2 += b.Float32()
					sum3 += b.Float32()
				}
				k[i*kvDim+kj] = hwy.Float32ToFloat16(sum0)
				k[(i+1)*kvDim+kj] = hwy.Float32ToFloat16(sum1)
				k[(i+2)*kvDim+kj] = hwy.Float32ToFloat16(sum2)
				k[(i+3)*kvDim+kj] = hwy.Float32ToFloat16(sum3)
			} else {
				vj := j - qDim - kvDim
				if biasV != nil {
					b := biasV[vj]
					sum0 += b.Float32()
					sum1 += b.Float32()
					sum2 += b.Float32()
					sum3 += b.Float32()
				}
				v[i*kvDim+vj] = hwy.Float32ToFloat16(sum0)
				v[(i+1)*kvDim+vj] = hwy.Float32ToFloat16(sum1)
				v[(i+2)*kvDim+vj] = hwy.Float32ToFloat16(sum2)
				v[(i+3)*kvDim+vj] = hwy.Float32ToFloat16(sum3)
			}
		}
	}
	for ; i < batchSize; i++ {
		xRow := i * inFeatures
		for j := range totalOut {
			wRow := j * inFeatures
			acc := asm.ZeroFloat16x8AVX2()
			var p int
			for p = 0; p+lanes <= inFeatures; p += lanes {
				vX := asm.LoadFloat16x8AVX2Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(x[xRow+p:]))), len(x[xRow+p:])))
				vW := asm.LoadFloat16x8AVX2Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(wQKV[wRow+p:]))), len(wQKV[wRow+p:])))
				acc = vX.MulAdd(vW, acc)
			}
			sum := acc.ReduceSum()
			for ; p < inFeatures; p++ {
				sum += x[xRow+p].Float32() * wQKV[wRow+p].Float32()
			}
			if j < qDim {
				if biasQ != nil {
					sum += biasQ[j].Float32()
				}
				q[i*qDim+j] = hwy.Float32ToFloat16(sum)
			} else if j < qDim+kvDim {
				kj := j - qDim
				if biasK != nil {
					sum += biasK[kj].Float32()
				}
				k[i*kvDim+kj] = hwy.Float32ToFloat16(sum)
			} else {
				vj := j - qDim - kvDim
				if biasV != nil {
					sum += biasV[vj].Float32()
				}
				v[i*kvDim+vj] = hwy.Float32ToFloat16(sum)
			}
		}
	}
}

func BaseQKVDense_avx2_BFloat16(x []hwy.BFloat16, wQKV []hwy.BFloat16, biasQ []hwy.BFloat16, biasK []hwy.BFloat16, biasV []hwy.BFloat16, q []hwy.BFloat16, k []hwy.BFloat16, v []hwy.BFloat16, batchSize int, inFeatures int, qDim int, kvDim int) {
	totalOut := qDim + 2*kvDim
	if len(x) < batchSize*inFeatures {
		panic("qkvdense: x slice too short")
	}
	if len(wQKV) < totalOut*inFeatures {
		panic("qkvdense: wQKV slice too short")
	}
	if len(q) < batchSize*qDim {
		panic("qkvdense: q slice too short")
	}
	if len(k) < batchSize*kvDim {
		panic("qkvdense: k slice too short")
	}
	if len(v) < batchSize*kvDim {
		panic("qkvdense: v slice too short")
	}
	lanes := 8
	var i int
	for i = 0; i+3 < batchSize; i += 4 {
		xRow0 := i * inFeatures
		xRow1 := (i + 1) * inFeatures
		xRow2 := (i + 2) * inFeatures
		xRow3 := (i + 3) * inFeatures
		for j := range totalOut {
			wRow := j * inFeatures
			acc0 := asm.ZeroBFloat16x8AVX2()
			acc1 := asm.ZeroBFloat16x8AVX2()
			acc2 := asm.ZeroBFloat16x8AVX2()
			acc3 := asm.ZeroBFloat16x8AVX2()
			var p int
			for p = 0; p+lanes <= inFeatures; p += lanes {
				vW := asm.LoadBFloat16x8AVX2Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(wQKV[wRow+p:]))), len(wQKV[wRow+p:])))
				vX0 := asm.LoadBFloat16x8AVX2Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(x[xRow0+p:]))), len(x[xRow0+p:])))
				vX1 := asm.LoadBFloat16x8AVX2Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(x[xRow1+p:]))), len(x[xRow1+p:])))
				vX2 := asm.LoadBFloat16x8AVX2Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(x[xRow2+p:]))), len(x[xRow2+p:])))
				vX3 := asm.LoadBFloat16x8AVX2Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(x[xRow3+p:]))), len(x[xRow3+p:])))
				acc0 = vX0.MulAdd(vW, acc0)
				acc1 = vX1.MulAdd(vW, acc1)
				acc2 = vX2.MulAdd(vW, acc2)
				acc3 = vX3.MulAdd(vW, acc3)
			}
			sum0 := acc0.ReduceSum()
			sum1 := acc1.ReduceSum()
			sum2 := acc2.ReduceSum()
			sum3 := acc3.ReduceSum()
			for ; p < inFeatures; p++ {
				sum0 += x[xRow0+p].Float32() * wQKV[wRow+p].Float32()
				sum1 += x[xRow1+p].Float32() * wQKV[wRow+p].Float32()
				sum2 += x[xRow2+p].Float32() * wQKV[wRow+p].Float32()
				sum3 += x[xRow3+p].Float32() * wQKV[wRow+p].Float32()
			}
			if j < qDim {
				if biasQ != nil {
					b := biasQ[j]
					sum0 += b.Float32()
					sum1 += b.Float32()
					sum2 += b.Float32()
					sum3 += b.Float32()
				}
				q[i*qDim+j] = hwy.Float32ToBFloat16(sum0)
				q[(i+1)*qDim+j] = hwy.Float32ToBFloat16(sum1)
				q[(i+2)*qDim+j] = hwy.Float32ToBFloat16(sum2)
				q[(i+3)*qDim+j] = hwy.Float32ToBFloat16(sum3)
			} else if j < qDim+kvDim {
				kj := j - qDim
				if biasK != nil {
					b := biasK[kj]
					sum0 += b.Float32()
					sum1 += b.Float32()
					sum2 += b.Float32()
					sum3 += b.Float32()
				}
				k[i*kvDim+kj] = hwy.Float32ToBFloat16(sum0)
				k[(i+1)*kvDim+kj] = hwy.Float32ToBFloat16(sum1)
				k[(i+2)*kvDim+kj] = hwy.Float32ToBFloat16(sum2)
				k[(i+3)*kvDim+kj] = hwy.Float32ToBFloat16(sum3)
			} else {
				vj := j - qDim - kvDim
				if biasV != nil {
					b := biasV[vj]
					sum0 += b.Float32()
					sum1 += b.Float32()
					sum2 += b.Float32()
					sum3 += b.Float32()
				}
				v[i*kvDim+vj] = hwy.Float32ToBFloat16(sum0)
				v[(i+1)*kvDim+vj] = hwy.Float32ToBFloat16(sum1)
				v[(i+2)*kvDim+vj] = hwy.Float32ToBFloat16(sum2)
				v[(i+3)*kvDim+vj] = hwy.Float32ToBFloat16(sum3)
			}
		}
	}
	for ; i < batchSize; i++ {
		xRow := i * inFeatures
		for j := range totalOut {
			wRow := j * inFeatures
			acc := asm.ZeroBFloat16x8AVX2()
			var p int
			for p = 0; p+lanes <= inFeatures; p += lanes {
				vX := asm.LoadBFloat16x8AVX2Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(x[xRow+p:]))), len(x[xRow+p:])))
				vW := asm.LoadBFloat16x8AVX2Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(wQKV[wRow+p:]))), len(wQKV[wRow+p:])))
				acc = vX.MulAdd(vW, acc)
			}
			sum := acc.ReduceSum()
			for ; p < inFeatures; p++ {
				sum += x[xRow+p].Float32() * wQKV[wRow+p].Float32()
			}
			if j < qDim {
				if biasQ != nil {
					sum += biasQ[j].Float32()
				}
				q[i*qDim+j] = hwy.Float32ToBFloat16(sum)
			} else if j < qDim+kvDim {
				kj := j - qDim
				if biasK != nil {
					sum += biasK[kj].Float32()
				}
				k[i*kvDim+kj] = hwy.Float32ToBFloat16(sum)
			} else {
				vj := j - qDim - kvDim
				if biasV != nil {
					sum += biasV[vj].Float32()
				}
				v[i*kvDim+vj] = hwy.Float32ToBFloat16(sum)
			}
		}
	}
}

func BaseQKVDense_avx2(x []float32, wQKV []float32, biasQ []float32, biasK []float32, biasV []float32, q []float32, k []float32, v []float32, batchSize int, inFeatures int, qDim int, kvDim int) {
	totalOut := qDim + 2*kvDim
	if len(x) < batchSize*inFeatures {
		panic("qkvdense: x slice too short")
	}
	if len(wQKV) < totalOut*inFeatures {
		panic("qkvdense: wQKV slice too short")
	}
	if len(q) < batchSize*qDim {
		panic("qkvdense: q slice too short")
	}
	if len(k) < batchSize*kvDim {
		panic("qkvdense: k slice too short")
	}
	if len(v) < batchSize*kvDim {
		panic("qkvdense: v slice too short")
	}
	lanes := 8
	var i int
	for i = 0; i+3 < batchSize; i += 4 {
		xRow0 := i * inFeatures
		xRow1 := (i + 1) * inFeatures
		xRow2 := (i + 2) * inFeatures
		xRow3 := (i + 3) * inFeatures
		for j := range totalOut {
			wRow := j * inFeatures
			acc0 := archsimd.BroadcastFloat32x8(0)
			acc1 := archsimd.BroadcastFloat32x8(0)
			acc2 := archsimd.BroadcastFloat32x8(0)
			acc3 := archsimd.BroadcastFloat32x8(0)
			var p int
			for p = 0; p+lanes <= inFeatures; p += lanes {
				vW := archsimd.LoadFloat32x8Slice(wQKV[wRow+p:])
				vX0 := archsimd.LoadFloat32x8Slice(x[xRow0+p:])
				vX1 := archsimd.LoadFloat32x8Slice(x[xRow1+p:])
				vX2 := archsimd.LoadFloat32x8Slice(x[xRow2+p:])
				vX3 := archsimd.LoadFloat32x8Slice(x[xRow3+p:])
				acc0 = vX0.MulAdd(vW, acc0)
				acc1 = vX1.MulAdd(vW, acc1)
				acc2 = vX2.MulAdd(vW, acc2)
				acc3 = vX3.MulAdd(vW, acc3)
			}
			sum0 := hwy.ReduceSum_AVX2_F32x8(acc0)
			sum1 := hwy.ReduceSum_AVX2_F32x8(acc1)
			sum2 := hwy.ReduceSum_AVX2_F32x8(acc2)
			sum3 := hwy.ReduceSum_AVX2_F32x8(acc3)
			for ; p < inFeatures; p++ {
				sum0 += x[xRow0+p] * wQKV[wRow+p]
				sum1 += x[xRow1+p] * wQKV[wRow+p]
				sum2 += x[xRow2+p] * wQKV[wRow+p]
				sum3 += x[xRow3+p] * wQKV[wRow+p]
			}
			if j < qDim {
				if biasQ != nil {
					b := biasQ[j]
					sum0 += b
					sum1 += b
					sum2 += b
					sum3 += b
				}
				q[i*qDim+j] = sum0
				q[(i+1)*qDim+j] = sum1
				q[(i+2)*qDim+j] = sum2
				q[(i+3)*qDim+j] = sum3
			} else if j < qDim+kvDim {
				kj := j - qDim
				if biasK != nil {
					b := biasK[kj]
					sum0 += b
					sum1 += b
					sum2 += b
					sum3 += b
				}
				k[i*kvDim+kj] = sum0
				k[(i+1)*kvDim+kj] = sum1
				k[(i+2)*kvDim+kj] = sum2
				k[(i+3)*kvDim+kj] = sum3
			} else {
				vj := j - qDim - kvDim
				if biasV != nil {
					b := biasV[vj]
					sum0 += b
					sum1 += b
					sum2 += b
					sum3 += b
				}
				v[i*kvDim+vj] = sum0
				v[(i+1)*kvDim+vj] = sum1
				v[(i+2)*kvDim+vj] = sum2
				v[(i+3)*kvDim+vj] = sum3
			}
		}
	}
	for ; i < batchSize; i++ {
		xRow := i * inFeatures
		for j := range totalOut {
			wRow := j * inFeatures
			acc := archsimd.BroadcastFloat32x8(0)
			var p int
			for p = 0; p+lanes <= inFeatures; p += lanes {
				vX := archsimd.LoadFloat32x8Slice(x[xRow+p:])
				vW := archsimd.LoadFloat32x8Slice(wQKV[wRow+p:])
				acc = vX.MulAdd(vW, acc)
			}
			sum := hwy.ReduceSum_AVX2_F32x8(acc)
			for ; p < inFeatures; p++ {
				sum += x[xRow+p] * wQKV[wRow+p]
			}
			if j < qDim {
				if biasQ != nil {
					sum += biasQ[j]
				}
				q[i*qDim+j] = sum
			} else if j < qDim+kvDim {
				kj := j - qDim
				if biasK != nil {
					sum += biasK[kj]
				}
				k[i*kvDim+kj] = sum
			} else {
				vj := j - qDim - kvDim
				if biasV != nil {
					sum += biasV[vj]
				}
				v[i*kvDim+vj] = sum
			}
		}
	}
}

func BaseQKVDense_avx2_Float64(x []float64, wQKV []float64, biasQ []float64, biasK []float64, biasV []float64, q []float64, k []float64, v []float64, batchSize int, inFeatures int, qDim int, kvDim int) {
	totalOut := qDim + 2*kvDim
	if len(x) < batchSize*inFeatures {
		panic("qkvdense: x slice too short")
	}
	if len(wQKV) < totalOut*inFeatures {
		panic("qkvdense: wQKV slice too short")
	}
	if len(q) < batchSize*qDim {
		panic("qkvdense: q slice too short")
	}
	if len(k) < batchSize*kvDim {
		panic("qkvdense: k slice too short")
	}
	if len(v) < batchSize*kvDim {
		panic("qkvdense: v slice too short")
	}
	lanes := 4
	var i int
	for i = 0; i+3 < batchSize; i += 4 {
		xRow0 := i * inFeatures
		xRow1 := (i + 1) * inFeatures
		xRow2 := (i + 2) * inFeatures
		xRow3 := (i + 3) * inFeatures
		for j := range totalOut {
			wRow := j * inFeatures
			acc0 := archsimd.BroadcastFloat64x4(0)
			acc1 := archsimd.BroadcastFloat64x4(0)
			acc2 := archsimd.BroadcastFloat64x4(0)
			acc3 := archsimd.BroadcastFloat64x4(0)
			var p int
			for p = 0; p+lanes <= inFeatures; p += lanes {
				vW := archsimd.LoadFloat64x4Slice(wQKV[wRow+p:])
				vX0 := archsimd.LoadFloat64x4Slice(x[xRow0+p:])
				vX1 := archsimd.LoadFloat64x4Slice(x[xRow1+p:])
				vX2 := archsimd.LoadFloat64x4Slice(x[xRow2+p:])
				vX3 := archsimd.LoadFloat64x4Slice(x[xRow3+p:])
				acc0 = vX0.MulAdd(vW, acc0)
				acc1 = vX1.MulAdd(vW, acc1)
				acc2 = vX2.MulAdd(vW, acc2)
				acc3 = vX3.MulAdd(vW, acc3)
			}
			sum0 := hwy.ReduceSum_AVX2_F64x4(acc0)
			sum1 := hwy.ReduceSum_AVX2_F64x4(acc1)
			sum2 := hwy.ReduceSum_AVX2_F64x4(acc2)
			sum3 := hwy.ReduceSum_AVX2_F64x4(acc3)
			for ; p < inFeatures; p++ {
				sum0 += x[xRow0+p] * wQKV[wRow+p]
				sum1 += x[xRow1+p] * wQKV[wRow+p]
				sum2 += x[xRow2+p] * wQKV[wRow+p]
				sum3 += x[xRow3+p] * wQKV[wRow+p]
			}
			if j < qDim {
				if biasQ != nil {
					b := biasQ[j]
					sum0 += b
					sum1 += b
					sum2 += b
					sum3 += b
				}
				q[i*qDim+j] = sum0
				q[(i+1)*qDim+j] = sum1
				q[(i+2)*qDim+j] = sum2
				q[(i+3)*qDim+j] = sum3
			} else if j < qDim+kvDim {
				kj := j - qDim
				if biasK != nil {
					b := biasK[kj]
					sum0 += b
					sum1 += b
					sum2 += b
					sum3 += b
				}
				k[i*kvDim+kj] = sum0
				k[(i+1)*kvDim+kj] = sum1
				k[(i+2)*kvDim+kj] = sum2
				k[(i+3)*kvDim+kj] = sum3
			} else {
				vj := j - qDim - kvDim
				if biasV != nil {
					b := biasV[vj]
					sum0 += b
					sum1 += b
					sum2 += b
					sum3 += b
				}
				v[i*kvDim+vj] = sum0
				v[(i+1)*kvDim+vj] = sum1
				v[(i+2)*kvDim+vj] = sum2
				v[(i+3)*kvDim+vj] = sum3
			}
		}
	}
	for ; i < batchSize; i++ {
		xRow := i * inFeatures
		for j := range totalOut {
			wRow := j * inFeatures
			acc := archsimd.BroadcastFloat64x4(0)
			var p int
			for p = 0; p+lanes <= inFeatures; p += lanes {
				vX := archsimd.LoadFloat64x4Slice(x[xRow+p:])
				vW := archsimd.LoadFloat64x4Slice(wQKV[wRow+p:])
				acc = vX.MulAdd(vW, acc)
			}
			sum := hwy.ReduceSum_AVX2_F64x4(acc)
			for ; p < inFeatures; p++ {
				sum += x[xRow+p] * wQKV[wRow+p]
			}
			if j < qDim {
				if biasQ != nil {
					sum += biasQ[j]
				}
				q[i*qDim+j] = sum
			} else if j < qDim+kvDim {
				kj := j - qDim
				if biasK != nil {
					sum += biasK[kj]
				}
				k[i*kvDim+kj] = sum
			} else {
				vj := j - qDim - kvDim
				if biasV != nil {
					sum += biasV[vj]
				}
				v[i*kvDim+vj] = sum
			}
		}
	}
}
