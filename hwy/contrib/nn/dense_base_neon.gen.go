// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

//go:build arm64

package nn

import (
	"unsafe"

	"github.com/ajroetker/go-highway/hwy"
	"github.com/ajroetker/go-highway/hwy/asm"
)

func BaseDense_neon_Float16(x []hwy.Float16, weight []hwy.Float16, bias []hwy.Float16, output []hwy.Float16, batchSize int, inFeatures int, outFeatures int) {
	if len(x) < batchSize*inFeatures {
		panic("dense: x slice too short")
	}
	if len(weight) < outFeatures*inFeatures {
		panic("dense: weight slice too short")
	}
	if len(output) < batchSize*outFeatures {
		panic("dense: output slice too short")
	}
	if bias != nil && len(bias) < outFeatures {
		panic("dense: bias slice too short")
	}
	lanes := 8
	var i int
	for i = 0; i+3 < batchSize; i += 4 {
		xRow0 := i * inFeatures
		xRow1 := (i + 1) * inFeatures
		xRow2 := (i + 2) * inFeatures
		xRow3 := (i + 3) * inFeatures
		oRow0 := i * outFeatures
		oRow1 := (i + 1) * outFeatures
		oRow2 := (i + 2) * outFeatures
		oRow3 := (i + 3) * outFeatures
		for j := 0; j < outFeatures; j++ {
			wRow := j * inFeatures
			acc0 := asm.ZeroFloat16x8()
			acc1 := asm.ZeroFloat16x8()
			acc2 := asm.ZeroFloat16x8()
			acc3 := asm.ZeroFloat16x8()
			var p int
			for p = 0; p+lanes <= inFeatures; p += lanes {
				vW := asm.LoadFloat16x8Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(weight[wRow+p:]))), len(weight[wRow+p:])))
				vX0 := asm.LoadFloat16x8Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(x[xRow0+p:]))), len(x[xRow0+p:])))
				vX1 := asm.LoadFloat16x8Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(x[xRow1+p:]))), len(x[xRow1+p:])))
				vX2 := asm.LoadFloat16x8Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(x[xRow2+p:]))), len(x[xRow2+p:])))
				vX3 := asm.LoadFloat16x8Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(x[xRow3+p:]))), len(x[xRow3+p:])))
				vX0.MulAddAcc(vW, &acc0)
				vX1.MulAddAcc(vW, &acc1)
				vX2.MulAddAcc(vW, &acc2)
				vX3.MulAddAcc(vW, &acc3)
			}
			sum0 := acc0.ReduceSum()
			sum1 := acc1.ReduceSum()
			sum2 := acc2.ReduceSum()
			sum3 := acc3.ReduceSum()
			for ; p < inFeatures; p++ {
				sum0 += x[xRow0+p].Float32() * weight[wRow+p].Float32()
				sum1 += x[xRow1+p].Float32() * weight[wRow+p].Float32()
				sum2 += x[xRow2+p].Float32() * weight[wRow+p].Float32()
				sum3 += x[xRow3+p].Float32() * weight[wRow+p].Float32()
			}
			if bias != nil {
				b := bias[j]
				sum0 += b.Float32()
				sum1 += b.Float32()
				sum2 += b.Float32()
				sum3 += b.Float32()
			}
			output[oRow0+j] = hwy.Float32ToFloat16(sum0)
			output[oRow1+j] = hwy.Float32ToFloat16(sum1)
			output[oRow2+j] = hwy.Float32ToFloat16(sum2)
			output[oRow3+j] = hwy.Float32ToFloat16(sum3)
		}
	}
	for ; i < batchSize; i++ {
		xRow := i * inFeatures
		oRow := i * outFeatures
		for j := 0; j < outFeatures; j++ {
			wRow := j * inFeatures
			acc := asm.ZeroFloat16x8()
			var p int
			for p = 0; p+lanes <= inFeatures; p += lanes {
				vX := asm.LoadFloat16x8Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(x[xRow+p:]))), len(x[xRow+p:])))
				vW := asm.LoadFloat16x8Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(weight[wRow+p:]))), len(weight[wRow+p:])))
				vX.MulAddAcc(vW, &acc)
			}
			sum := acc.ReduceSum()
			for ; p < inFeatures; p++ {
				sum += x[xRow+p].Float32() * weight[wRow+p].Float32()
			}
			if bias != nil {
				sum += bias[j].Float32()
			}
			output[oRow+j] = hwy.Float32ToFloat16(sum)
		}
	}
}

func BaseDense_neon_BFloat16(x []hwy.BFloat16, weight []hwy.BFloat16, bias []hwy.BFloat16, output []hwy.BFloat16, batchSize int, inFeatures int, outFeatures int) {
	if len(x) < batchSize*inFeatures {
		panic("dense: x slice too short")
	}
	if len(weight) < outFeatures*inFeatures {
		panic("dense: weight slice too short")
	}
	if len(output) < batchSize*outFeatures {
		panic("dense: output slice too short")
	}
	if bias != nil && len(bias) < outFeatures {
		panic("dense: bias slice too short")
	}
	lanes := 8
	var i int
	for i = 0; i+3 < batchSize; i += 4 {
		xRow0 := i * inFeatures
		xRow1 := (i + 1) * inFeatures
		xRow2 := (i + 2) * inFeatures
		xRow3 := (i + 3) * inFeatures
		oRow0 := i * outFeatures
		oRow1 := (i + 1) * outFeatures
		oRow2 := (i + 2) * outFeatures
		oRow3 := (i + 3) * outFeatures
		for j := 0; j < outFeatures; j++ {
			wRow := j * inFeatures
			acc0 := asm.ZeroBFloat16x8()
			acc1 := asm.ZeroBFloat16x8()
			acc2 := asm.ZeroBFloat16x8()
			acc3 := asm.ZeroBFloat16x8()
			var p int
			for p = 0; p+lanes <= inFeatures; p += lanes {
				vW := asm.LoadBFloat16x8Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(weight[wRow+p:]))), len(weight[wRow+p:])))
				vX0 := asm.LoadBFloat16x8Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(x[xRow0+p:]))), len(x[xRow0+p:])))
				vX1 := asm.LoadBFloat16x8Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(x[xRow1+p:]))), len(x[xRow1+p:])))
				vX2 := asm.LoadBFloat16x8Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(x[xRow2+p:]))), len(x[xRow2+p:])))
				vX3 := asm.LoadBFloat16x8Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(x[xRow3+p:]))), len(x[xRow3+p:])))
				vX0.MulAddAcc(vW, &acc0)
				vX1.MulAddAcc(vW, &acc1)
				vX2.MulAddAcc(vW, &acc2)
				vX3.MulAddAcc(vW, &acc3)
			}
			sum0 := acc0.ReduceSum()
			sum1 := acc1.ReduceSum()
			sum2 := acc2.ReduceSum()
			sum3 := acc3.ReduceSum()
			for ; p < inFeatures; p++ {
				sum0 += x[xRow0+p].Float32() * weight[wRow+p].Float32()
				sum1 += x[xRow1+p].Float32() * weight[wRow+p].Float32()
				sum2 += x[xRow2+p].Float32() * weight[wRow+p].Float32()
				sum3 += x[xRow3+p].Float32() * weight[wRow+p].Float32()
			}
			if bias != nil {
				b := bias[j]
				sum0 += b.Float32()
				sum1 += b.Float32()
				sum2 += b.Float32()
				sum3 += b.Float32()
			}
			output[oRow0+j] = hwy.Float32ToBFloat16(sum0)
			output[oRow1+j] = hwy.Float32ToBFloat16(sum1)
			output[oRow2+j] = hwy.Float32ToBFloat16(sum2)
			output[oRow3+j] = hwy.Float32ToBFloat16(sum3)
		}
	}
	for ; i < batchSize; i++ {
		xRow := i * inFeatures
		oRow := i * outFeatures
		for j := 0; j < outFeatures; j++ {
			wRow := j * inFeatures
			acc := asm.ZeroBFloat16x8()
			var p int
			for p = 0; p+lanes <= inFeatures; p += lanes {
				vX := asm.LoadBFloat16x8Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(x[xRow+p:]))), len(x[xRow+p:])))
				vW := asm.LoadBFloat16x8Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(weight[wRow+p:]))), len(weight[wRow+p:])))
				vX.MulAddAcc(vW, &acc)
			}
			sum := acc.ReduceSum()
			for ; p < inFeatures; p++ {
				sum += x[xRow+p].Float32() * weight[wRow+p].Float32()
			}
			if bias != nil {
				sum += bias[j].Float32()
			}
			output[oRow+j] = hwy.Float32ToBFloat16(sum)
		}
	}
}

func BaseDense_neon(x []float32, weight []float32, bias []float32, output []float32, batchSize int, inFeatures int, outFeatures int) {
	if len(x) < batchSize*inFeatures {
		panic("dense: x slice too short")
	}
	if len(weight) < outFeatures*inFeatures {
		panic("dense: weight slice too short")
	}
	if len(output) < batchSize*outFeatures {
		panic("dense: output slice too short")
	}
	if bias != nil && len(bias) < outFeatures {
		panic("dense: bias slice too short")
	}
	lanes := 4
	var i int
	for i = 0; i+3 < batchSize; i += 4 {
		xRow0 := i * inFeatures
		xRow1 := (i + 1) * inFeatures
		xRow2 := (i + 2) * inFeatures
		xRow3 := (i + 3) * inFeatures
		oRow0 := i * outFeatures
		oRow1 := (i + 1) * outFeatures
		oRow2 := (i + 2) * outFeatures
		oRow3 := (i + 3) * outFeatures
		for j := 0; j < outFeatures; j++ {
			wRow := j * inFeatures
			acc0 := asm.ZeroFloat32x4()
			acc1 := asm.ZeroFloat32x4()
			acc2 := asm.ZeroFloat32x4()
			acc3 := asm.ZeroFloat32x4()
			var p int
			for p = 0; p+lanes <= inFeatures; p += lanes {
				vW := asm.LoadFloat32x4Slice(weight[wRow+p:])
				vX0 := asm.LoadFloat32x4Slice(x[xRow0+p:])
				vX1 := asm.LoadFloat32x4Slice(x[xRow1+p:])
				vX2 := asm.LoadFloat32x4Slice(x[xRow2+p:])
				vX3 := asm.LoadFloat32x4Slice(x[xRow3+p:])
				vX0.MulAddAcc(vW, &acc0)
				vX1.MulAddAcc(vW, &acc1)
				vX2.MulAddAcc(vW, &acc2)
				vX3.MulAddAcc(vW, &acc3)
			}
			sum0 := acc0.ReduceSum()
			sum1 := acc1.ReduceSum()
			sum2 := acc2.ReduceSum()
			sum3 := acc3.ReduceSum()
			for ; p < inFeatures; p++ {
				sum0 += x[xRow0+p] * weight[wRow+p]
				sum1 += x[xRow1+p] * weight[wRow+p]
				sum2 += x[xRow2+p] * weight[wRow+p]
				sum3 += x[xRow3+p] * weight[wRow+p]
			}
			if bias != nil {
				b := bias[j]
				sum0 += b
				sum1 += b
				sum2 += b
				sum3 += b
			}
			output[oRow0+j] = sum0
			output[oRow1+j] = sum1
			output[oRow2+j] = sum2
			output[oRow3+j] = sum3
		}
	}
	for ; i < batchSize; i++ {
		xRow := i * inFeatures
		oRow := i * outFeatures
		for j := 0; j < outFeatures; j++ {
			wRow := j * inFeatures
			acc := asm.ZeroFloat32x4()
			var p int
			for p = 0; p+lanes <= inFeatures; p += lanes {
				vX := asm.LoadFloat32x4Slice(x[xRow+p:])
				vW := asm.LoadFloat32x4Slice(weight[wRow+p:])
				vX.MulAddAcc(vW, &acc)
			}
			sum := acc.ReduceSum()
			for ; p < inFeatures; p++ {
				sum += x[xRow+p] * weight[wRow+p]
			}
			if bias != nil {
				sum += bias[j]
			}
			output[oRow+j] = sum
		}
	}
}

func BaseDense_neon_Float64(x []float64, weight []float64, bias []float64, output []float64, batchSize int, inFeatures int, outFeatures int) {
	if len(x) < batchSize*inFeatures {
		panic("dense: x slice too short")
	}
	if len(weight) < outFeatures*inFeatures {
		panic("dense: weight slice too short")
	}
	if len(output) < batchSize*outFeatures {
		panic("dense: output slice too short")
	}
	if bias != nil && len(bias) < outFeatures {
		panic("dense: bias slice too short")
	}
	lanes := 2
	var i int
	for i = 0; i+3 < batchSize; i += 4 {
		xRow0 := i * inFeatures
		xRow1 := (i + 1) * inFeatures
		xRow2 := (i + 2) * inFeatures
		xRow3 := (i + 3) * inFeatures
		oRow0 := i * outFeatures
		oRow1 := (i + 1) * outFeatures
		oRow2 := (i + 2) * outFeatures
		oRow3 := (i + 3) * outFeatures
		for j := 0; j < outFeatures; j++ {
			wRow := j * inFeatures
			acc0 := asm.ZeroFloat64x2()
			acc1 := asm.ZeroFloat64x2()
			acc2 := asm.ZeroFloat64x2()
			acc3 := asm.ZeroFloat64x2()
			var p int
			for p = 0; p+lanes <= inFeatures; p += lanes {
				vW := asm.LoadFloat64x2Slice(weight[wRow+p:])
				vX0 := asm.LoadFloat64x2Slice(x[xRow0+p:])
				vX1 := asm.LoadFloat64x2Slice(x[xRow1+p:])
				vX2 := asm.LoadFloat64x2Slice(x[xRow2+p:])
				vX3 := asm.LoadFloat64x2Slice(x[xRow3+p:])
				vX0.MulAddAcc(vW, &acc0)
				vX1.MulAddAcc(vW, &acc1)
				vX2.MulAddAcc(vW, &acc2)
				vX3.MulAddAcc(vW, &acc3)
			}
			sum0 := acc0.ReduceSum()
			sum1 := acc1.ReduceSum()
			sum2 := acc2.ReduceSum()
			sum3 := acc3.ReduceSum()
			for ; p < inFeatures; p++ {
				sum0 += x[xRow0+p] * weight[wRow+p]
				sum1 += x[xRow1+p] * weight[wRow+p]
				sum2 += x[xRow2+p] * weight[wRow+p]
				sum3 += x[xRow3+p] * weight[wRow+p]
			}
			if bias != nil {
				b := bias[j]
				sum0 += b
				sum1 += b
				sum2 += b
				sum3 += b
			}
			output[oRow0+j] = sum0
			output[oRow1+j] = sum1
			output[oRow2+j] = sum2
			output[oRow3+j] = sum3
		}
	}
	for ; i < batchSize; i++ {
		xRow := i * inFeatures
		oRow := i * outFeatures
		for j := 0; j < outFeatures; j++ {
			wRow := j * inFeatures
			acc := asm.ZeroFloat64x2()
			var p int
			for p = 0; p+lanes <= inFeatures; p += lanes {
				vX := asm.LoadFloat64x2Slice(x[xRow+p:])
				vW := asm.LoadFloat64x2Slice(weight[wRow+p:])
				vX.MulAddAcc(vW, &acc)
			}
			sum := acc.ReduceSum()
			for ; p < inFeatures; p++ {
				sum += x[xRow+p] * weight[wRow+p]
			}
			if bias != nil {
				sum += bias[j]
			}
			output[oRow+j] = sum
		}
	}
}
