// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

//go:build arm64

package nn

import (
	stdmath "math"

	"github.com/ajroetker/go-highway/hwy"
	"github.com/ajroetker/go-highway/hwy/contrib/algo"
	"github.com/ajroetker/go-highway/hwy/contrib/math"
)

func BaseSoftmax_neon_Float16(input []hwy.Float16, output []hwy.Float16) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	maxVal := input[0]
	for i := 1; i < size; i++ {
		if input[i].Float32() > maxVal.Float32() {
			maxVal = input[i]
		}
	}
	shifted := make([]hwy.Float16, size)
	for i := range size {
		shifted[i] = hwy.Float32ToFloat16(input[i].Float32() - maxVal.Float32())
	}
	algo.BaseApply_neon_Float16(shifted, output, math.BaseExpVec_neon_Float16)
	var expSum float32
	for i := range size {
		expSum += output[i].Float32()
	}
	invSum := float32(1.0) / expSum
	for i := range size {
		output[i] = hwy.Float32ToFloat16(output[i].Float32() * invSum)
	}
}

func BaseSoftmax_neon_BFloat16(input []hwy.BFloat16, output []hwy.BFloat16) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	maxVal := input[0]
	for i := 1; i < size; i++ {
		if input[i].Float32() > maxVal.Float32() {
			maxVal = input[i]
		}
	}
	shifted := make([]hwy.BFloat16, size)
	for i := range size {
		shifted[i] = hwy.Float32ToBFloat16(input[i].Float32() - maxVal.Float32())
	}
	algo.BaseApply_neon_BFloat16(shifted, output, math.BaseExpVec_neon_BFloat16)
	var expSum float32
	for i := range size {
		expSum += output[i].Float32()
	}
	invSum := float32(1.0) / expSum
	for i := range size {
		output[i] = hwy.Float32ToBFloat16(output[i].Float32() * invSum)
	}
}

func BaseSoftmax_neon(input []float32, output []float32) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	maxVal := input[0]
	for i := 1; i < size; i++ {
		if input[i] > maxVal {
			maxVal = input[i]
		}
	}
	shifted := make([]float32, size)
	for i := range size {
		shifted[i] = input[i] - maxVal
	}
	algo.BaseApply_neon(shifted, output, math.BaseExpVec_neon)
	var expSum float32
	for i := range size {
		expSum += output[i]
	}
	invSum := float32(1.0) / expSum
	for i := range size {
		output[i] = output[i] * invSum
	}
}

func BaseSoftmax_neon_Float64(input []float64, output []float64) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	maxVal := input[0]
	for i := 1; i < size; i++ {
		if input[i] > maxVal {
			maxVal = input[i]
		}
	}
	shifted := make([]float64, size)
	for i := range size {
		shifted[i] = input[i] - maxVal
	}
	algo.BaseApply_neon_Float64(shifted, output, math.BaseExpVec_neon_Float64)
	var expSum float64
	for i := range size {
		expSum += output[i]
	}
	invSum := float64(1.0) / expSum
	for i := range size {
		output[i] = output[i] * invSum
	}
}

func BaseSoftmaxInPlace_neon_Float16(x []hwy.Float16) {
	BaseSoftmax_neon_Float16(x, x)
}

func BaseSoftmaxInPlace_neon_BFloat16(x []hwy.BFloat16) {
	BaseSoftmax_neon_BFloat16(x, x)
}

func BaseSoftmaxInPlace_neon(x []float32) {
	BaseSoftmax_neon(x, x)
}

func BaseSoftmaxInPlace_neon_Float64(x []float64) {
	BaseSoftmax_neon_Float64(x, x)
}

func BaseLogSoftmax_neon_Float16(input []hwy.Float16, output []hwy.Float16) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	maxVal := input[0]
	for i := 1; i < size; i++ {
		if input[i].Float32() > maxVal.Float32() {
			maxVal = input[i]
		}
	}
	shifted := make([]hwy.Float16, size)
	expVals := make([]hwy.Float16, size)
	for i := range size {
		shifted[i] = hwy.Float32ToFloat16(input[i].Float32() - maxVal.Float32())
	}
	algo.BaseApply_neon_Float16(shifted, expVals, math.BaseExpVec_neon_Float16)
	var expSum float32
	for i := range size {
		expSum += expVals[i].Float32()
	}
	logSumExp := float32(stdmath.Log(float64(expSum)))
	for i := range size {
		output[i] = hwy.Float32ToFloat16(shifted[i].Float32() - logSumExp)
	}
}

func BaseLogSoftmax_neon_BFloat16(input []hwy.BFloat16, output []hwy.BFloat16) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	maxVal := input[0]
	for i := 1; i < size; i++ {
		if input[i].Float32() > maxVal.Float32() {
			maxVal = input[i]
		}
	}
	shifted := make([]hwy.BFloat16, size)
	expVals := make([]hwy.BFloat16, size)
	for i := range size {
		shifted[i] = hwy.Float32ToBFloat16(input[i].Float32() - maxVal.Float32())
	}
	algo.BaseApply_neon_BFloat16(shifted, expVals, math.BaseExpVec_neon_BFloat16)
	var expSum float32
	for i := range size {
		expSum += expVals[i].Float32()
	}
	logSumExp := float32(stdmath.Log(float64(expSum)))
	for i := range size {
		output[i] = hwy.Float32ToBFloat16(shifted[i].Float32() - logSumExp)
	}
}

func BaseLogSoftmax_neon(input []float32, output []float32) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	maxVal := input[0]
	for i := 1; i < size; i++ {
		if input[i] > maxVal {
			maxVal = input[i]
		}
	}
	shifted := make([]float32, size)
	expVals := make([]float32, size)
	for i := range size {
		shifted[i] = input[i] - maxVal
	}
	algo.BaseApply_neon(shifted, expVals, math.BaseExpVec_neon)
	var expSum float32
	for i := range size {
		expSum += expVals[i]
	}
	logSumExp := float32(stdmath.Log(float64(expSum)))
	for i := range size {
		output[i] = shifted[i] - logSumExp
	}
}

func BaseLogSoftmax_neon_Float64(input []float64, output []float64) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	maxVal := input[0]
	for i := 1; i < size; i++ {
		if input[i] > maxVal {
			maxVal = input[i]
		}
	}
	shifted := make([]float64, size)
	expVals := make([]float64, size)
	for i := range size {
		shifted[i] = input[i] - maxVal
	}
	algo.BaseApply_neon_Float64(shifted, expVals, math.BaseExpVec_neon_Float64)
	var expSum float64
	for i := range size {
		expSum += expVals[i]
	}
	logSumExp := float64(stdmath.Log(float64(expSum)))
	for i := range size {
		output[i] = shifted[i] - logSumExp
	}
}

func BaseLogSoftmaxInPlace_neon_Float16(x []hwy.Float16) {
	BaseLogSoftmax_neon_Float16(x, x)
}

func BaseLogSoftmaxInPlace_neon_BFloat16(x []hwy.BFloat16) {
	BaseLogSoftmax_neon_BFloat16(x, x)
}

func BaseLogSoftmaxInPlace_neon(x []float32) {
	BaseLogSoftmax_neon(x, x)
}

func BaseLogSoftmaxInPlace_neon_Float64(x []float64) {
	BaseLogSoftmax_neon_Float64(x, x)
}

func BaseSoftmaxScalar_neon_Float16(input []hwy.Float16, output []hwy.Float16) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	maxVal := input[0]
	for i := 1; i < size; i++ {
		if input[i].Float32() > maxVal.Float32() {
			maxVal = input[i]
		}
	}
	var expSum float32
	for i := range size {
		output[i] = hwy.Float32ToFloat16(float32(stdmath.Exp(float64(input[i] - maxVal))))
		expSum += output[i].Float32()
	}
	invSum := float32(1.0) / expSum
	for i := range size {
		output[i] = hwy.Float32ToFloat16(output[i].Float32() * invSum)
	}
}

func BaseSoftmaxScalar_neon_BFloat16(input []hwy.BFloat16, output []hwy.BFloat16) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	maxVal := input[0]
	for i := 1; i < size; i++ {
		if input[i].Float32() > maxVal.Float32() {
			maxVal = input[i]
		}
	}
	var expSum float32
	for i := range size {
		output[i] = hwy.Float32ToBFloat16(float32(stdmath.Exp(float64(input[i] - maxVal))))
		expSum += output[i].Float32()
	}
	invSum := float32(1.0) / expSum
	for i := range size {
		output[i] = hwy.Float32ToBFloat16(output[i].Float32() * invSum)
	}
}

func BaseSoftmaxScalar_neon(input []float32, output []float32) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	maxVal := input[0]
	for i := 1; i < size; i++ {
		if input[i] > maxVal {
			maxVal = input[i]
		}
	}
	var expSum float32
	for i := range size {
		output[i] = float32(stdmath.Exp(float64(input[i] - maxVal)))
		expSum += output[i]
	}
	invSum := float32(1.0) / expSum
	for i := range size {
		output[i] = output[i] * invSum
	}
}

func BaseSoftmaxScalar_neon_Float64(input []float64, output []float64) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	maxVal := input[0]
	for i := 1; i < size; i++ {
		if input[i] > maxVal {
			maxVal = input[i]
		}
	}
	var expSum float64
	for i := range size {
		output[i] = float64(stdmath.Exp(float64(input[i] - maxVal)))
		expSum += output[i]
	}
	invSum := float64(1.0) / expSum
	for i := range size {
		output[i] = output[i] * invSum
	}
}

func BaseSoftmaxWithTemperature_neon_Float16(input []hwy.Float16, output []hwy.Float16, temperature hwy.Float16) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	maxVal := input[0]
	for i := 1; i < size; i++ {
		if input[i].Float32() > maxVal.Float32() {
			maxVal = input[i]
		}
	}
	invTemp := float32(1.0) / temperature.Float32()
	shifted := make([]hwy.Float16, size)
	for i := range size {
		shifted[i] = hwy.Float32ToFloat16((input[i].Float32() - maxVal.Float32()) * invTemp)
	}
	algo.BaseApply_neon_Float16(shifted, output, math.BaseExpVec_neon_Float16)
	var expSum float32
	for i := range size {
		expSum += output[i].Float32()
	}
	invSum := float32(1.0) / expSum
	for i := range size {
		output[i] = hwy.Float32ToFloat16(output[i].Float32() * invSum)
	}
}

func BaseSoftmaxWithTemperature_neon_BFloat16(input []hwy.BFloat16, output []hwy.BFloat16, temperature hwy.BFloat16) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	maxVal := input[0]
	for i := 1; i < size; i++ {
		if input[i].Float32() > maxVal.Float32() {
			maxVal = input[i]
		}
	}
	invTemp := float32(1.0) / temperature.Float32()
	shifted := make([]hwy.BFloat16, size)
	for i := range size {
		shifted[i] = hwy.Float32ToBFloat16((input[i].Float32() - maxVal.Float32()) * invTemp)
	}
	algo.BaseApply_neon_BFloat16(shifted, output, math.BaseExpVec_neon_BFloat16)
	var expSum float32
	for i := range size {
		expSum += output[i].Float32()
	}
	invSum := float32(1.0) / expSum
	for i := range size {
		output[i] = hwy.Float32ToBFloat16(output[i].Float32() * invSum)
	}
}

func BaseSoftmaxWithTemperature_neon(input []float32, output []float32, temperature float32) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	maxVal := input[0]
	for i := 1; i < size; i++ {
		if input[i] > maxVal {
			maxVal = input[i]
		}
	}
	invTemp := float32(1.0) / temperature
	shifted := make([]float32, size)
	for i := range size {
		shifted[i] = (input[i] - maxVal) * invTemp
	}
	algo.BaseApply_neon(shifted, output, math.BaseExpVec_neon)
	var expSum float32
	for i := range size {
		expSum += output[i]
	}
	invSum := float32(1.0) / expSum
	for i := range size {
		output[i] = output[i] * invSum
	}
}

func BaseSoftmaxWithTemperature_neon_Float64(input []float64, output []float64, temperature float64) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	maxVal := input[0]
	for i := 1; i < size; i++ {
		if input[i] > maxVal {
			maxVal = input[i]
		}
	}
	invTemp := float64(1.0) / temperature
	shifted := make([]float64, size)
	for i := range size {
		shifted[i] = (input[i] - maxVal) * invTemp
	}
	algo.BaseApply_neon_Float64(shifted, output, math.BaseExpVec_neon_Float64)
	var expSum float64
	for i := range size {
		expSum += output[i]
	}
	invSum := float64(1.0) / expSum
	for i := range size {
		output[i] = output[i] * invSum
	}
}
