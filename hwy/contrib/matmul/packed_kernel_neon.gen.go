// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

//go:build arm64

package matmul

import (
	"github.com/ajroetker/go-highway/hwy"
	"github.com/ajroetker/go-highway/hwy/asm"
)

func BasePackedMicroKernel_neon_Float16(packedA []hwy.Float16, packedB []hwy.Float16, c []hwy.Float16, n int, ir int, jr int, kc int, mr int, nr int) {
	lanes := 8
	if mr != 4 || nr != lanes*2 {
		basePackedMicroKernelGeneral(packedA, packedB, c, n, ir, jr, kc, mr, nr)
		return
	}
	acc00 := hwy.Zero[hwy.Float16]()
	acc01 := hwy.Zero[hwy.Float16]()
	acc10 := hwy.Zero[hwy.Float16]()
	acc11 := hwy.Zero[hwy.Float16]()
	acc20 := hwy.Zero[hwy.Float16]()
	acc21 := hwy.Zero[hwy.Float16]()
	acc30 := hwy.Zero[hwy.Float16]()
	acc31 := hwy.Zero[hwy.Float16]()
	aIdx := 0
	bIdx := 0
	for p := 0; p < kc; p++ {
		a0 := packedA[aIdx]
		a1 := packedA[aIdx+1]
		a2 := packedA[aIdx+2]
		a3 := packedA[aIdx+3]
		aIdx += 4
		vA0 := hwy.Set(a0)
		vA1 := hwy.Set(a1)
		vA2 := hwy.Set(a2)
		vA3 := hwy.Set(a3)
		vB0 := hwy.Load(packedB[bIdx:])
		vB1 := hwy.Load(packedB[bIdx+lanes:])
		bIdx += nr
		acc00 = hwy.FMAF16(vA0, vB0, acc00)
		acc01 = hwy.FMAF16(vA0, vB1, acc01)
		acc10 = hwy.FMAF16(vA1, vB0, acc10)
		acc11 = hwy.FMAF16(vA1, vB1, acc11)
		acc20 = hwy.FMAF16(vA2, vB0, acc20)
		acc21 = hwy.FMAF16(vA2, vB1, acc21)
		acc30 = hwy.FMAF16(vA3, vB0, acc30)
		acc31 = hwy.FMAF16(vA3, vB1, acc31)
	}
	cRow0 := ir * n
	cRow1 := (ir + 1) * n
	cRow2 := (ir + 2) * n
	cRow3 := (ir + 3) * n
	vC := hwy.Load(c[cRow0+jr:])
	vC = hwy.AddF16(vC, acc00)
	hwy.Store(vC, c[cRow0+jr:])
	vC = hwy.Load(c[cRow0+jr+lanes:])
	vC = hwy.AddF16(vC, acc01)
	hwy.Store(vC, c[cRow0+jr+lanes:])
	vC = hwy.Load(c[cRow1+jr:])
	vC = hwy.AddF16(vC, acc10)
	hwy.Store(vC, c[cRow1+jr:])
	vC = hwy.Load(c[cRow1+jr+lanes:])
	vC = hwy.AddF16(vC, acc11)
	hwy.Store(vC, c[cRow1+jr+lanes:])
	vC = hwy.Load(c[cRow2+jr:])
	vC = hwy.AddF16(vC, acc20)
	hwy.Store(vC, c[cRow2+jr:])
	vC = hwy.Load(c[cRow2+jr+lanes:])
	vC = hwy.AddF16(vC, acc21)
	hwy.Store(vC, c[cRow2+jr+lanes:])
	vC = hwy.Load(c[cRow3+jr:])
	vC = hwy.AddF16(vC, acc30)
	hwy.Store(vC, c[cRow3+jr:])
	vC = hwy.Load(c[cRow3+jr+lanes:])
	vC = hwy.AddF16(vC, acc31)
	hwy.Store(vC, c[cRow3+jr+lanes:])
}

func BasePackedMicroKernel_neon_BFloat16(packedA []hwy.BFloat16, packedB []hwy.BFloat16, c []hwy.BFloat16, n int, ir int, jr int, kc int, mr int, nr int) {
	lanes := 8
	if mr != 4 || nr != lanes*2 {
		basePackedMicroKernelGeneral(packedA, packedB, c, n, ir, jr, kc, mr, nr)
		return
	}
	acc00 := hwy.Zero[hwy.BFloat16]()
	acc01 := hwy.Zero[hwy.BFloat16]()
	acc10 := hwy.Zero[hwy.BFloat16]()
	acc11 := hwy.Zero[hwy.BFloat16]()
	acc20 := hwy.Zero[hwy.BFloat16]()
	acc21 := hwy.Zero[hwy.BFloat16]()
	acc30 := hwy.Zero[hwy.BFloat16]()
	acc31 := hwy.Zero[hwy.BFloat16]()
	aIdx := 0
	bIdx := 0
	for p := 0; p < kc; p++ {
		a0 := packedA[aIdx]
		a1 := packedA[aIdx+1]
		a2 := packedA[aIdx+2]
		a3 := packedA[aIdx+3]
		aIdx += 4
		vA0 := hwy.Set(a0)
		vA1 := hwy.Set(a1)
		vA2 := hwy.Set(a2)
		vA3 := hwy.Set(a3)
		vB0 := hwy.Load(packedB[bIdx:])
		vB1 := hwy.Load(packedB[bIdx+lanes:])
		bIdx += nr
		acc00 = hwy.FMABF16(vA0, vB0, acc00)
		acc01 = hwy.FMABF16(vA0, vB1, acc01)
		acc10 = hwy.FMABF16(vA1, vB0, acc10)
		acc11 = hwy.FMABF16(vA1, vB1, acc11)
		acc20 = hwy.FMABF16(vA2, vB0, acc20)
		acc21 = hwy.FMABF16(vA2, vB1, acc21)
		acc30 = hwy.FMABF16(vA3, vB0, acc30)
		acc31 = hwy.FMABF16(vA3, vB1, acc31)
	}
	cRow0 := ir * n
	cRow1 := (ir + 1) * n
	cRow2 := (ir + 2) * n
	cRow3 := (ir + 3) * n
	vC := hwy.Load(c[cRow0+jr:])
	vC = hwy.AddBF16(vC, acc00)
	hwy.Store(vC, c[cRow0+jr:])
	vC = hwy.Load(c[cRow0+jr+lanes:])
	vC = hwy.AddBF16(vC, acc01)
	hwy.Store(vC, c[cRow0+jr+lanes:])
	vC = hwy.Load(c[cRow1+jr:])
	vC = hwy.AddBF16(vC, acc10)
	hwy.Store(vC, c[cRow1+jr:])
	vC = hwy.Load(c[cRow1+jr+lanes:])
	vC = hwy.AddBF16(vC, acc11)
	hwy.Store(vC, c[cRow1+jr+lanes:])
	vC = hwy.Load(c[cRow2+jr:])
	vC = hwy.AddBF16(vC, acc20)
	hwy.Store(vC, c[cRow2+jr:])
	vC = hwy.Load(c[cRow2+jr+lanes:])
	vC = hwy.AddBF16(vC, acc21)
	hwy.Store(vC, c[cRow2+jr+lanes:])
	vC = hwy.Load(c[cRow3+jr:])
	vC = hwy.AddBF16(vC, acc30)
	hwy.Store(vC, c[cRow3+jr:])
	vC = hwy.Load(c[cRow3+jr+lanes:])
	vC = hwy.AddBF16(vC, acc31)
	hwy.Store(vC, c[cRow3+jr+lanes:])
}

func BasePackedMicroKernel_neon(packedA []float32, packedB []float32, c []float32, n int, ir int, jr int, kc int, mr int, nr int) {
	lanes := 4
	if mr != 4 || nr != lanes*2 {
		basePackedMicroKernelGeneral(packedA, packedB, c, n, ir, jr, kc, mr, nr)
		return
	}
	acc00 := asm.ZeroFloat32x4()
	acc01 := asm.ZeroFloat32x4()
	acc10 := asm.ZeroFloat32x4()
	acc11 := asm.ZeroFloat32x4()
	acc20 := asm.ZeroFloat32x4()
	acc21 := asm.ZeroFloat32x4()
	acc30 := asm.ZeroFloat32x4()
	acc31 := asm.ZeroFloat32x4()
	aIdx := 0
	bIdx := 0
	for p := 0; p < kc; p++ {
		a0 := packedA[aIdx]
		a1 := packedA[aIdx+1]
		a2 := packedA[aIdx+2]
		a3 := packedA[aIdx+3]
		aIdx += 4
		vA0 := asm.BroadcastFloat32x4(a0)
		vA1 := asm.BroadcastFloat32x4(a1)
		vA2 := asm.BroadcastFloat32x4(a2)
		vA3 := asm.BroadcastFloat32x4(a3)
		vB0 := asm.LoadFloat32x4Slice(packedB[bIdx:])
		vB1 := asm.LoadFloat32x4Slice(packedB[bIdx+lanes:])
		bIdx += nr
		acc00 = vA0.MulAdd(vB0, acc00)
		acc01 = vA0.MulAdd(vB1, acc01)
		acc10 = vA1.MulAdd(vB0, acc10)
		acc11 = vA1.MulAdd(vB1, acc11)
		acc20 = vA2.MulAdd(vB0, acc20)
		acc21 = vA2.MulAdd(vB1, acc21)
		acc30 = vA3.MulAdd(vB0, acc30)
		acc31 = vA3.MulAdd(vB1, acc31)
	}
	cRow0 := ir * n
	cRow1 := (ir + 1) * n
	cRow2 := (ir + 2) * n
	cRow3 := (ir + 3) * n
	vC := asm.LoadFloat32x4Slice(c[cRow0+jr:])
	vC = vC.Add(acc00)
	vC.StoreSlice(c[cRow0+jr:])
	vC = asm.LoadFloat32x4Slice(c[cRow0+jr+lanes:])
	vC = vC.Add(acc01)
	vC.StoreSlice(c[cRow0+jr+lanes:])
	vC = asm.LoadFloat32x4Slice(c[cRow1+jr:])
	vC = vC.Add(acc10)
	vC.StoreSlice(c[cRow1+jr:])
	vC = asm.LoadFloat32x4Slice(c[cRow1+jr+lanes:])
	vC = vC.Add(acc11)
	vC.StoreSlice(c[cRow1+jr+lanes:])
	vC = asm.LoadFloat32x4Slice(c[cRow2+jr:])
	vC = vC.Add(acc20)
	vC.StoreSlice(c[cRow2+jr:])
	vC = asm.LoadFloat32x4Slice(c[cRow2+jr+lanes:])
	vC = vC.Add(acc21)
	vC.StoreSlice(c[cRow2+jr+lanes:])
	vC = asm.LoadFloat32x4Slice(c[cRow3+jr:])
	vC = vC.Add(acc30)
	vC.StoreSlice(c[cRow3+jr:])
	vC = asm.LoadFloat32x4Slice(c[cRow3+jr+lanes:])
	vC = vC.Add(acc31)
	vC.StoreSlice(c[cRow3+jr+lanes:])
}

func BasePackedMicroKernel_neon_Float64(packedA []float64, packedB []float64, c []float64, n int, ir int, jr int, kc int, mr int, nr int) {
	lanes := 2
	if mr != 4 || nr != lanes*2 {
		basePackedMicroKernelGeneral(packedA, packedB, c, n, ir, jr, kc, mr, nr)
		return
	}
	acc00 := asm.ZeroFloat64x2()
	acc01 := asm.ZeroFloat64x2()
	acc10 := asm.ZeroFloat64x2()
	acc11 := asm.ZeroFloat64x2()
	acc20 := asm.ZeroFloat64x2()
	acc21 := asm.ZeroFloat64x2()
	acc30 := asm.ZeroFloat64x2()
	acc31 := asm.ZeroFloat64x2()
	aIdx := 0
	bIdx := 0
	for p := 0; p < kc; p++ {
		a0 := packedA[aIdx]
		a1 := packedA[aIdx+1]
		a2 := packedA[aIdx+2]
		a3 := packedA[aIdx+3]
		aIdx += 4
		vA0 := asm.BroadcastFloat64x2(a0)
		vA1 := asm.BroadcastFloat64x2(a1)
		vA2 := asm.BroadcastFloat64x2(a2)
		vA3 := asm.BroadcastFloat64x2(a3)
		vB0 := asm.LoadFloat64x2Slice(packedB[bIdx:])
		vB1 := asm.LoadFloat64x2Slice(packedB[bIdx+lanes:])
		bIdx += nr
		acc00 = vA0.MulAdd(vB0, acc00)
		acc01 = vA0.MulAdd(vB1, acc01)
		acc10 = vA1.MulAdd(vB0, acc10)
		acc11 = vA1.MulAdd(vB1, acc11)
		acc20 = vA2.MulAdd(vB0, acc20)
		acc21 = vA2.MulAdd(vB1, acc21)
		acc30 = vA3.MulAdd(vB0, acc30)
		acc31 = vA3.MulAdd(vB1, acc31)
	}
	cRow0 := ir * n
	cRow1 := (ir + 1) * n
	cRow2 := (ir + 2) * n
	cRow3 := (ir + 3) * n
	vC := asm.LoadFloat64x2Slice(c[cRow0+jr:])
	vC = vC.Add(acc00)
	vC.StoreSlice(c[cRow0+jr:])
	vC = asm.LoadFloat64x2Slice(c[cRow0+jr+lanes:])
	vC = vC.Add(acc01)
	vC.StoreSlice(c[cRow0+jr+lanes:])
	vC = asm.LoadFloat64x2Slice(c[cRow1+jr:])
	vC = vC.Add(acc10)
	vC.StoreSlice(c[cRow1+jr:])
	vC = asm.LoadFloat64x2Slice(c[cRow1+jr+lanes:])
	vC = vC.Add(acc11)
	vC.StoreSlice(c[cRow1+jr+lanes:])
	vC = asm.LoadFloat64x2Slice(c[cRow2+jr:])
	vC = vC.Add(acc20)
	vC.StoreSlice(c[cRow2+jr:])
	vC = asm.LoadFloat64x2Slice(c[cRow2+jr+lanes:])
	vC = vC.Add(acc21)
	vC.StoreSlice(c[cRow2+jr+lanes:])
	vC = asm.LoadFloat64x2Slice(c[cRow3+jr:])
	vC = vC.Add(acc30)
	vC.StoreSlice(c[cRow3+jr:])
	vC = asm.LoadFloat64x2Slice(c[cRow3+jr+lanes:])
	vC = vC.Add(acc31)
	vC.StoreSlice(c[cRow3+jr+lanes:])
}

func BasePackedMicroKernelPartial_neon_Float16(packedA []hwy.Float16, packedB []hwy.Float16, c []hwy.Float16, n int, ir int, jr int, kc int, mr int, nr int, activeRows int, activeCols int) {
	lanes := 8
	for r := 0; r < activeRows; r++ {
		cRowStart := (ir + r) * n
		var col int
		for col = 0; col+lanes <= activeCols; col += lanes {
			acc := hwy.Zero[hwy.Float16]()
			for p := 0; p < kc; p++ {
				aVal := packedA[p*mr+r]
				vA := hwy.Set(aVal)
				vB := hwy.Load(packedB[p*nr+col:])
				acc = hwy.FMAF16(vA, vB, acc)
			}
			vC := hwy.Load(c[cRowStart+jr+col:])
			vC = hwy.AddF16(vC, acc)
			hwy.Store(vC, c[cRowStart+jr+col:])
		}
		for ; col < activeCols; col++ {
			var sum float32
			for p := 0; p < kc; p++ {
				sum += packedA[p*mr+r].Float32() * packedB[p*nr+col].Float32()
			}
			c[cRowStart+jr+col] = hwy.Float32ToFloat16(c[cRowStart+jr+col].Float32() + sum)
		}
	}
}

func BasePackedMicroKernelPartial_neon_BFloat16(packedA []hwy.BFloat16, packedB []hwy.BFloat16, c []hwy.BFloat16, n int, ir int, jr int, kc int, mr int, nr int, activeRows int, activeCols int) {
	lanes := 8
	for r := 0; r < activeRows; r++ {
		cRowStart := (ir + r) * n
		var col int
		for col = 0; col+lanes <= activeCols; col += lanes {
			acc := hwy.Zero[hwy.BFloat16]()
			for p := 0; p < kc; p++ {
				aVal := packedA[p*mr+r]
				vA := hwy.Set(aVal)
				vB := hwy.Load(packedB[p*nr+col:])
				acc = hwy.FMABF16(vA, vB, acc)
			}
			vC := hwy.Load(c[cRowStart+jr+col:])
			vC = hwy.AddBF16(vC, acc)
			hwy.Store(vC, c[cRowStart+jr+col:])
		}
		for ; col < activeCols; col++ {
			var sum float32
			for p := 0; p < kc; p++ {
				sum += packedA[p*mr+r].Float32() * packedB[p*nr+col].Float32()
			}
			c[cRowStart+jr+col] = hwy.Float32ToBFloat16(c[cRowStart+jr+col].Float32() + sum)
		}
	}
}

func BasePackedMicroKernelPartial_neon(packedA []float32, packedB []float32, c []float32, n int, ir int, jr int, kc int, mr int, nr int, activeRows int, activeCols int) {
	lanes := 4
	for r := 0; r < activeRows; r++ {
		cRowStart := (ir + r) * n
		var col int
		for col = 0; col+lanes <= activeCols; col += lanes {
			acc := asm.ZeroFloat32x4()
			for p := 0; p < kc; p++ {
				aVal := packedA[p*mr+r]
				vA := asm.BroadcastFloat32x4(aVal)
				vB := asm.LoadFloat32x4Slice(packedB[p*nr+col:])
				acc = vA.MulAdd(vB, acc)
			}
			vC := asm.LoadFloat32x4Slice(c[cRowStart+jr+col:])
			vC = vC.Add(acc)
			vC.StoreSlice(c[cRowStart+jr+col:])
		}
		for ; col < activeCols; col++ {
			var sum float32
			for p := 0; p < kc; p++ {
				sum += packedA[p*mr+r] * packedB[p*nr+col]
			}
			c[cRowStart+jr+col] += sum
		}
	}
}

func BasePackedMicroKernelPartial_neon_Float64(packedA []float64, packedB []float64, c []float64, n int, ir int, jr int, kc int, mr int, nr int, activeRows int, activeCols int) {
	lanes := 2
	for r := 0; r < activeRows; r++ {
		cRowStart := (ir + r) * n
		var col int
		for col = 0; col+lanes <= activeCols; col += lanes {
			acc := asm.ZeroFloat64x2()
			for p := 0; p < kc; p++ {
				aVal := packedA[p*mr+r]
				vA := asm.BroadcastFloat64x2(aVal)
				vB := asm.LoadFloat64x2Slice(packedB[p*nr+col:])
				acc = vA.MulAdd(vB, acc)
			}
			vC := asm.LoadFloat64x2Slice(c[cRowStart+jr+col:])
			vC = vC.Add(acc)
			vC.StoreSlice(c[cRowStart+jr+col:])
		}
		for ; col < activeCols; col++ {
			var sum float64
			for p := 0; p < kc; p++ {
				sum += packedA[p*mr+r] * packedB[p*nr+col]
			}
			c[cRowStart+jr+col] += sum
		}
	}
}
