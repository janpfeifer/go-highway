// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

//go:build amd64 && goexperiment.simd

package matmul

import (
	"github.com/ajroetker/go-highway/hwy"
	"simd/archsimd"
)

func BasePackedMicroKernel4x2_avx2_Float16(packedA []hwy.Float16, packedB []hwy.Float16, output []hwy.Float16, outputStride int, outRowStart int, outColStart int, panelK int, lanes int) {
	acc00 := hwy.Zero[hwy.Float16]()
	acc01 := hwy.Zero[hwy.Float16]()
	acc10 := hwy.Zero[hwy.Float16]()
	acc11 := hwy.Zero[hwy.Float16]()
	acc20 := hwy.Zero[hwy.Float16]()
	acc21 := hwy.Zero[hwy.Float16]()
	acc30 := hwy.Zero[hwy.Float16]()
	acc31 := hwy.Zero[hwy.Float16]()
	nr := 2 * lanes
	mr := 4
	aIdx := 0
	bIdx := 0
	_ = packedA[panelK*mr-1].Float32()
	_ = packedB[panelK*nr-1].Float32()
	p := 0
	for ; p+3 < panelK; p += 4 {
		bVec0_0 := hwy.Load(packedB[bIdx:])
		bVec1_0 := hwy.Load(packedB[bIdx+lanes:])
		a0_0 := hwy.Set(packedA[aIdx])
		a1_0 := hwy.Set(packedA[aIdx+1])
		a2_0 := hwy.Set(packedA[aIdx+2])
		a3_0 := hwy.Set(packedA[aIdx+3])
		acc00 = hwy.FMAF16(a0_0, bVec0_0, acc00)
		acc01 = hwy.FMAF16(a0_0, bVec1_0, acc01)
		acc10 = hwy.FMAF16(a1_0, bVec0_0, acc10)
		acc11 = hwy.FMAF16(a1_0, bVec1_0, acc11)
		acc20 = hwy.FMAF16(a2_0, bVec0_0, acc20)
		acc21 = hwy.FMAF16(a2_0, bVec1_0, acc21)
		acc30 = hwy.FMAF16(a3_0, bVec0_0, acc30)
		acc31 = hwy.FMAF16(a3_0, bVec1_0, acc31)
		bVec0_1 := hwy.Load(packedB[bIdx+nr:])
		bVec1_1 := hwy.Load(packedB[bIdx+nr+lanes:])
		a0_1 := hwy.Set(packedA[aIdx+mr])
		a1_1 := hwy.Set(packedA[aIdx+mr+1])
		a2_1 := hwy.Set(packedA[aIdx+mr+2])
		a3_1 := hwy.Set(packedA[aIdx+mr+3])
		acc00 = hwy.FMAF16(a0_1, bVec0_1, acc00)
		acc01 = hwy.FMAF16(a0_1, bVec1_1, acc01)
		acc10 = hwy.FMAF16(a1_1, bVec0_1, acc10)
		acc11 = hwy.FMAF16(a1_1, bVec1_1, acc11)
		acc20 = hwy.FMAF16(a2_1, bVec0_1, acc20)
		acc21 = hwy.FMAF16(a2_1, bVec1_1, acc21)
		acc30 = hwy.FMAF16(a3_1, bVec0_1, acc30)
		acc31 = hwy.FMAF16(a3_1, bVec1_1, acc31)
		bVec0_2 := hwy.Load(packedB[bIdx+2*nr:])
		bVec1_2 := hwy.Load(packedB[bIdx+2*nr+lanes:])
		a0_2 := hwy.Set(packedA[aIdx+2*mr])
		a1_2 := hwy.Set(packedA[aIdx+2*mr+1])
		a2_2 := hwy.Set(packedA[aIdx+2*mr+2])
		a3_2 := hwy.Set(packedA[aIdx+2*mr+3])
		acc00 = hwy.FMAF16(a0_2, bVec0_2, acc00)
		acc01 = hwy.FMAF16(a0_2, bVec1_2, acc01)
		acc10 = hwy.FMAF16(a1_2, bVec0_2, acc10)
		acc11 = hwy.FMAF16(a1_2, bVec1_2, acc11)
		acc20 = hwy.FMAF16(a2_2, bVec0_2, acc20)
		acc21 = hwy.FMAF16(a2_2, bVec1_2, acc21)
		acc30 = hwy.FMAF16(a3_2, bVec0_2, acc30)
		acc31 = hwy.FMAF16(a3_2, bVec1_2, acc31)
		bVec0_3 := hwy.Load(packedB[bIdx+3*nr:])
		bVec1_3 := hwy.Load(packedB[bIdx+3*nr+lanes:])
		a0_3 := hwy.Set(packedA[aIdx+3*mr])
		a1_3 := hwy.Set(packedA[aIdx+3*mr+1])
		a2_3 := hwy.Set(packedA[aIdx+3*mr+2])
		a3_3 := hwy.Set(packedA[aIdx+3*mr+3])
		acc00 = hwy.FMAF16(a0_3, bVec0_3, acc00)
		acc01 = hwy.FMAF16(a0_3, bVec1_3, acc01)
		acc10 = hwy.FMAF16(a1_3, bVec0_3, acc10)
		acc11 = hwy.FMAF16(a1_3, bVec1_3, acc11)
		acc20 = hwy.FMAF16(a2_3, bVec0_3, acc20)
		acc21 = hwy.FMAF16(a2_3, bVec1_3, acc21)
		acc30 = hwy.FMAF16(a3_3, bVec0_3, acc30)
		acc31 = hwy.FMAF16(a3_3, bVec1_3, acc31)
		aIdx += 4 * mr
		bIdx += 4 * nr
	}
	for ; p < panelK; p++ {
		bVec0 := hwy.Load(packedB[bIdx:])
		bVec1 := hwy.Load(packedB[bIdx+lanes:])
		bIdx += nr
		a0 := hwy.Set(packedA[aIdx])
		a1 := hwy.Set(packedA[aIdx+1])
		a2 := hwy.Set(packedA[aIdx+2])
		a3 := hwy.Set(packedA[aIdx+3])
		aIdx += mr
		acc00 = hwy.FMAF16(a0, bVec0, acc00)
		acc01 = hwy.FMAF16(a0, bVec1, acc01)
		acc10 = hwy.FMAF16(a1, bVec0, acc10)
		acc11 = hwy.FMAF16(a1, bVec1, acc11)
		acc20 = hwy.FMAF16(a2, bVec0, acc20)
		acc21 = hwy.FMAF16(a2, bVec1, acc21)
		acc30 = hwy.FMAF16(a3, bVec0, acc30)
		acc31 = hwy.FMAF16(a3, bVec1, acc31)
	}
	outIdx0 := outRowStart*outputStride + outColStart
	outIdx1 := outIdx0 + outputStride
	outIdx2 := outIdx1 + outputStride
	outIdx3 := outIdx2 + outputStride
	hwy.Store(acc00, output[outIdx0:])
	hwy.Store(acc01, output[outIdx0+lanes:])
	hwy.Store(acc10, output[outIdx1:])
	hwy.Store(acc11, output[outIdx1+lanes:])
	hwy.Store(acc20, output[outIdx2:])
	hwy.Store(acc21, output[outIdx2+lanes:])
	hwy.Store(acc30, output[outIdx3:])
	hwy.Store(acc31, output[outIdx3+lanes:])
}

func BasePackedMicroKernel4x2_avx2_BFloat16(packedA []hwy.BFloat16, packedB []hwy.BFloat16, output []hwy.BFloat16, outputStride int, outRowStart int, outColStart int, panelK int, lanes int) {
	acc00 := hwy.Zero[hwy.BFloat16]()
	acc01 := hwy.Zero[hwy.BFloat16]()
	acc10 := hwy.Zero[hwy.BFloat16]()
	acc11 := hwy.Zero[hwy.BFloat16]()
	acc20 := hwy.Zero[hwy.BFloat16]()
	acc21 := hwy.Zero[hwy.BFloat16]()
	acc30 := hwy.Zero[hwy.BFloat16]()
	acc31 := hwy.Zero[hwy.BFloat16]()
	nr := 2 * lanes
	mr := 4
	aIdx := 0
	bIdx := 0
	_ = packedA[panelK*mr-1].Float32()
	_ = packedB[panelK*nr-1].Float32()
	p := 0
	for ; p+3 < panelK; p += 4 {
		bVec0_0 := hwy.Load(packedB[bIdx:])
		bVec1_0 := hwy.Load(packedB[bIdx+lanes:])
		a0_0 := hwy.Set(packedA[aIdx])
		a1_0 := hwy.Set(packedA[aIdx+1])
		a2_0 := hwy.Set(packedA[aIdx+2])
		a3_0 := hwy.Set(packedA[aIdx+3])
		acc00 = hwy.FMABF16(a0_0, bVec0_0, acc00)
		acc01 = hwy.FMABF16(a0_0, bVec1_0, acc01)
		acc10 = hwy.FMABF16(a1_0, bVec0_0, acc10)
		acc11 = hwy.FMABF16(a1_0, bVec1_0, acc11)
		acc20 = hwy.FMABF16(a2_0, bVec0_0, acc20)
		acc21 = hwy.FMABF16(a2_0, bVec1_0, acc21)
		acc30 = hwy.FMABF16(a3_0, bVec0_0, acc30)
		acc31 = hwy.FMABF16(a3_0, bVec1_0, acc31)
		bVec0_1 := hwy.Load(packedB[bIdx+nr:])
		bVec1_1 := hwy.Load(packedB[bIdx+nr+lanes:])
		a0_1 := hwy.Set(packedA[aIdx+mr])
		a1_1 := hwy.Set(packedA[aIdx+mr+1])
		a2_1 := hwy.Set(packedA[aIdx+mr+2])
		a3_1 := hwy.Set(packedA[aIdx+mr+3])
		acc00 = hwy.FMABF16(a0_1, bVec0_1, acc00)
		acc01 = hwy.FMABF16(a0_1, bVec1_1, acc01)
		acc10 = hwy.FMABF16(a1_1, bVec0_1, acc10)
		acc11 = hwy.FMABF16(a1_1, bVec1_1, acc11)
		acc20 = hwy.FMABF16(a2_1, bVec0_1, acc20)
		acc21 = hwy.FMABF16(a2_1, bVec1_1, acc21)
		acc30 = hwy.FMABF16(a3_1, bVec0_1, acc30)
		acc31 = hwy.FMABF16(a3_1, bVec1_1, acc31)
		bVec0_2 := hwy.Load(packedB[bIdx+2*nr:])
		bVec1_2 := hwy.Load(packedB[bIdx+2*nr+lanes:])
		a0_2 := hwy.Set(packedA[aIdx+2*mr])
		a1_2 := hwy.Set(packedA[aIdx+2*mr+1])
		a2_2 := hwy.Set(packedA[aIdx+2*mr+2])
		a3_2 := hwy.Set(packedA[aIdx+2*mr+3])
		acc00 = hwy.FMABF16(a0_2, bVec0_2, acc00)
		acc01 = hwy.FMABF16(a0_2, bVec1_2, acc01)
		acc10 = hwy.FMABF16(a1_2, bVec0_2, acc10)
		acc11 = hwy.FMABF16(a1_2, bVec1_2, acc11)
		acc20 = hwy.FMABF16(a2_2, bVec0_2, acc20)
		acc21 = hwy.FMABF16(a2_2, bVec1_2, acc21)
		acc30 = hwy.FMABF16(a3_2, bVec0_2, acc30)
		acc31 = hwy.FMABF16(a3_2, bVec1_2, acc31)
		bVec0_3 := hwy.Load(packedB[bIdx+3*nr:])
		bVec1_3 := hwy.Load(packedB[bIdx+3*nr+lanes:])
		a0_3 := hwy.Set(packedA[aIdx+3*mr])
		a1_3 := hwy.Set(packedA[aIdx+3*mr+1])
		a2_3 := hwy.Set(packedA[aIdx+3*mr+2])
		a3_3 := hwy.Set(packedA[aIdx+3*mr+3])
		acc00 = hwy.FMABF16(a0_3, bVec0_3, acc00)
		acc01 = hwy.FMABF16(a0_3, bVec1_3, acc01)
		acc10 = hwy.FMABF16(a1_3, bVec0_3, acc10)
		acc11 = hwy.FMABF16(a1_3, bVec1_3, acc11)
		acc20 = hwy.FMABF16(a2_3, bVec0_3, acc20)
		acc21 = hwy.FMABF16(a2_3, bVec1_3, acc21)
		acc30 = hwy.FMABF16(a3_3, bVec0_3, acc30)
		acc31 = hwy.FMABF16(a3_3, bVec1_3, acc31)
		aIdx += 4 * mr
		bIdx += 4 * nr
	}
	for ; p < panelK; p++ {
		bVec0 := hwy.Load(packedB[bIdx:])
		bVec1 := hwy.Load(packedB[bIdx+lanes:])
		bIdx += nr
		a0 := hwy.Set(packedA[aIdx])
		a1 := hwy.Set(packedA[aIdx+1])
		a2 := hwy.Set(packedA[aIdx+2])
		a3 := hwy.Set(packedA[aIdx+3])
		aIdx += mr
		acc00 = hwy.FMABF16(a0, bVec0, acc00)
		acc01 = hwy.FMABF16(a0, bVec1, acc01)
		acc10 = hwy.FMABF16(a1, bVec0, acc10)
		acc11 = hwy.FMABF16(a1, bVec1, acc11)
		acc20 = hwy.FMABF16(a2, bVec0, acc20)
		acc21 = hwy.FMABF16(a2, bVec1, acc21)
		acc30 = hwy.FMABF16(a3, bVec0, acc30)
		acc31 = hwy.FMABF16(a3, bVec1, acc31)
	}
	outIdx0 := outRowStart*outputStride + outColStart
	outIdx1 := outIdx0 + outputStride
	outIdx2 := outIdx1 + outputStride
	outIdx3 := outIdx2 + outputStride
	hwy.Store(acc00, output[outIdx0:])
	hwy.Store(acc01, output[outIdx0+lanes:])
	hwy.Store(acc10, output[outIdx1:])
	hwy.Store(acc11, output[outIdx1+lanes:])
	hwy.Store(acc20, output[outIdx2:])
	hwy.Store(acc21, output[outIdx2+lanes:])
	hwy.Store(acc30, output[outIdx3:])
	hwy.Store(acc31, output[outIdx3+lanes:])
}

func BasePackedMicroKernel4x2_avx2(packedA []float32, packedB []float32, output []float32, outputStride int, outRowStart int, outColStart int, panelK int, lanes int) {
	acc00 := archsimd.BroadcastFloat32x8(0)
	acc01 := archsimd.BroadcastFloat32x8(0)
	acc10 := archsimd.BroadcastFloat32x8(0)
	acc11 := archsimd.BroadcastFloat32x8(0)
	acc20 := archsimd.BroadcastFloat32x8(0)
	acc21 := archsimd.BroadcastFloat32x8(0)
	acc30 := archsimd.BroadcastFloat32x8(0)
	acc31 := archsimd.BroadcastFloat32x8(0)
	nr := 2 * lanes
	mr := 4
	aIdx := 0
	bIdx := 0
	_ = packedA[panelK*mr-1]
	_ = packedB[panelK*nr-1]
	p := 0
	for ; p+3 < panelK; p += 4 {
		bVec0_0 := archsimd.LoadFloat32x8Slice(packedB[bIdx:])
		bVec1_0 := archsimd.LoadFloat32x8Slice(packedB[bIdx+lanes:])
		a0_0 := archsimd.BroadcastFloat32x8(packedA[aIdx])
		a1_0 := archsimd.BroadcastFloat32x8(packedA[aIdx+1])
		a2_0 := archsimd.BroadcastFloat32x8(packedA[aIdx+2])
		a3_0 := archsimd.BroadcastFloat32x8(packedA[aIdx+3])
		acc00 = a0_0.MulAdd(bVec0_0, acc00)
		acc01 = a0_0.MulAdd(bVec1_0, acc01)
		acc10 = a1_0.MulAdd(bVec0_0, acc10)
		acc11 = a1_0.MulAdd(bVec1_0, acc11)
		acc20 = a2_0.MulAdd(bVec0_0, acc20)
		acc21 = a2_0.MulAdd(bVec1_0, acc21)
		acc30 = a3_0.MulAdd(bVec0_0, acc30)
		acc31 = a3_0.MulAdd(bVec1_0, acc31)
		bVec0_1 := archsimd.LoadFloat32x8Slice(packedB[bIdx+nr:])
		bVec1_1 := archsimd.LoadFloat32x8Slice(packedB[bIdx+nr+lanes:])
		a0_1 := archsimd.BroadcastFloat32x8(packedA[aIdx+mr])
		a1_1 := archsimd.BroadcastFloat32x8(packedA[aIdx+mr+1])
		a2_1 := archsimd.BroadcastFloat32x8(packedA[aIdx+mr+2])
		a3_1 := archsimd.BroadcastFloat32x8(packedA[aIdx+mr+3])
		acc00 = a0_1.MulAdd(bVec0_1, acc00)
		acc01 = a0_1.MulAdd(bVec1_1, acc01)
		acc10 = a1_1.MulAdd(bVec0_1, acc10)
		acc11 = a1_1.MulAdd(bVec1_1, acc11)
		acc20 = a2_1.MulAdd(bVec0_1, acc20)
		acc21 = a2_1.MulAdd(bVec1_1, acc21)
		acc30 = a3_1.MulAdd(bVec0_1, acc30)
		acc31 = a3_1.MulAdd(bVec1_1, acc31)
		bVec0_2 := archsimd.LoadFloat32x8Slice(packedB[bIdx+2*nr:])
		bVec1_2 := archsimd.LoadFloat32x8Slice(packedB[bIdx+2*nr+lanes:])
		a0_2 := archsimd.BroadcastFloat32x8(packedA[aIdx+2*mr])
		a1_2 := archsimd.BroadcastFloat32x8(packedA[aIdx+2*mr+1])
		a2_2 := archsimd.BroadcastFloat32x8(packedA[aIdx+2*mr+2])
		a3_2 := archsimd.BroadcastFloat32x8(packedA[aIdx+2*mr+3])
		acc00 = a0_2.MulAdd(bVec0_2, acc00)
		acc01 = a0_2.MulAdd(bVec1_2, acc01)
		acc10 = a1_2.MulAdd(bVec0_2, acc10)
		acc11 = a1_2.MulAdd(bVec1_2, acc11)
		acc20 = a2_2.MulAdd(bVec0_2, acc20)
		acc21 = a2_2.MulAdd(bVec1_2, acc21)
		acc30 = a3_2.MulAdd(bVec0_2, acc30)
		acc31 = a3_2.MulAdd(bVec1_2, acc31)
		bVec0_3 := archsimd.LoadFloat32x8Slice(packedB[bIdx+3*nr:])
		bVec1_3 := archsimd.LoadFloat32x8Slice(packedB[bIdx+3*nr+lanes:])
		a0_3 := archsimd.BroadcastFloat32x8(packedA[aIdx+3*mr])
		a1_3 := archsimd.BroadcastFloat32x8(packedA[aIdx+3*mr+1])
		a2_3 := archsimd.BroadcastFloat32x8(packedA[aIdx+3*mr+2])
		a3_3 := archsimd.BroadcastFloat32x8(packedA[aIdx+3*mr+3])
		acc00 = a0_3.MulAdd(bVec0_3, acc00)
		acc01 = a0_3.MulAdd(bVec1_3, acc01)
		acc10 = a1_3.MulAdd(bVec0_3, acc10)
		acc11 = a1_3.MulAdd(bVec1_3, acc11)
		acc20 = a2_3.MulAdd(bVec0_3, acc20)
		acc21 = a2_3.MulAdd(bVec1_3, acc21)
		acc30 = a3_3.MulAdd(bVec0_3, acc30)
		acc31 = a3_3.MulAdd(bVec1_3, acc31)
		aIdx += 4 * mr
		bIdx += 4 * nr
	}
	for ; p < panelK; p++ {
		bVec0 := archsimd.LoadFloat32x8Slice(packedB[bIdx:])
		bVec1 := archsimd.LoadFloat32x8Slice(packedB[bIdx+lanes:])
		bIdx += nr
		a0 := archsimd.BroadcastFloat32x8(packedA[aIdx])
		a1 := archsimd.BroadcastFloat32x8(packedA[aIdx+1])
		a2 := archsimd.BroadcastFloat32x8(packedA[aIdx+2])
		a3 := archsimd.BroadcastFloat32x8(packedA[aIdx+3])
		aIdx += mr
		acc00 = a0.MulAdd(bVec0, acc00)
		acc01 = a0.MulAdd(bVec1, acc01)
		acc10 = a1.MulAdd(bVec0, acc10)
		acc11 = a1.MulAdd(bVec1, acc11)
		acc20 = a2.MulAdd(bVec0, acc20)
		acc21 = a2.MulAdd(bVec1, acc21)
		acc30 = a3.MulAdd(bVec0, acc30)
		acc31 = a3.MulAdd(bVec1, acc31)
	}
	outIdx0 := outRowStart*outputStride + outColStart
	outIdx1 := outIdx0 + outputStride
	outIdx2 := outIdx1 + outputStride
	outIdx3 := outIdx2 + outputStride
	acc00.StoreSlice(output[outIdx0:])
	acc01.StoreSlice(output[outIdx0+lanes:])
	acc10.StoreSlice(output[outIdx1:])
	acc11.StoreSlice(output[outIdx1+lanes:])
	acc20.StoreSlice(output[outIdx2:])
	acc21.StoreSlice(output[outIdx2+lanes:])
	acc30.StoreSlice(output[outIdx3:])
	acc31.StoreSlice(output[outIdx3+lanes:])
}

func BasePackedMicroKernel4x2_avx2_Float64(packedA []float64, packedB []float64, output []float64, outputStride int, outRowStart int, outColStart int, panelK int, lanes int) {
	acc00 := archsimd.BroadcastFloat64x4(0)
	acc01 := archsimd.BroadcastFloat64x4(0)
	acc10 := archsimd.BroadcastFloat64x4(0)
	acc11 := archsimd.BroadcastFloat64x4(0)
	acc20 := archsimd.BroadcastFloat64x4(0)
	acc21 := archsimd.BroadcastFloat64x4(0)
	acc30 := archsimd.BroadcastFloat64x4(0)
	acc31 := archsimd.BroadcastFloat64x4(0)
	nr := 2 * lanes
	mr := 4
	aIdx := 0
	bIdx := 0
	_ = packedA[panelK*mr-1]
	_ = packedB[panelK*nr-1]
	p := 0
	for ; p+3 < panelK; p += 4 {
		bVec0_0 := archsimd.LoadFloat64x4Slice(packedB[bIdx:])
		bVec1_0 := archsimd.LoadFloat64x4Slice(packedB[bIdx+lanes:])
		a0_0 := archsimd.BroadcastFloat64x4(packedA[aIdx])
		a1_0 := archsimd.BroadcastFloat64x4(packedA[aIdx+1])
		a2_0 := archsimd.BroadcastFloat64x4(packedA[aIdx+2])
		a3_0 := archsimd.BroadcastFloat64x4(packedA[aIdx+3])
		acc00 = a0_0.MulAdd(bVec0_0, acc00)
		acc01 = a0_0.MulAdd(bVec1_0, acc01)
		acc10 = a1_0.MulAdd(bVec0_0, acc10)
		acc11 = a1_0.MulAdd(bVec1_0, acc11)
		acc20 = a2_0.MulAdd(bVec0_0, acc20)
		acc21 = a2_0.MulAdd(bVec1_0, acc21)
		acc30 = a3_0.MulAdd(bVec0_0, acc30)
		acc31 = a3_0.MulAdd(bVec1_0, acc31)
		bVec0_1 := archsimd.LoadFloat64x4Slice(packedB[bIdx+nr:])
		bVec1_1 := archsimd.LoadFloat64x4Slice(packedB[bIdx+nr+lanes:])
		a0_1 := archsimd.BroadcastFloat64x4(packedA[aIdx+mr])
		a1_1 := archsimd.BroadcastFloat64x4(packedA[aIdx+mr+1])
		a2_1 := archsimd.BroadcastFloat64x4(packedA[aIdx+mr+2])
		a3_1 := archsimd.BroadcastFloat64x4(packedA[aIdx+mr+3])
		acc00 = a0_1.MulAdd(bVec0_1, acc00)
		acc01 = a0_1.MulAdd(bVec1_1, acc01)
		acc10 = a1_1.MulAdd(bVec0_1, acc10)
		acc11 = a1_1.MulAdd(bVec1_1, acc11)
		acc20 = a2_1.MulAdd(bVec0_1, acc20)
		acc21 = a2_1.MulAdd(bVec1_1, acc21)
		acc30 = a3_1.MulAdd(bVec0_1, acc30)
		acc31 = a3_1.MulAdd(bVec1_1, acc31)
		bVec0_2 := archsimd.LoadFloat64x4Slice(packedB[bIdx+2*nr:])
		bVec1_2 := archsimd.LoadFloat64x4Slice(packedB[bIdx+2*nr+lanes:])
		a0_2 := archsimd.BroadcastFloat64x4(packedA[aIdx+2*mr])
		a1_2 := archsimd.BroadcastFloat64x4(packedA[aIdx+2*mr+1])
		a2_2 := archsimd.BroadcastFloat64x4(packedA[aIdx+2*mr+2])
		a3_2 := archsimd.BroadcastFloat64x4(packedA[aIdx+2*mr+3])
		acc00 = a0_2.MulAdd(bVec0_2, acc00)
		acc01 = a0_2.MulAdd(bVec1_2, acc01)
		acc10 = a1_2.MulAdd(bVec0_2, acc10)
		acc11 = a1_2.MulAdd(bVec1_2, acc11)
		acc20 = a2_2.MulAdd(bVec0_2, acc20)
		acc21 = a2_2.MulAdd(bVec1_2, acc21)
		acc30 = a3_2.MulAdd(bVec0_2, acc30)
		acc31 = a3_2.MulAdd(bVec1_2, acc31)
		bVec0_3 := archsimd.LoadFloat64x4Slice(packedB[bIdx+3*nr:])
		bVec1_3 := archsimd.LoadFloat64x4Slice(packedB[bIdx+3*nr+lanes:])
		a0_3 := archsimd.BroadcastFloat64x4(packedA[aIdx+3*mr])
		a1_3 := archsimd.BroadcastFloat64x4(packedA[aIdx+3*mr+1])
		a2_3 := archsimd.BroadcastFloat64x4(packedA[aIdx+3*mr+2])
		a3_3 := archsimd.BroadcastFloat64x4(packedA[aIdx+3*mr+3])
		acc00 = a0_3.MulAdd(bVec0_3, acc00)
		acc01 = a0_3.MulAdd(bVec1_3, acc01)
		acc10 = a1_3.MulAdd(bVec0_3, acc10)
		acc11 = a1_3.MulAdd(bVec1_3, acc11)
		acc20 = a2_3.MulAdd(bVec0_3, acc20)
		acc21 = a2_3.MulAdd(bVec1_3, acc21)
		acc30 = a3_3.MulAdd(bVec0_3, acc30)
		acc31 = a3_3.MulAdd(bVec1_3, acc31)
		aIdx += 4 * mr
		bIdx += 4 * nr
	}
	for ; p < panelK; p++ {
		bVec0 := archsimd.LoadFloat64x4Slice(packedB[bIdx:])
		bVec1 := archsimd.LoadFloat64x4Slice(packedB[bIdx+lanes:])
		bIdx += nr
		a0 := archsimd.BroadcastFloat64x4(packedA[aIdx])
		a1 := archsimd.BroadcastFloat64x4(packedA[aIdx+1])
		a2 := archsimd.BroadcastFloat64x4(packedA[aIdx+2])
		a3 := archsimd.BroadcastFloat64x4(packedA[aIdx+3])
		aIdx += mr
		acc00 = a0.MulAdd(bVec0, acc00)
		acc01 = a0.MulAdd(bVec1, acc01)
		acc10 = a1.MulAdd(bVec0, acc10)
		acc11 = a1.MulAdd(bVec1, acc11)
		acc20 = a2.MulAdd(bVec0, acc20)
		acc21 = a2.MulAdd(bVec1, acc21)
		acc30 = a3.MulAdd(bVec0, acc30)
		acc31 = a3.MulAdd(bVec1, acc31)
	}
	outIdx0 := outRowStart*outputStride + outColStart
	outIdx1 := outIdx0 + outputStride
	outIdx2 := outIdx1 + outputStride
	outIdx3 := outIdx2 + outputStride
	acc00.StoreSlice(output[outIdx0:])
	acc01.StoreSlice(output[outIdx0+lanes:])
	acc10.StoreSlice(output[outIdx1:])
	acc11.StoreSlice(output[outIdx1+lanes:])
	acc20.StoreSlice(output[outIdx2:])
	acc21.StoreSlice(output[outIdx2+lanes:])
	acc30.StoreSlice(output[outIdx3:])
	acc31.StoreSlice(output[outIdx3+lanes:])
}

func BaseZeroSlice_avx2_Float16(s []hwy.Float16, n int) {
	vZero := hwy.Zero[hwy.Float16]()
	lanes := 16
	var idx int
	for idx = 0; idx+lanes <= n; idx += lanes {
		hwy.Store(vZero, s[idx:])
	}
	for ; idx < n; idx++ {
		s[idx] = hwy.Float32ToFloat16(0)
	}
}

func BaseZeroSlice_avx2_BFloat16(s []hwy.BFloat16, n int) {
	vZero := hwy.Zero[hwy.BFloat16]()
	lanes := 16
	var idx int
	for idx = 0; idx+lanes <= n; idx += lanes {
		hwy.Store(vZero, s[idx:])
	}
	for ; idx < n; idx++ {
		s[idx] = hwy.Float32ToBFloat16(0)
	}
}

func BaseZeroSlice_avx2(s []float32, n int) {
	vZero := archsimd.BroadcastFloat32x8(0)
	lanes := 8
	var idx int
	for idx = 0; idx+lanes <= n; idx += lanes {
		vZero.StoreSlice(s[idx:])
	}
	for ; idx < n; idx++ {
		s[idx] = 0
	}
}

func BaseZeroSlice_avx2_Float64(s []float64, n int) {
	vZero := archsimd.BroadcastFloat64x4(0)
	lanes := 4
	var idx int
	for idx = 0; idx+lanes <= n; idx += lanes {
		vZero.StoreSlice(s[idx:])
	}
	for ; idx < n; idx++ {
		s[idx] = 0
	}
}
