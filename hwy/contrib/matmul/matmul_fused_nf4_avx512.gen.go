// Code generated by hwygen. DO NOT EDIT.
//go:build amd64 && goexperiment.simd

package matmul

import (
	"simd/archsimd"
)

func BaseFusedNF4MatMul_avx512(input []float32, packed []uint8, scales []float32, output []float32, M int, K int, N int, groupSize int) {
	if M == 0 || K == 0 || N == 0 {
		return
	}
	numGroups := (N + groupSize - 1) / groupSize
	lanes := 16
	dequantBuf := [16]float32{}
	for m := 0; m < M; m++ {
		inputRow := input[m*K : (m+1)*K]
		outputRow := output[m*N : (m+1)*N]
		var n int
		for n = 0; n+lanes <= N; n += lanes {
			acc := archsimd.BroadcastFloat32x16(0)
			for k := 0; k < K; k++ {
				inputVal := archsimd.BroadcastFloat32x16(inputRow[k])
				baseIdx := k * N
				scaleBase := k * numGroups
				for lane := 0; lane < lanes; lane++ {
					colIdx := n + lane
					weightIdx := baseIdx + colIdx
					packedIdx := weightIdx / 2
					var quantIdx int
					if weightIdx%2 == 0 {
						quantIdx = int(packed[packedIdx] & 0x0F)
					} else {
						quantIdx = int((packed[packedIdx] >> 4) & 0x0F)
					}
					groupIdx := colIdx / groupSize
					scale := scales[scaleBase+groupIdx]
					dequantBuf[lane] = nf4LookupTable[quantIdx] * scale
				}
				weights := archsimd.LoadFloat32x16Slice(dequantBuf[:])
				acc = inputVal.MulAdd(weights, acc)
			}
			acc.StoreSlice(outputRow[n:])
		}
		for ; n < N; n++ {
			groupIdx := n / groupSize
			sum := float32(0)
			for k := 0; k < K; k++ {
				weightIdx := k*N + n
				packedIdx := weightIdx / 2
				var quantIdx int
				if weightIdx%2 == 0 {
					quantIdx = int(packed[packedIdx] & 0x0F)
				} else {
					quantIdx = int((packed[packedIdx] >> 4) & 0x0F)
				}
				scale := scales[k*numGroups+groupIdx]
				weight := nf4LookupTable[quantIdx] * scale
				sum += inputRow[k] * weight
			}
			outputRow[n] = sum
		}
	}
}

func BaseFusedInt4MatMul_avx512(input []float32, packed []uint8, scales []float32, output []float32, M int, K int, N int, groupSize int) {
	if M == 0 || K == 0 || N == 0 {
		return
	}
	numGroups := (N + groupSize - 1) / groupSize
	lanes := 16
	dequantBuf := [16]float32{}
	for m := 0; m < M; m++ {
		inputRow := input[m*K : (m+1)*K]
		outputRow := output[m*N : (m+1)*N]
		var n int
		for n = 0; n+lanes <= N; n += lanes {
			acc := archsimd.BroadcastFloat32x16(0)
			for k := 0; k < K; k++ {
				inputVal := archsimd.BroadcastFloat32x16(inputRow[k])
				baseIdx := k * N
				scaleBase := k * numGroups
				for lane := 0; lane < lanes; lane++ {
					colIdx := n + lane
					weightIdx := baseIdx + colIdx
					packedIdx := weightIdx / 2
					var unsignedVal int
					if weightIdx%2 == 0 {
						unsignedVal = int(packed[packedIdx] & 0x0F)
					} else {
						unsignedVal = int((packed[packedIdx] >> 4) & 0x0F)
					}
					groupIdx := colIdx / groupSize
					scale := scales[scaleBase+groupIdx]
					dequantBuf[lane] = float32(unsignedVal-8) * scale
				}
				weights := archsimd.LoadFloat32x16Slice(dequantBuf[:])
				acc = inputVal.MulAdd(weights, acc)
			}
			acc.StoreSlice(outputRow[n:])
		}
		for ; n < N; n++ {
			groupIdx := n / groupSize
			sum := float32(0)
			for k := 0; k < K; k++ {
				weightIdx := k*N + n
				packedIdx := weightIdx / 2
				var unsignedVal int
				if weightIdx%2 == 0 {
					unsignedVal = int(packed[packedIdx] & 0x0F)
				} else {
					unsignedVal = int((packed[packedIdx] >> 4) & 0x0F)
				}
				scale := scales[k*numGroups+groupIdx]
				weight := float32(unsignedVal-8) * scale
				sum += inputRow[k] * weight
			}
			outputRow[n] = sum
		}
	}
}
