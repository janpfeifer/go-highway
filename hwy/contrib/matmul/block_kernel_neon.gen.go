// Code generated by hwygen. DO NOT EDIT.
//go:build arm64

package matmul

import (
	"github.com/ajroetker/go-highway/hwy/asm"
)

func BaseBlockMulAdd_neon(aT []float32, b []float32, c []float32, blockDim int) {
	if len(aT) < blockDim*blockDim {
		panic("BlockMulAdd: aT slice too short")
	}
	if len(b) < blockDim*blockDim {
		panic("BlockMulAdd: B slice too short")
	}
	if len(c) < blockDim*blockDim {
		panic("BlockMulAdd: C slice too short")
	}
	lanes := 4
	for i := 0; i < blockDim; i++ {
		cRowStart := i * blockDim
		for k := 0; k < blockDim; k++ {
			aik := aT[k*blockDim+i]
			vA := asm.BroadcastFloat32x4(aik)
			bRowStart := k * blockDim
			var j int
			for j = 0; j+lanes <= blockDim; j += lanes {
				vB := asm.LoadFloat32x4Slice(b[bRowStart+j:])
				vC := asm.LoadFloat32x4Slice(c[cRowStart+j:])
				vC = vA.MulAdd(vB, vC)
				vC.StoreSlice(c[cRowStart+j:])
			}
			for ; j < blockDim; j++ {
				c[cRowStart+j] += aik * b[bRowStart+j]
			}
		}
	}
}

func BaseBlockMulAdd_neon_Float64(aT []float64, b []float64, c []float64, blockDim int) {
	if len(aT) < blockDim*blockDim {
		panic("BlockMulAdd: aT slice too short")
	}
	if len(b) < blockDim*blockDim {
		panic("BlockMulAdd: B slice too short")
	}
	if len(c) < blockDim*blockDim {
		panic("BlockMulAdd: C slice too short")
	}
	lanes := 2
	for i := 0; i < blockDim; i++ {
		cRowStart := i * blockDim
		for k := 0; k < blockDim; k++ {
			aik := aT[k*blockDim+i]
			vA := asm.BroadcastFloat64x2(aik)
			bRowStart := k * blockDim
			var j int
			for j = 0; j+lanes <= blockDim; j += lanes {
				vB := asm.LoadFloat64x2Slice(b[bRowStart+j:])
				vC := asm.LoadFloat64x2Slice(c[cRowStart+j:])
				vC = vA.MulAdd(vB, vC)
				vC.StoreSlice(c[cRowStart+j:])
			}
			for ; j < blockDim; j++ {
				c[cRowStart+j] += aik * b[bRowStart+j]
			}
		}
	}
}

func BaseBlockMulAdd2_neon(aT []float32, b []float32, c []float32, blockDim int) {
	if len(aT) < blockDim*blockDim {
		panic("BlockMulAdd2: aT slice too short")
	}
	if len(b) < blockDim*blockDim {
		panic("BlockMulAdd2: B slice too short")
	}
	if len(c) < blockDim*blockDim {
		panic("BlockMulAdd2: C slice too short")
	}
	lanes := 4
	var i int
	for i = 0; i+1 < blockDim; i += 2 {
		cRow0Start := i * blockDim
		cRow1Start := (i + 1) * blockDim
		for k := 0; k < blockDim; k++ {
			a0k := aT[k*blockDim+i]
			a1k := aT[k*blockDim+i+1]
			vA0 := asm.BroadcastFloat32x4(a0k)
			vA1 := asm.BroadcastFloat32x4(a1k)
			bRowStart := k * blockDim
			var j int
			for j = 0; j+lanes <= blockDim; j += lanes {
				vB := asm.LoadFloat32x4Slice(b[bRowStart+j:])
				vC0 := asm.LoadFloat32x4Slice(c[cRow0Start+j:])
				vC0 = vA0.MulAdd(vB, vC0)
				vC0.StoreSlice(c[cRow0Start+j:])
				vC1 := asm.LoadFloat32x4Slice(c[cRow1Start+j:])
				vC1 = vA1.MulAdd(vB, vC1)
				vC1.StoreSlice(c[cRow1Start+j:])
			}
			for ; j < blockDim; j++ {
				c[cRow0Start+j] += a0k * b[bRowStart+j]
				c[cRow1Start+j] += a1k * b[bRowStart+j]
			}
		}
	}
	if i < blockDim {
		cRowStart := i * blockDim
		for k := 0; k < blockDim; k++ {
			aik := aT[k*blockDim+i]
			vA := asm.BroadcastFloat32x4(aik)
			bRowStart := k * blockDim
			var j int
			for j = 0; j+lanes <= blockDim; j += lanes {
				vB := asm.LoadFloat32x4Slice(b[bRowStart+j:])
				vC := asm.LoadFloat32x4Slice(c[cRowStart+j:])
				vC = vA.MulAdd(vB, vC)
				vC.StoreSlice(c[cRowStart+j:])
			}
			for ; j < blockDim; j++ {
				c[cRowStart+j] += aik * b[bRowStart+j]
			}
		}
	}
}

func BaseBlockMulAdd2_neon_Float64(aT []float64, b []float64, c []float64, blockDim int) {
	if len(aT) < blockDim*blockDim {
		panic("BlockMulAdd2: aT slice too short")
	}
	if len(b) < blockDim*blockDim {
		panic("BlockMulAdd2: B slice too short")
	}
	if len(c) < blockDim*blockDim {
		panic("BlockMulAdd2: C slice too short")
	}
	lanes := 2
	var i int
	for i = 0; i+1 < blockDim; i += 2 {
		cRow0Start := i * blockDim
		cRow1Start := (i + 1) * blockDim
		for k := 0; k < blockDim; k++ {
			a0k := aT[k*blockDim+i]
			a1k := aT[k*blockDim+i+1]
			vA0 := asm.BroadcastFloat64x2(a0k)
			vA1 := asm.BroadcastFloat64x2(a1k)
			bRowStart := k * blockDim
			var j int
			for j = 0; j+lanes <= blockDim; j += lanes {
				vB := asm.LoadFloat64x2Slice(b[bRowStart+j:])
				vC0 := asm.LoadFloat64x2Slice(c[cRow0Start+j:])
				vC0 = vA0.MulAdd(vB, vC0)
				vC0.StoreSlice(c[cRow0Start+j:])
				vC1 := asm.LoadFloat64x2Slice(c[cRow1Start+j:])
				vC1 = vA1.MulAdd(vB, vC1)
				vC1.StoreSlice(c[cRow1Start+j:])
			}
			for ; j < blockDim; j++ {
				c[cRow0Start+j] += a0k * b[bRowStart+j]
				c[cRow1Start+j] += a1k * b[bRowStart+j]
			}
		}
	}
	if i < blockDim {
		cRowStart := i * blockDim
		for k := 0; k < blockDim; k++ {
			aik := aT[k*blockDim+i]
			vA := asm.BroadcastFloat64x2(aik)
			bRowStart := k * blockDim
			var j int
			for j = 0; j+lanes <= blockDim; j += lanes {
				vB := asm.LoadFloat64x2Slice(b[bRowStart+j:])
				vC := asm.LoadFloat64x2Slice(c[cRowStart+j:])
				vC = vA.MulAdd(vB, vC)
				vC.StoreSlice(c[cRowStart+j:])
			}
			for ; j < blockDim; j++ {
				c[cRowStart+j] += aik * b[bRowStart+j]
			}
		}
	}
}

func BaseBlockMulAdd4_neon(aT []float32, b []float32, c []float32, blockDim int) {
	if len(aT) < blockDim*blockDim {
		panic("BlockMulAdd4: aT slice too short")
	}
	if len(b) < blockDim*blockDim {
		panic("BlockMulAdd4: B slice too short")
	}
	if len(c) < blockDim*blockDim {
		panic("BlockMulAdd4: C slice too short")
	}
	lanes := 4
	var i int
	for i = 0; i+3 < blockDim; i += 4 {
		cRow0 := i * blockDim
		cRow1 := (i + 1) * blockDim
		cRow2 := (i + 2) * blockDim
		cRow3 := (i + 3) * blockDim
		for k := 0; k < blockDim; k++ {
			aTRowK := k * blockDim
			a0k := aT[aTRowK+i]
			a1k := aT[aTRowK+i+1]
			a2k := aT[aTRowK+i+2]
			a3k := aT[aTRowK+i+3]
			vA0 := asm.BroadcastFloat32x4(a0k)
			vA1 := asm.BroadcastFloat32x4(a1k)
			vA2 := asm.BroadcastFloat32x4(a2k)
			vA3 := asm.BroadcastFloat32x4(a3k)
			bRowStart := k * blockDim
			var j int
			for j = 0; j+lanes <= blockDim; j += lanes {
				vB := asm.LoadFloat32x4Slice(b[bRowStart+j:])
				vC0 := asm.LoadFloat32x4Slice(c[cRow0+j:])
				vC0 = vA0.MulAdd(vB, vC0)
				vC0.StoreSlice(c[cRow0+j:])
				vC1 := asm.LoadFloat32x4Slice(c[cRow1+j:])
				vC1 = vA1.MulAdd(vB, vC1)
				vC1.StoreSlice(c[cRow1+j:])
				vC2 := asm.LoadFloat32x4Slice(c[cRow2+j:])
				vC2 = vA2.MulAdd(vB, vC2)
				vC2.StoreSlice(c[cRow2+j:])
				vC3 := asm.LoadFloat32x4Slice(c[cRow3+j:])
				vC3 = vA3.MulAdd(vB, vC3)
				vC3.StoreSlice(c[cRow3+j:])
			}
			for ; j < blockDim; j++ {
				c[cRow0+j] += a0k * b[bRowStart+j]
				c[cRow1+j] += a1k * b[bRowStart+j]
				c[cRow2+j] += a2k * b[bRowStart+j]
				c[cRow3+j] += a3k * b[bRowStart+j]
			}
		}
	}
	for ; i < blockDim; i++ {
		cRowStart := i * blockDim
		for k := 0; k < blockDim; k++ {
			aik := aT[k*blockDim+i]
			vA := asm.BroadcastFloat32x4(aik)
			bRowStart := k * blockDim
			var j int
			for j = 0; j+lanes <= blockDim; j += lanes {
				vB := asm.LoadFloat32x4Slice(b[bRowStart+j:])
				vC := asm.LoadFloat32x4Slice(c[cRowStart+j:])
				vC = vA.MulAdd(vB, vC)
				vC.StoreSlice(c[cRowStart+j:])
			}
			for ; j < blockDim; j++ {
				c[cRowStart+j] += aik * b[bRowStart+j]
			}
		}
	}
}

func BaseBlockMulAdd4_neon_Float64(aT []float64, b []float64, c []float64, blockDim int) {
	if len(aT) < blockDim*blockDim {
		panic("BlockMulAdd4: aT slice too short")
	}
	if len(b) < blockDim*blockDim {
		panic("BlockMulAdd4: B slice too short")
	}
	if len(c) < blockDim*blockDim {
		panic("BlockMulAdd4: C slice too short")
	}
	lanes := 2
	var i int
	for i = 0; i+3 < blockDim; i += 4 {
		cRow0 := i * blockDim
		cRow1 := (i + 1) * blockDim
		cRow2 := (i + 2) * blockDim
		cRow3 := (i + 3) * blockDim
		for k := 0; k < blockDim; k++ {
			aTRowK := k * blockDim
			a0k := aT[aTRowK+i]
			a1k := aT[aTRowK+i+1]
			a2k := aT[aTRowK+i+2]
			a3k := aT[aTRowK+i+3]
			vA0 := asm.BroadcastFloat64x2(a0k)
			vA1 := asm.BroadcastFloat64x2(a1k)
			vA2 := asm.BroadcastFloat64x2(a2k)
			vA3 := asm.BroadcastFloat64x2(a3k)
			bRowStart := k * blockDim
			var j int
			for j = 0; j+lanes <= blockDim; j += lanes {
				vB := asm.LoadFloat64x2Slice(b[bRowStart+j:])
				vC0 := asm.LoadFloat64x2Slice(c[cRow0+j:])
				vC0 = vA0.MulAdd(vB, vC0)
				vC0.StoreSlice(c[cRow0+j:])
				vC1 := asm.LoadFloat64x2Slice(c[cRow1+j:])
				vC1 = vA1.MulAdd(vB, vC1)
				vC1.StoreSlice(c[cRow1+j:])
				vC2 := asm.LoadFloat64x2Slice(c[cRow2+j:])
				vC2 = vA2.MulAdd(vB, vC2)
				vC2.StoreSlice(c[cRow2+j:])
				vC3 := asm.LoadFloat64x2Slice(c[cRow3+j:])
				vC3 = vA3.MulAdd(vB, vC3)
				vC3.StoreSlice(c[cRow3+j:])
			}
			for ; j < blockDim; j++ {
				c[cRow0+j] += a0k * b[bRowStart+j]
				c[cRow1+j] += a1k * b[bRowStart+j]
				c[cRow2+j] += a2k * b[bRowStart+j]
				c[cRow3+j] += a3k * b[bRowStart+j]
			}
		}
	}
	for ; i < blockDim; i++ {
		cRowStart := i * blockDim
		for k := 0; k < blockDim; k++ {
			aik := aT[k*blockDim+i]
			vA := asm.BroadcastFloat64x2(aik)
			bRowStart := k * blockDim
			var j int
			for j = 0; j+lanes <= blockDim; j += lanes {
				vB := asm.LoadFloat64x2Slice(b[bRowStart+j:])
				vC := asm.LoadFloat64x2Slice(c[cRowStart+j:])
				vC = vA.MulAdd(vB, vC)
				vC.StoreSlice(c[cRowStart+j:])
			}
			for ; j < blockDim; j++ {
				c[cRowStart+j] += aik * b[bRowStart+j]
			}
		}
	}
}
