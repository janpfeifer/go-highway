// Code generated by hwygen. DO NOT EDIT.
//go:build amd64 && goexperiment.simd

package matmul

import (
	"github.com/ajroetker/go-highway/hwy"
	"simd/archsimd"
)

func BasePackRHSFast_avx512_Float16(b []hwy.Float16, packed []hwy.Float16, n int, rowStart int, colStart int, panelK int, panelCols int, nr int) {
	lanes := 32
	dstIdx := 0
	for stripColIdx := 0; stripColIdx < panelCols; stripColIdx += nr {
		validCols := min(nr, panelCols-stripColIdx)
		baseCol := colStart + stripColIdx
		if validCols == nr && nr >= lanes && nr%lanes == 0 {
			for kk := 0; kk < panelK; kk++ {
				srcIdx := (rowStart+kk)*n + baseCol
				for c := 0; c < nr; c += lanes {
					v := hwy.Load(b[srcIdx+c:])
					hwy.Store(v, packed[dstIdx+c:])
				}
				dstIdx += nr
			}
			continue
		}
		for kk := 0; kk < panelK; kk++ {
			srcIdx := (rowStart+kk)*n + baseCol
			for c := 0; c < validCols; c++ {
				packed[dstIdx] = hwy.Float32ToFloat16(b[srcIdx+c].Float32())
				dstIdx++
			}
			for c := validCols; c < nr; c++ {
				packed[dstIdx] = hwy.Float32ToFloat16(0)
				dstIdx++
			}
		}
	}
}

func BasePackRHSFast_avx512_BFloat16(b []hwy.BFloat16, packed []hwy.BFloat16, n int, rowStart int, colStart int, panelK int, panelCols int, nr int) {
	lanes := 32
	dstIdx := 0
	for stripColIdx := 0; stripColIdx < panelCols; stripColIdx += nr {
		validCols := min(nr, panelCols-stripColIdx)
		baseCol := colStart + stripColIdx
		if validCols == nr && nr >= lanes && nr%lanes == 0 {
			for kk := 0; kk < panelK; kk++ {
				srcIdx := (rowStart+kk)*n + baseCol
				for c := 0; c < nr; c += lanes {
					v := hwy.Load(b[srcIdx+c:])
					hwy.Store(v, packed[dstIdx+c:])
				}
				dstIdx += nr
			}
			continue
		}
		for kk := 0; kk < panelK; kk++ {
			srcIdx := (rowStart+kk)*n + baseCol
			for c := 0; c < validCols; c++ {
				packed[dstIdx] = hwy.Float32ToBFloat16(b[srcIdx+c].Float32())
				dstIdx++
			}
			for c := validCols; c < nr; c++ {
				packed[dstIdx] = hwy.Float32ToBFloat16(0)
				dstIdx++
			}
		}
	}
}

func BasePackRHSFast_avx512(b []float32, packed []float32, n int, rowStart int, colStart int, panelK int, panelCols int, nr int) {
	lanes := 16
	dstIdx := 0
	for stripColIdx := 0; stripColIdx < panelCols; stripColIdx += nr {
		validCols := min(nr, panelCols-stripColIdx)
		baseCol := colStart + stripColIdx
		if validCols == nr && nr >= lanes && nr%lanes == 0 {
			for kk := 0; kk < panelK; kk++ {
				srcIdx := (rowStart+kk)*n + baseCol
				for c := 0; c < nr; c += lanes {
					v := archsimd.LoadFloat32x16Slice(b[srcIdx+c:])
					v.StoreSlice(packed[dstIdx+c:])
				}
				dstIdx += nr
			}
			continue
		}
		for kk := 0; kk < panelK; kk++ {
			srcIdx := (rowStart+kk)*n + baseCol
			for c := 0; c < validCols; c++ {
				packed[dstIdx] = b[srcIdx+c]
				dstIdx++
			}
			for c := validCols; c < nr; c++ {
				packed[dstIdx] = 0
				dstIdx++
			}
		}
	}
}

func BasePackRHSFast_avx512_Float64(b []float64, packed []float64, n int, rowStart int, colStart int, panelK int, panelCols int, nr int) {
	lanes := 8
	dstIdx := 0
	for stripColIdx := 0; stripColIdx < panelCols; stripColIdx += nr {
		validCols := min(nr, panelCols-stripColIdx)
		baseCol := colStart + stripColIdx
		if validCols == nr && nr >= lanes && nr%lanes == 0 {
			for kk := 0; kk < panelK; kk++ {
				srcIdx := (rowStart+kk)*n + baseCol
				for c := 0; c < nr; c += lanes {
					v := archsimd.LoadFloat64x8Slice(b[srcIdx+c:])
					v.StoreSlice(packed[dstIdx+c:])
				}
				dstIdx += nr
			}
			continue
		}
		for kk := 0; kk < panelK; kk++ {
			srcIdx := (rowStart+kk)*n + baseCol
			for c := 0; c < validCols; c++ {
				packed[dstIdx] = b[srcIdx+c]
				dstIdx++
			}
			for c := validCols; c < nr; c++ {
				packed[dstIdx] = 0
				dstIdx++
			}
		}
	}
}

func BaseApplyPackedOutput_avx512_Float16(packedOutput []hwy.Float16, output []hwy.Float16, alpha hwy.Float16, beta hwy.Float16, packedStride int, outputRowOffset int, outputColOffset int, outputStride int, height int, width int) {
	lanes := 32
	alphaVec := hwy.Set(alpha)
	betaVec := hwy.Set(beta)
	for r := 0; r < height; r++ {
		packedIdx := r * packedStride
		outputIdx := (outputRowOffset+r)*outputStride + outputColOffset
		c := 0
		for ; c+lanes <= width; c += lanes {
			packedVal := hwy.Load(packedOutput[packedIdx+c:])
			outputVal := hwy.Load(output[outputIdx+c:])
			scaledOutput := hwy.MulF16(outputVal, betaVec)
			newVal := hwy.FMAF16(packedVal, alphaVec, scaledOutput)
			hwy.Store(newVal, output[outputIdx+c:])
		}
		for ; c < width; c++ {
			val := packedOutput[packedIdx+c]
			output[outputIdx+c] = hwy.Float32ToFloat16(beta.Float32()*output[outputIdx+c].Float32() + alpha.Float32()*val.Float32())
		}
	}
}

func BaseApplyPackedOutput_avx512_BFloat16(packedOutput []hwy.BFloat16, output []hwy.BFloat16, alpha hwy.BFloat16, beta hwy.BFloat16, packedStride int, outputRowOffset int, outputColOffset int, outputStride int, height int, width int) {
	lanes := 32
	alphaVec := hwy.Set(alpha)
	betaVec := hwy.Set(beta)
	for r := 0; r < height; r++ {
		packedIdx := r * packedStride
		outputIdx := (outputRowOffset+r)*outputStride + outputColOffset
		c := 0
		for ; c+lanes <= width; c += lanes {
			packedVal := hwy.Load(packedOutput[packedIdx+c:])
			outputVal := hwy.Load(output[outputIdx+c:])
			scaledOutput := hwy.MulBF16(outputVal, betaVec)
			newVal := hwy.FMABF16(packedVal, alphaVec, scaledOutput)
			hwy.Store(newVal, output[outputIdx+c:])
		}
		for ; c < width; c++ {
			val := packedOutput[packedIdx+c]
			output[outputIdx+c] = hwy.Float32ToBFloat16(beta.Float32()*output[outputIdx+c].Float32() + alpha.Float32()*val.Float32())
		}
	}
}

func BaseApplyPackedOutput_avx512(packedOutput []float32, output []float32, alpha float32, beta float32, packedStride int, outputRowOffset int, outputColOffset int, outputStride int, height int, width int) {
	lanes := 16
	alphaVec := archsimd.BroadcastFloat32x16(alpha)
	betaVec := archsimd.BroadcastFloat32x16(beta)
	for r := 0; r < height; r++ {
		packedIdx := r * packedStride
		outputIdx := (outputRowOffset+r)*outputStride + outputColOffset
		c := 0
		for ; c+lanes <= width; c += lanes {
			packedVal := archsimd.LoadFloat32x16Slice(packedOutput[packedIdx+c:])
			outputVal := archsimd.LoadFloat32x16Slice(output[outputIdx+c:])
			scaledOutput := outputVal.Mul(betaVec)
			newVal := packedVal.MulAdd(alphaVec, scaledOutput)
			newVal.StoreSlice(output[outputIdx+c:])
		}
		for ; c < width; c++ {
			val := packedOutput[packedIdx+c]
			output[outputIdx+c] = beta*output[outputIdx+c] + alpha*val
		}
	}
}

func BaseApplyPackedOutput_avx512_Float64(packedOutput []float64, output []float64, alpha float64, beta float64, packedStride int, outputRowOffset int, outputColOffset int, outputStride int, height int, width int) {
	lanes := 8
	alphaVec := archsimd.BroadcastFloat64x8(alpha)
	betaVec := archsimd.BroadcastFloat64x8(beta)
	for r := 0; r < height; r++ {
		packedIdx := r * packedStride
		outputIdx := (outputRowOffset+r)*outputStride + outputColOffset
		c := 0
		for ; c+lanes <= width; c += lanes {
			packedVal := archsimd.LoadFloat64x8Slice(packedOutput[packedIdx+c:])
			outputVal := archsimd.LoadFloat64x8Slice(output[outputIdx+c:])
			scaledOutput := outputVal.Mul(betaVec)
			newVal := packedVal.MulAdd(alphaVec, scaledOutput)
			newVal.StoreSlice(output[outputIdx+c:])
		}
		for ; c < width; c++ {
			val := packedOutput[packedIdx+c]
			output[outputIdx+c] = beta*output[outputIdx+c] + alpha*val
		}
	}
}

func BaseApplyPackedOutputSimple_avx512_Float16(packedOutput []hwy.Float16, output []hwy.Float16, packedStride int, outputRowOffset int, outputColOffset int, outputStride int, height int, width int) {
	lanes := 32
	for r := 0; r < height; r++ {
		packedIdx := r * packedStride
		outputIdx := (outputRowOffset+r)*outputStride + outputColOffset
		c := 0
		for ; c+lanes <= width; c += lanes {
			v := hwy.Load(packedOutput[packedIdx+c:])
			hwy.Store(v, output[outputIdx+c:])
		}
		for ; c < width; c++ {
			output[outputIdx+c] = hwy.Float32ToFloat16(packedOutput[packedIdx+c].Float32())
		}
	}
}

func BaseApplyPackedOutputSimple_avx512_BFloat16(packedOutput []hwy.BFloat16, output []hwy.BFloat16, packedStride int, outputRowOffset int, outputColOffset int, outputStride int, height int, width int) {
	lanes := 32
	for r := 0; r < height; r++ {
		packedIdx := r * packedStride
		outputIdx := (outputRowOffset+r)*outputStride + outputColOffset
		c := 0
		for ; c+lanes <= width; c += lanes {
			v := hwy.Load(packedOutput[packedIdx+c:])
			hwy.Store(v, output[outputIdx+c:])
		}
		for ; c < width; c++ {
			output[outputIdx+c] = hwy.Float32ToBFloat16(packedOutput[packedIdx+c].Float32())
		}
	}
}

func BaseApplyPackedOutputSimple_avx512(packedOutput []float32, output []float32, packedStride int, outputRowOffset int, outputColOffset int, outputStride int, height int, width int) {
	lanes := 16
	for r := 0; r < height; r++ {
		packedIdx := r * packedStride
		outputIdx := (outputRowOffset+r)*outputStride + outputColOffset
		c := 0
		for ; c+lanes <= width; c += lanes {
			v := archsimd.LoadFloat32x16Slice(packedOutput[packedIdx+c:])
			v.StoreSlice(output[outputIdx+c:])
		}
		for ; c < width; c++ {
			output[outputIdx+c] = packedOutput[packedIdx+c]
		}
	}
}

func BaseApplyPackedOutputSimple_avx512_Float64(packedOutput []float64, output []float64, packedStride int, outputRowOffset int, outputColOffset int, outputStride int, height int, width int) {
	lanes := 8
	for r := 0; r < height; r++ {
		packedIdx := r * packedStride
		outputIdx := (outputRowOffset+r)*outputStride + outputColOffset
		c := 0
		for ; c+lanes <= width; c += lanes {
			v := archsimd.LoadFloat64x8Slice(packedOutput[packedIdx+c:])
			v.StoreSlice(output[outputIdx+c:])
		}
		for ; c < width; c++ {
			output[outputIdx+c] = packedOutput[packedIdx+c]
		}
	}
}

func BaseApplyPackedOutputAccum_avx512_Float16(packedOutput []hwy.Float16, output []hwy.Float16, packedStride int, outputRowOffset int, outputColOffset int, outputStride int, height int, width int) {
	lanes := 32
	for r := 0; r < height; r++ {
		packedIdx := r * packedStride
		outputIdx := (outputRowOffset+r)*outputStride + outputColOffset
		c := 0
		for ; c+lanes <= width; c += lanes {
			packedVal := hwy.Load(packedOutput[packedIdx+c:])
			outputVal := hwy.Load(output[outputIdx+c:])
			newVal := hwy.AddF16(outputVal, packedVal)
			hwy.Store(newVal, output[outputIdx+c:])
		}
		for ; c < width; c++ {
			output[outputIdx+c] = hwy.Float32ToFloat16(output[outputIdx+c].Float32() + packedOutput[packedIdx+c].Float32())
		}
	}
}

func BaseApplyPackedOutputAccum_avx512_BFloat16(packedOutput []hwy.BFloat16, output []hwy.BFloat16, packedStride int, outputRowOffset int, outputColOffset int, outputStride int, height int, width int) {
	lanes := 32
	for r := 0; r < height; r++ {
		packedIdx := r * packedStride
		outputIdx := (outputRowOffset+r)*outputStride + outputColOffset
		c := 0
		for ; c+lanes <= width; c += lanes {
			packedVal := hwy.Load(packedOutput[packedIdx+c:])
			outputVal := hwy.Load(output[outputIdx+c:])
			newVal := hwy.AddBF16(outputVal, packedVal)
			hwy.Store(newVal, output[outputIdx+c:])
		}
		for ; c < width; c++ {
			output[outputIdx+c] = hwy.Float32ToBFloat16(output[outputIdx+c].Float32() + packedOutput[packedIdx+c].Float32())
		}
	}
}

func BaseApplyPackedOutputAccum_avx512(packedOutput []float32, output []float32, packedStride int, outputRowOffset int, outputColOffset int, outputStride int, height int, width int) {
	lanes := 16
	for r := 0; r < height; r++ {
		packedIdx := r * packedStride
		outputIdx := (outputRowOffset+r)*outputStride + outputColOffset
		c := 0
		for ; c+lanes <= width; c += lanes {
			packedVal := archsimd.LoadFloat32x16Slice(packedOutput[packedIdx+c:])
			outputVal := archsimd.LoadFloat32x16Slice(output[outputIdx+c:])
			newVal := outputVal.Add(packedVal)
			newVal.StoreSlice(output[outputIdx+c:])
		}
		for ; c < width; c++ {
			output[outputIdx+c] += packedOutput[packedIdx+c]
		}
	}
}

func BaseApplyPackedOutputAccum_avx512_Float64(packedOutput []float64, output []float64, packedStride int, outputRowOffset int, outputColOffset int, outputStride int, height int, width int) {
	lanes := 8
	for r := 0; r < height; r++ {
		packedIdx := r * packedStride
		outputIdx := (outputRowOffset+r)*outputStride + outputColOffset
		c := 0
		for ; c+lanes <= width; c += lanes {
			packedVal := archsimd.LoadFloat64x8Slice(packedOutput[packedIdx+c:])
			outputVal := archsimd.LoadFloat64x8Slice(output[outputIdx+c:])
			newVal := outputVal.Add(packedVal)
			newVal.StoreSlice(output[outputIdx+c:])
		}
		for ; c < width; c++ {
			output[outputIdx+c] += packedOutput[packedIdx+c]
		}
	}
}
