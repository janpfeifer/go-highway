// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

//go:build amd64 && goexperiment.simd

package matmul

import (
	"simd/archsimd"
	"unsafe"

	"github.com/ajroetker/go-highway/hwy"
	"github.com/ajroetker/go-highway/hwy/asm"
)

func BaseBlockedMatMul_avx2_Float16(a []hwy.Float16, b []hwy.Float16, c []hwy.Float16, m int, n int, k int) {
	if len(a) < m*k {
		panic("matmul: A slice too short")
	}
	if len(b) < k*n {
		panic("matmul: B slice too short")
	}
	if len(c) < m*n {
		panic("matmul: C slice too short")
	}
	vZero := asm.ZeroFloat16x8AVX2()
	lanes := 8
	total := m * n
	var idx int
	for idx = 0; idx+lanes <= total; idx += lanes {
		vZero.StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(c[idx:]))), len(c[idx:])))
	}
	for ; idx < total; idx++ {
		c[idx] = hwy.Float32ToFloat16(0)
	}
	mr := 4
	nr := lanes * 2
	for i0 := 0; i0 < m; i0 += BlockSize {
		iEnd := min(i0+BlockSize, m)
		for j0 := 0; j0 < n; j0 += BlockSize {
			jEnd := min(j0+BlockSize, n)
			var i int
			for i = i0; i+mr <= iEnd; i += mr {
				var j int
				for j = j0; j+nr <= jEnd; j += nr {
					acc00 := asm.ZeroFloat16x8AVX2()
					acc01 := asm.ZeroFloat16x8AVX2()
					acc10 := asm.ZeroFloat16x8AVX2()
					acc11 := asm.ZeroFloat16x8AVX2()
					acc20 := asm.ZeroFloat16x8AVX2()
					acc21 := asm.ZeroFloat16x8AVX2()
					acc30 := asm.ZeroFloat16x8AVX2()
					acc31 := asm.ZeroFloat16x8AVX2()
					for p := 0; p < k; p++ {
						a0p := a[i*k+p]
						a1p := a[(i+1)*k+p]
						a2p := a[(i+2)*k+p]
						a3p := a[(i+3)*k+p]
						vA0 := asm.BroadcastFloat16x8AVX2(uint16(a0p))
						vA1 := asm.BroadcastFloat16x8AVX2(uint16(a1p))
						vA2 := asm.BroadcastFloat16x8AVX2(uint16(a2p))
						vA3 := asm.BroadcastFloat16x8AVX2(uint16(a3p))
						bRowStart := p * n
						vB0 := asm.LoadFloat16x8AVX2Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(b[bRowStart+j:]))), len(b[bRowStart+j:])))
						vB1 := asm.LoadFloat16x8AVX2Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(b[bRowStart+j+lanes:]))), len(b[bRowStart+j+lanes:])))
						acc00 = vA0.MulAdd(vB0, acc00)
						acc01 = vA0.MulAdd(vB1, acc01)
						acc10 = vA1.MulAdd(vB0, acc10)
						acc11 = vA1.MulAdd(vB1, acc11)
						acc20 = vA2.MulAdd(vB0, acc20)
						acc21 = vA2.MulAdd(vB1, acc21)
						acc30 = vA3.MulAdd(vB0, acc30)
						acc31 = vA3.MulAdd(vB1, acc31)
					}
					cRow0 := i * n
					cRow1 := (i + 1) * n
					cRow2 := (i + 2) * n
					cRow3 := (i + 3) * n
					acc00.StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(c[cRow0+j:]))), len(c[cRow0+j:])))
					acc01.StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(c[cRow0+j+lanes:]))), len(c[cRow0+j+lanes:])))
					acc10.StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(c[cRow1+j:]))), len(c[cRow1+j:])))
					acc11.StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(c[cRow1+j+lanes:]))), len(c[cRow1+j+lanes:])))
					acc20.StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(c[cRow2+j:]))), len(c[cRow2+j:])))
					acc21.StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(c[cRow2+j+lanes:]))), len(c[cRow2+j+lanes:])))
					acc30.StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(c[cRow3+j:]))), len(c[cRow3+j:])))
					acc31.StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(c[cRow3+j+lanes:]))), len(c[cRow3+j+lanes:])))
				}
				for ; j < jEnd; j += lanes {
					remaining := jEnd - j
					if remaining >= lanes {
						acc0 := asm.ZeroFloat16x8AVX2()
						acc1 := asm.ZeroFloat16x8AVX2()
						acc2 := asm.ZeroFloat16x8AVX2()
						acc3 := asm.ZeroFloat16x8AVX2()
						for p := 0; p < k; p++ {
							vA0 := asm.BroadcastFloat16x8AVX2(uint16(a[i*k+p]))
							vA1 := asm.BroadcastFloat16x8AVX2(uint16(a[(i+1)*k+p]))
							vA2 := asm.BroadcastFloat16x8AVX2(uint16(a[(i+2)*k+p]))
							vA3 := asm.BroadcastFloat16x8AVX2(uint16(a[(i+3)*k+p]))
							vB := asm.LoadFloat16x8AVX2Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(b[p*n+j:]))), len(b[p*n+j:])))
							acc0 = vA0.MulAdd(vB, acc0)
							acc1 = vA1.MulAdd(vB, acc1)
							acc2 = vA2.MulAdd(vB, acc2)
							acc3 = vA3.MulAdd(vB, acc3)
						}
						acc0.StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(c[i*n+j:]))), len(c[i*n+j:])))
						acc1.StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(c[(i+1)*n+j:]))), len(c[(i+1)*n+j:])))
						acc2.StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(c[(i+2)*n+j:]))), len(c[(i+2)*n+j:])))
						acc3.StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(c[(i+3)*n+j:]))), len(c[(i+3)*n+j:])))
					} else {
						for jj := j; jj < jEnd; jj++ {
							var sum0, sum1, sum2, sum3 float32
							for p := 0; p < k; p++ {
								bpj := b[p*n+jj]
								sum0 += a[i*k+p].Float32() * bpj.Float32()
								sum1 += a[(i+1)*k+p].Float32() * bpj.Float32()
								sum2 += a[(i+2)*k+p].Float32() * bpj.Float32()
								sum3 += a[(i+3)*k+p].Float32() * bpj.Float32()
							}
							c[i*n+jj] = hwy.Float32ToFloat16(sum0)
							c[(i+1)*n+jj] = hwy.Float32ToFloat16(sum1)
							c[(i+2)*n+jj] = hwy.Float32ToFloat16(sum2)
							c[(i+3)*n+jj] = hwy.Float32ToFloat16(sum3)
						}
						break
					}
				}
			}
			for i+2 <= iEnd {
				cRow0 := i * n
				cRow1 := (i + 1) * n
				var j int
				for j = j0; j+lanes <= jEnd; j += lanes {
					acc0 := asm.ZeroFloat16x8AVX2()
					acc1 := asm.ZeroFloat16x8AVX2()
					for p := 0; p < k; p++ {
						vA0 := asm.BroadcastFloat16x8AVX2(uint16(a[i*k+p]))
						vA1 := asm.BroadcastFloat16x8AVX2(uint16(a[(i+1)*k+p]))
						vB := asm.LoadFloat16x8AVX2Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(b[p*n+j:]))), len(b[p*n+j:])))
						acc0 = vA0.MulAdd(vB, acc0)
						acc1 = vA1.MulAdd(vB, acc1)
					}
					acc0.StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(c[cRow0+j:]))), len(c[cRow0+j:])))
					acc1.StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(c[cRow1+j:]))), len(c[cRow1+j:])))
				}
				for ; j < jEnd; j++ {
					var sum0, sum1 float32
					for p := 0; p < k; p++ {
						bp := b[p*n+j]
						sum0 += a[i*k+p].Float32() * bp.Float32()
						sum1 += a[(i+1)*k+p].Float32() * bp.Float32()
					}
					c[cRow0+j] = hwy.Float32ToFloat16(sum0)
					c[cRow1+j] = hwy.Float32ToFloat16(sum1)
				}
				i += 2
			}
			for ; i < iEnd; i++ {
				cRowStart := i * n
				var j int
				for j = j0; j+lanes <= jEnd; j += lanes {
					acc := asm.ZeroFloat16x8AVX2()
					for p := 0; p < k; p++ {
						vA := asm.BroadcastFloat16x8AVX2(uint16(a[i*k+p]))
						vB := asm.LoadFloat16x8AVX2Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(b[p*n+j:]))), len(b[p*n+j:])))
						acc = vA.MulAdd(vB, acc)
					}
					acc.StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(c[cRowStart+j:]))), len(c[cRowStart+j:])))
				}
				for ; j < jEnd; j++ {
					var sum float32
					for p := 0; p < k; p++ {
						sum += a[i*k+p].Float32() * b[p*n+j].Float32()
					}
					c[cRowStart+j] = hwy.Float32ToFloat16(sum)
				}
			}
		}
	}
}

func BaseBlockedMatMul_avx2_BFloat16(a []hwy.BFloat16, b []hwy.BFloat16, c []hwy.BFloat16, m int, n int, k int) {
	if len(a) < m*k {
		panic("matmul: A slice too short")
	}
	if len(b) < k*n {
		panic("matmul: B slice too short")
	}
	if len(c) < m*n {
		panic("matmul: C slice too short")
	}
	vZero := asm.ZeroBFloat16x8AVX2()
	lanes := 8
	total := m * n
	var idx int
	for idx = 0; idx+lanes <= total; idx += lanes {
		vZero.StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(c[idx:]))), len(c[idx:])))
	}
	for ; idx < total; idx++ {
		c[idx] = hwy.Float32ToBFloat16(0)
	}
	mr := 4
	nr := lanes * 2
	for i0 := 0; i0 < m; i0 += BlockSize {
		iEnd := min(i0+BlockSize, m)
		for j0 := 0; j0 < n; j0 += BlockSize {
			jEnd := min(j0+BlockSize, n)
			var i int
			for i = i0; i+mr <= iEnd; i += mr {
				var j int
				for j = j0; j+nr <= jEnd; j += nr {
					acc00 := asm.ZeroBFloat16x8AVX2()
					acc01 := asm.ZeroBFloat16x8AVX2()
					acc10 := asm.ZeroBFloat16x8AVX2()
					acc11 := asm.ZeroBFloat16x8AVX2()
					acc20 := asm.ZeroBFloat16x8AVX2()
					acc21 := asm.ZeroBFloat16x8AVX2()
					acc30 := asm.ZeroBFloat16x8AVX2()
					acc31 := asm.ZeroBFloat16x8AVX2()
					for p := 0; p < k; p++ {
						a0p := a[i*k+p]
						a1p := a[(i+1)*k+p]
						a2p := a[(i+2)*k+p]
						a3p := a[(i+3)*k+p]
						vA0 := asm.BroadcastBFloat16x8AVX2(uint16(a0p))
						vA1 := asm.BroadcastBFloat16x8AVX2(uint16(a1p))
						vA2 := asm.BroadcastBFloat16x8AVX2(uint16(a2p))
						vA3 := asm.BroadcastBFloat16x8AVX2(uint16(a3p))
						bRowStart := p * n
						vB0 := asm.LoadBFloat16x8AVX2Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(b[bRowStart+j:]))), len(b[bRowStart+j:])))
						vB1 := asm.LoadBFloat16x8AVX2Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(b[bRowStart+j+lanes:]))), len(b[bRowStart+j+lanes:])))
						acc00 = vA0.MulAdd(vB0, acc00)
						acc01 = vA0.MulAdd(vB1, acc01)
						acc10 = vA1.MulAdd(vB0, acc10)
						acc11 = vA1.MulAdd(vB1, acc11)
						acc20 = vA2.MulAdd(vB0, acc20)
						acc21 = vA2.MulAdd(vB1, acc21)
						acc30 = vA3.MulAdd(vB0, acc30)
						acc31 = vA3.MulAdd(vB1, acc31)
					}
					cRow0 := i * n
					cRow1 := (i + 1) * n
					cRow2 := (i + 2) * n
					cRow3 := (i + 3) * n
					acc00.StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(c[cRow0+j:]))), len(c[cRow0+j:])))
					acc01.StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(c[cRow0+j+lanes:]))), len(c[cRow0+j+lanes:])))
					acc10.StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(c[cRow1+j:]))), len(c[cRow1+j:])))
					acc11.StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(c[cRow1+j+lanes:]))), len(c[cRow1+j+lanes:])))
					acc20.StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(c[cRow2+j:]))), len(c[cRow2+j:])))
					acc21.StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(c[cRow2+j+lanes:]))), len(c[cRow2+j+lanes:])))
					acc30.StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(c[cRow3+j:]))), len(c[cRow3+j:])))
					acc31.StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(c[cRow3+j+lanes:]))), len(c[cRow3+j+lanes:])))
				}
				for ; j < jEnd; j += lanes {
					remaining := jEnd - j
					if remaining >= lanes {
						acc0 := asm.ZeroBFloat16x8AVX2()
						acc1 := asm.ZeroBFloat16x8AVX2()
						acc2 := asm.ZeroBFloat16x8AVX2()
						acc3 := asm.ZeroBFloat16x8AVX2()
						for p := 0; p < k; p++ {
							vA0 := asm.BroadcastBFloat16x8AVX2(uint16(a[i*k+p]))
							vA1 := asm.BroadcastBFloat16x8AVX2(uint16(a[(i+1)*k+p]))
							vA2 := asm.BroadcastBFloat16x8AVX2(uint16(a[(i+2)*k+p]))
							vA3 := asm.BroadcastBFloat16x8AVX2(uint16(a[(i+3)*k+p]))
							vB := asm.LoadBFloat16x8AVX2Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(b[p*n+j:]))), len(b[p*n+j:])))
							acc0 = vA0.MulAdd(vB, acc0)
							acc1 = vA1.MulAdd(vB, acc1)
							acc2 = vA2.MulAdd(vB, acc2)
							acc3 = vA3.MulAdd(vB, acc3)
						}
						acc0.StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(c[i*n+j:]))), len(c[i*n+j:])))
						acc1.StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(c[(i+1)*n+j:]))), len(c[(i+1)*n+j:])))
						acc2.StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(c[(i+2)*n+j:]))), len(c[(i+2)*n+j:])))
						acc3.StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(c[(i+3)*n+j:]))), len(c[(i+3)*n+j:])))
					} else {
						for jj := j; jj < jEnd; jj++ {
							var sum0, sum1, sum2, sum3 float32
							for p := 0; p < k; p++ {
								bpj := b[p*n+jj]
								sum0 += a[i*k+p].Float32() * bpj.Float32()
								sum1 += a[(i+1)*k+p].Float32() * bpj.Float32()
								sum2 += a[(i+2)*k+p].Float32() * bpj.Float32()
								sum3 += a[(i+3)*k+p].Float32() * bpj.Float32()
							}
							c[i*n+jj] = hwy.Float32ToBFloat16(sum0)
							c[(i+1)*n+jj] = hwy.Float32ToBFloat16(sum1)
							c[(i+2)*n+jj] = hwy.Float32ToBFloat16(sum2)
							c[(i+3)*n+jj] = hwy.Float32ToBFloat16(sum3)
						}
						break
					}
				}
			}
			for i+2 <= iEnd {
				cRow0 := i * n
				cRow1 := (i + 1) * n
				var j int
				for j = j0; j+lanes <= jEnd; j += lanes {
					acc0 := asm.ZeroBFloat16x8AVX2()
					acc1 := asm.ZeroBFloat16x8AVX2()
					for p := 0; p < k; p++ {
						vA0 := asm.BroadcastBFloat16x8AVX2(uint16(a[i*k+p]))
						vA1 := asm.BroadcastBFloat16x8AVX2(uint16(a[(i+1)*k+p]))
						vB := asm.LoadBFloat16x8AVX2Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(b[p*n+j:]))), len(b[p*n+j:])))
						acc0 = vA0.MulAdd(vB, acc0)
						acc1 = vA1.MulAdd(vB, acc1)
					}
					acc0.StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(c[cRow0+j:]))), len(c[cRow0+j:])))
					acc1.StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(c[cRow1+j:]))), len(c[cRow1+j:])))
				}
				for ; j < jEnd; j++ {
					var sum0, sum1 float32
					for p := 0; p < k; p++ {
						bp := b[p*n+j]
						sum0 += a[i*k+p].Float32() * bp.Float32()
						sum1 += a[(i+1)*k+p].Float32() * bp.Float32()
					}
					c[cRow0+j] = hwy.Float32ToBFloat16(sum0)
					c[cRow1+j] = hwy.Float32ToBFloat16(sum1)
				}
				i += 2
			}
			for ; i < iEnd; i++ {
				cRowStart := i * n
				var j int
				for j = j0; j+lanes <= jEnd; j += lanes {
					acc := asm.ZeroBFloat16x8AVX2()
					for p := 0; p < k; p++ {
						vA := asm.BroadcastBFloat16x8AVX2(uint16(a[i*k+p]))
						vB := asm.LoadBFloat16x8AVX2Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(b[p*n+j:]))), len(b[p*n+j:])))
						acc = vA.MulAdd(vB, acc)
					}
					acc.StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(c[cRowStart+j:]))), len(c[cRowStart+j:])))
				}
				for ; j < jEnd; j++ {
					var sum float32
					for p := 0; p < k; p++ {
						sum += a[i*k+p].Float32() * b[p*n+j].Float32()
					}
					c[cRowStart+j] = hwy.Float32ToBFloat16(sum)
				}
			}
		}
	}
}

func BaseBlockedMatMul_avx2(a []float32, b []float32, c []float32, m int, n int, k int) {
	if len(a) < m*k {
		panic("matmul: A slice too short")
	}
	if len(b) < k*n {
		panic("matmul: B slice too short")
	}
	if len(c) < m*n {
		panic("matmul: C slice too short")
	}
	vZero := archsimd.BroadcastFloat32x8(0)
	lanes := 8
	total := m * n
	var idx int
	for idx = 0; idx+lanes <= total; idx += lanes {
		vZero.StoreSlice(c[idx:])
	}
	for ; idx < total; idx++ {
		c[idx] = 0
	}
	mr := 4
	nr := lanes * 2
	for i0 := 0; i0 < m; i0 += BlockSize {
		iEnd := min(i0+BlockSize, m)
		for j0 := 0; j0 < n; j0 += BlockSize {
			jEnd := min(j0+BlockSize, n)
			var i int
			for i = i0; i+mr <= iEnd; i += mr {
				var j int
				for j = j0; j+nr <= jEnd; j += nr {
					acc00 := archsimd.BroadcastFloat32x8(0)
					acc01 := archsimd.BroadcastFloat32x8(0)
					acc10 := archsimd.BroadcastFloat32x8(0)
					acc11 := archsimd.BroadcastFloat32x8(0)
					acc20 := archsimd.BroadcastFloat32x8(0)
					acc21 := archsimd.BroadcastFloat32x8(0)
					acc30 := archsimd.BroadcastFloat32x8(0)
					acc31 := archsimd.BroadcastFloat32x8(0)
					for p := 0; p < k; p++ {
						a0p := a[i*k+p]
						a1p := a[(i+1)*k+p]
						a2p := a[(i+2)*k+p]
						a3p := a[(i+3)*k+p]
						vA0 := archsimd.BroadcastFloat32x8(a0p)
						vA1 := archsimd.BroadcastFloat32x8(a1p)
						vA2 := archsimd.BroadcastFloat32x8(a2p)
						vA3 := archsimd.BroadcastFloat32x8(a3p)
						bRowStart := p * n
						vB0 := archsimd.LoadFloat32x8Slice(b[bRowStart+j:])
						vB1 := archsimd.LoadFloat32x8Slice(b[bRowStart+j+lanes:])
						acc00 = vA0.MulAdd(vB0, acc00)
						acc01 = vA0.MulAdd(vB1, acc01)
						acc10 = vA1.MulAdd(vB0, acc10)
						acc11 = vA1.MulAdd(vB1, acc11)
						acc20 = vA2.MulAdd(vB0, acc20)
						acc21 = vA2.MulAdd(vB1, acc21)
						acc30 = vA3.MulAdd(vB0, acc30)
						acc31 = vA3.MulAdd(vB1, acc31)
					}
					cRow0 := i * n
					cRow1 := (i + 1) * n
					cRow2 := (i + 2) * n
					cRow3 := (i + 3) * n
					acc00.StoreSlice(c[cRow0+j:])
					acc01.StoreSlice(c[cRow0+j+lanes:])
					acc10.StoreSlice(c[cRow1+j:])
					acc11.StoreSlice(c[cRow1+j+lanes:])
					acc20.StoreSlice(c[cRow2+j:])
					acc21.StoreSlice(c[cRow2+j+lanes:])
					acc30.StoreSlice(c[cRow3+j:])
					acc31.StoreSlice(c[cRow3+j+lanes:])
				}
				for ; j < jEnd; j += lanes {
					remaining := jEnd - j
					if remaining >= lanes {
						acc0 := archsimd.BroadcastFloat32x8(0)
						acc1 := archsimd.BroadcastFloat32x8(0)
						acc2 := archsimd.BroadcastFloat32x8(0)
						acc3 := archsimd.BroadcastFloat32x8(0)
						for p := 0; p < k; p++ {
							vA0 := archsimd.BroadcastFloat32x8(a[i*k+p])
							vA1 := archsimd.BroadcastFloat32x8(a[(i+1)*k+p])
							vA2 := archsimd.BroadcastFloat32x8(a[(i+2)*k+p])
							vA3 := archsimd.BroadcastFloat32x8(a[(i+3)*k+p])
							vB := archsimd.LoadFloat32x8Slice(b[p*n+j:])
							acc0 = vA0.MulAdd(vB, acc0)
							acc1 = vA1.MulAdd(vB, acc1)
							acc2 = vA2.MulAdd(vB, acc2)
							acc3 = vA3.MulAdd(vB, acc3)
						}
						acc0.StoreSlice(c[i*n+j:])
						acc1.StoreSlice(c[(i+1)*n+j:])
						acc2.StoreSlice(c[(i+2)*n+j:])
						acc3.StoreSlice(c[(i+3)*n+j:])
					} else {
						for jj := j; jj < jEnd; jj++ {
							var sum0, sum1, sum2, sum3 float32
							for p := 0; p < k; p++ {
								bpj := b[p*n+jj]
								sum0 += a[i*k+p] * bpj
								sum1 += a[(i+1)*k+p] * bpj
								sum2 += a[(i+2)*k+p] * bpj
								sum3 += a[(i+3)*k+p] * bpj
							}
							c[i*n+jj] = sum0
							c[(i+1)*n+jj] = sum1
							c[(i+2)*n+jj] = sum2
							c[(i+3)*n+jj] = sum3
						}
						break
					}
				}
			}
			for i+2 <= iEnd {
				cRow0 := i * n
				cRow1 := (i + 1) * n
				var j int
				for j = j0; j+lanes <= jEnd; j += lanes {
					acc0 := archsimd.BroadcastFloat32x8(0)
					acc1 := archsimd.BroadcastFloat32x8(0)
					for p := 0; p < k; p++ {
						vA0 := archsimd.BroadcastFloat32x8(a[i*k+p])
						vA1 := archsimd.BroadcastFloat32x8(a[(i+1)*k+p])
						vB := archsimd.LoadFloat32x8Slice(b[p*n+j:])
						acc0 = vA0.MulAdd(vB, acc0)
						acc1 = vA1.MulAdd(vB, acc1)
					}
					acc0.StoreSlice(c[cRow0+j:])
					acc1.StoreSlice(c[cRow1+j:])
				}
				for ; j < jEnd; j++ {
					var sum0, sum1 float32
					for p := 0; p < k; p++ {
						bp := b[p*n+j]
						sum0 += a[i*k+p] * bp
						sum1 += a[(i+1)*k+p] * bp
					}
					c[cRow0+j] = sum0
					c[cRow1+j] = sum1
				}
				i += 2
			}
			for ; i < iEnd; i++ {
				cRowStart := i * n
				var j int
				for j = j0; j+lanes <= jEnd; j += lanes {
					acc := archsimd.BroadcastFloat32x8(0)
					for p := 0; p < k; p++ {
						vA := archsimd.BroadcastFloat32x8(a[i*k+p])
						vB := archsimd.LoadFloat32x8Slice(b[p*n+j:])
						acc = vA.MulAdd(vB, acc)
					}
					acc.StoreSlice(c[cRowStart+j:])
				}
				for ; j < jEnd; j++ {
					var sum float32
					for p := 0; p < k; p++ {
						sum += a[i*k+p] * b[p*n+j]
					}
					c[cRowStart+j] = sum
				}
			}
		}
	}
}

func BaseBlockedMatMul_avx2_Float64(a []float64, b []float64, c []float64, m int, n int, k int) {
	if len(a) < m*k {
		panic("matmul: A slice too short")
	}
	if len(b) < k*n {
		panic("matmul: B slice too short")
	}
	if len(c) < m*n {
		panic("matmul: C slice too short")
	}
	vZero := archsimd.BroadcastFloat64x4(0)
	lanes := 4
	total := m * n
	var idx int
	for idx = 0; idx+lanes <= total; idx += lanes {
		vZero.StoreSlice(c[idx:])
	}
	for ; idx < total; idx++ {
		c[idx] = 0
	}
	mr := 4
	nr := lanes * 2
	for i0 := 0; i0 < m; i0 += BlockSize {
		iEnd := min(i0+BlockSize, m)
		for j0 := 0; j0 < n; j0 += BlockSize {
			jEnd := min(j0+BlockSize, n)
			var i int
			for i = i0; i+mr <= iEnd; i += mr {
				var j int
				for j = j0; j+nr <= jEnd; j += nr {
					acc00 := archsimd.BroadcastFloat64x4(0)
					acc01 := archsimd.BroadcastFloat64x4(0)
					acc10 := archsimd.BroadcastFloat64x4(0)
					acc11 := archsimd.BroadcastFloat64x4(0)
					acc20 := archsimd.BroadcastFloat64x4(0)
					acc21 := archsimd.BroadcastFloat64x4(0)
					acc30 := archsimd.BroadcastFloat64x4(0)
					acc31 := archsimd.BroadcastFloat64x4(0)
					for p := 0; p < k; p++ {
						a0p := a[i*k+p]
						a1p := a[(i+1)*k+p]
						a2p := a[(i+2)*k+p]
						a3p := a[(i+3)*k+p]
						vA0 := archsimd.BroadcastFloat64x4(a0p)
						vA1 := archsimd.BroadcastFloat64x4(a1p)
						vA2 := archsimd.BroadcastFloat64x4(a2p)
						vA3 := archsimd.BroadcastFloat64x4(a3p)
						bRowStart := p * n
						vB0 := archsimd.LoadFloat64x4Slice(b[bRowStart+j:])
						vB1 := archsimd.LoadFloat64x4Slice(b[bRowStart+j+lanes:])
						acc00 = vA0.MulAdd(vB0, acc00)
						acc01 = vA0.MulAdd(vB1, acc01)
						acc10 = vA1.MulAdd(vB0, acc10)
						acc11 = vA1.MulAdd(vB1, acc11)
						acc20 = vA2.MulAdd(vB0, acc20)
						acc21 = vA2.MulAdd(vB1, acc21)
						acc30 = vA3.MulAdd(vB0, acc30)
						acc31 = vA3.MulAdd(vB1, acc31)
					}
					cRow0 := i * n
					cRow1 := (i + 1) * n
					cRow2 := (i + 2) * n
					cRow3 := (i + 3) * n
					acc00.StoreSlice(c[cRow0+j:])
					acc01.StoreSlice(c[cRow0+j+lanes:])
					acc10.StoreSlice(c[cRow1+j:])
					acc11.StoreSlice(c[cRow1+j+lanes:])
					acc20.StoreSlice(c[cRow2+j:])
					acc21.StoreSlice(c[cRow2+j+lanes:])
					acc30.StoreSlice(c[cRow3+j:])
					acc31.StoreSlice(c[cRow3+j+lanes:])
				}
				for ; j < jEnd; j += lanes {
					remaining := jEnd - j
					if remaining >= lanes {
						acc0 := archsimd.BroadcastFloat64x4(0)
						acc1 := archsimd.BroadcastFloat64x4(0)
						acc2 := archsimd.BroadcastFloat64x4(0)
						acc3 := archsimd.BroadcastFloat64x4(0)
						for p := 0; p < k; p++ {
							vA0 := archsimd.BroadcastFloat64x4(a[i*k+p])
							vA1 := archsimd.BroadcastFloat64x4(a[(i+1)*k+p])
							vA2 := archsimd.BroadcastFloat64x4(a[(i+2)*k+p])
							vA3 := archsimd.BroadcastFloat64x4(a[(i+3)*k+p])
							vB := archsimd.LoadFloat64x4Slice(b[p*n+j:])
							acc0 = vA0.MulAdd(vB, acc0)
							acc1 = vA1.MulAdd(vB, acc1)
							acc2 = vA2.MulAdd(vB, acc2)
							acc3 = vA3.MulAdd(vB, acc3)
						}
						acc0.StoreSlice(c[i*n+j:])
						acc1.StoreSlice(c[(i+1)*n+j:])
						acc2.StoreSlice(c[(i+2)*n+j:])
						acc3.StoreSlice(c[(i+3)*n+j:])
					} else {
						for jj := j; jj < jEnd; jj++ {
							var sum0, sum1, sum2, sum3 float64
							for p := 0; p < k; p++ {
								bpj := b[p*n+jj]
								sum0 += a[i*k+p] * bpj
								sum1 += a[(i+1)*k+p] * bpj
								sum2 += a[(i+2)*k+p] * bpj
								sum3 += a[(i+3)*k+p] * bpj
							}
							c[i*n+jj] = sum0
							c[(i+1)*n+jj] = sum1
							c[(i+2)*n+jj] = sum2
							c[(i+3)*n+jj] = sum3
						}
						break
					}
				}
			}
			for i+2 <= iEnd {
				cRow0 := i * n
				cRow1 := (i + 1) * n
				var j int
				for j = j0; j+lanes <= jEnd; j += lanes {
					acc0 := archsimd.BroadcastFloat64x4(0)
					acc1 := archsimd.BroadcastFloat64x4(0)
					for p := 0; p < k; p++ {
						vA0 := archsimd.BroadcastFloat64x4(a[i*k+p])
						vA1 := archsimd.BroadcastFloat64x4(a[(i+1)*k+p])
						vB := archsimd.LoadFloat64x4Slice(b[p*n+j:])
						acc0 = vA0.MulAdd(vB, acc0)
						acc1 = vA1.MulAdd(vB, acc1)
					}
					acc0.StoreSlice(c[cRow0+j:])
					acc1.StoreSlice(c[cRow1+j:])
				}
				for ; j < jEnd; j++ {
					var sum0, sum1 float64
					for p := 0; p < k; p++ {
						bp := b[p*n+j]
						sum0 += a[i*k+p] * bp
						sum1 += a[(i+1)*k+p] * bp
					}
					c[cRow0+j] = sum0
					c[cRow1+j] = sum1
				}
				i += 2
			}
			for ; i < iEnd; i++ {
				cRowStart := i * n
				var j int
				for j = j0; j+lanes <= jEnd; j += lanes {
					acc := archsimd.BroadcastFloat64x4(0)
					for p := 0; p < k; p++ {
						vA := archsimd.BroadcastFloat64x4(a[i*k+p])
						vB := archsimd.LoadFloat64x4Slice(b[p*n+j:])
						acc = vA.MulAdd(vB, acc)
					}
					acc.StoreSlice(c[cRowStart+j:])
				}
				for ; j < jEnd; j++ {
					var sum float64
					for p := 0; p < k; p++ {
						sum += a[i*k+p] * b[p*n+j]
					}
					c[cRowStart+j] = sum
				}
			}
		}
	}
}
