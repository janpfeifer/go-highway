// Code generated by hwygen. DO NOT EDIT.
//go:build amd64 && goexperiment.simd

package matmul

import (
	"simd/archsimd"
)

func BaseBlockedMatMul_avx2(a []float32, b []float32, c []float32, m int, n int, k int) {
	if len(a) < m*k {
		panic("matmul: A slice too short")
	}
	if len(b) < k*n {
		panic("matmul: B slice too short")
	}
	if len(c) < m*n {
		panic("matmul: C slice too short")
	}
	vZero := archsimd.BroadcastFloat32x8(0)
	lanes := 8
	total := m * n
	var idx int
	for idx = 0; idx+lanes <= total; idx += lanes {
		vZero.StoreSlice(c[idx:])
	}
	for ; idx < total; idx++ {
		c[idx] = 0
	}
	for i0 := 0; i0 < m; i0 += BlockSize {
		iEnd := min(i0+BlockSize, m)
		for j0 := 0; j0 < n; j0 += BlockSize {
			jEnd := min(j0+BlockSize, n)
			blockN := jEnd - j0
			for p0 := 0; p0 < k; p0 += BlockSize {
				pEnd := min(p0+BlockSize, k)
				for i := i0; i < iEnd; i++ {
					cRowStart := i*n + j0
					for p := p0; p < pEnd; p++ {
						aip := a[i*k+p]
						vA := archsimd.BroadcastFloat32x8(aip)
						bRowStart := p*n + j0
						var j int
						for j = 0; j+lanes <= blockN; j += lanes {
							vB := archsimd.LoadFloat32x8Slice(b[bRowStart+j:])
							vC := archsimd.LoadFloat32x8Slice(c[cRowStart+j:])
							vC = vA.MulAdd(vB, vC)
							vC.StoreSlice(c[cRowStart+j:])
						}
						for ; j < blockN; j++ {
							c[cRowStart+j] += aip * b[bRowStart+j]
						}
					}
				}
			}
		}
	}
}

func BaseBlockedMatMul_avx2_Float64(a []float64, b []float64, c []float64, m int, n int, k int) {
	if len(a) < m*k {
		panic("matmul: A slice too short")
	}
	if len(b) < k*n {
		panic("matmul: B slice too short")
	}
	if len(c) < m*n {
		panic("matmul: C slice too short")
	}
	vZero := archsimd.BroadcastFloat64x4(0)
	lanes := 4
	total := m * n
	var idx int
	for idx = 0; idx+lanes <= total; idx += lanes {
		vZero.StoreSlice(c[idx:])
	}
	for ; idx < total; idx++ {
		c[idx] = 0
	}
	for i0 := 0; i0 < m; i0 += BlockSize {
		iEnd := min(i0+BlockSize, m)
		for j0 := 0; j0 < n; j0 += BlockSize {
			jEnd := min(j0+BlockSize, n)
			blockN := jEnd - j0
			for p0 := 0; p0 < k; p0 += BlockSize {
				pEnd := min(p0+BlockSize, k)
				for i := i0; i < iEnd; i++ {
					cRowStart := i*n + j0
					for p := p0; p < pEnd; p++ {
						aip := a[i*k+p]
						vA := archsimd.BroadcastFloat64x4(aip)
						bRowStart := p*n + j0
						var j int
						for j = 0; j+lanes <= blockN; j += lanes {
							vB := archsimd.LoadFloat64x4Slice(b[bRowStart+j:])
							vC := archsimd.LoadFloat64x4Slice(c[cRowStart+j:])
							vC = vA.MulAdd(vB, vC)
							vC.StoreSlice(c[cRowStart+j:])
						}
						for ; j < blockN; j++ {
							c[cRowStart+j] += aip * b[bRowStart+j]
						}
					}
				}
			}
		}
	}
}
