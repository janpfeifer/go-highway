// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

package matmul

import (
	"github.com/ajroetker/go-highway/hwy"
)

func BaseTranspose2DStrided_fallback_Float16(src []hwy.Float16, rowStart int, rowEnd int, k int, dstM int, dst []hwy.Float16) {
	if rowStart >= rowEnd {
		return
	}
	m := rowEnd - rowStart
	lanes := hwy.MaxLanes[hwy.Float16]()
	for i := rowStart; i <= rowEnd-lanes; i += lanes {
		for j := 0; j <= k-lanes; j += lanes {
			{
				rows_1 := make([]hwy.Vec[hwy.Float16], lanes)
				for r_1 := 0; r_1 < lanes; r_1++ {
					rows_1[r_1] = hwy.Load(src[(i+r_1)*k+j:])
				}
				for level_1 := 0; (1 << level_1) < lanes; level_1++ {
					stride_1 := 1 << level_1
					newRows_1 := make([]hwy.Vec[hwy.Float16], lanes)
					for i_1 := 0; i_1 < lanes; i_1 += 2 * stride_1 {
						for j_1 := 0; j_1 < stride_1; j_1++ {
							newRows_1[i_1+j_1] = hwy.InterleaveLower(rows_1[i_1+j_1], rows_1[i_1+j_1+stride_1])
							newRows_1[i_1+j_1+stride_1] = hwy.InterleaveUpper(rows_1[i_1+j_1], rows_1[i_1+j_1+stride_1])
						}
					}
					rows_1 = newRows_1
				}
				for c_1 := 0; c_1 < lanes; c_1++ {
					hwy.Store(rows_1[c_1], dst[(j+c_1)*dstM+i:])
				}
			}
		}
	}
	{
		blockRowStart_2 := ((rowStart + lanes - 1) / lanes) * lanes
		blockRowEnd_2 := (rowEnd / lanes) * lanes
		blockK_2 := (k / lanes) * lanes
		for i_2 := rowStart; i_2 < rowEnd; i_2++ {
			for j_2 := blockK_2; j_2 < k; j_2++ {
				dst[j_2*dstM+i_2] = hwy.Float32ToFloat16(src[i_2*k+j_2].Float32())
			}
		}
		for i_2 := rowStart; i_2 < min(blockRowStart_2, rowEnd); i_2++ {
			for j_2 := 0; j_2 < blockK_2; j_2++ {
				dst[j_2*dstM+i_2] = hwy.Float32ToFloat16(src[i_2*k+j_2].Float32())
			}
		}
		for i_2 := max(blockRowEnd_2, rowStart); i_2 < rowEnd; i_2++ {
			for j_2 := 0; j_2 < blockK_2; j_2++ {
				dst[j_2*dstM+i_2] = hwy.Float32ToFloat16(src[i_2*k+j_2].Float32())
			}
		}
	}
	_ = m
}

func BaseTranspose2DStrided_fallback_BFloat16(src []hwy.BFloat16, rowStart int, rowEnd int, k int, dstM int, dst []hwy.BFloat16) {
	if rowStart >= rowEnd {
		return
	}
	m := rowEnd - rowStart
	lanes := hwy.MaxLanes[hwy.BFloat16]()
	for i := rowStart; i <= rowEnd-lanes; i += lanes {
		for j := 0; j <= k-lanes; j += lanes {
			{
				rows_1 := make([]hwy.Vec[hwy.BFloat16], lanes)
				for r_1 := 0; r_1 < lanes; r_1++ {
					rows_1[r_1] = hwy.Load(src[(i+r_1)*k+j:])
				}
				for level_1 := 0; (1 << level_1) < lanes; level_1++ {
					stride_1 := 1 << level_1
					newRows_1 := make([]hwy.Vec[hwy.BFloat16], lanes)
					for i_1 := 0; i_1 < lanes; i_1 += 2 * stride_1 {
						for j_1 := 0; j_1 < stride_1; j_1++ {
							newRows_1[i_1+j_1] = hwy.InterleaveLower(rows_1[i_1+j_1], rows_1[i_1+j_1+stride_1])
							newRows_1[i_1+j_1+stride_1] = hwy.InterleaveUpper(rows_1[i_1+j_1], rows_1[i_1+j_1+stride_1])
						}
					}
					rows_1 = newRows_1
				}
				for c_1 := 0; c_1 < lanes; c_1++ {
					hwy.Store(rows_1[c_1], dst[(j+c_1)*dstM+i:])
				}
			}
		}
	}
	{
		blockRowStart_2 := ((rowStart + lanes - 1) / lanes) * lanes
		blockRowEnd_2 := (rowEnd / lanes) * lanes
		blockK_2 := (k / lanes) * lanes
		for i_2 := rowStart; i_2 < rowEnd; i_2++ {
			for j_2 := blockK_2; j_2 < k; j_2++ {
				dst[j_2*dstM+i_2] = hwy.Float32ToBFloat16(src[i_2*k+j_2].Float32())
			}
		}
		for i_2 := rowStart; i_2 < min(blockRowStart_2, rowEnd); i_2++ {
			for j_2 := 0; j_2 < blockK_2; j_2++ {
				dst[j_2*dstM+i_2] = hwy.Float32ToBFloat16(src[i_2*k+j_2].Float32())
			}
		}
		for i_2 := max(blockRowEnd_2, rowStart); i_2 < rowEnd; i_2++ {
			for j_2 := 0; j_2 < blockK_2; j_2++ {
				dst[j_2*dstM+i_2] = hwy.Float32ToBFloat16(src[i_2*k+j_2].Float32())
			}
		}
	}
	_ = m
}

func BaseTranspose2DStrided_fallback(src []float32, rowStart int, rowEnd int, k int, dstM int, dst []float32) {
	if rowStart >= rowEnd {
		return
	}
	m := rowEnd - rowStart
	for i := rowStart; i <= rowEnd-1; i++ {
		for j := 0; j <= k-1; j++ {
			{
				rows_1 := make([]float32, 1)
				for r_1 := 0; r_1 < 1; r_1++ {
					rows_1[r_1] = src[(i+r_1)*k+j]
				}
				for level_1 := 0; (1 << level_1) < 1; level_1++ {
					stride_1 := 1 << level_1
					newRows_1 := make([]float32, 1)
					for i_1 := 0; i_1 < 1; i_1 += 2 * stride_1 {
						for j_1 := 0; j_1 < stride_1; j_1++ {
							newRows_1[i_1+j_1] = rows_1[i_1+j_1]
							newRows_1[i_1+j_1+stride_1] = rows_1[i_1+j_1+stride_1]
						}
					}
					rows_1 = newRows_1
				}
				for c_1 := 0; c_1 < 1; c_1++ {
					dst[(j+c_1)*dstM+i] = rows_1[c_1]
				}
			}
		}
	}
	{
		blockRowStart_2 := ((rowStart + 1 - 1) / 1) * 1
		blockRowEnd_2 := (rowEnd / 1) * 1
		blockK_2 := (k / 1) * 1
		for i_2 := rowStart; i_2 < rowEnd; i_2++ {
			for j_2 := blockK_2; j_2 < k; j_2++ {
				dst[j_2*dstM+i_2] = src[i_2*k+j_2]
			}
		}
		for i_2 := rowStart; i_2 < min(blockRowStart_2, rowEnd); i_2++ {
			for j_2 := 0; j_2 < blockK_2; j_2++ {
				dst[j_2*dstM+i_2] = src[i_2*k+j_2]
			}
		}
		for i_2 := max(blockRowEnd_2, rowStart); i_2 < rowEnd; i_2++ {
			for j_2 := 0; j_2 < blockK_2; j_2++ {
				dst[j_2*dstM+i_2] = src[i_2*k+j_2]
			}
		}
	}
	_ = m
}

func BaseTranspose2DStrided_fallback_Float64(src []float64, rowStart int, rowEnd int, k int, dstM int, dst []float64) {
	if rowStart >= rowEnd {
		return
	}
	m := rowEnd - rowStart
	for i := rowStart; i <= rowEnd-1; i++ {
		for j := 0; j <= k-1; j++ {
			{
				rows_1 := make([]float64, 1)
				for r_1 := 0; r_1 < 1; r_1++ {
					rows_1[r_1] = src[(i+r_1)*k+j]
				}
				for level_1 := 0; (1 << level_1) < 1; level_1++ {
					stride_1 := 1 << level_1
					newRows_1 := make([]float64, 1)
					for i_1 := 0; i_1 < 1; i_1 += 2 * stride_1 {
						for j_1 := 0; j_1 < stride_1; j_1++ {
							newRows_1[i_1+j_1] = rows_1[i_1+j_1]
							newRows_1[i_1+j_1+stride_1] = rows_1[i_1+j_1+stride_1]
						}
					}
					rows_1 = newRows_1
				}
				for c_1 := 0; c_1 < 1; c_1++ {
					dst[(j+c_1)*dstM+i] = rows_1[c_1]
				}
			}
		}
	}
	{
		blockRowStart_2 := ((rowStart + 1 - 1) / 1) * 1
		blockRowEnd_2 := (rowEnd / 1) * 1
		blockK_2 := (k / 1) * 1
		for i_2 := rowStart; i_2 < rowEnd; i_2++ {
			for j_2 := blockK_2; j_2 < k; j_2++ {
				dst[j_2*dstM+i_2] = src[i_2*k+j_2]
			}
		}
		for i_2 := rowStart; i_2 < min(blockRowStart_2, rowEnd); i_2++ {
			for j_2 := 0; j_2 < blockK_2; j_2++ {
				dst[j_2*dstM+i_2] = src[i_2*k+j_2]
			}
		}
		for i_2 := max(blockRowEnd_2, rowStart); i_2 < rowEnd; i_2++ {
			for j_2 := 0; j_2 < blockK_2; j_2++ {
				dst[j_2*dstM+i_2] = src[i_2*k+j_2]
			}
		}
	}
	_ = m
}

func BaseTranspose2D_fallback_Float16(src []hwy.Float16, m int, k int, dst []hwy.Float16) {
	if len(src) < m*k || len(dst) < k*m {
		return
	}
	lanes := hwy.MaxLanes[hwy.Float16]()
	for i := 0; i <= m-lanes; i += lanes {
		for j := 0; j <= k-lanes; j += lanes {
			{
				rows_1 := make([]hwy.Vec[hwy.Float16], lanes)
				for r_1 := 0; r_1 < lanes; r_1++ {
					rows_1[r_1] = hwy.Load(src[(i+r_1)*k+j:])
				}
				for level_1 := 0; (1 << level_1) < lanes; level_1++ {
					stride_1 := 1 << level_1
					newRows_1 := make([]hwy.Vec[hwy.Float16], lanes)
					for i_1 := 0; i_1 < lanes; i_1 += 2 * stride_1 {
						for j_1 := 0; j_1 < stride_1; j_1++ {
							newRows_1[i_1+j_1] = hwy.InterleaveLower(rows_1[i_1+j_1], rows_1[i_1+j_1+stride_1])
							newRows_1[i_1+j_1+stride_1] = hwy.InterleaveUpper(rows_1[i_1+j_1], rows_1[i_1+j_1+stride_1])
						}
					}
					rows_1 = newRows_1
				}
				for c_1 := 0; c_1 < lanes; c_1++ {
					hwy.Store(rows_1[c_1], dst[(j+c_1)*m+i:])
				}
			}
		}
	}
	{
		blockM_2 := (m / lanes) * lanes
		blockK_2 := (k / lanes) * lanes
		for i_2 := 0; i_2 < m; i_2++ {
			for j_2 := blockK_2; j_2 < k; j_2++ {
				dst[j_2*m+i_2] = hwy.Float32ToFloat16(src[i_2*k+j_2].Float32())
			}
		}
		for i_2 := blockM_2; i_2 < m; i_2++ {
			for j_2 := 0; j_2 < blockK_2; j_2++ {
				dst[j_2*m+i_2] = hwy.Float32ToFloat16(src[i_2*k+j_2].Float32())
			}
		}
	}
}

func BaseTranspose2D_fallback_BFloat16(src []hwy.BFloat16, m int, k int, dst []hwy.BFloat16) {
	if len(src) < m*k || len(dst) < k*m {
		return
	}
	lanes := hwy.MaxLanes[hwy.BFloat16]()
	for i := 0; i <= m-lanes; i += lanes {
		for j := 0; j <= k-lanes; j += lanes {
			{
				rows_1 := make([]hwy.Vec[hwy.BFloat16], lanes)
				for r_1 := 0; r_1 < lanes; r_1++ {
					rows_1[r_1] = hwy.Load(src[(i+r_1)*k+j:])
				}
				for level_1 := 0; (1 << level_1) < lanes; level_1++ {
					stride_1 := 1 << level_1
					newRows_1 := make([]hwy.Vec[hwy.BFloat16], lanes)
					for i_1 := 0; i_1 < lanes; i_1 += 2 * stride_1 {
						for j_1 := 0; j_1 < stride_1; j_1++ {
							newRows_1[i_1+j_1] = hwy.InterleaveLower(rows_1[i_1+j_1], rows_1[i_1+j_1+stride_1])
							newRows_1[i_1+j_1+stride_1] = hwy.InterleaveUpper(rows_1[i_1+j_1], rows_1[i_1+j_1+stride_1])
						}
					}
					rows_1 = newRows_1
				}
				for c_1 := 0; c_1 < lanes; c_1++ {
					hwy.Store(rows_1[c_1], dst[(j+c_1)*m+i:])
				}
			}
		}
	}
	{
		blockM_2 := (m / lanes) * lanes
		blockK_2 := (k / lanes) * lanes
		for i_2 := 0; i_2 < m; i_2++ {
			for j_2 := blockK_2; j_2 < k; j_2++ {
				dst[j_2*m+i_2] = hwy.Float32ToBFloat16(src[i_2*k+j_2].Float32())
			}
		}
		for i_2 := blockM_2; i_2 < m; i_2++ {
			for j_2 := 0; j_2 < blockK_2; j_2++ {
				dst[j_2*m+i_2] = hwy.Float32ToBFloat16(src[i_2*k+j_2].Float32())
			}
		}
	}
}

func BaseTranspose2D_fallback(src []float32, m int, k int, dst []float32) {
	if len(src) < m*k || len(dst) < k*m {
		return
	}
	for i := 0; i <= m-1; i++ {
		for j := 0; j <= k-1; j++ {
			{
				rows_1 := make([]float32, 1)
				for r_1 := 0; r_1 < 1; r_1++ {
					rows_1[r_1] = src[(i+r_1)*k+j]
				}
				for level_1 := 0; (1 << level_1) < 1; level_1++ {
					stride_1 := 1 << level_1
					newRows_1 := make([]float32, 1)
					for i_1 := 0; i_1 < 1; i_1 += 2 * stride_1 {
						for j_1 := 0; j_1 < stride_1; j_1++ {
							newRows_1[i_1+j_1] = rows_1[i_1+j_1]
							newRows_1[i_1+j_1+stride_1] = rows_1[i_1+j_1+stride_1]
						}
					}
					rows_1 = newRows_1
				}
				for c_1 := 0; c_1 < 1; c_1++ {
					dst[(j+c_1)*m+i] = rows_1[c_1]
				}
			}
		}
	}
	{
		blockM_2 := (m / 1) * 1
		blockK_2 := (k / 1) * 1
		for i_2 := 0; i_2 < m; i_2++ {
			for j_2 := blockK_2; j_2 < k; j_2++ {
				dst[j_2*m+i_2] = src[i_2*k+j_2]
			}
		}
		for i_2 := blockM_2; i_2 < m; i_2++ {
			for j_2 := 0; j_2 < blockK_2; j_2++ {
				dst[j_2*m+i_2] = src[i_2*k+j_2]
			}
		}
	}
}

func BaseTranspose2D_fallback_Float64(src []float64, m int, k int, dst []float64) {
	if len(src) < m*k || len(dst) < k*m {
		return
	}
	for i := 0; i <= m-1; i++ {
		for j := 0; j <= k-1; j++ {
			{
				rows_1 := make([]float64, 1)
				for r_1 := 0; r_1 < 1; r_1++ {
					rows_1[r_1] = src[(i+r_1)*k+j]
				}
				for level_1 := 0; (1 << level_1) < 1; level_1++ {
					stride_1 := 1 << level_1
					newRows_1 := make([]float64, 1)
					for i_1 := 0; i_1 < 1; i_1 += 2 * stride_1 {
						for j_1 := 0; j_1 < stride_1; j_1++ {
							newRows_1[i_1+j_1] = rows_1[i_1+j_1]
							newRows_1[i_1+j_1+stride_1] = rows_1[i_1+j_1+stride_1]
						}
					}
					rows_1 = newRows_1
				}
				for c_1 := 0; c_1 < 1; c_1++ {
					dst[(j+c_1)*m+i] = rows_1[c_1]
				}
			}
		}
	}
	{
		blockM_2 := (m / 1) * 1
		blockK_2 := (k / 1) * 1
		for i_2 := 0; i_2 < m; i_2++ {
			for j_2 := blockK_2; j_2 < k; j_2++ {
				dst[j_2*m+i_2] = src[i_2*k+j_2]
			}
		}
		for i_2 := blockM_2; i_2 < m; i_2++ {
			for j_2 := 0; j_2 < blockK_2; j_2++ {
				dst[j_2*m+i_2] = src[i_2*k+j_2]
			}
		}
	}
}
