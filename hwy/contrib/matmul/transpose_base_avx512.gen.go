// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

//go:build amd64 && goexperiment.simd

package matmul

import (
	"simd/archsimd"
	"unsafe"

	"github.com/ajroetker/go-highway/hwy"
)

func BaseTranspose2DStrided_avx512_Float16(src []hwy.Float16, rowStart int, rowEnd int, k int, dstM int, dst []hwy.Float16) {
	if rowStart >= rowEnd {
		return
	}
	m := rowEnd - rowStart
	lanes := 32
	i := rowStart
	for ; i <= rowEnd-lanes; i += lanes * 3 {
		for j := 0; j <= k-lanes; j += lanes {
			{
				rows_1 := [32]hwy.Vec[hwy.Float16]{}
				for r_1 := 0; r_1 < lanes; r_1++ {
					rows_1[r_1] = hwy.Load(src[(i+r_1)*k+j:])
				}
				for level_1 := 0; (1 << level_1) < lanes; level_1++ {
					stride_1 := 1 << level_1
					newRows_1 := [32]hwy.Vec[hwy.Float16]{}
					for i_1 := 0; i_1 < lanes; i_1 += 2 * stride_1 {
						for j_1 := 0; j_1 < stride_1; j_1++ {
							newRows_1[i_1+j_1] = hwy.InterleaveLower(rows_1[i_1+j_1], rows_1[i_1+j_1+stride_1])
							newRows_1[i_1+j_1+stride_1] = hwy.InterleaveUpper(rows_1[i_1+j_1], rows_1[i_1+j_1+stride_1])
						}
					}
					rows_1 = newRows_1
				}
				for c_1 := 0; c_1 < lanes; c_1++ {
					hwy.StoreFull(rows_1[c_1], dst[(j+c_1)*dstM+i:])
				}
			}
		}
		for j1 := 0; j1 <= k-lanes; j1 += lanes {
			{
				rows_11 := [32]hwy.Vec[hwy.Float16]{}
				for r_11 := 0; r_11 < lanes; r_11++ {
					rows_11[r_11] = hwy.Load(src[(i+r_11)*k+j1:])
				}
				for level_11 := 0; (1 << level_11) < lanes; level_11++ {
					stride_11 := 1 << level_11
					newRows_11 := [32]hwy.Vec[hwy.Float16]{}
					for i_11 := 0; i_11 < lanes; i_11 += 2 * stride_11 {
						for j_11 := 0; j_11 < stride_11; j_11++ {
							newRows_11[i_11+j_11] = hwy.InterleaveLower(rows_11[i_11+j_11], rows_11[i_11+j_11+stride_11])
							newRows_11[i_11+j_11+stride_11] = hwy.InterleaveUpper(rows_11[i_11+j_11], rows_11[i_11+j_11+stride_11])
						}
					}
					rows_11 = newRows_11
				}
				for c_11 := 0; c_11 < lanes; c_11++ {
					hwy.StoreFull(rows_11[c_11], dst[(j1+c_11)*dstM+i:])
				}
			}
		}
		for j2 := 0; j2 <= k-lanes; j2 += lanes {
			{
				rows_12 := [32]hwy.Vec[hwy.Float16]{}
				for r_12 := 0; r_12 < lanes; r_12++ {
					rows_12[r_12] = hwy.Load(src[(i+r_12)*k+j2:])
				}
				for level_12 := 0; (1 << level_12) < lanes; level_12++ {
					stride_12 := 1 << level_12
					newRows_12 := [32]hwy.Vec[hwy.Float16]{}
					for i_12 := 0; i_12 < lanes; i_12 += 2 * stride_12 {
						for j_12 := 0; j_12 < stride_12; j_12++ {
							newRows_12[i_12+j_12] = hwy.InterleaveLower(rows_12[i_12+j_12], rows_12[i_12+j_12+stride_12])
							newRows_12[i_12+j_12+stride_12] = hwy.InterleaveUpper(rows_12[i_12+j_12], rows_12[i_12+j_12+stride_12])
						}
					}
					rows_12 = newRows_12
				}
				for c_12 := 0; c_12 < lanes; c_12++ {
					hwy.StoreFull(rows_12[c_12], dst[(j2+c_12)*dstM+i:])
				}
			}
		}
	}
	for ; i <= rowEnd-lanes; i += lanes {
		for j := 0; j <= k-lanes; j += lanes {
			{
				rows_1 := [32]hwy.Vec[hwy.Float16]{}
				for r_1 := 0; r_1 < lanes; r_1++ {
					rows_1[r_1] = hwy.Load(src[(i+r_1)*k+j:])
				}
				for level_1 := 0; (1 << level_1) < lanes; level_1++ {
					stride_1 := 1 << level_1
					newRows_1 := [32]hwy.Vec[hwy.Float16]{}
					for i_1 := 0; i_1 < lanes; i_1 += 2 * stride_1 {
						for j_1 := 0; j_1 < stride_1; j_1++ {
							newRows_1[i_1+j_1] = hwy.InterleaveLower(rows_1[i_1+j_1], rows_1[i_1+j_1+stride_1])
							newRows_1[i_1+j_1+stride_1] = hwy.InterleaveUpper(rows_1[i_1+j_1], rows_1[i_1+j_1+stride_1])
						}
					}
					rows_1 = newRows_1
				}
				for c_1 := 0; c_1 < lanes; c_1++ {
					hwy.StoreFull(rows_1[c_1], dst[(j+c_1)*dstM+i:])
				}
			}
		}
	}
	{
		blockRowStart_2 := ((rowStart + lanes - 1) / lanes) * lanes
		blockRowEnd_2 := (rowEnd / lanes) * lanes
		blockK_2 := (k / lanes) * lanes
		for i_2 := rowStart; i_2 < rowEnd; i_2++ {
			for j_2 := blockK_2; j_2 < k; j_2++ {
				dst[j_2*dstM+i_2] = hwy.Float32ToFloat16(src[i_2*k+j_2].Float32())
			}
		}
		for i_2 := rowStart; i_2 < min(blockRowStart_2, rowEnd); i_2++ {
			for j_2 := 0; j_2 < blockK_2; j_2++ {
				dst[j_2*dstM+i_2] = hwy.Float32ToFloat16(src[i_2*k+j_2].Float32())
			}
		}
		for i_2 := max(blockRowEnd_2, rowStart); i_2 < rowEnd; i_2++ {
			for j_2 := 0; j_2 < blockK_2; j_2++ {
				dst[j_2*dstM+i_2] = hwy.Float32ToFloat16(src[i_2*k+j_2].Float32())
			}
		}
	}
	_ = m
}

func BaseTranspose2DStrided_avx512_BFloat16(src []hwy.BFloat16, rowStart int, rowEnd int, k int, dstM int, dst []hwy.BFloat16) {
	if rowStart >= rowEnd {
		return
	}
	m := rowEnd - rowStart
	lanes := 32
	i := rowStart
	for ; i <= rowEnd-lanes; i += lanes * 3 {
		for j := 0; j <= k-lanes; j += lanes {
			{
				rows_1 := [32]hwy.Vec[hwy.BFloat16]{}
				for r_1 := 0; r_1 < lanes; r_1++ {
					rows_1[r_1] = hwy.Load(src[(i+r_1)*k+j:])
				}
				for level_1 := 0; (1 << level_1) < lanes; level_1++ {
					stride_1 := 1 << level_1
					newRows_1 := [32]hwy.Vec[hwy.BFloat16]{}
					for i_1 := 0; i_1 < lanes; i_1 += 2 * stride_1 {
						for j_1 := 0; j_1 < stride_1; j_1++ {
							newRows_1[i_1+j_1] = hwy.InterleaveLower(rows_1[i_1+j_1], rows_1[i_1+j_1+stride_1])
							newRows_1[i_1+j_1+stride_1] = hwy.InterleaveUpper(rows_1[i_1+j_1], rows_1[i_1+j_1+stride_1])
						}
					}
					rows_1 = newRows_1
				}
				for c_1 := 0; c_1 < lanes; c_1++ {
					hwy.StoreFull(rows_1[c_1], dst[(j+c_1)*dstM+i:])
				}
			}
		}
		for j1 := 0; j1 <= k-lanes; j1 += lanes {
			{
				rows_11 := [32]hwy.Vec[hwy.BFloat16]{}
				for r_11 := 0; r_11 < lanes; r_11++ {
					rows_11[r_11] = hwy.Load(src[(i+r_11)*k+j1:])
				}
				for level_11 := 0; (1 << level_11) < lanes; level_11++ {
					stride_11 := 1 << level_11
					newRows_11 := [32]hwy.Vec[hwy.BFloat16]{}
					for i_11 := 0; i_11 < lanes; i_11 += 2 * stride_11 {
						for j_11 := 0; j_11 < stride_11; j_11++ {
							newRows_11[i_11+j_11] = hwy.InterleaveLower(rows_11[i_11+j_11], rows_11[i_11+j_11+stride_11])
							newRows_11[i_11+j_11+stride_11] = hwy.InterleaveUpper(rows_11[i_11+j_11], rows_11[i_11+j_11+stride_11])
						}
					}
					rows_11 = newRows_11
				}
				for c_11 := 0; c_11 < lanes; c_11++ {
					hwy.StoreFull(rows_11[c_11], dst[(j1+c_11)*dstM+i:])
				}
			}
		}
		for j2 := 0; j2 <= k-lanes; j2 += lanes {
			{
				rows_12 := [32]hwy.Vec[hwy.BFloat16]{}
				for r_12 := 0; r_12 < lanes; r_12++ {
					rows_12[r_12] = hwy.Load(src[(i+r_12)*k+j2:])
				}
				for level_12 := 0; (1 << level_12) < lanes; level_12++ {
					stride_12 := 1 << level_12
					newRows_12 := [32]hwy.Vec[hwy.BFloat16]{}
					for i_12 := 0; i_12 < lanes; i_12 += 2 * stride_12 {
						for j_12 := 0; j_12 < stride_12; j_12++ {
							newRows_12[i_12+j_12] = hwy.InterleaveLower(rows_12[i_12+j_12], rows_12[i_12+j_12+stride_12])
							newRows_12[i_12+j_12+stride_12] = hwy.InterleaveUpper(rows_12[i_12+j_12], rows_12[i_12+j_12+stride_12])
						}
					}
					rows_12 = newRows_12
				}
				for c_12 := 0; c_12 < lanes; c_12++ {
					hwy.StoreFull(rows_12[c_12], dst[(j2+c_12)*dstM+i:])
				}
			}
		}
	}
	for ; i <= rowEnd-lanes; i += lanes {
		for j := 0; j <= k-lanes; j += lanes {
			{
				rows_1 := [32]hwy.Vec[hwy.BFloat16]{}
				for r_1 := 0; r_1 < lanes; r_1++ {
					rows_1[r_1] = hwy.Load(src[(i+r_1)*k+j:])
				}
				for level_1 := 0; (1 << level_1) < lanes; level_1++ {
					stride_1 := 1 << level_1
					newRows_1 := [32]hwy.Vec[hwy.BFloat16]{}
					for i_1 := 0; i_1 < lanes; i_1 += 2 * stride_1 {
						for j_1 := 0; j_1 < stride_1; j_1++ {
							newRows_1[i_1+j_1] = hwy.InterleaveLower(rows_1[i_1+j_1], rows_1[i_1+j_1+stride_1])
							newRows_1[i_1+j_1+stride_1] = hwy.InterleaveUpper(rows_1[i_1+j_1], rows_1[i_1+j_1+stride_1])
						}
					}
					rows_1 = newRows_1
				}
				for c_1 := 0; c_1 < lanes; c_1++ {
					hwy.StoreFull(rows_1[c_1], dst[(j+c_1)*dstM+i:])
				}
			}
		}
	}
	{
		blockRowStart_2 := ((rowStart + lanes - 1) / lanes) * lanes
		blockRowEnd_2 := (rowEnd / lanes) * lanes
		blockK_2 := (k / lanes) * lanes
		for i_2 := rowStart; i_2 < rowEnd; i_2++ {
			for j_2 := blockK_2; j_2 < k; j_2++ {
				dst[j_2*dstM+i_2] = hwy.Float32ToBFloat16(src[i_2*k+j_2].Float32())
			}
		}
		for i_2 := rowStart; i_2 < min(blockRowStart_2, rowEnd); i_2++ {
			for j_2 := 0; j_2 < blockK_2; j_2++ {
				dst[j_2*dstM+i_2] = hwy.Float32ToBFloat16(src[i_2*k+j_2].Float32())
			}
		}
		for i_2 := max(blockRowEnd_2, rowStart); i_2 < rowEnd; i_2++ {
			for j_2 := 0; j_2 < blockK_2; j_2++ {
				dst[j_2*dstM+i_2] = hwy.Float32ToBFloat16(src[i_2*k+j_2].Float32())
			}
		}
	}
	_ = m
}

func BaseTranspose2DStrided_avx512(src []float32, rowStart int, rowEnd int, k int, dstM int, dst []float32) {
	if rowStart >= rowEnd {
		return
	}
	m := rowEnd - rowStart
	lanes := 16
	i := rowStart
	for ; i <= rowEnd-lanes; i += lanes * 3 {
		for j := 0; j <= k-lanes; j += lanes {
			{
				rows_1 := [16]archsimd.Float32x16{}
				for r_1 := 0; r_1 < lanes; r_1++ {
					rows_1[r_1] = archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&src[(i+r_1)*k+j])))
				}
				for level_1 := 0; (1 << level_1) < lanes; level_1++ {
					stride_1 := 1 << level_1
					newRows_1 := [16]archsimd.Float32x16{}
					for i_1 := 0; i_1 < lanes; i_1 += 2 * stride_1 {
						for j_1 := 0; j_1 < stride_1; j_1++ {
							newRows_1[i_1+j_1] = hwy.InterleaveLower_AVX512_F32x16(rows_1[i_1+j_1], rows_1[i_1+j_1+stride_1])
							newRows_1[i_1+j_1+stride_1] = hwy.InterleaveUpper_AVX512_F32x16(rows_1[i_1+j_1], rows_1[i_1+j_1+stride_1])
						}
					}
					rows_1 = newRows_1
				}
				for c_1 := 0; c_1 < lanes; c_1++ {
					rows_1[c_1].Store((*[16]float32)(unsafe.Pointer(&dst[(j+c_1)*dstM+i])))
				}
			}
		}
		for j1 := 0; j1 <= k-lanes; j1 += lanes {
			{
				rows_11 := [16]archsimd.Float32x16{}
				for r_11 := 0; r_11 < lanes; r_11++ {
					rows_11[r_11] = archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&src[(i+r_11)*k+j1])))
				}
				for level_11 := 0; (1 << level_11) < lanes; level_11++ {
					stride_11 := 1 << level_11
					newRows_11 := [16]archsimd.Float32x16{}
					for i_11 := 0; i_11 < lanes; i_11 += 2 * stride_11 {
						for j_11 := 0; j_11 < stride_11; j_11++ {
							newRows_11[i_11+j_11] = hwy.InterleaveLower_AVX512_F32x16(rows_11[i_11+j_11], rows_11[i_11+j_11+stride_11])
							newRows_11[i_11+j_11+stride_11] = hwy.InterleaveUpper_AVX512_F32x16(rows_11[i_11+j_11], rows_11[i_11+j_11+stride_11])
						}
					}
					rows_11 = newRows_11
				}
				for c_11 := 0; c_11 < lanes; c_11++ {
					rows_11[c_11].Store((*[16]float32)(unsafe.Pointer(&dst[(j1+c_11)*dstM+i])))
				}
			}
		}
		for j2 := 0; j2 <= k-lanes; j2 += lanes {
			{
				rows_12 := [16]archsimd.Float32x16{}
				for r_12 := 0; r_12 < lanes; r_12++ {
					rows_12[r_12] = archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&src[(i+r_12)*k+j2])))
				}
				for level_12 := 0; (1 << level_12) < lanes; level_12++ {
					stride_12 := 1 << level_12
					newRows_12 := [16]archsimd.Float32x16{}
					for i_12 := 0; i_12 < lanes; i_12 += 2 * stride_12 {
						for j_12 := 0; j_12 < stride_12; j_12++ {
							newRows_12[i_12+j_12] = hwy.InterleaveLower_AVX512_F32x16(rows_12[i_12+j_12], rows_12[i_12+j_12+stride_12])
							newRows_12[i_12+j_12+stride_12] = hwy.InterleaveUpper_AVX512_F32x16(rows_12[i_12+j_12], rows_12[i_12+j_12+stride_12])
						}
					}
					rows_12 = newRows_12
				}
				for c_12 := 0; c_12 < lanes; c_12++ {
					rows_12[c_12].Store((*[16]float32)(unsafe.Pointer(&dst[(j2+c_12)*dstM+i])))
				}
			}
		}
	}
	for ; i <= rowEnd-lanes; i += lanes {
		for j := 0; j <= k-lanes; j += lanes {
			{
				rows_1 := [16]archsimd.Float32x16{}
				for r_1 := 0; r_1 < lanes; r_1++ {
					rows_1[r_1] = archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&src[(i+r_1)*k+j])))
				}
				for level_1 := 0; (1 << level_1) < lanes; level_1++ {
					stride_1 := 1 << level_1
					newRows_1 := [16]archsimd.Float32x16{}
					for i_1 := 0; i_1 < lanes; i_1 += 2 * stride_1 {
						for j_1 := 0; j_1 < stride_1; j_1++ {
							newRows_1[i_1+j_1] = hwy.InterleaveLower_AVX512_F32x16(rows_1[i_1+j_1], rows_1[i_1+j_1+stride_1])
							newRows_1[i_1+j_1+stride_1] = hwy.InterleaveUpper_AVX512_F32x16(rows_1[i_1+j_1], rows_1[i_1+j_1+stride_1])
						}
					}
					rows_1 = newRows_1
				}
				for c_1 := 0; c_1 < lanes; c_1++ {
					rows_1[c_1].Store((*[16]float32)(unsafe.Pointer(&dst[(j+c_1)*dstM+i])))
				}
			}
		}
	}
	{
		blockRowStart_2 := ((rowStart + lanes - 1) / lanes) * lanes
		blockRowEnd_2 := (rowEnd / lanes) * lanes
		blockK_2 := (k / lanes) * lanes
		for i_2 := rowStart; i_2 < rowEnd; i_2++ {
			for j_2 := blockK_2; j_2 < k; j_2++ {
				dst[j_2*dstM+i_2] = src[i_2*k+j_2]
			}
		}
		for i_2 := rowStart; i_2 < min(blockRowStart_2, rowEnd); i_2++ {
			for j_2 := 0; j_2 < blockK_2; j_2++ {
				dst[j_2*dstM+i_2] = src[i_2*k+j_2]
			}
		}
		for i_2 := max(blockRowEnd_2, rowStart); i_2 < rowEnd; i_2++ {
			for j_2 := 0; j_2 < blockK_2; j_2++ {
				dst[j_2*dstM+i_2] = src[i_2*k+j_2]
			}
		}
	}
	_ = m
}

func BaseTranspose2DStrided_avx512_Float64(src []float64, rowStart int, rowEnd int, k int, dstM int, dst []float64) {
	if rowStart >= rowEnd {
		return
	}
	m := rowEnd - rowStart
	lanes := 8
	i := rowStart
	for ; i <= rowEnd-lanes; i += lanes * 3 {
		for j := 0; j <= k-lanes; j += lanes {
			{
				rows_1 := [8]archsimd.Float64x8{}
				for r_1 := 0; r_1 < lanes; r_1++ {
					rows_1[r_1] = archsimd.LoadFloat64x8((*[8]float64)(unsafe.Pointer(&src[(i+r_1)*k+j])))
				}
				for level_1 := 0; (1 << level_1) < lanes; level_1++ {
					stride_1 := 1 << level_1
					newRows_1 := [8]archsimd.Float64x8{}
					for i_1 := 0; i_1 < lanes; i_1 += 2 * stride_1 {
						for j_1 := 0; j_1 < stride_1; j_1++ {
							newRows_1[i_1+j_1] = hwy.InterleaveLower_AVX512_F64x8(rows_1[i_1+j_1], rows_1[i_1+j_1+stride_1])
							newRows_1[i_1+j_1+stride_1] = hwy.InterleaveUpper_AVX512_F64x8(rows_1[i_1+j_1], rows_1[i_1+j_1+stride_1])
						}
					}
					rows_1 = newRows_1
				}
				for c_1 := 0; c_1 < lanes; c_1++ {
					rows_1[c_1].Store((*[8]float64)(unsafe.Pointer(&dst[(j+c_1)*dstM+i])))
				}
			}
		}
		for j1 := 0; j1 <= k-lanes; j1 += lanes {
			{
				rows_11 := [8]archsimd.Float64x8{}
				for r_11 := 0; r_11 < lanes; r_11++ {
					rows_11[r_11] = archsimd.LoadFloat64x8((*[8]float64)(unsafe.Pointer(&src[(i+r_11)*k+j1])))
				}
				for level_11 := 0; (1 << level_11) < lanes; level_11++ {
					stride_11 := 1 << level_11
					newRows_11 := [8]archsimd.Float64x8{}
					for i_11 := 0; i_11 < lanes; i_11 += 2 * stride_11 {
						for j_11 := 0; j_11 < stride_11; j_11++ {
							newRows_11[i_11+j_11] = hwy.InterleaveLower_AVX512_F64x8(rows_11[i_11+j_11], rows_11[i_11+j_11+stride_11])
							newRows_11[i_11+j_11+stride_11] = hwy.InterleaveUpper_AVX512_F64x8(rows_11[i_11+j_11], rows_11[i_11+j_11+stride_11])
						}
					}
					rows_11 = newRows_11
				}
				for c_11 := 0; c_11 < lanes; c_11++ {
					rows_11[c_11].Store((*[8]float64)(unsafe.Pointer(&dst[(j1+c_11)*dstM+i])))
				}
			}
		}
		for j2 := 0; j2 <= k-lanes; j2 += lanes {
			{
				rows_12 := [8]archsimd.Float64x8{}
				for r_12 := 0; r_12 < lanes; r_12++ {
					rows_12[r_12] = archsimd.LoadFloat64x8((*[8]float64)(unsafe.Pointer(&src[(i+r_12)*k+j2])))
				}
				for level_12 := 0; (1 << level_12) < lanes; level_12++ {
					stride_12 := 1 << level_12
					newRows_12 := [8]archsimd.Float64x8{}
					for i_12 := 0; i_12 < lanes; i_12 += 2 * stride_12 {
						for j_12 := 0; j_12 < stride_12; j_12++ {
							newRows_12[i_12+j_12] = hwy.InterleaveLower_AVX512_F64x8(rows_12[i_12+j_12], rows_12[i_12+j_12+stride_12])
							newRows_12[i_12+j_12+stride_12] = hwy.InterleaveUpper_AVX512_F64x8(rows_12[i_12+j_12], rows_12[i_12+j_12+stride_12])
						}
					}
					rows_12 = newRows_12
				}
				for c_12 := 0; c_12 < lanes; c_12++ {
					rows_12[c_12].Store((*[8]float64)(unsafe.Pointer(&dst[(j2+c_12)*dstM+i])))
				}
			}
		}
	}
	for ; i <= rowEnd-lanes; i += lanes {
		for j := 0; j <= k-lanes; j += lanes {
			{
				rows_1 := [8]archsimd.Float64x8{}
				for r_1 := 0; r_1 < lanes; r_1++ {
					rows_1[r_1] = archsimd.LoadFloat64x8((*[8]float64)(unsafe.Pointer(&src[(i+r_1)*k+j])))
				}
				for level_1 := 0; (1 << level_1) < lanes; level_1++ {
					stride_1 := 1 << level_1
					newRows_1 := [8]archsimd.Float64x8{}
					for i_1 := 0; i_1 < lanes; i_1 += 2 * stride_1 {
						for j_1 := 0; j_1 < stride_1; j_1++ {
							newRows_1[i_1+j_1] = hwy.InterleaveLower_AVX512_F64x8(rows_1[i_1+j_1], rows_1[i_1+j_1+stride_1])
							newRows_1[i_1+j_1+stride_1] = hwy.InterleaveUpper_AVX512_F64x8(rows_1[i_1+j_1], rows_1[i_1+j_1+stride_1])
						}
					}
					rows_1 = newRows_1
				}
				for c_1 := 0; c_1 < lanes; c_1++ {
					rows_1[c_1].Store((*[8]float64)(unsafe.Pointer(&dst[(j+c_1)*dstM+i])))
				}
			}
		}
	}
	{
		blockRowStart_2 := ((rowStart + lanes - 1) / lanes) * lanes
		blockRowEnd_2 := (rowEnd / lanes) * lanes
		blockK_2 := (k / lanes) * lanes
		for i_2 := rowStart; i_2 < rowEnd; i_2++ {
			for j_2 := blockK_2; j_2 < k; j_2++ {
				dst[j_2*dstM+i_2] = src[i_2*k+j_2]
			}
		}
		for i_2 := rowStart; i_2 < min(blockRowStart_2, rowEnd); i_2++ {
			for j_2 := 0; j_2 < blockK_2; j_2++ {
				dst[j_2*dstM+i_2] = src[i_2*k+j_2]
			}
		}
		for i_2 := max(blockRowEnd_2, rowStart); i_2 < rowEnd; i_2++ {
			for j_2 := 0; j_2 < blockK_2; j_2++ {
				dst[j_2*dstM+i_2] = src[i_2*k+j_2]
			}
		}
	}
	_ = m
}

func BaseTranspose2D_avx512_Float16(src []hwy.Float16, m int, k int, dst []hwy.Float16) {
	if len(src) < m*k || len(dst) < k*m {
		return
	}
	lanes := 32
	i := 0
	for ; i <= m-lanes; i += lanes * 3 {
		for j := 0; j <= k-lanes; j += lanes {
			{
				rows_1 := [32]hwy.Vec[hwy.Float16]{}
				for r_1 := 0; r_1 < lanes; r_1++ {
					rows_1[r_1] = hwy.Load(src[(i+r_1)*k+j:])
				}
				for level_1 := 0; (1 << level_1) < lanes; level_1++ {
					stride_1 := 1 << level_1
					newRows_1 := [32]hwy.Vec[hwy.Float16]{}
					for i_1 := 0; i_1 < lanes; i_1 += 2 * stride_1 {
						for j_1 := 0; j_1 < stride_1; j_1++ {
							newRows_1[i_1+j_1] = hwy.InterleaveLower(rows_1[i_1+j_1], rows_1[i_1+j_1+stride_1])
							newRows_1[i_1+j_1+stride_1] = hwy.InterleaveUpper(rows_1[i_1+j_1], rows_1[i_1+j_1+stride_1])
						}
					}
					rows_1 = newRows_1
				}
				for c_1 := 0; c_1 < lanes; c_1++ {
					hwy.StoreFull(rows_1[c_1], dst[(j+c_1)*m+i:])
				}
			}
		}
		for j1 := 0; j1 <= k-lanes; j1 += lanes {
			{
				rows_11 := [32]hwy.Vec[hwy.Float16]{}
				for r_11 := 0; r_11 < lanes; r_11++ {
					rows_11[r_11] = hwy.Load(src[(i+r_11)*k+j1:])
				}
				for level_11 := 0; (1 << level_11) < lanes; level_11++ {
					stride_11 := 1 << level_11
					newRows_11 := [32]hwy.Vec[hwy.Float16]{}
					for i_11 := 0; i_11 < lanes; i_11 += 2 * stride_11 {
						for j_11 := 0; j_11 < stride_11; j_11++ {
							newRows_11[i_11+j_11] = hwy.InterleaveLower(rows_11[i_11+j_11], rows_11[i_11+j_11+stride_11])
							newRows_11[i_11+j_11+stride_11] = hwy.InterleaveUpper(rows_11[i_11+j_11], rows_11[i_11+j_11+stride_11])
						}
					}
					rows_11 = newRows_11
				}
				for c_11 := 0; c_11 < lanes; c_11++ {
					hwy.StoreFull(rows_11[c_11], dst[(j1+c_11)*m+i:])
				}
			}
		}
		for j2 := 0; j2 <= k-lanes; j2 += lanes {
			{
				rows_12 := [32]hwy.Vec[hwy.Float16]{}
				for r_12 := 0; r_12 < lanes; r_12++ {
					rows_12[r_12] = hwy.Load(src[(i+r_12)*k+j2:])
				}
				for level_12 := 0; (1 << level_12) < lanes; level_12++ {
					stride_12 := 1 << level_12
					newRows_12 := [32]hwy.Vec[hwy.Float16]{}
					for i_12 := 0; i_12 < lanes; i_12 += 2 * stride_12 {
						for j_12 := 0; j_12 < stride_12; j_12++ {
							newRows_12[i_12+j_12] = hwy.InterleaveLower(rows_12[i_12+j_12], rows_12[i_12+j_12+stride_12])
							newRows_12[i_12+j_12+stride_12] = hwy.InterleaveUpper(rows_12[i_12+j_12], rows_12[i_12+j_12+stride_12])
						}
					}
					rows_12 = newRows_12
				}
				for c_12 := 0; c_12 < lanes; c_12++ {
					hwy.StoreFull(rows_12[c_12], dst[(j2+c_12)*m+i:])
				}
			}
		}
	}
	for ; i <= m-lanes; i += lanes {
		for j := 0; j <= k-lanes; j += lanes {
			{
				rows_1 := [32]hwy.Vec[hwy.Float16]{}
				for r_1 := 0; r_1 < lanes; r_1++ {
					rows_1[r_1] = hwy.Load(src[(i+r_1)*k+j:])
				}
				for level_1 := 0; (1 << level_1) < lanes; level_1++ {
					stride_1 := 1 << level_1
					newRows_1 := [32]hwy.Vec[hwy.Float16]{}
					for i_1 := 0; i_1 < lanes; i_1 += 2 * stride_1 {
						for j_1 := 0; j_1 < stride_1; j_1++ {
							newRows_1[i_1+j_1] = hwy.InterleaveLower(rows_1[i_1+j_1], rows_1[i_1+j_1+stride_1])
							newRows_1[i_1+j_1+stride_1] = hwy.InterleaveUpper(rows_1[i_1+j_1], rows_1[i_1+j_1+stride_1])
						}
					}
					rows_1 = newRows_1
				}
				for c_1 := 0; c_1 < lanes; c_1++ {
					hwy.StoreFull(rows_1[c_1], dst[(j+c_1)*m+i:])
				}
			}
		}
	}
	{
		blockM_2 := (m / lanes) * lanes
		blockK_2 := (k / lanes) * lanes
		for i_2 := 0; i_2 < m; i_2++ {
			for j_2 := blockK_2; j_2 < k; j_2++ {
				dst[j_2*m+i_2] = hwy.Float32ToFloat16(src[i_2*k+j_2].Float32())
			}
		}
		for i_2 := blockM_2; i_2 < m; i_2++ {
			for j_2 := 0; j_2 < blockK_2; j_2++ {
				dst[j_2*m+i_2] = hwy.Float32ToFloat16(src[i_2*k+j_2].Float32())
			}
		}
	}
}

func BaseTranspose2D_avx512_BFloat16(src []hwy.BFloat16, m int, k int, dst []hwy.BFloat16) {
	if len(src) < m*k || len(dst) < k*m {
		return
	}
	lanes := 32
	i := 0
	for ; i <= m-lanes; i += lanes * 3 {
		for j := 0; j <= k-lanes; j += lanes {
			{
				rows_1 := [32]hwy.Vec[hwy.BFloat16]{}
				for r_1 := 0; r_1 < lanes; r_1++ {
					rows_1[r_1] = hwy.Load(src[(i+r_1)*k+j:])
				}
				for level_1 := 0; (1 << level_1) < lanes; level_1++ {
					stride_1 := 1 << level_1
					newRows_1 := [32]hwy.Vec[hwy.BFloat16]{}
					for i_1 := 0; i_1 < lanes; i_1 += 2 * stride_1 {
						for j_1 := 0; j_1 < stride_1; j_1++ {
							newRows_1[i_1+j_1] = hwy.InterleaveLower(rows_1[i_1+j_1], rows_1[i_1+j_1+stride_1])
							newRows_1[i_1+j_1+stride_1] = hwy.InterleaveUpper(rows_1[i_1+j_1], rows_1[i_1+j_1+stride_1])
						}
					}
					rows_1 = newRows_1
				}
				for c_1 := 0; c_1 < lanes; c_1++ {
					hwy.StoreFull(rows_1[c_1], dst[(j+c_1)*m+i:])
				}
			}
		}
		for j1 := 0; j1 <= k-lanes; j1 += lanes {
			{
				rows_11 := [32]hwy.Vec[hwy.BFloat16]{}
				for r_11 := 0; r_11 < lanes; r_11++ {
					rows_11[r_11] = hwy.Load(src[(i+r_11)*k+j1:])
				}
				for level_11 := 0; (1 << level_11) < lanes; level_11++ {
					stride_11 := 1 << level_11
					newRows_11 := [32]hwy.Vec[hwy.BFloat16]{}
					for i_11 := 0; i_11 < lanes; i_11 += 2 * stride_11 {
						for j_11 := 0; j_11 < stride_11; j_11++ {
							newRows_11[i_11+j_11] = hwy.InterleaveLower(rows_11[i_11+j_11], rows_11[i_11+j_11+stride_11])
							newRows_11[i_11+j_11+stride_11] = hwy.InterleaveUpper(rows_11[i_11+j_11], rows_11[i_11+j_11+stride_11])
						}
					}
					rows_11 = newRows_11
				}
				for c_11 := 0; c_11 < lanes; c_11++ {
					hwy.StoreFull(rows_11[c_11], dst[(j1+c_11)*m+i:])
				}
			}
		}
		for j2 := 0; j2 <= k-lanes; j2 += lanes {
			{
				rows_12 := [32]hwy.Vec[hwy.BFloat16]{}
				for r_12 := 0; r_12 < lanes; r_12++ {
					rows_12[r_12] = hwy.Load(src[(i+r_12)*k+j2:])
				}
				for level_12 := 0; (1 << level_12) < lanes; level_12++ {
					stride_12 := 1 << level_12
					newRows_12 := [32]hwy.Vec[hwy.BFloat16]{}
					for i_12 := 0; i_12 < lanes; i_12 += 2 * stride_12 {
						for j_12 := 0; j_12 < stride_12; j_12++ {
							newRows_12[i_12+j_12] = hwy.InterleaveLower(rows_12[i_12+j_12], rows_12[i_12+j_12+stride_12])
							newRows_12[i_12+j_12+stride_12] = hwy.InterleaveUpper(rows_12[i_12+j_12], rows_12[i_12+j_12+stride_12])
						}
					}
					rows_12 = newRows_12
				}
				for c_12 := 0; c_12 < lanes; c_12++ {
					hwy.StoreFull(rows_12[c_12], dst[(j2+c_12)*m+i:])
				}
			}
		}
	}
	for ; i <= m-lanes; i += lanes {
		for j := 0; j <= k-lanes; j += lanes {
			{
				rows_1 := [32]hwy.Vec[hwy.BFloat16]{}
				for r_1 := 0; r_1 < lanes; r_1++ {
					rows_1[r_1] = hwy.Load(src[(i+r_1)*k+j:])
				}
				for level_1 := 0; (1 << level_1) < lanes; level_1++ {
					stride_1 := 1 << level_1
					newRows_1 := [32]hwy.Vec[hwy.BFloat16]{}
					for i_1 := 0; i_1 < lanes; i_1 += 2 * stride_1 {
						for j_1 := 0; j_1 < stride_1; j_1++ {
							newRows_1[i_1+j_1] = hwy.InterleaveLower(rows_1[i_1+j_1], rows_1[i_1+j_1+stride_1])
							newRows_1[i_1+j_1+stride_1] = hwy.InterleaveUpper(rows_1[i_1+j_1], rows_1[i_1+j_1+stride_1])
						}
					}
					rows_1 = newRows_1
				}
				for c_1 := 0; c_1 < lanes; c_1++ {
					hwy.StoreFull(rows_1[c_1], dst[(j+c_1)*m+i:])
				}
			}
		}
	}
	{
		blockM_2 := (m / lanes) * lanes
		blockK_2 := (k / lanes) * lanes
		for i_2 := 0; i_2 < m; i_2++ {
			for j_2 := blockK_2; j_2 < k; j_2++ {
				dst[j_2*m+i_2] = hwy.Float32ToBFloat16(src[i_2*k+j_2].Float32())
			}
		}
		for i_2 := blockM_2; i_2 < m; i_2++ {
			for j_2 := 0; j_2 < blockK_2; j_2++ {
				dst[j_2*m+i_2] = hwy.Float32ToBFloat16(src[i_2*k+j_2].Float32())
			}
		}
	}
}

func BaseTranspose2D_avx512(src []float32, m int, k int, dst []float32) {
	if len(src) < m*k || len(dst) < k*m {
		return
	}
	lanes := 16
	i := 0
	for ; i <= m-lanes; i += lanes * 3 {
		for j := 0; j <= k-lanes; j += lanes {
			{
				rows_1 := [16]archsimd.Float32x16{}
				for r_1 := 0; r_1 < lanes; r_1++ {
					rows_1[r_1] = archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&src[(i+r_1)*k+j])))
				}
				for level_1 := 0; (1 << level_1) < lanes; level_1++ {
					stride_1 := 1 << level_1
					newRows_1 := [16]archsimd.Float32x16{}
					for i_1 := 0; i_1 < lanes; i_1 += 2 * stride_1 {
						for j_1 := 0; j_1 < stride_1; j_1++ {
							newRows_1[i_1+j_1] = hwy.InterleaveLower_AVX512_F32x16(rows_1[i_1+j_1], rows_1[i_1+j_1+stride_1])
							newRows_1[i_1+j_1+stride_1] = hwy.InterleaveUpper_AVX512_F32x16(rows_1[i_1+j_1], rows_1[i_1+j_1+stride_1])
						}
					}
					rows_1 = newRows_1
				}
				for c_1 := 0; c_1 < lanes; c_1++ {
					rows_1[c_1].Store((*[16]float32)(unsafe.Pointer(&dst[(j+c_1)*m+i])))
				}
			}
		}
		for j1 := 0; j1 <= k-lanes; j1 += lanes {
			{
				rows_11 := [16]archsimd.Float32x16{}
				for r_11 := 0; r_11 < lanes; r_11++ {
					rows_11[r_11] = archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&src[(i+r_11)*k+j1])))
				}
				for level_11 := 0; (1 << level_11) < lanes; level_11++ {
					stride_11 := 1 << level_11
					newRows_11 := [16]archsimd.Float32x16{}
					for i_11 := 0; i_11 < lanes; i_11 += 2 * stride_11 {
						for j_11 := 0; j_11 < stride_11; j_11++ {
							newRows_11[i_11+j_11] = hwy.InterleaveLower_AVX512_F32x16(rows_11[i_11+j_11], rows_11[i_11+j_11+stride_11])
							newRows_11[i_11+j_11+stride_11] = hwy.InterleaveUpper_AVX512_F32x16(rows_11[i_11+j_11], rows_11[i_11+j_11+stride_11])
						}
					}
					rows_11 = newRows_11
				}
				for c_11 := 0; c_11 < lanes; c_11++ {
					rows_11[c_11].Store((*[16]float32)(unsafe.Pointer(&dst[(j1+c_11)*m+i])))
				}
			}
		}
		for j2 := 0; j2 <= k-lanes; j2 += lanes {
			{
				rows_12 := [16]archsimd.Float32x16{}
				for r_12 := 0; r_12 < lanes; r_12++ {
					rows_12[r_12] = archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&src[(i+r_12)*k+j2])))
				}
				for level_12 := 0; (1 << level_12) < lanes; level_12++ {
					stride_12 := 1 << level_12
					newRows_12 := [16]archsimd.Float32x16{}
					for i_12 := 0; i_12 < lanes; i_12 += 2 * stride_12 {
						for j_12 := 0; j_12 < stride_12; j_12++ {
							newRows_12[i_12+j_12] = hwy.InterleaveLower_AVX512_F32x16(rows_12[i_12+j_12], rows_12[i_12+j_12+stride_12])
							newRows_12[i_12+j_12+stride_12] = hwy.InterleaveUpper_AVX512_F32x16(rows_12[i_12+j_12], rows_12[i_12+j_12+stride_12])
						}
					}
					rows_12 = newRows_12
				}
				for c_12 := 0; c_12 < lanes; c_12++ {
					rows_12[c_12].Store((*[16]float32)(unsafe.Pointer(&dst[(j2+c_12)*m+i])))
				}
			}
		}
	}
	for ; i <= m-lanes; i += lanes {
		for j := 0; j <= k-lanes; j += lanes {
			{
				rows_1 := [16]archsimd.Float32x16{}
				for r_1 := 0; r_1 < lanes; r_1++ {
					rows_1[r_1] = archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&src[(i+r_1)*k+j])))
				}
				for level_1 := 0; (1 << level_1) < lanes; level_1++ {
					stride_1 := 1 << level_1
					newRows_1 := [16]archsimd.Float32x16{}
					for i_1 := 0; i_1 < lanes; i_1 += 2 * stride_1 {
						for j_1 := 0; j_1 < stride_1; j_1++ {
							newRows_1[i_1+j_1] = hwy.InterleaveLower_AVX512_F32x16(rows_1[i_1+j_1], rows_1[i_1+j_1+stride_1])
							newRows_1[i_1+j_1+stride_1] = hwy.InterleaveUpper_AVX512_F32x16(rows_1[i_1+j_1], rows_1[i_1+j_1+stride_1])
						}
					}
					rows_1 = newRows_1
				}
				for c_1 := 0; c_1 < lanes; c_1++ {
					rows_1[c_1].Store((*[16]float32)(unsafe.Pointer(&dst[(j+c_1)*m+i])))
				}
			}
		}
	}
	{
		blockM_2 := (m / lanes) * lanes
		blockK_2 := (k / lanes) * lanes
		for i_2 := 0; i_2 < m; i_2++ {
			for j_2 := blockK_2; j_2 < k; j_2++ {
				dst[j_2*m+i_2] = src[i_2*k+j_2]
			}
		}
		for i_2 := blockM_2; i_2 < m; i_2++ {
			for j_2 := 0; j_2 < blockK_2; j_2++ {
				dst[j_2*m+i_2] = src[i_2*k+j_2]
			}
		}
	}
}

func BaseTranspose2D_avx512_Float64(src []float64, m int, k int, dst []float64) {
	if len(src) < m*k || len(dst) < k*m {
		return
	}
	lanes := 8
	i := 0
	for ; i <= m-lanes; i += lanes * 3 {
		for j := 0; j <= k-lanes; j += lanes {
			{
				rows_1 := [8]archsimd.Float64x8{}
				for r_1 := 0; r_1 < lanes; r_1++ {
					rows_1[r_1] = archsimd.LoadFloat64x8((*[8]float64)(unsafe.Pointer(&src[(i+r_1)*k+j])))
				}
				for level_1 := 0; (1 << level_1) < lanes; level_1++ {
					stride_1 := 1 << level_1
					newRows_1 := [8]archsimd.Float64x8{}
					for i_1 := 0; i_1 < lanes; i_1 += 2 * stride_1 {
						for j_1 := 0; j_1 < stride_1; j_1++ {
							newRows_1[i_1+j_1] = hwy.InterleaveLower_AVX512_F64x8(rows_1[i_1+j_1], rows_1[i_1+j_1+stride_1])
							newRows_1[i_1+j_1+stride_1] = hwy.InterleaveUpper_AVX512_F64x8(rows_1[i_1+j_1], rows_1[i_1+j_1+stride_1])
						}
					}
					rows_1 = newRows_1
				}
				for c_1 := 0; c_1 < lanes; c_1++ {
					rows_1[c_1].Store((*[8]float64)(unsafe.Pointer(&dst[(j+c_1)*m+i])))
				}
			}
		}
		for j1 := 0; j1 <= k-lanes; j1 += lanes {
			{
				rows_11 := [8]archsimd.Float64x8{}
				for r_11 := 0; r_11 < lanes; r_11++ {
					rows_11[r_11] = archsimd.LoadFloat64x8((*[8]float64)(unsafe.Pointer(&src[(i+r_11)*k+j1])))
				}
				for level_11 := 0; (1 << level_11) < lanes; level_11++ {
					stride_11 := 1 << level_11
					newRows_11 := [8]archsimd.Float64x8{}
					for i_11 := 0; i_11 < lanes; i_11 += 2 * stride_11 {
						for j_11 := 0; j_11 < stride_11; j_11++ {
							newRows_11[i_11+j_11] = hwy.InterleaveLower_AVX512_F64x8(rows_11[i_11+j_11], rows_11[i_11+j_11+stride_11])
							newRows_11[i_11+j_11+stride_11] = hwy.InterleaveUpper_AVX512_F64x8(rows_11[i_11+j_11], rows_11[i_11+j_11+stride_11])
						}
					}
					rows_11 = newRows_11
				}
				for c_11 := 0; c_11 < lanes; c_11++ {
					rows_11[c_11].Store((*[8]float64)(unsafe.Pointer(&dst[(j1+c_11)*m+i])))
				}
			}
		}
		for j2 := 0; j2 <= k-lanes; j2 += lanes {
			{
				rows_12 := [8]archsimd.Float64x8{}
				for r_12 := 0; r_12 < lanes; r_12++ {
					rows_12[r_12] = archsimd.LoadFloat64x8((*[8]float64)(unsafe.Pointer(&src[(i+r_12)*k+j2])))
				}
				for level_12 := 0; (1 << level_12) < lanes; level_12++ {
					stride_12 := 1 << level_12
					newRows_12 := [8]archsimd.Float64x8{}
					for i_12 := 0; i_12 < lanes; i_12 += 2 * stride_12 {
						for j_12 := 0; j_12 < stride_12; j_12++ {
							newRows_12[i_12+j_12] = hwy.InterleaveLower_AVX512_F64x8(rows_12[i_12+j_12], rows_12[i_12+j_12+stride_12])
							newRows_12[i_12+j_12+stride_12] = hwy.InterleaveUpper_AVX512_F64x8(rows_12[i_12+j_12], rows_12[i_12+j_12+stride_12])
						}
					}
					rows_12 = newRows_12
				}
				for c_12 := 0; c_12 < lanes; c_12++ {
					rows_12[c_12].Store((*[8]float64)(unsafe.Pointer(&dst[(j2+c_12)*m+i])))
				}
			}
		}
	}
	for ; i <= m-lanes; i += lanes {
		for j := 0; j <= k-lanes; j += lanes {
			{
				rows_1 := [8]archsimd.Float64x8{}
				for r_1 := 0; r_1 < lanes; r_1++ {
					rows_1[r_1] = archsimd.LoadFloat64x8((*[8]float64)(unsafe.Pointer(&src[(i+r_1)*k+j])))
				}
				for level_1 := 0; (1 << level_1) < lanes; level_1++ {
					stride_1 := 1 << level_1
					newRows_1 := [8]archsimd.Float64x8{}
					for i_1 := 0; i_1 < lanes; i_1 += 2 * stride_1 {
						for j_1 := 0; j_1 < stride_1; j_1++ {
							newRows_1[i_1+j_1] = hwy.InterleaveLower_AVX512_F64x8(rows_1[i_1+j_1], rows_1[i_1+j_1+stride_1])
							newRows_1[i_1+j_1+stride_1] = hwy.InterleaveUpper_AVX512_F64x8(rows_1[i_1+j_1], rows_1[i_1+j_1+stride_1])
						}
					}
					rows_1 = newRows_1
				}
				for c_1 := 0; c_1 < lanes; c_1++ {
					rows_1[c_1].Store((*[8]float64)(unsafe.Pointer(&dst[(j+c_1)*m+i])))
				}
			}
		}
	}
	{
		blockM_2 := (m / lanes) * lanes
		blockK_2 := (k / lanes) * lanes
		for i_2 := 0; i_2 < m; i_2++ {
			for j_2 := blockK_2; j_2 < k; j_2++ {
				dst[j_2*m+i_2] = src[i_2*k+j_2]
			}
		}
		for i_2 := blockM_2; i_2 < m; i_2++ {
			for j_2 := 0; j_2 < blockK_2; j_2++ {
				dst[j_2*m+i_2] = src[i_2*k+j_2]
			}
		}
	}
}
