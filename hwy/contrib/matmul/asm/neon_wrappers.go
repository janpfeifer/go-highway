//go:build !noasm && arm64

// NEON Matrix Multiplication for ARM64
// Uses NEON SIMD instructions for efficient matrix multiply.
package asm

import (
	"unsafe"

	"github.com/ajroetker/go-highway/hwy"
)

// NEON f16/bf16 requires ARMv8.2-A FP16 and ARMv8.6-A BF16 extensions
//go:generate go tool goat ../c/matmul_neon_arm64.c -O3 --target arm64 -e="-march=armv8.6-a+fp16+bf16"

// ============================================================================
// NEON Matrix Multiplication
// ============================================================================

// MatMulNEONF16 performs matrix multiplication using NEON: C = A * B
// A is M x K (row-major), B is K x N (row-major), C is M x N (row-major).
//
// Requires N to be a multiple of 8 (NEON f16 = 8 elements per vector).
//
// Parameters:
//   - a: M x K matrix (row-major)
//   - b: K x N matrix (row-major)
//   - c: M x N matrix (row-major, output)
//   - m, n, k: matrix dimensions
func MatMulNEONF16(a, b, c []hwy.Float16, m, n, k int) {
	if m == 0 || n == 0 || k == 0 {
		return
	}
	if len(a) < m*k || len(b) < k*n || len(c) < m*n {
		return
	}
	mVal := int64(m)
	nVal := int64(n)
	kVal := int64(k)
	matmul_neon_f16(
		unsafe.Pointer(&a[0]),
		unsafe.Pointer(&b[0]),
		unsafe.Pointer(&c[0]),
		unsafe.Pointer(&mVal),
		unsafe.Pointer(&nVal),
		unsafe.Pointer(&kVal),
	)
}

// MatMulNEONBF16 performs matrix multiplication using NEON: C = A * B
// Uses BFDOT for bf16 computation with f32 accumulation.
// A is M x K (row-major), B is K x N (row-major), C is M x N (row-major).
//
// Requires N to be a multiple of 4 (NEON bf16 dot product produces 4 f32 results).
//
// Parameters:
//   - a: M x K matrix (row-major)
//   - b: K x N matrix (row-major)
//   - c: M x N matrix (row-major, output)
//   - m, n, k: matrix dimensions
func MatMulNEONBF16(a, b, c []hwy.BFloat16, m, n, k int) {
	if m == 0 || n == 0 || k == 0 {
		return
	}
	if len(a) < m*k || len(b) < k*n || len(c) < m*n {
		return
	}
	mVal := int64(m)
	nVal := int64(n)
	kVal := int64(k)
	matmul_neon_bf16(
		unsafe.Pointer(&a[0]),
		unsafe.Pointer(&b[0]),
		unsafe.Pointer(&c[0]),
		unsafe.Pointer(&mVal),
		unsafe.Pointer(&nVal),
		unsafe.Pointer(&kVal),
	)
}

// MatMulNEONF32 performs matrix multiplication using NEON: C = A * B
// A is M x K (row-major), B is K x N (row-major), C is M x N (row-major).
//
// Requires N to be a multiple of 4 (NEON f32 = 4 elements per vector).
//
// Parameters:
//   - a: M x K matrix (row-major)
//   - b: K x N matrix (row-major)
//   - c: M x N matrix (row-major, output)
//   - m, n, k: matrix dimensions
func MatMulNEONF32(a, b, c []float32, m, n, k int) {
	if m == 0 || n == 0 || k == 0 {
		return
	}
	if len(a) < m*k || len(b) < k*n || len(c) < m*n {
		return
	}
	mVal := int64(m)
	nVal := int64(n)
	kVal := int64(k)
	matmul_neon_f32(
		unsafe.Pointer(&a[0]),
		unsafe.Pointer(&b[0]),
		unsafe.Pointer(&c[0]),
		unsafe.Pointer(&mVal),
		unsafe.Pointer(&nVal),
		unsafe.Pointer(&kVal),
	)
}

// MatMulNEONF64 performs matrix multiplication using NEON: C = A * B
// A is M x K (row-major), B is K x N (row-major), C is M x N (row-major).
//
// Requires N to be a multiple of 2 (NEON f64 = 2 elements per vector).
//
// Parameters:
//   - a: M x K matrix (row-major)
//   - b: K x N matrix (row-major)
//   - c: M x N matrix (row-major, output)
//   - m, n, k: matrix dimensions
func MatMulNEONF64(a, b, c []float64, m, n, k int) {
	if m == 0 || n == 0 || k == 0 {
		return
	}
	if len(a) < m*k || len(b) < k*n || len(c) < m*n {
		return
	}
	mVal := int64(m)
	nVal := int64(n)
	kVal := int64(k)
	matmul_neon_f64(
		unsafe.Pointer(&a[0]),
		unsafe.Pointer(&b[0]),
		unsafe.Pointer(&c[0]),
		unsafe.Pointer(&mVal),
		unsafe.Pointer(&nVal),
		unsafe.Pointer(&kVal),
	)
}

// Assembly function declarations are in matmul_neon_arm64.go (generated by GoAT)
