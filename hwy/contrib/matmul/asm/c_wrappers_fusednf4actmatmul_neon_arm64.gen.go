//go:build !noasm && arm64
// Code generated by hwygen -c. DO NOT EDIT.

package asm

import "unsafe"

// Public wrapper functions
// FusedNF4MatMulSiLUCF32 computes FusedNF4MatMulSiLU using NEON SIMD assembly.
func FusedNF4MatMulSiLUCF32(input []float32, packed []uint8, scales, output []float32, M, K, N, groupSize int) {
	if len(input) == 0 || len(packed) == 0 || len(scales) == 0 || len(output) == 0 {
		return
	}
	MVal := int64(M)
	KVal := int64(K)
	NVal := int64(N)
	groupSizeVal := int64(groupSize)
	fusednf4matmulsilu_c_f32_neon(
		unsafe.Pointer(&input[0]),
		unsafe.Pointer(&packed[0]),
		unsafe.Pointer(&scales[0]),
		unsafe.Pointer(&output[0]),
		unsafe.Pointer(&MVal),
		unsafe.Pointer(&KVal),
		unsafe.Pointer(&NVal),
		unsafe.Pointer(&groupSizeVal),
	)
}

// FusedNF4MatMulGELUCF32 computes FusedNF4MatMulGELU using NEON SIMD assembly.
func FusedNF4MatMulGELUCF32(input []float32, packed []uint8, scales, output []float32, M, K, N, groupSize int) {
	if len(input) == 0 || len(packed) == 0 || len(scales) == 0 || len(output) == 0 {
		return
	}
	MVal := int64(M)
	KVal := int64(K)
	NVal := int64(N)
	groupSizeVal := int64(groupSize)
	fusednf4matmulgelu_c_f32_neon(
		unsafe.Pointer(&input[0]),
		unsafe.Pointer(&packed[0]),
		unsafe.Pointer(&scales[0]),
		unsafe.Pointer(&output[0]),
		unsafe.Pointer(&MVal),
		unsafe.Pointer(&KVal),
		unsafe.Pointer(&NVal),
		unsafe.Pointer(&groupSizeVal),
	)
}

// FusedNF4MatMulGELUApproxCF32 computes FusedNF4MatMulGELUApprox using NEON SIMD assembly.
func FusedNF4MatMulGELUApproxCF32(input []float32, packed []uint8, scales, output []float32, M, K, N, groupSize int) {
	if len(input) == 0 || len(packed) == 0 || len(scales) == 0 || len(output) == 0 {
		return
	}
	MVal := int64(M)
	KVal := int64(K)
	NVal := int64(N)
	groupSizeVal := int64(groupSize)
	fusednf4matmulgeluapprox_c_f32_neon(
		unsafe.Pointer(&input[0]),
		unsafe.Pointer(&packed[0]),
		unsafe.Pointer(&scales[0]),
		unsafe.Pointer(&output[0]),
		unsafe.Pointer(&MVal),
		unsafe.Pointer(&KVal),
		unsafe.Pointer(&NVal),
		unsafe.Pointer(&groupSizeVal),
	)
}

// FusedNF4MatMulReLUCF32 computes FusedNF4MatMulReLU using NEON SIMD assembly.
func FusedNF4MatMulReLUCF32(input []float32, packed []uint8, scales, output []float32, M, K, N, groupSize int) {
	if len(input) == 0 || len(packed) == 0 || len(scales) == 0 || len(output) == 0 {
		return
	}
	MVal := int64(M)
	KVal := int64(K)
	NVal := int64(N)
	groupSizeVal := int64(groupSize)
	fusednf4matmulrelu_c_f32_neon(
		unsafe.Pointer(&input[0]),
		unsafe.Pointer(&packed[0]),
		unsafe.Pointer(&scales[0]),
		unsafe.Pointer(&output[0]),
		unsafe.Pointer(&MVal),
		unsafe.Pointer(&KVal),
		unsafe.Pointer(&NVal),
		unsafe.Pointer(&groupSizeVal),
	)
}

// FusedInt4MatMulSiLUCF32 computes FusedInt4MatMulSiLU using NEON SIMD assembly.
func FusedInt4MatMulSiLUCF32(input []float32, packed []uint8, scales, output []float32, M, K, N, groupSize int) {
	if len(input) == 0 || len(packed) == 0 || len(scales) == 0 || len(output) == 0 {
		return
	}
	MVal := int64(M)
	KVal := int64(K)
	NVal := int64(N)
	groupSizeVal := int64(groupSize)
	fusedint4matmulsilu_c_f32_neon(
		unsafe.Pointer(&input[0]),
		unsafe.Pointer(&packed[0]),
		unsafe.Pointer(&scales[0]),
		unsafe.Pointer(&output[0]),
		unsafe.Pointer(&MVal),
		unsafe.Pointer(&KVal),
		unsafe.Pointer(&NVal),
		unsafe.Pointer(&groupSizeVal),
	)
}

// FusedInt4MatMulGELUCF32 computes FusedInt4MatMulGELU using NEON SIMD assembly.
func FusedInt4MatMulGELUCF32(input []float32, packed []uint8, scales, output []float32, M, K, N, groupSize int) {
	if len(input) == 0 || len(packed) == 0 || len(scales) == 0 || len(output) == 0 {
		return
	}
	MVal := int64(M)
	KVal := int64(K)
	NVal := int64(N)
	groupSizeVal := int64(groupSize)
	fusedint4matmulgelu_c_f32_neon(
		unsafe.Pointer(&input[0]),
		unsafe.Pointer(&packed[0]),
		unsafe.Pointer(&scales[0]),
		unsafe.Pointer(&output[0]),
		unsafe.Pointer(&MVal),
		unsafe.Pointer(&KVal),
		unsafe.Pointer(&NVal),
		unsafe.Pointer(&groupSizeVal),
	)
}

// FusedInt4MatMulGELUApproxCF32 computes FusedInt4MatMulGELUApprox using NEON SIMD assembly.
func FusedInt4MatMulGELUApproxCF32(input []float32, packed []uint8, scales, output []float32, M, K, N, groupSize int) {
	if len(input) == 0 || len(packed) == 0 || len(scales) == 0 || len(output) == 0 {
		return
	}
	MVal := int64(M)
	KVal := int64(K)
	NVal := int64(N)
	groupSizeVal := int64(groupSize)
	fusedint4matmulgeluapprox_c_f32_neon(
		unsafe.Pointer(&input[0]),
		unsafe.Pointer(&packed[0]),
		unsafe.Pointer(&scales[0]),
		unsafe.Pointer(&output[0]),
		unsafe.Pointer(&MVal),
		unsafe.Pointer(&KVal),
		unsafe.Pointer(&NVal),
		unsafe.Pointer(&groupSizeVal),
	)
}

// FusedInt4MatMulReLUCF32 computes FusedInt4MatMulReLU using NEON SIMD assembly.
func FusedInt4MatMulReLUCF32(input []float32, packed []uint8, scales, output []float32, M, K, N, groupSize int) {
	if len(input) == 0 || len(packed) == 0 || len(scales) == 0 || len(output) == 0 {
		return
	}
	MVal := int64(M)
	KVal := int64(K)
	NVal := int64(N)
	groupSizeVal := int64(groupSize)
	fusedint4matmulrelu_c_f32_neon(
		unsafe.Pointer(&input[0]),
		unsafe.Pointer(&packed[0]),
		unsafe.Pointer(&scales[0]),
		unsafe.Pointer(&output[0]),
		unsafe.Pointer(&MVal),
		unsafe.Pointer(&KVal),
		unsafe.Pointer(&NVal),
		unsafe.Pointer(&groupSizeVal),
	)
}

// FusedNF4MatMulSwiGLUCF32 computes FusedNF4MatMulSwiGLU using NEON SIMD assembly.
func FusedNF4MatMulSwiGLUCF32(input []float32, gatePacked []uint8, gateScales []float32, upPacked []uint8, upScales, output []float32, M, K, N, groupSize int) {
	if len(input) == 0 || len(gatePacked) == 0 || len(gateScales) == 0 || len(upPacked) == 0 || len(upScales) == 0 || len(output) == 0 {
		return
	}
	MVal := int64(M)
	KVal := int64(K)
	NVal := int64(N)
	groupSizeVal := int64(groupSize)
	fusednf4matmulswiglu_c_f32_neon(
		unsafe.Pointer(&input[0]),
		unsafe.Pointer(&gatePacked[0]),
		unsafe.Pointer(&gateScales[0]),
		unsafe.Pointer(&upPacked[0]),
		unsafe.Pointer(&upScales[0]),
		unsafe.Pointer(&output[0]),
		unsafe.Pointer(&MVal),
		unsafe.Pointer(&KVal),
		unsafe.Pointer(&NVal),
		unsafe.Pointer(&groupSizeVal),
	)
}

// FusedInt4MatMulSwiGLUCF32 computes FusedInt4MatMulSwiGLU using NEON SIMD assembly.
func FusedInt4MatMulSwiGLUCF32(input []float32, gatePacked []uint8, gateScales []float32, upPacked []uint8, upScales, output []float32, M, K, N, groupSize int) {
	if len(input) == 0 || len(gatePacked) == 0 || len(gateScales) == 0 || len(upPacked) == 0 || len(upScales) == 0 || len(output) == 0 {
		return
	}
	MVal := int64(M)
	KVal := int64(K)
	NVal := int64(N)
	groupSizeVal := int64(groupSize)
	fusedint4matmulswiglu_c_f32_neon(
		unsafe.Pointer(&input[0]),
		unsafe.Pointer(&gatePacked[0]),
		unsafe.Pointer(&gateScales[0]),
		unsafe.Pointer(&upPacked[0]),
		unsafe.Pointer(&upScales[0]),
		unsafe.Pointer(&output[0]),
		unsafe.Pointer(&MVal),
		unsafe.Pointer(&KVal),
		unsafe.Pointer(&NVal),
		unsafe.Pointer(&groupSizeVal),
	)
}

