// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

//go:build arm64

package matmul

import (
	"unsafe"

	"github.com/ajroetker/go-highway/hwy"
	"github.com/ajroetker/go-highway/hwy/asm"
)

func BaseBlockedMatMul_neon_Float16(a []hwy.Float16, b []hwy.Float16, c []hwy.Float16, m int, n int, k int) {
	if len(a) < m*k {
		panic("matmul: A slice too short")
	}
	if len(b) < k*n {
		panic("matmul: B slice too short")
	}
	if len(c) < m*n {
		panic("matmul: C slice too short")
	}
	vZero := asm.ZeroFloat16x8()
	lanes := 8
	total := m * n
	var idx int
	for idx = 0; idx+lanes <= total; idx += lanes {
		vZero.StorePtr(unsafe.Pointer(&c[idx:][0]))
	}
	for ; idx < total; idx++ {
		c[idx] = hwy.Float32ToFloat16(0)
	}
	mr := 4
	nr := lanes * 2
	for i0 := 0; i0 < m; i0 += BlockSize {
		iEnd := min(i0+BlockSize, m)
		for j0 := 0; j0 < n; j0 += BlockSize {
			jEnd := min(j0+BlockSize, n)
			var i int
			for i = i0; i+mr <= iEnd; i += mr {
				var j int
				for j = j0; j+nr <= jEnd; j += nr {
					acc00 := asm.ZeroFloat16x8()
					acc01 := asm.ZeroFloat16x8()
					acc10 := asm.ZeroFloat16x8()
					acc11 := asm.ZeroFloat16x8()
					acc20 := asm.ZeroFloat16x8()
					acc21 := asm.ZeroFloat16x8()
					acc30 := asm.ZeroFloat16x8()
					acc31 := asm.ZeroFloat16x8()
					for p := range k {
						a0p := a[i*k+p]
						a1p := a[(i+1)*k+p]
						a2p := a[(i+2)*k+p]
						a3p := a[(i+3)*k+p]
						vA0 := asm.BroadcastFloat16x8(uint16(a0p))
						vA1 := asm.BroadcastFloat16x8(uint16(a1p))
						vA2 := asm.BroadcastFloat16x8(uint16(a2p))
						vA3 := asm.BroadcastFloat16x8(uint16(a3p))
						bRowStart := p * n
						vB0 := asm.LoadFloat16x8Ptr(unsafe.Pointer(&b[bRowStart+j:][0]))
						vB1 := asm.LoadFloat16x8Ptr(unsafe.Pointer(&b[bRowStart+j+lanes:][0]))
						vA0.MulAddAcc(vB0, &acc00)
						vA0.MulAddAcc(vB1, &acc01)
						vA1.MulAddAcc(vB0, &acc10)
						vA1.MulAddAcc(vB1, &acc11)
						vA2.MulAddAcc(vB0, &acc20)
						vA2.MulAddAcc(vB1, &acc21)
						vA3.MulAddAcc(vB0, &acc30)
						vA3.MulAddAcc(vB1, &acc31)
					}
					cRow0 := i * n
					cRow1 := (i + 1) * n
					cRow2 := (i + 2) * n
					cRow3 := (i + 3) * n
					acc00.StorePtr(unsafe.Pointer(&c[cRow0+j:][0]))
					acc01.StorePtr(unsafe.Pointer(&c[cRow0+j+lanes:][0]))
					acc10.StorePtr(unsafe.Pointer(&c[cRow1+j:][0]))
					acc11.StorePtr(unsafe.Pointer(&c[cRow1+j+lanes:][0]))
					acc20.StorePtr(unsafe.Pointer(&c[cRow2+j:][0]))
					acc21.StorePtr(unsafe.Pointer(&c[cRow2+j+lanes:][0]))
					acc30.StorePtr(unsafe.Pointer(&c[cRow3+j:][0]))
					acc31.StorePtr(unsafe.Pointer(&c[cRow3+j+lanes:][0]))
				}
				for ; j < jEnd; j += lanes {
					remaining := jEnd - j
					if remaining >= lanes {
						acc0 := asm.ZeroFloat16x8()
						acc1 := asm.ZeroFloat16x8()
						acc2 := asm.ZeroFloat16x8()
						acc3 := asm.ZeroFloat16x8()
						for p := range k {
							vA0 := asm.BroadcastFloat16x8(uint16(a[i*k+p]))
							vA1 := asm.BroadcastFloat16x8(uint16(a[(i+1)*k+p]))
							vA2 := asm.BroadcastFloat16x8(uint16(a[(i+2)*k+p]))
							vA3 := asm.BroadcastFloat16x8(uint16(a[(i+3)*k+p]))
							vB := asm.LoadFloat16x8Ptr(unsafe.Pointer(&b[p*n+j:][0]))
							vA0.MulAddAcc(vB, &acc0)
							vA1.MulAddAcc(vB, &acc1)
							vA2.MulAddAcc(vB, &acc2)
							vA3.MulAddAcc(vB, &acc3)
						}
						acc0.StorePtr(unsafe.Pointer(&c[i*n+j:][0]))
						acc1.StorePtr(unsafe.Pointer(&c[(i+1)*n+j:][0]))
						acc2.StorePtr(unsafe.Pointer(&c[(i+2)*n+j:][0]))
						acc3.StorePtr(unsafe.Pointer(&c[(i+3)*n+j:][0]))
					} else {
						for jj := j; jj < jEnd; jj++ {
							var sum0, sum1, sum2, sum3 float32
							for p := range k {
								bpj := b[p*n+jj]
								sum0 += a[i*k+p].Float32() * bpj.Float32()
								sum1 += a[(i+1)*k+p].Float32() * bpj.Float32()
								sum2 += a[(i+2)*k+p].Float32() * bpj.Float32()
								sum3 += a[(i+3)*k+p].Float32() * bpj.Float32()
							}
							c[i*n+jj] = hwy.Float32ToFloat16(sum0)
							c[(i+1)*n+jj] = hwy.Float32ToFloat16(sum1)
							c[(i+2)*n+jj] = hwy.Float32ToFloat16(sum2)
							c[(i+3)*n+jj] = hwy.Float32ToFloat16(sum3)
						}
						break
					}
				}
			}
			for i+2 <= iEnd {
				cRow0 := i * n
				cRow1 := (i + 1) * n
				var j int
				for j = j0; j+lanes <= jEnd; j += lanes {
					acc0 := asm.ZeroFloat16x8()
					acc1 := asm.ZeroFloat16x8()
					for p := range k {
						vA0 := asm.BroadcastFloat16x8(uint16(a[i*k+p]))
						vA1 := asm.BroadcastFloat16x8(uint16(a[(i+1)*k+p]))
						vB := asm.LoadFloat16x8Ptr(unsafe.Pointer(&b[p*n+j:][0]))
						vA0.MulAddAcc(vB, &acc0)
						vA1.MulAddAcc(vB, &acc1)
					}
					acc0.StorePtr(unsafe.Pointer(&c[cRow0+j:][0]))
					acc1.StorePtr(unsafe.Pointer(&c[cRow1+j:][0]))
				}
				for ; j < jEnd; j++ {
					var sum0, sum1 float32
					for p := range k {
						bp := b[p*n+j]
						sum0 += a[i*k+p].Float32() * bp.Float32()
						sum1 += a[(i+1)*k+p].Float32() * bp.Float32()
					}
					c[cRow0+j] = hwy.Float32ToFloat16(sum0)
					c[cRow1+j] = hwy.Float32ToFloat16(sum1)
				}
				i += 2
			}
			for ; i < iEnd; i++ {
				cRowStart := i * n
				var j int
				for j = j0; j+lanes <= jEnd; j += lanes {
					acc := asm.ZeroFloat16x8()
					for p := range k {
						vA := asm.BroadcastFloat16x8(uint16(a[i*k+p]))
						vB := asm.LoadFloat16x8Ptr(unsafe.Pointer(&b[p*n+j:][0]))
						vA.MulAddAcc(vB, &acc)
					}
					acc.StorePtr(unsafe.Pointer(&c[cRowStart+j:][0]))
				}
				for ; j < jEnd; j++ {
					var sum float32
					for p := range k {
						sum += a[i*k+p].Float32() * b[p*n+j].Float32()
					}
					c[cRowStart+j] = hwy.Float32ToFloat16(sum)
				}
			}
		}
	}
}

func BaseBlockedMatMul_neon_BFloat16(a []hwy.BFloat16, b []hwy.BFloat16, c []hwy.BFloat16, m int, n int, k int) {
	if len(a) < m*k {
		panic("matmul: A slice too short")
	}
	if len(b) < k*n {
		panic("matmul: B slice too short")
	}
	if len(c) < m*n {
		panic("matmul: C slice too short")
	}
	vZero := asm.ZeroBFloat16x8()
	lanes := 8
	total := m * n
	var idx int
	for idx = 0; idx+lanes <= total; idx += lanes {
		vZero.StorePtr(unsafe.Pointer(&c[idx:][0]))
	}
	for ; idx < total; idx++ {
		c[idx] = hwy.Float32ToBFloat16(0)
	}
	mr := 4
	nr := lanes * 2
	for i0 := 0; i0 < m; i0 += BlockSize {
		iEnd := min(i0+BlockSize, m)
		for j0 := 0; j0 < n; j0 += BlockSize {
			jEnd := min(j0+BlockSize, n)
			var i int
			for i = i0; i+mr <= iEnd; i += mr {
				var j int
				for j = j0; j+nr <= jEnd; j += nr {
					acc00 := asm.ZeroBFloat16x8()
					acc01 := asm.ZeroBFloat16x8()
					acc10 := asm.ZeroBFloat16x8()
					acc11 := asm.ZeroBFloat16x8()
					acc20 := asm.ZeroBFloat16x8()
					acc21 := asm.ZeroBFloat16x8()
					acc30 := asm.ZeroBFloat16x8()
					acc31 := asm.ZeroBFloat16x8()
					for p := range k {
						a0p := a[i*k+p]
						a1p := a[(i+1)*k+p]
						a2p := a[(i+2)*k+p]
						a3p := a[(i+3)*k+p]
						vA0 := asm.BroadcastBFloat16x8(uint16(a0p))
						vA1 := asm.BroadcastBFloat16x8(uint16(a1p))
						vA2 := asm.BroadcastBFloat16x8(uint16(a2p))
						vA3 := asm.BroadcastBFloat16x8(uint16(a3p))
						bRowStart := p * n
						vB0 := asm.LoadBFloat16x8Ptr(unsafe.Pointer(&b[bRowStart+j:][0]))
						vB1 := asm.LoadBFloat16x8Ptr(unsafe.Pointer(&b[bRowStart+j+lanes:][0]))
						vA0.MulAddAcc(vB0, &acc00)
						vA0.MulAddAcc(vB1, &acc01)
						vA1.MulAddAcc(vB0, &acc10)
						vA1.MulAddAcc(vB1, &acc11)
						vA2.MulAddAcc(vB0, &acc20)
						vA2.MulAddAcc(vB1, &acc21)
						vA3.MulAddAcc(vB0, &acc30)
						vA3.MulAddAcc(vB1, &acc31)
					}
					cRow0 := i * n
					cRow1 := (i + 1) * n
					cRow2 := (i + 2) * n
					cRow3 := (i + 3) * n
					acc00.StorePtr(unsafe.Pointer(&c[cRow0+j:][0]))
					acc01.StorePtr(unsafe.Pointer(&c[cRow0+j+lanes:][0]))
					acc10.StorePtr(unsafe.Pointer(&c[cRow1+j:][0]))
					acc11.StorePtr(unsafe.Pointer(&c[cRow1+j+lanes:][0]))
					acc20.StorePtr(unsafe.Pointer(&c[cRow2+j:][0]))
					acc21.StorePtr(unsafe.Pointer(&c[cRow2+j+lanes:][0]))
					acc30.StorePtr(unsafe.Pointer(&c[cRow3+j:][0]))
					acc31.StorePtr(unsafe.Pointer(&c[cRow3+j+lanes:][0]))
				}
				for ; j < jEnd; j += lanes {
					remaining := jEnd - j
					if remaining >= lanes {
						acc0 := asm.ZeroBFloat16x8()
						acc1 := asm.ZeroBFloat16x8()
						acc2 := asm.ZeroBFloat16x8()
						acc3 := asm.ZeroBFloat16x8()
						for p := range k {
							vA0 := asm.BroadcastBFloat16x8(uint16(a[i*k+p]))
							vA1 := asm.BroadcastBFloat16x8(uint16(a[(i+1)*k+p]))
							vA2 := asm.BroadcastBFloat16x8(uint16(a[(i+2)*k+p]))
							vA3 := asm.BroadcastBFloat16x8(uint16(a[(i+3)*k+p]))
							vB := asm.LoadBFloat16x8Ptr(unsafe.Pointer(&b[p*n+j:][0]))
							vA0.MulAddAcc(vB, &acc0)
							vA1.MulAddAcc(vB, &acc1)
							vA2.MulAddAcc(vB, &acc2)
							vA3.MulAddAcc(vB, &acc3)
						}
						acc0.StorePtr(unsafe.Pointer(&c[i*n+j:][0]))
						acc1.StorePtr(unsafe.Pointer(&c[(i+1)*n+j:][0]))
						acc2.StorePtr(unsafe.Pointer(&c[(i+2)*n+j:][0]))
						acc3.StorePtr(unsafe.Pointer(&c[(i+3)*n+j:][0]))
					} else {
						for jj := j; jj < jEnd; jj++ {
							var sum0, sum1, sum2, sum3 float32
							for p := range k {
								bpj := b[p*n+jj]
								sum0 += a[i*k+p].Float32() * bpj.Float32()
								sum1 += a[(i+1)*k+p].Float32() * bpj.Float32()
								sum2 += a[(i+2)*k+p].Float32() * bpj.Float32()
								sum3 += a[(i+3)*k+p].Float32() * bpj.Float32()
							}
							c[i*n+jj] = hwy.Float32ToBFloat16(sum0)
							c[(i+1)*n+jj] = hwy.Float32ToBFloat16(sum1)
							c[(i+2)*n+jj] = hwy.Float32ToBFloat16(sum2)
							c[(i+3)*n+jj] = hwy.Float32ToBFloat16(sum3)
						}
						break
					}
				}
			}
			for i+2 <= iEnd {
				cRow0 := i * n
				cRow1 := (i + 1) * n
				var j int
				for j = j0; j+lanes <= jEnd; j += lanes {
					acc0 := asm.ZeroBFloat16x8()
					acc1 := asm.ZeroBFloat16x8()
					for p := range k {
						vA0 := asm.BroadcastBFloat16x8(uint16(a[i*k+p]))
						vA1 := asm.BroadcastBFloat16x8(uint16(a[(i+1)*k+p]))
						vB := asm.LoadBFloat16x8Ptr(unsafe.Pointer(&b[p*n+j:][0]))
						vA0.MulAddAcc(vB, &acc0)
						vA1.MulAddAcc(vB, &acc1)
					}
					acc0.StorePtr(unsafe.Pointer(&c[cRow0+j:][0]))
					acc1.StorePtr(unsafe.Pointer(&c[cRow1+j:][0]))
				}
				for ; j < jEnd; j++ {
					var sum0, sum1 float32
					for p := range k {
						bp := b[p*n+j]
						sum0 += a[i*k+p].Float32() * bp.Float32()
						sum1 += a[(i+1)*k+p].Float32() * bp.Float32()
					}
					c[cRow0+j] = hwy.Float32ToBFloat16(sum0)
					c[cRow1+j] = hwy.Float32ToBFloat16(sum1)
				}
				i += 2
			}
			for ; i < iEnd; i++ {
				cRowStart := i * n
				var j int
				for j = j0; j+lanes <= jEnd; j += lanes {
					acc := asm.ZeroBFloat16x8()
					for p := range k {
						vA := asm.BroadcastBFloat16x8(uint16(a[i*k+p]))
						vB := asm.LoadBFloat16x8Ptr(unsafe.Pointer(&b[p*n+j:][0]))
						vA.MulAddAcc(vB, &acc)
					}
					acc.StorePtr(unsafe.Pointer(&c[cRowStart+j:][0]))
				}
				for ; j < jEnd; j++ {
					var sum float32
					for p := range k {
						sum += a[i*k+p].Float32() * b[p*n+j].Float32()
					}
					c[cRowStart+j] = hwy.Float32ToBFloat16(sum)
				}
			}
		}
	}
}

func BaseBlockedMatMul_neon(a []float32, b []float32, c []float32, m int, n int, k int) {
	if len(a) < m*k {
		panic("matmul: A slice too short")
	}
	if len(b) < k*n {
		panic("matmul: B slice too short")
	}
	if len(c) < m*n {
		panic("matmul: C slice too short")
	}
	vZero := asm.ZeroFloat32x4()
	lanes := 4
	total := m * n
	var idx int
	for idx = 0; idx+lanes <= total; idx += lanes {
		vZero.Store((*[4]float32)(unsafe.Pointer(&c[idx])))
	}
	for ; idx < total; idx++ {
		c[idx] = 0
	}
	mr := 4
	nr := lanes * 2
	for i0 := 0; i0 < m; i0 += BlockSize {
		iEnd := min(i0+BlockSize, m)
		for j0 := 0; j0 < n; j0 += BlockSize {
			jEnd := min(j0+BlockSize, n)
			var i int
			for i = i0; i+mr <= iEnd; i += mr {
				var j int
				for j = j0; j+nr <= jEnd; j += nr {
					acc00 := asm.ZeroFloat32x4()
					acc01 := asm.ZeroFloat32x4()
					acc10 := asm.ZeroFloat32x4()
					acc11 := asm.ZeroFloat32x4()
					acc20 := asm.ZeroFloat32x4()
					acc21 := asm.ZeroFloat32x4()
					acc30 := asm.ZeroFloat32x4()
					acc31 := asm.ZeroFloat32x4()
					for p := range k {
						a0p := a[i*k+p]
						a1p := a[(i+1)*k+p]
						a2p := a[(i+2)*k+p]
						a3p := a[(i+3)*k+p]
						vA0 := asm.BroadcastFloat32x4(a0p)
						vA1 := asm.BroadcastFloat32x4(a1p)
						vA2 := asm.BroadcastFloat32x4(a2p)
						vA3 := asm.BroadcastFloat32x4(a3p)
						bRowStart := p * n
						vB0 := asm.LoadFloat32x4((*[4]float32)(unsafe.Pointer(&b[bRowStart+j])))
						vB1 := asm.LoadFloat32x4((*[4]float32)(unsafe.Pointer(&b[bRowStart+j+lanes])))
						vA0.MulAddAcc(vB0, &acc00)
						vA0.MulAddAcc(vB1, &acc01)
						vA1.MulAddAcc(vB0, &acc10)
						vA1.MulAddAcc(vB1, &acc11)
						vA2.MulAddAcc(vB0, &acc20)
						vA2.MulAddAcc(vB1, &acc21)
						vA3.MulAddAcc(vB0, &acc30)
						vA3.MulAddAcc(vB1, &acc31)
					}
					cRow0 := i * n
					cRow1 := (i + 1) * n
					cRow2 := (i + 2) * n
					cRow3 := (i + 3) * n
					acc00.Store((*[4]float32)(unsafe.Pointer(&c[cRow0+j])))
					acc01.Store((*[4]float32)(unsafe.Pointer(&c[cRow0+j+lanes])))
					acc10.Store((*[4]float32)(unsafe.Pointer(&c[cRow1+j])))
					acc11.Store((*[4]float32)(unsafe.Pointer(&c[cRow1+j+lanes])))
					acc20.Store((*[4]float32)(unsafe.Pointer(&c[cRow2+j])))
					acc21.Store((*[4]float32)(unsafe.Pointer(&c[cRow2+j+lanes])))
					acc30.Store((*[4]float32)(unsafe.Pointer(&c[cRow3+j])))
					acc31.Store((*[4]float32)(unsafe.Pointer(&c[cRow3+j+lanes])))
				}
				for ; j < jEnd; j += lanes {
					remaining := jEnd - j
					if remaining >= lanes {
						acc0 := asm.ZeroFloat32x4()
						acc1 := asm.ZeroFloat32x4()
						acc2 := asm.ZeroFloat32x4()
						acc3 := asm.ZeroFloat32x4()
						for p := range k {
							vA0 := asm.BroadcastFloat32x4(a[i*k+p])
							vA1 := asm.BroadcastFloat32x4(a[(i+1)*k+p])
							vA2 := asm.BroadcastFloat32x4(a[(i+2)*k+p])
							vA3 := asm.BroadcastFloat32x4(a[(i+3)*k+p])
							vB := asm.LoadFloat32x4((*[4]float32)(unsafe.Pointer(&b[p*n+j])))
							vA0.MulAddAcc(vB, &acc0)
							vA1.MulAddAcc(vB, &acc1)
							vA2.MulAddAcc(vB, &acc2)
							vA3.MulAddAcc(vB, &acc3)
						}
						acc0.Store((*[4]float32)(unsafe.Pointer(&c[i*n+j])))
						acc1.Store((*[4]float32)(unsafe.Pointer(&c[(i+1)*n+j])))
						acc2.Store((*[4]float32)(unsafe.Pointer(&c[(i+2)*n+j])))
						acc3.Store((*[4]float32)(unsafe.Pointer(&c[(i+3)*n+j])))
					} else {
						for jj := j; jj < jEnd; jj++ {
							var sum0, sum1, sum2, sum3 float32
							for p := range k {
								bpj := b[p*n+jj]
								sum0 += a[i*k+p] * bpj
								sum1 += a[(i+1)*k+p] * bpj
								sum2 += a[(i+2)*k+p] * bpj
								sum3 += a[(i+3)*k+p] * bpj
							}
							c[i*n+jj] = sum0
							c[(i+1)*n+jj] = sum1
							c[(i+2)*n+jj] = sum2
							c[(i+3)*n+jj] = sum3
						}
						break
					}
				}
			}
			for i+2 <= iEnd {
				cRow0 := i * n
				cRow1 := (i + 1) * n
				var j int
				for j = j0; j+lanes <= jEnd; j += lanes {
					acc0 := asm.ZeroFloat32x4()
					acc1 := asm.ZeroFloat32x4()
					for p := range k {
						vA0 := asm.BroadcastFloat32x4(a[i*k+p])
						vA1 := asm.BroadcastFloat32x4(a[(i+1)*k+p])
						vB := asm.LoadFloat32x4((*[4]float32)(unsafe.Pointer(&b[p*n+j])))
						vA0.MulAddAcc(vB, &acc0)
						vA1.MulAddAcc(vB, &acc1)
					}
					acc0.Store((*[4]float32)(unsafe.Pointer(&c[cRow0+j])))
					acc1.Store((*[4]float32)(unsafe.Pointer(&c[cRow1+j])))
				}
				for ; j < jEnd; j++ {
					var sum0, sum1 float32
					for p := range k {
						bp := b[p*n+j]
						sum0 += a[i*k+p] * bp
						sum1 += a[(i+1)*k+p] * bp
					}
					c[cRow0+j] = sum0
					c[cRow1+j] = sum1
				}
				i += 2
			}
			for ; i < iEnd; i++ {
				cRowStart := i * n
				var j int
				for j = j0; j+lanes <= jEnd; j += lanes {
					acc := asm.ZeroFloat32x4()
					for p := range k {
						vA := asm.BroadcastFloat32x4(a[i*k+p])
						vB := asm.LoadFloat32x4((*[4]float32)(unsafe.Pointer(&b[p*n+j])))
						vA.MulAddAcc(vB, &acc)
					}
					acc.Store((*[4]float32)(unsafe.Pointer(&c[cRowStart+j])))
				}
				for ; j < jEnd; j++ {
					var sum float32
					for p := range k {
						sum += a[i*k+p] * b[p*n+j]
					}
					c[cRowStart+j] = sum
				}
			}
		}
	}
}

func BaseBlockedMatMul_neon_Float64(a []float64, b []float64, c []float64, m int, n int, k int) {
	if len(a) < m*k {
		panic("matmul: A slice too short")
	}
	if len(b) < k*n {
		panic("matmul: B slice too short")
	}
	if len(c) < m*n {
		panic("matmul: C slice too short")
	}
	vZero := asm.ZeroFloat64x2()
	lanes := 2
	total := m * n
	var idx int
	for idx = 0; idx+lanes <= total; idx += lanes {
		vZero.Store((*[2]float64)(unsafe.Pointer(&c[idx])))
	}
	for ; idx < total; idx++ {
		c[idx] = 0
	}
	mr := 4
	nr := lanes * 2
	for i0 := 0; i0 < m; i0 += BlockSize {
		iEnd := min(i0+BlockSize, m)
		for j0 := 0; j0 < n; j0 += BlockSize {
			jEnd := min(j0+BlockSize, n)
			var i int
			for i = i0; i+mr <= iEnd; i += mr {
				var j int
				for j = j0; j+nr <= jEnd; j += nr {
					acc00 := asm.ZeroFloat64x2()
					acc01 := asm.ZeroFloat64x2()
					acc10 := asm.ZeroFloat64x2()
					acc11 := asm.ZeroFloat64x2()
					acc20 := asm.ZeroFloat64x2()
					acc21 := asm.ZeroFloat64x2()
					acc30 := asm.ZeroFloat64x2()
					acc31 := asm.ZeroFloat64x2()
					for p := range k {
						a0p := a[i*k+p]
						a1p := a[(i+1)*k+p]
						a2p := a[(i+2)*k+p]
						a3p := a[(i+3)*k+p]
						vA0 := asm.BroadcastFloat64x2(a0p)
						vA1 := asm.BroadcastFloat64x2(a1p)
						vA2 := asm.BroadcastFloat64x2(a2p)
						vA3 := asm.BroadcastFloat64x2(a3p)
						bRowStart := p * n
						vB0 := asm.LoadFloat64x2((*[2]float64)(unsafe.Pointer(&b[bRowStart+j])))
						vB1 := asm.LoadFloat64x2((*[2]float64)(unsafe.Pointer(&b[bRowStart+j+lanes])))
						vA0.MulAddAcc(vB0, &acc00)
						vA0.MulAddAcc(vB1, &acc01)
						vA1.MulAddAcc(vB0, &acc10)
						vA1.MulAddAcc(vB1, &acc11)
						vA2.MulAddAcc(vB0, &acc20)
						vA2.MulAddAcc(vB1, &acc21)
						vA3.MulAddAcc(vB0, &acc30)
						vA3.MulAddAcc(vB1, &acc31)
					}
					cRow0 := i * n
					cRow1 := (i + 1) * n
					cRow2 := (i + 2) * n
					cRow3 := (i + 3) * n
					acc00.Store((*[2]float64)(unsafe.Pointer(&c[cRow0+j])))
					acc01.Store((*[2]float64)(unsafe.Pointer(&c[cRow0+j+lanes])))
					acc10.Store((*[2]float64)(unsafe.Pointer(&c[cRow1+j])))
					acc11.Store((*[2]float64)(unsafe.Pointer(&c[cRow1+j+lanes])))
					acc20.Store((*[2]float64)(unsafe.Pointer(&c[cRow2+j])))
					acc21.Store((*[2]float64)(unsafe.Pointer(&c[cRow2+j+lanes])))
					acc30.Store((*[2]float64)(unsafe.Pointer(&c[cRow3+j])))
					acc31.Store((*[2]float64)(unsafe.Pointer(&c[cRow3+j+lanes])))
				}
				for ; j < jEnd; j += lanes {
					remaining := jEnd - j
					if remaining >= lanes {
						acc0 := asm.ZeroFloat64x2()
						acc1 := asm.ZeroFloat64x2()
						acc2 := asm.ZeroFloat64x2()
						acc3 := asm.ZeroFloat64x2()
						for p := range k {
							vA0 := asm.BroadcastFloat64x2(a[i*k+p])
							vA1 := asm.BroadcastFloat64x2(a[(i+1)*k+p])
							vA2 := asm.BroadcastFloat64x2(a[(i+2)*k+p])
							vA3 := asm.BroadcastFloat64x2(a[(i+3)*k+p])
							vB := asm.LoadFloat64x2((*[2]float64)(unsafe.Pointer(&b[p*n+j])))
							vA0.MulAddAcc(vB, &acc0)
							vA1.MulAddAcc(vB, &acc1)
							vA2.MulAddAcc(vB, &acc2)
							vA3.MulAddAcc(vB, &acc3)
						}
						acc0.Store((*[2]float64)(unsafe.Pointer(&c[i*n+j])))
						acc1.Store((*[2]float64)(unsafe.Pointer(&c[(i+1)*n+j])))
						acc2.Store((*[2]float64)(unsafe.Pointer(&c[(i+2)*n+j])))
						acc3.Store((*[2]float64)(unsafe.Pointer(&c[(i+3)*n+j])))
					} else {
						for jj := j; jj < jEnd; jj++ {
							var sum0, sum1, sum2, sum3 float64
							for p := range k {
								bpj := b[p*n+jj]
								sum0 += a[i*k+p] * bpj
								sum1 += a[(i+1)*k+p] * bpj
								sum2 += a[(i+2)*k+p] * bpj
								sum3 += a[(i+3)*k+p] * bpj
							}
							c[i*n+jj] = sum0
							c[(i+1)*n+jj] = sum1
							c[(i+2)*n+jj] = sum2
							c[(i+3)*n+jj] = sum3
						}
						break
					}
				}
			}
			for i+2 <= iEnd {
				cRow0 := i * n
				cRow1 := (i + 1) * n
				var j int
				for j = j0; j+lanes <= jEnd; j += lanes {
					acc0 := asm.ZeroFloat64x2()
					acc1 := asm.ZeroFloat64x2()
					for p := range k {
						vA0 := asm.BroadcastFloat64x2(a[i*k+p])
						vA1 := asm.BroadcastFloat64x2(a[(i+1)*k+p])
						vB := asm.LoadFloat64x2((*[2]float64)(unsafe.Pointer(&b[p*n+j])))
						vA0.MulAddAcc(vB, &acc0)
						vA1.MulAddAcc(vB, &acc1)
					}
					acc0.Store((*[2]float64)(unsafe.Pointer(&c[cRow0+j])))
					acc1.Store((*[2]float64)(unsafe.Pointer(&c[cRow1+j])))
				}
				for ; j < jEnd; j++ {
					var sum0, sum1 float64
					for p := range k {
						bp := b[p*n+j]
						sum0 += a[i*k+p] * bp
						sum1 += a[(i+1)*k+p] * bp
					}
					c[cRow0+j] = sum0
					c[cRow1+j] = sum1
				}
				i += 2
			}
			for ; i < iEnd; i++ {
				cRowStart := i * n
				var j int
				for j = j0; j+lanes <= jEnd; j += lanes {
					acc := asm.ZeroFloat64x2()
					for p := range k {
						vA := asm.BroadcastFloat64x2(a[i*k+p])
						vB := asm.LoadFloat64x2((*[2]float64)(unsafe.Pointer(&b[p*n+j])))
						vA.MulAddAcc(vB, &acc)
					}
					acc.Store((*[2]float64)(unsafe.Pointer(&c[cRowStart+j])))
				}
				for ; j < jEnd; j++ {
					var sum float64
					for p := range k {
						sum += a[i*k+p] * b[p*n+j]
					}
					c[cRowStart+j] = sum
				}
			}
		}
	}
}
