// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

//go:build arm64

package matmul

import (
	"github.com/ajroetker/go-highway/hwy"
)

var PackedMatMulFloat16 func(a []hwy.Float16, b []hwy.Float16, c []hwy.Float16, m int, n int, k int)
var PackedMatMulBFloat16 func(a []hwy.BFloat16, b []hwy.BFloat16, c []hwy.BFloat16, m int, n int, k int)
var PackedMatMulFloat32 func(a []float32, b []float32, c []float32, m int, n int, k int)
var PackedMatMulFloat64 func(a []float64, b []float64, c []float64, m int, n int, k int)
var PackedMatMulWithBuffersFloat16 func(a []hwy.Float16, b []hwy.Float16, c []hwy.Float16, m int, n int, k int, packedA []hwy.Float16, packedB []hwy.Float16, params CacheParams)
var PackedMatMulWithBuffersBFloat16 func(a []hwy.BFloat16, b []hwy.BFloat16, c []hwy.BFloat16, m int, n int, k int, packedA []hwy.BFloat16, packedB []hwy.BFloat16, params CacheParams)
var PackedMatMulWithBuffersFloat32 func(a []float32, b []float32, c []float32, m int, n int, k int, packedA []float32, packedB []float32, params CacheParams)
var PackedMatMulWithBuffersFloat64 func(a []float64, b []float64, c []float64, m int, n int, k int, packedA []float64, packedB []float64, params CacheParams)
var PackedMatMulStripFloat16 func(a []hwy.Float16, b []hwy.Float16, c []hwy.Float16, m int, n int, k int, rowStart int, rowEnd int, packedA []hwy.Float16, packedB []hwy.Float16, params CacheParams)
var PackedMatMulStripBFloat16 func(a []hwy.BFloat16, b []hwy.BFloat16, c []hwy.BFloat16, m int, n int, k int, rowStart int, rowEnd int, packedA []hwy.BFloat16, packedB []hwy.BFloat16, params CacheParams)
var PackedMatMulStripFloat32 func(a []float32, b []float32, c []float32, m int, n int, k int, rowStart int, rowEnd int, packedA []float32, packedB []float32, params CacheParams)
var PackedMatMulStripFloat64 func(a []float64, b []float64, c []float64, m int, n int, k int, rowStart int, rowEnd int, packedA []float64, packedB []float64, params CacheParams)

// PackedMatMul computes C = A * B using the GotoBLAS-style 5-loop algorithm
// with matrix packing for optimal cache utilization.
//
// The algorithm structure (GEBP - GEneral Block Panel multiplication):
//
//	for jc := 0; jc < n; jc += Nc:       // Loop 5: B panels (L3 cache)
//	  for pc := 0; pc < k; pc += Kc:     // Loop 4: K blocking (L1 cache)
//	    PackRHS(B[pc:pc+Kc, jc:jc+Nc])   // Pack B panel once per (jc, pc)
//	    for ic := 0; ic < m; ic += Mc:   // Loop 3: A panels (L2 cache)
//	      PackLHS(A[ic:ic+Mc, pc:pc+Kc]) // Pack A panel once per (jc, pc, ic)
//	      for jr := 0; jr < Nc; jr += Nr:   // Loop 2: micro-tile columns
//	        for ir := 0; ir < Mc; ir += Mr: // Loop 1: micro-tile rows
//	          PackedMicroKernel(...)        // Mr × Nr micro-tile
//
// Key benefits over streaming matmul:
//   - K-dimension blocking prevents L1 cache thrashing
//   - Packed layout enables sequential memory access in innermost loops
//   - Accumulators stay in registers across entire Kc loop
//   - B panel reused across all A panels (L3 blocking)
//   - A panel reused across all micro-columns (L2 blocking)
//
// Parameters:
//   - a: Input matrix A in row-major order (M × K)
//   - b: Input matrix B in row-major order (K × N)
//   - c: Output matrix C in row-major order (M × N), will be zeroed
//   - m, n, k: Matrix dimensions
//
// This function dispatches to the appropriate SIMD implementation at runtime.
func PackedMatMul[T hwy.Floats](a []T, b []T, c []T, m int, n int, k int) {
	switch any(a).(type) {
	case []hwy.Float16:
		PackedMatMulFloat16(any(a).([]hwy.Float16), any(b).([]hwy.Float16), any(c).([]hwy.Float16), m, n, k)
	case []hwy.BFloat16:
		PackedMatMulBFloat16(any(a).([]hwy.BFloat16), any(b).([]hwy.BFloat16), any(c).([]hwy.BFloat16), m, n, k)
	case []float32:
		PackedMatMulFloat32(any(a).([]float32), any(b).([]float32), any(c).([]float32), m, n, k)
	case []float64:
		PackedMatMulFloat64(any(a).([]float64), any(b).([]float64), any(c).([]float64), m, n, k)
	}
}

// PackedMatMulWithBuffers is like BasePackedMatMul but uses pre-allocated buffers.
// This is useful for parallel execution where each worker has its own buffers.
//
// This function dispatches to the appropriate SIMD implementation at runtime.
func PackedMatMulWithBuffers[T hwy.Floats](a []T, b []T, c []T, m int, n int, k int, packedA []T, packedB []T, params CacheParams) {
	switch any(a).(type) {
	case []hwy.Float16:
		PackedMatMulWithBuffersFloat16(any(a).([]hwy.Float16), any(b).([]hwy.Float16), any(c).([]hwy.Float16), m, n, k, any(packedA).([]hwy.Float16), any(packedB).([]hwy.Float16), params)
	case []hwy.BFloat16:
		PackedMatMulWithBuffersBFloat16(any(a).([]hwy.BFloat16), any(b).([]hwy.BFloat16), any(c).([]hwy.BFloat16), m, n, k, any(packedA).([]hwy.BFloat16), any(packedB).([]hwy.BFloat16), params)
	case []float32:
		PackedMatMulWithBuffersFloat32(any(a).([]float32), any(b).([]float32), any(c).([]float32), m, n, k, any(packedA).([]float32), any(packedB).([]float32), params)
	case []float64:
		PackedMatMulWithBuffersFloat64(any(a).([]float64), any(b).([]float64), any(c).([]float64), m, n, k, any(packedA).([]float64), any(packedB).([]float64), params)
	}
}

// PackedMatMulStrip computes a horizontal strip of C = A * B.
// Used by parallel implementation to divide work across workers.
//
// Computes: C[rowStart:rowEnd, :] = A[rowStart:rowEnd, :] * B
//
// Parameters:
//   - rowStart, rowEnd: Row range to compute (0-indexed)
//   - packedA, packedB: Pre-allocated packing buffers
//   - params: Cache blocking parameters
//
// This function dispatches to the appropriate SIMD implementation at runtime.
func PackedMatMulStrip[T hwy.Floats](a []T, b []T, c []T, m int, n int, k int, rowStart int, rowEnd int, packedA []T, packedB []T, params CacheParams) {
	switch any(a).(type) {
	case []hwy.Float16:
		PackedMatMulStripFloat16(any(a).([]hwy.Float16), any(b).([]hwy.Float16), any(c).([]hwy.Float16), m, n, k, rowStart, rowEnd, any(packedA).([]hwy.Float16), any(packedB).([]hwy.Float16), params)
	case []hwy.BFloat16:
		PackedMatMulStripBFloat16(any(a).([]hwy.BFloat16), any(b).([]hwy.BFloat16), any(c).([]hwy.BFloat16), m, n, k, rowStart, rowEnd, any(packedA).([]hwy.BFloat16), any(packedB).([]hwy.BFloat16), params)
	case []float32:
		PackedMatMulStripFloat32(any(a).([]float32), any(b).([]float32), any(c).([]float32), m, n, k, rowStart, rowEnd, any(packedA).([]float32), any(packedB).([]float32), params)
	case []float64:
		PackedMatMulStripFloat64(any(a).([]float64), any(b).([]float64), any(c).([]float64), m, n, k, rowStart, rowEnd, any(packedA).([]float64), any(packedB).([]float64), params)
	}
}

func init() {
	if hwy.NoSimdEnv() {
		initPackedmatmulFallback()
		return
	}
	initPackedmatmulNEON()
	return
}

func initPackedmatmulNEON() {
	PackedMatMulFloat16 = BasePackedMatMul_neon_Float16
	PackedMatMulBFloat16 = BasePackedMatMul_neon_BFloat16
	PackedMatMulFloat32 = BasePackedMatMul_neon
	PackedMatMulFloat64 = BasePackedMatMul_neon_Float64
	PackedMatMulWithBuffersFloat16 = BasePackedMatMulWithBuffers_neon_Float16
	PackedMatMulWithBuffersBFloat16 = BasePackedMatMulWithBuffers_neon_BFloat16
	PackedMatMulWithBuffersFloat32 = BasePackedMatMulWithBuffers_neon
	PackedMatMulWithBuffersFloat64 = BasePackedMatMulWithBuffers_neon_Float64
	PackedMatMulStripFloat16 = BasePackedMatMulStrip_neon_Float16
	PackedMatMulStripBFloat16 = BasePackedMatMulStrip_neon_BFloat16
	PackedMatMulStripFloat32 = BasePackedMatMulStrip_neon
	PackedMatMulStripFloat64 = BasePackedMatMulStrip_neon_Float64
}

func initPackedmatmulFallback() {
	PackedMatMulFloat16 = BasePackedMatMul_fallback_Float16
	PackedMatMulBFloat16 = BasePackedMatMul_fallback_BFloat16
	PackedMatMulFloat32 = BasePackedMatMul_fallback
	PackedMatMulFloat64 = BasePackedMatMul_fallback_Float64
	PackedMatMulWithBuffersFloat16 = BasePackedMatMulWithBuffers_fallback_Float16
	PackedMatMulWithBuffersBFloat16 = BasePackedMatMulWithBuffers_fallback_BFloat16
	PackedMatMulWithBuffersFloat32 = BasePackedMatMulWithBuffers_fallback
	PackedMatMulWithBuffersFloat64 = BasePackedMatMulWithBuffers_fallback_Float64
	PackedMatMulStripFloat16 = BasePackedMatMulStrip_fallback_Float16
	PackedMatMulStripBFloat16 = BasePackedMatMulStrip_fallback_BFloat16
	PackedMatMulStripFloat32 = BasePackedMatMulStrip_fallback
	PackedMatMulStripFloat64 = BasePackedMatMulStrip_fallback_Float64
}
