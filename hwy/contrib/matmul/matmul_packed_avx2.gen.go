// Code generated by hwygen. DO NOT EDIT.
//go:build amd64 && goexperiment.simd

package matmul

import (
	"github.com/ajroetker/go-highway/hwy"
)

func BasePackedMatMul_avx2_Float16(a []hwy.Float16, b []hwy.Float16, c []hwy.Float16, m int, n int, k int) {
	if len(a) < m*k {
		panic("packedmatmul: A slice too short")
	}
	if len(b) < k*n {
		panic("packedmatmul: B slice too short")
	}
	if len(c) < m*n {
		panic("packedmatmul: C slice too short")
	}
	params := getCacheParams[hwy.Float16]()
	mr, nr := params.Mr, params.Nr
	kc, mc, nc := params.Kc, params.Mc, params.Nc
	packedASize := params.PackedASize()
	packedBSize := params.PackedBSize()
	packedA := make([]hwy.Float16, packedASize)
	packedB := make([]hwy.Float16, packedBSize)
	zeroMatrix(c, m*n)
	for jc := 0; jc < n; jc += nc {
		jcEnd := min(jc+nc, n)
		panelCols := jcEnd - jc
		for pc := 0; pc < k; pc += kc {
			pcEnd := min(pc+kc, k)
			panelK := pcEnd - pc
			PackRHS(b, packedB, k, n, pc, jc, panelK, panelCols, nr)
			for ic := 0; ic < m; ic += mc {
				icEnd := min(ic+mc, m)
				panelRows := icEnd - ic
				activeRowsLast := PackLHS(a, packedA, m, k, ic, pc, panelRows, panelK, mr)
				gebp(packedA, packedB, c, n, ic, jc, panelRows, panelCols, panelK, mr, nr, activeRowsLast)
			}
		}
	}
}

func BasePackedMatMul_avx2_BFloat16(a []hwy.BFloat16, b []hwy.BFloat16, c []hwy.BFloat16, m int, n int, k int) {
	if len(a) < m*k {
		panic("packedmatmul: A slice too short")
	}
	if len(b) < k*n {
		panic("packedmatmul: B slice too short")
	}
	if len(c) < m*n {
		panic("packedmatmul: C slice too short")
	}
	params := getCacheParams[hwy.BFloat16]()
	mr, nr := params.Mr, params.Nr
	kc, mc, nc := params.Kc, params.Mc, params.Nc
	packedASize := params.PackedASize()
	packedBSize := params.PackedBSize()
	packedA := make([]hwy.BFloat16, packedASize)
	packedB := make([]hwy.BFloat16, packedBSize)
	zeroMatrix(c, m*n)
	for jc := 0; jc < n; jc += nc {
		jcEnd := min(jc+nc, n)
		panelCols := jcEnd - jc
		for pc := 0; pc < k; pc += kc {
			pcEnd := min(pc+kc, k)
			panelK := pcEnd - pc
			PackRHS(b, packedB, k, n, pc, jc, panelK, panelCols, nr)
			for ic := 0; ic < m; ic += mc {
				icEnd := min(ic+mc, m)
				panelRows := icEnd - ic
				activeRowsLast := PackLHS(a, packedA, m, k, ic, pc, panelRows, panelK, mr)
				gebp(packedA, packedB, c, n, ic, jc, panelRows, panelCols, panelK, mr, nr, activeRowsLast)
			}
		}
	}
}

func BasePackedMatMul_avx2(a []float32, b []float32, c []float32, m int, n int, k int) {
	if len(a) < m*k {
		panic("packedmatmul: A slice too short")
	}
	if len(b) < k*n {
		panic("packedmatmul: B slice too short")
	}
	if len(c) < m*n {
		panic("packedmatmul: C slice too short")
	}
	params := getCacheParams[float32]()
	mr, nr := params.Mr, params.Nr
	kc, mc, nc := params.Kc, params.Mc, params.Nc
	packedASize := params.PackedASize()
	packedBSize := params.PackedBSize()
	packedA := make([]float32, packedASize)
	packedB := make([]float32, packedBSize)
	zeroMatrix(c, m*n)
	for jc := 0; jc < n; jc += nc {
		jcEnd := min(jc+nc, n)
		panelCols := jcEnd - jc
		for pc := 0; pc < k; pc += kc {
			pcEnd := min(pc+kc, k)
			panelK := pcEnd - pc
			PackRHS(b, packedB, k, n, pc, jc, panelK, panelCols, nr)
			for ic := 0; ic < m; ic += mc {
				icEnd := min(ic+mc, m)
				panelRows := icEnd - ic
				activeRowsLast := PackLHS(a, packedA, m, k, ic, pc, panelRows, panelK, mr)
				gebp(packedA, packedB, c, n, ic, jc, panelRows, panelCols, panelK, mr, nr, activeRowsLast)
			}
		}
	}
}

func BasePackedMatMul_avx2_Float64(a []float64, b []float64, c []float64, m int, n int, k int) {
	if len(a) < m*k {
		panic("packedmatmul: A slice too short")
	}
	if len(b) < k*n {
		panic("packedmatmul: B slice too short")
	}
	if len(c) < m*n {
		panic("packedmatmul: C slice too short")
	}
	params := getCacheParams[float64]()
	mr, nr := params.Mr, params.Nr
	kc, mc, nc := params.Kc, params.Mc, params.Nc
	packedASize := params.PackedASize()
	packedBSize := params.PackedBSize()
	packedA := make([]float64, packedASize)
	packedB := make([]float64, packedBSize)
	zeroMatrix(c, m*n)
	for jc := 0; jc < n; jc += nc {
		jcEnd := min(jc+nc, n)
		panelCols := jcEnd - jc
		for pc := 0; pc < k; pc += kc {
			pcEnd := min(pc+kc, k)
			panelK := pcEnd - pc
			PackRHS(b, packedB, k, n, pc, jc, panelK, panelCols, nr)
			for ic := 0; ic < m; ic += mc {
				icEnd := min(ic+mc, m)
				panelRows := icEnd - ic
				activeRowsLast := PackLHS(a, packedA, m, k, ic, pc, panelRows, panelK, mr)
				gebp(packedA, packedB, c, n, ic, jc, panelRows, panelCols, panelK, mr, nr, activeRowsLast)
			}
		}
	}
}

func BasePackedMatMulWithBuffers_avx2_Float16(a []hwy.Float16, b []hwy.Float16, c []hwy.Float16, m int, n int, k int, packedA []hwy.Float16, packedB []hwy.Float16, params CacheParams) {
	if len(a) < m*k {
		panic("packedmatmul: A slice too short")
	}
	if len(b) < k*n {
		panic("packedmatmul: B slice too short")
	}
	if len(c) < m*n {
		panic("packedmatmul: C slice too short")
	}
	mr, nr := params.Mr, params.Nr
	kc, mc, nc := params.Kc, params.Mc, params.Nc
	zeroMatrix(c, m*n)
	for jc := 0; jc < n; jc += nc {
		jcEnd := min(jc+nc, n)
		panelCols := jcEnd - jc
		for pc := 0; pc < k; pc += kc {
			pcEnd := min(pc+kc, k)
			panelK := pcEnd - pc
			PackRHS(b, packedB, k, n, pc, jc, panelK, panelCols, nr)
			for ic := 0; ic < m; ic += mc {
				icEnd := min(ic+mc, m)
				panelRows := icEnd - ic
				activeRowsLast := PackLHS(a, packedA, m, k, ic, pc, panelRows, panelK, mr)
				gebp(packedA, packedB, c, n, ic, jc, panelRows, panelCols, panelK, mr, nr, activeRowsLast)
			}
		}
	}
}

func BasePackedMatMulWithBuffers_avx2_BFloat16(a []hwy.BFloat16, b []hwy.BFloat16, c []hwy.BFloat16, m int, n int, k int, packedA []hwy.BFloat16, packedB []hwy.BFloat16, params CacheParams) {
	if len(a) < m*k {
		panic("packedmatmul: A slice too short")
	}
	if len(b) < k*n {
		panic("packedmatmul: B slice too short")
	}
	if len(c) < m*n {
		panic("packedmatmul: C slice too short")
	}
	mr, nr := params.Mr, params.Nr
	kc, mc, nc := params.Kc, params.Mc, params.Nc
	zeroMatrix(c, m*n)
	for jc := 0; jc < n; jc += nc {
		jcEnd := min(jc+nc, n)
		panelCols := jcEnd - jc
		for pc := 0; pc < k; pc += kc {
			pcEnd := min(pc+kc, k)
			panelK := pcEnd - pc
			PackRHS(b, packedB, k, n, pc, jc, panelK, panelCols, nr)
			for ic := 0; ic < m; ic += mc {
				icEnd := min(ic+mc, m)
				panelRows := icEnd - ic
				activeRowsLast := PackLHS(a, packedA, m, k, ic, pc, panelRows, panelK, mr)
				gebp(packedA, packedB, c, n, ic, jc, panelRows, panelCols, panelK, mr, nr, activeRowsLast)
			}
		}
	}
}

func BasePackedMatMulWithBuffers_avx2(a []float32, b []float32, c []float32, m int, n int, k int, packedA []float32, packedB []float32, params CacheParams) {
	if len(a) < m*k {
		panic("packedmatmul: A slice too short")
	}
	if len(b) < k*n {
		panic("packedmatmul: B slice too short")
	}
	if len(c) < m*n {
		panic("packedmatmul: C slice too short")
	}
	mr, nr := params.Mr, params.Nr
	kc, mc, nc := params.Kc, params.Mc, params.Nc
	zeroMatrix(c, m*n)
	for jc := 0; jc < n; jc += nc {
		jcEnd := min(jc+nc, n)
		panelCols := jcEnd - jc
		for pc := 0; pc < k; pc += kc {
			pcEnd := min(pc+kc, k)
			panelK := pcEnd - pc
			PackRHS(b, packedB, k, n, pc, jc, panelK, panelCols, nr)
			for ic := 0; ic < m; ic += mc {
				icEnd := min(ic+mc, m)
				panelRows := icEnd - ic
				activeRowsLast := PackLHS(a, packedA, m, k, ic, pc, panelRows, panelK, mr)
				gebp(packedA, packedB, c, n, ic, jc, panelRows, panelCols, panelK, mr, nr, activeRowsLast)
			}
		}
	}
}

func BasePackedMatMulWithBuffers_avx2_Float64(a []float64, b []float64, c []float64, m int, n int, k int, packedA []float64, packedB []float64, params CacheParams) {
	if len(a) < m*k {
		panic("packedmatmul: A slice too short")
	}
	if len(b) < k*n {
		panic("packedmatmul: B slice too short")
	}
	if len(c) < m*n {
		panic("packedmatmul: C slice too short")
	}
	mr, nr := params.Mr, params.Nr
	kc, mc, nc := params.Kc, params.Mc, params.Nc
	zeroMatrix(c, m*n)
	for jc := 0; jc < n; jc += nc {
		jcEnd := min(jc+nc, n)
		panelCols := jcEnd - jc
		for pc := 0; pc < k; pc += kc {
			pcEnd := min(pc+kc, k)
			panelK := pcEnd - pc
			PackRHS(b, packedB, k, n, pc, jc, panelK, panelCols, nr)
			for ic := 0; ic < m; ic += mc {
				icEnd := min(ic+mc, m)
				panelRows := icEnd - ic
				activeRowsLast := PackLHS(a, packedA, m, k, ic, pc, panelRows, panelK, mr)
				gebp(packedA, packedB, c, n, ic, jc, panelRows, panelCols, panelK, mr, nr, activeRowsLast)
			}
		}
	}
}

func BasePackedMatMulStrip_avx2_Float16(a []hwy.Float16, b []hwy.Float16, c []hwy.Float16, m int, n int, k int, rowStart int, rowEnd int, packedA []hwy.Float16, packedB []hwy.Float16, params CacheParams) {
	mr, nr := params.Mr, params.Nr
	kc, mc, nc := params.Kc, params.Mc, params.Nc
	stripM := rowEnd - rowStart
	zeroMatrix(c[rowStart*n:rowEnd*n], stripM*n)
	for jc := 0; jc < n; jc += nc {
		jcEnd := min(jc+nc, n)
		panelCols := jcEnd - jc
		for pc := 0; pc < k; pc += kc {
			pcEnd := min(pc+kc, k)
			panelK := pcEnd - pc
			PackRHS(b, packedB, k, n, pc, jc, panelK, panelCols, nr)
			for ic := rowStart; ic < rowEnd; ic += mc {
				icEnd := min(ic+mc, rowEnd)
				panelRows := icEnd - ic
				activeRowsLast := PackLHS(a, packedA, m, k, ic, pc, panelRows, panelK, mr)
				gebp(packedA, packedB, c, n, ic, jc, panelRows, panelCols, panelK, mr, nr, activeRowsLast)
			}
		}
	}
}

func BasePackedMatMulStrip_avx2_BFloat16(a []hwy.BFloat16, b []hwy.BFloat16, c []hwy.BFloat16, m int, n int, k int, rowStart int, rowEnd int, packedA []hwy.BFloat16, packedB []hwy.BFloat16, params CacheParams) {
	mr, nr := params.Mr, params.Nr
	kc, mc, nc := params.Kc, params.Mc, params.Nc
	stripM := rowEnd - rowStart
	zeroMatrix(c[rowStart*n:rowEnd*n], stripM*n)
	for jc := 0; jc < n; jc += nc {
		jcEnd := min(jc+nc, n)
		panelCols := jcEnd - jc
		for pc := 0; pc < k; pc += kc {
			pcEnd := min(pc+kc, k)
			panelK := pcEnd - pc
			PackRHS(b, packedB, k, n, pc, jc, panelK, panelCols, nr)
			for ic := rowStart; ic < rowEnd; ic += mc {
				icEnd := min(ic+mc, rowEnd)
				panelRows := icEnd - ic
				activeRowsLast := PackLHS(a, packedA, m, k, ic, pc, panelRows, panelK, mr)
				gebp(packedA, packedB, c, n, ic, jc, panelRows, panelCols, panelK, mr, nr, activeRowsLast)
			}
		}
	}
}

func BasePackedMatMulStrip_avx2(a []float32, b []float32, c []float32, m int, n int, k int, rowStart int, rowEnd int, packedA []float32, packedB []float32, params CacheParams) {
	mr, nr := params.Mr, params.Nr
	kc, mc, nc := params.Kc, params.Mc, params.Nc
	stripM := rowEnd - rowStart
	zeroMatrix(c[rowStart*n:rowEnd*n], stripM*n)
	for jc := 0; jc < n; jc += nc {
		jcEnd := min(jc+nc, n)
		panelCols := jcEnd - jc
		for pc := 0; pc < k; pc += kc {
			pcEnd := min(pc+kc, k)
			panelK := pcEnd - pc
			PackRHS(b, packedB, k, n, pc, jc, panelK, panelCols, nr)
			for ic := rowStart; ic < rowEnd; ic += mc {
				icEnd := min(ic+mc, rowEnd)
				panelRows := icEnd - ic
				activeRowsLast := PackLHS(a, packedA, m, k, ic, pc, panelRows, panelK, mr)
				gebp(packedA, packedB, c, n, ic, jc, panelRows, panelCols, panelK, mr, nr, activeRowsLast)
			}
		}
	}
}

func BasePackedMatMulStrip_avx2_Float64(a []float64, b []float64, c []float64, m int, n int, k int, rowStart int, rowEnd int, packedA []float64, packedB []float64, params CacheParams) {
	mr, nr := params.Mr, params.Nr
	kc, mc, nc := params.Kc, params.Mc, params.Nc
	stripM := rowEnd - rowStart
	zeroMatrix(c[rowStart*n:rowEnd*n], stripM*n)
	for jc := 0; jc < n; jc += nc {
		jcEnd := min(jc+nc, n)
		panelCols := jcEnd - jc
		for pc := 0; pc < k; pc += kc {
			pcEnd := min(pc+kc, k)
			panelK := pcEnd - pc
			PackRHS(b, packedB, k, n, pc, jc, panelK, panelCols, nr)
			for ic := rowStart; ic < rowEnd; ic += mc {
				icEnd := min(ic+mc, rowEnd)
				panelRows := icEnd - ic
				activeRowsLast := PackLHS(a, packedA, m, k, ic, pc, panelRows, panelK, mr)
				gebp(packedA, packedB, c, n, ic, jc, panelRows, panelCols, panelK, mr, nr, activeRowsLast)
			}
		}
	}
}
