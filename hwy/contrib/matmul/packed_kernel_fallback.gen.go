// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

package matmul

import (
	"github.com/ajroetker/go-highway/hwy"
)

func BasePackedMicroKernel_fallback_Float16(packedA []hwy.Float16, packedB []hwy.Float16, c []hwy.Float16, n int, ir int, jr int, kc int, mr int, nr int) {
	lanes := hwy.Zero[hwy.Float16]().NumLanes()
	if mr != 4 || nr != lanes*2 {
		basePackedMicroKernelGeneral(packedA, packedB, c, n, ir, jr, kc, mr, nr)
		return
	}
	acc00 := hwy.Zero[hwy.Float16]()
	acc01 := hwy.Zero[hwy.Float16]()
	acc10 := hwy.Zero[hwy.Float16]()
	acc11 := hwy.Zero[hwy.Float16]()
	acc20 := hwy.Zero[hwy.Float16]()
	acc21 := hwy.Zero[hwy.Float16]()
	acc30 := hwy.Zero[hwy.Float16]()
	acc31 := hwy.Zero[hwy.Float16]()
	aIdx := 0
	bIdx := 0
	for p := 0; p < kc; p++ {
		a0 := packedA[aIdx]
		a1 := packedA[aIdx+1]
		a2 := packedA[aIdx+2]
		a3 := packedA[aIdx+3]
		aIdx += 4
		vA0 := hwy.Set(a0)
		vA1 := hwy.Set(a1)
		vA2 := hwy.Set(a2)
		vA3 := hwy.Set(a3)
		vB0 := hwy.Load(packedB[bIdx:])
		vB1 := hwy.Load(packedB[bIdx+lanes:])
		bIdx += nr
		acc00 = hwy.MulAdd(vA0, vB0, acc00)
		acc01 = hwy.MulAdd(vA0, vB1, acc01)
		acc10 = hwy.MulAdd(vA1, vB0, acc10)
		acc11 = hwy.MulAdd(vA1, vB1, acc11)
		acc20 = hwy.MulAdd(vA2, vB0, acc20)
		acc21 = hwy.MulAdd(vA2, vB1, acc21)
		acc30 = hwy.MulAdd(vA3, vB0, acc30)
		acc31 = hwy.MulAdd(vA3, vB1, acc31)
	}
	cRow0 := ir * n
	cRow1 := (ir + 1) * n
	cRow2 := (ir + 2) * n
	cRow3 := (ir + 3) * n
	vC := hwy.Load(c[cRow0+jr:])
	vC = hwy.Add(vC, acc00)
	hwy.Store(vC, c[cRow0+jr:])
	vC = hwy.Load(c[cRow0+jr+lanes:])
	vC = hwy.Add(vC, acc01)
	hwy.Store(vC, c[cRow0+jr+lanes:])
	vC = hwy.Load(c[cRow1+jr:])
	vC = hwy.Add(vC, acc10)
	hwy.Store(vC, c[cRow1+jr:])
	vC = hwy.Load(c[cRow1+jr+lanes:])
	vC = hwy.Add(vC, acc11)
	hwy.Store(vC, c[cRow1+jr+lanes:])
	vC = hwy.Load(c[cRow2+jr:])
	vC = hwy.Add(vC, acc20)
	hwy.Store(vC, c[cRow2+jr:])
	vC = hwy.Load(c[cRow2+jr+lanes:])
	vC = hwy.Add(vC, acc21)
	hwy.Store(vC, c[cRow2+jr+lanes:])
	vC = hwy.Load(c[cRow3+jr:])
	vC = hwy.Add(vC, acc30)
	hwy.Store(vC, c[cRow3+jr:])
	vC = hwy.Load(c[cRow3+jr+lanes:])
	vC = hwy.Add(vC, acc31)
	hwy.Store(vC, c[cRow3+jr+lanes:])
}

func BasePackedMicroKernel_fallback_BFloat16(packedA []hwy.BFloat16, packedB []hwy.BFloat16, c []hwy.BFloat16, n int, ir int, jr int, kc int, mr int, nr int) {
	lanes := hwy.Zero[hwy.BFloat16]().NumLanes()
	if mr != 4 || nr != lanes*2 {
		basePackedMicroKernelGeneral(packedA, packedB, c, n, ir, jr, kc, mr, nr)
		return
	}
	acc00 := hwy.Zero[hwy.BFloat16]()
	acc01 := hwy.Zero[hwy.BFloat16]()
	acc10 := hwy.Zero[hwy.BFloat16]()
	acc11 := hwy.Zero[hwy.BFloat16]()
	acc20 := hwy.Zero[hwy.BFloat16]()
	acc21 := hwy.Zero[hwy.BFloat16]()
	acc30 := hwy.Zero[hwy.BFloat16]()
	acc31 := hwy.Zero[hwy.BFloat16]()
	aIdx := 0
	bIdx := 0
	for p := 0; p < kc; p++ {
		a0 := packedA[aIdx]
		a1 := packedA[aIdx+1]
		a2 := packedA[aIdx+2]
		a3 := packedA[aIdx+3]
		aIdx += 4
		vA0 := hwy.Set(a0)
		vA1 := hwy.Set(a1)
		vA2 := hwy.Set(a2)
		vA3 := hwy.Set(a3)
		vB0 := hwy.Load(packedB[bIdx:])
		vB1 := hwy.Load(packedB[bIdx+lanes:])
		bIdx += nr
		acc00 = hwy.MulAdd(vA0, vB0, acc00)
		acc01 = hwy.MulAdd(vA0, vB1, acc01)
		acc10 = hwy.MulAdd(vA1, vB0, acc10)
		acc11 = hwy.MulAdd(vA1, vB1, acc11)
		acc20 = hwy.MulAdd(vA2, vB0, acc20)
		acc21 = hwy.MulAdd(vA2, vB1, acc21)
		acc30 = hwy.MulAdd(vA3, vB0, acc30)
		acc31 = hwy.MulAdd(vA3, vB1, acc31)
	}
	cRow0 := ir * n
	cRow1 := (ir + 1) * n
	cRow2 := (ir + 2) * n
	cRow3 := (ir + 3) * n
	vC := hwy.Load(c[cRow0+jr:])
	vC = hwy.Add(vC, acc00)
	hwy.Store(vC, c[cRow0+jr:])
	vC = hwy.Load(c[cRow0+jr+lanes:])
	vC = hwy.Add(vC, acc01)
	hwy.Store(vC, c[cRow0+jr+lanes:])
	vC = hwy.Load(c[cRow1+jr:])
	vC = hwy.Add(vC, acc10)
	hwy.Store(vC, c[cRow1+jr:])
	vC = hwy.Load(c[cRow1+jr+lanes:])
	vC = hwy.Add(vC, acc11)
	hwy.Store(vC, c[cRow1+jr+lanes:])
	vC = hwy.Load(c[cRow2+jr:])
	vC = hwy.Add(vC, acc20)
	hwy.Store(vC, c[cRow2+jr:])
	vC = hwy.Load(c[cRow2+jr+lanes:])
	vC = hwy.Add(vC, acc21)
	hwy.Store(vC, c[cRow2+jr+lanes:])
	vC = hwy.Load(c[cRow3+jr:])
	vC = hwy.Add(vC, acc30)
	hwy.Store(vC, c[cRow3+jr:])
	vC = hwy.Load(c[cRow3+jr+lanes:])
	vC = hwy.Add(vC, acc31)
	hwy.Store(vC, c[cRow3+jr+lanes:])
}

func BasePackedMicroKernel_fallback(packedA []float32, packedB []float32, c []float32, n int, ir int, jr int, kc int, mr int, nr int) {
	lanes := hwy.Zero[float32]().NumLanes()
	if mr != 4 || nr != lanes*2 {
		basePackedMicroKernelGeneral(packedA, packedB, c, n, ir, jr, kc, mr, nr)
		return
	}
	acc00 := hwy.Zero[float32]()
	acc01 := hwy.Zero[float32]()
	acc10 := hwy.Zero[float32]()
	acc11 := hwy.Zero[float32]()
	acc20 := hwy.Zero[float32]()
	acc21 := hwy.Zero[float32]()
	acc30 := hwy.Zero[float32]()
	acc31 := hwy.Zero[float32]()
	aIdx := 0
	bIdx := 0
	for p := 0; p < kc; p++ {
		a0 := packedA[aIdx]
		a1 := packedA[aIdx+1]
		a2 := packedA[aIdx+2]
		a3 := packedA[aIdx+3]
		aIdx += 4
		vA0 := hwy.Set(a0)
		vA1 := hwy.Set(a1)
		vA2 := hwy.Set(a2)
		vA3 := hwy.Set(a3)
		vB0 := hwy.Load(packedB[bIdx:])
		vB1 := hwy.Load(packedB[bIdx+lanes:])
		bIdx += nr
		acc00 = hwy.MulAdd(vA0, vB0, acc00)
		acc01 = hwy.MulAdd(vA0, vB1, acc01)
		acc10 = hwy.MulAdd(vA1, vB0, acc10)
		acc11 = hwy.MulAdd(vA1, vB1, acc11)
		acc20 = hwy.MulAdd(vA2, vB0, acc20)
		acc21 = hwy.MulAdd(vA2, vB1, acc21)
		acc30 = hwy.MulAdd(vA3, vB0, acc30)
		acc31 = hwy.MulAdd(vA3, vB1, acc31)
	}
	cRow0 := ir * n
	cRow1 := (ir + 1) * n
	cRow2 := (ir + 2) * n
	cRow3 := (ir + 3) * n
	vC := hwy.Load(c[cRow0+jr:])
	vC = hwy.Add(vC, acc00)
	hwy.Store(vC, c[cRow0+jr:])
	vC = hwy.Load(c[cRow0+jr+lanes:])
	vC = hwy.Add(vC, acc01)
	hwy.Store(vC, c[cRow0+jr+lanes:])
	vC = hwy.Load(c[cRow1+jr:])
	vC = hwy.Add(vC, acc10)
	hwy.Store(vC, c[cRow1+jr:])
	vC = hwy.Load(c[cRow1+jr+lanes:])
	vC = hwy.Add(vC, acc11)
	hwy.Store(vC, c[cRow1+jr+lanes:])
	vC = hwy.Load(c[cRow2+jr:])
	vC = hwy.Add(vC, acc20)
	hwy.Store(vC, c[cRow2+jr:])
	vC = hwy.Load(c[cRow2+jr+lanes:])
	vC = hwy.Add(vC, acc21)
	hwy.Store(vC, c[cRow2+jr+lanes:])
	vC = hwy.Load(c[cRow3+jr:])
	vC = hwy.Add(vC, acc30)
	hwy.Store(vC, c[cRow3+jr:])
	vC = hwy.Load(c[cRow3+jr+lanes:])
	vC = hwy.Add(vC, acc31)
	hwy.Store(vC, c[cRow3+jr+lanes:])
}

func BasePackedMicroKernel_fallback_Float64(packedA []float64, packedB []float64, c []float64, n int, ir int, jr int, kc int, mr int, nr int) {
	lanes := hwy.Zero[float64]().NumLanes()
	if mr != 4 || nr != lanes*2 {
		basePackedMicroKernelGeneral(packedA, packedB, c, n, ir, jr, kc, mr, nr)
		return
	}
	acc00 := hwy.Zero[float64]()
	acc01 := hwy.Zero[float64]()
	acc10 := hwy.Zero[float64]()
	acc11 := hwy.Zero[float64]()
	acc20 := hwy.Zero[float64]()
	acc21 := hwy.Zero[float64]()
	acc30 := hwy.Zero[float64]()
	acc31 := hwy.Zero[float64]()
	aIdx := 0
	bIdx := 0
	for p := 0; p < kc; p++ {
		a0 := packedA[aIdx]
		a1 := packedA[aIdx+1]
		a2 := packedA[aIdx+2]
		a3 := packedA[aIdx+3]
		aIdx += 4
		vA0 := hwy.Set(a0)
		vA1 := hwy.Set(a1)
		vA2 := hwy.Set(a2)
		vA3 := hwy.Set(a3)
		vB0 := hwy.Load(packedB[bIdx:])
		vB1 := hwy.Load(packedB[bIdx+lanes:])
		bIdx += nr
		acc00 = hwy.MulAdd(vA0, vB0, acc00)
		acc01 = hwy.MulAdd(vA0, vB1, acc01)
		acc10 = hwy.MulAdd(vA1, vB0, acc10)
		acc11 = hwy.MulAdd(vA1, vB1, acc11)
		acc20 = hwy.MulAdd(vA2, vB0, acc20)
		acc21 = hwy.MulAdd(vA2, vB1, acc21)
		acc30 = hwy.MulAdd(vA3, vB0, acc30)
		acc31 = hwy.MulAdd(vA3, vB1, acc31)
	}
	cRow0 := ir * n
	cRow1 := (ir + 1) * n
	cRow2 := (ir + 2) * n
	cRow3 := (ir + 3) * n
	vC := hwy.Load(c[cRow0+jr:])
	vC = hwy.Add(vC, acc00)
	hwy.Store(vC, c[cRow0+jr:])
	vC = hwy.Load(c[cRow0+jr+lanes:])
	vC = hwy.Add(vC, acc01)
	hwy.Store(vC, c[cRow0+jr+lanes:])
	vC = hwy.Load(c[cRow1+jr:])
	vC = hwy.Add(vC, acc10)
	hwy.Store(vC, c[cRow1+jr:])
	vC = hwy.Load(c[cRow1+jr+lanes:])
	vC = hwy.Add(vC, acc11)
	hwy.Store(vC, c[cRow1+jr+lanes:])
	vC = hwy.Load(c[cRow2+jr:])
	vC = hwy.Add(vC, acc20)
	hwy.Store(vC, c[cRow2+jr:])
	vC = hwy.Load(c[cRow2+jr+lanes:])
	vC = hwy.Add(vC, acc21)
	hwy.Store(vC, c[cRow2+jr+lanes:])
	vC = hwy.Load(c[cRow3+jr:])
	vC = hwy.Add(vC, acc30)
	hwy.Store(vC, c[cRow3+jr:])
	vC = hwy.Load(c[cRow3+jr+lanes:])
	vC = hwy.Add(vC, acc31)
	hwy.Store(vC, c[cRow3+jr+lanes:])
}

func basePackedMicroKernelGeneral_fallback_Float16(packedA []hwy.Float16, packedB []hwy.Float16, c []hwy.Float16, n int, ir int, jr int, kc int, mr int, nr int) {
	lanes := hwy.Zero[hwy.Float16]().NumLanes()
	for r := 0; r < mr; r++ {
		cRowStart := (ir + r) * n
		var col int
		for col = 0; col+lanes <= nr; col += lanes {
			acc := hwy.Zero[hwy.Float16]()
			for p := 0; p < kc; p++ {
				aVal := packedA[p*mr+r]
				vA := hwy.Set(aVal)
				vB := hwy.Load(packedB[p*nr+col:])
				acc = hwy.MulAdd(vA, vB, acc)
			}
			vC := hwy.Load(c[cRowStart+jr+col:])
			vC = hwy.Add(vC, acc)
			hwy.Store(vC, c[cRowStart+jr+col:])
		}
		for ; col < nr; col++ {
			var sum float32
			for p := 0; p < kc; p++ {
				sum += packedA[p*mr+r].Float32() * packedB[p*nr+col].Float32()
			}
			c[cRowStart+jr+col] = hwy.Float32ToFloat16(c[cRowStart+jr+col].Float32() + sum)
		}
	}
}

func basePackedMicroKernelGeneral_fallback_BFloat16(packedA []hwy.BFloat16, packedB []hwy.BFloat16, c []hwy.BFloat16, n int, ir int, jr int, kc int, mr int, nr int) {
	lanes := hwy.Zero[hwy.BFloat16]().NumLanes()
	for r := 0; r < mr; r++ {
		cRowStart := (ir + r) * n
		var col int
		for col = 0; col+lanes <= nr; col += lanes {
			acc := hwy.Zero[hwy.BFloat16]()
			for p := 0; p < kc; p++ {
				aVal := packedA[p*mr+r]
				vA := hwy.Set(aVal)
				vB := hwy.Load(packedB[p*nr+col:])
				acc = hwy.MulAdd(vA, vB, acc)
			}
			vC := hwy.Load(c[cRowStart+jr+col:])
			vC = hwy.Add(vC, acc)
			hwy.Store(vC, c[cRowStart+jr+col:])
		}
		for ; col < nr; col++ {
			var sum float32
			for p := 0; p < kc; p++ {
				sum += packedA[p*mr+r].Float32() * packedB[p*nr+col].Float32()
			}
			c[cRowStart+jr+col] = hwy.Float32ToBFloat16(c[cRowStart+jr+col].Float32() + sum)
		}
	}
}

func basePackedMicroKernelGeneral_fallback(packedA []float32, packedB []float32, c []float32, n int, ir int, jr int, kc int, mr int, nr int) {
	for r := 0; r < mr; r++ {
		cRowStart := (ir + r) * n
		var col int
		for col = 0; col < nr; col++ {
			acc := float32(0)
			for p := 0; p < kc; p++ {
				aVal := packedA[p*mr+r]
				vA := float32(aVal)
				vB := packedB[p*nr+col]
				acc = vA*vB + acc
			}
			vC := c[cRowStart+jr+col]
			vC = vC + acc
			c[cRowStart+jr+col] = vC
		}
		for ; col < nr; col++ {
			var sum float32
			for p := 0; p < kc; p++ {
				sum += packedA[p*mr+r] * packedB[p*nr+col]
			}
			c[cRowStart+jr+col] += sum
		}
	}
}

func basePackedMicroKernelGeneral_fallback_Float64(packedA []float64, packedB []float64, c []float64, n int, ir int, jr int, kc int, mr int, nr int) {
	for r := 0; r < mr; r++ {
		cRowStart := (ir + r) * n
		var col int
		for col = 0; col < nr; col++ {
			acc := float64(0)
			for p := 0; p < kc; p++ {
				aVal := packedA[p*mr+r]
				vA := float64(aVal)
				vB := packedB[p*nr+col]
				acc = vA*vB + acc
			}
			vC := c[cRowStart+jr+col]
			vC = vC + acc
			c[cRowStart+jr+col] = vC
		}
		for ; col < nr; col++ {
			var sum float64
			for p := 0; p < kc; p++ {
				sum += packedA[p*mr+r] * packedB[p*nr+col]
			}
			c[cRowStart+jr+col] += sum
		}
	}
}

func BasePackedMicroKernelPartial_fallback_Float16(packedA []hwy.Float16, packedB []hwy.Float16, c []hwy.Float16, n int, ir int, jr int, kc int, mr int, nr int, activeRows int, activeCols int) {
	lanes := hwy.Zero[hwy.Float16]().NumLanes()
	for r := 0; r < activeRows; r++ {
		cRowStart := (ir + r) * n
		var col int
		for col = 0; col+lanes <= activeCols; col += lanes {
			acc := hwy.Zero[hwy.Float16]()
			for p := 0; p < kc; p++ {
				aVal := packedA[p*mr+r]
				vA := hwy.Set(aVal)
				vB := hwy.Load(packedB[p*nr+col:])
				acc = hwy.MulAdd(vA, vB, acc)
			}
			vC := hwy.Load(c[cRowStart+jr+col:])
			vC = hwy.Add(vC, acc)
			hwy.Store(vC, c[cRowStart+jr+col:])
		}
		for ; col < activeCols; col++ {
			var sum float32
			for p := 0; p < kc; p++ {
				sum += packedA[p*mr+r].Float32() * packedB[p*nr+col].Float32()
			}
			c[cRowStart+jr+col] = hwy.Float32ToFloat16(c[cRowStart+jr+col].Float32() + sum)
		}
	}
}

func BasePackedMicroKernelPartial_fallback_BFloat16(packedA []hwy.BFloat16, packedB []hwy.BFloat16, c []hwy.BFloat16, n int, ir int, jr int, kc int, mr int, nr int, activeRows int, activeCols int) {
	lanes := hwy.Zero[hwy.BFloat16]().NumLanes()
	for r := 0; r < activeRows; r++ {
		cRowStart := (ir + r) * n
		var col int
		for col = 0; col+lanes <= activeCols; col += lanes {
			acc := hwy.Zero[hwy.BFloat16]()
			for p := 0; p < kc; p++ {
				aVal := packedA[p*mr+r]
				vA := hwy.Set(aVal)
				vB := hwy.Load(packedB[p*nr+col:])
				acc = hwy.MulAdd(vA, vB, acc)
			}
			vC := hwy.Load(c[cRowStart+jr+col:])
			vC = hwy.Add(vC, acc)
			hwy.Store(vC, c[cRowStart+jr+col:])
		}
		for ; col < activeCols; col++ {
			var sum float32
			for p := 0; p < kc; p++ {
				sum += packedA[p*mr+r].Float32() * packedB[p*nr+col].Float32()
			}
			c[cRowStart+jr+col] = hwy.Float32ToBFloat16(c[cRowStart+jr+col].Float32() + sum)
		}
	}
}

func BasePackedMicroKernelPartial_fallback(packedA []float32, packedB []float32, c []float32, n int, ir int, jr int, kc int, mr int, nr int, activeRows int, activeCols int) {
	for r := 0; r < activeRows; r++ {
		cRowStart := (ir + r) * n
		var col int
		for col = 0; col < activeCols; col++ {
			acc := float32(0)
			for p := 0; p < kc; p++ {
				aVal := packedA[p*mr+r]
				vA := float32(aVal)
				vB := packedB[p*nr+col]
				acc = vA*vB + acc
			}
			vC := c[cRowStart+jr+col]
			vC = vC + acc
			c[cRowStart+jr+col] = vC
		}
		for ; col < activeCols; col++ {
			var sum float32
			for p := 0; p < kc; p++ {
				sum += packedA[p*mr+r] * packedB[p*nr+col]
			}
			c[cRowStart+jr+col] += sum
		}
	}
}

func BasePackedMicroKernelPartial_fallback_Float64(packedA []float64, packedB []float64, c []float64, n int, ir int, jr int, kc int, mr int, nr int, activeRows int, activeCols int) {
	for r := 0; r < activeRows; r++ {
		cRowStart := (ir + r) * n
		var col int
		for col = 0; col < activeCols; col++ {
			acc := float64(0)
			for p := 0; p < kc; p++ {
				aVal := packedA[p*mr+r]
				vA := float64(aVal)
				vB := packedB[p*nr+col]
				acc = vA*vB + acc
			}
			vC := c[cRowStart+jr+col]
			vC = vC + acc
			c[cRowStart+jr+col] = vC
		}
		for ; col < activeCols; col++ {
			var sum float64
			for p := 0; p < kc; p++ {
				sum += packedA[p*mr+r] * packedB[p*nr+col]
			}
			c[cRowStart+jr+col] += sum
		}
	}
}
