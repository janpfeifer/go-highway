// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

//go:build !arm64 && !(amd64 && goexperiment.simd)

package matmul

import (
	"github.com/ajroetker/go-highway/hwy"
)

var PackLHSFloat16 func(a []hwy.Float16, packed []hwy.Float16, m int, k int, rowStart int, colStart int, panelRows int, panelK int, mr int) int
var PackLHSBFloat16 func(a []hwy.BFloat16, packed []hwy.BFloat16, m int, k int, rowStart int, colStart int, panelRows int, panelK int, mr int) int
var PackLHSFloat32 func(a []float32, packed []float32, m int, k int, rowStart int, colStart int, panelRows int, panelK int, mr int) int
var PackLHSFloat64 func(a []float64, packed []float64, m int, k int, rowStart int, colStart int, panelRows int, panelK int, mr int) int
var PackRHSFloat16 func(b []hwy.Float16, packed []hwy.Float16, k int, n int, rowStart int, colStart int, panelK int, panelCols int, nr int) int
var PackRHSBFloat16 func(b []hwy.BFloat16, packed []hwy.BFloat16, k int, n int, rowStart int, colStart int, panelK int, panelCols int, nr int) int
var PackRHSFloat32 func(b []float32, packed []float32, k int, n int, rowStart int, colStart int, panelK int, panelCols int, nr int) int
var PackRHSFloat64 func(b []float64, packed []float64, k int, n int, rowStart int, colStart int, panelK int, panelCols int, nr int) int
var PackLHSVecFloat16 func(a []hwy.Float16, packed []hwy.Float16, m int, k int, rowStart int, colStart int, panelRows int, panelK int, mr int) int
var PackLHSVecBFloat16 func(a []hwy.BFloat16, packed []hwy.BFloat16, m int, k int, rowStart int, colStart int, panelRows int, panelK int, mr int) int
var PackLHSVecFloat32 func(a []float32, packed []float32, m int, k int, rowStart int, colStart int, panelRows int, panelK int, mr int) int
var PackLHSVecFloat64 func(a []float64, packed []float64, m int, k int, rowStart int, colStart int, panelRows int, panelK int, mr int) int
var PackRHSVecFloat16 func(b []hwy.Float16, packed []hwy.Float16, k int, n int, rowStart int, colStart int, panelK int, panelCols int, nr int) int
var PackRHSVecBFloat16 func(b []hwy.BFloat16, packed []hwy.BFloat16, k int, n int, rowStart int, colStart int, panelK int, panelCols int, nr int) int
var PackRHSVecFloat32 func(b []float32, packed []float32, k int, n int, rowStart int, colStart int, panelK int, panelCols int, nr int) int
var PackRHSVecFloat64 func(b []float64, packed []float64, k int, n int, rowStart int, colStart int, panelK int, panelCols int, nr int) int

// PackLHS packs a panel of the LHS matrix (A) into a cache-friendly layout.
//
// Input A is M x K in row-major order. This function packs a panel of rows
// [rowStart, rowStart+panelRows) and columns [colStart, colStart+panelK).
//
// The packed layout is organized as micro-panels of Mr rows each:
//   - For each micro-panel i (rows i*Mr to (i+1)*Mr):
//   - For each k in [0, panelK):
//   - Store A[rowStart+i*Mr+0, colStart+k], ..., A[rowStart+i*Mr+Mr-1, colStart+k]
//
// This gives memory layout: [num_micro_panels, panelK, Mr]
// where num_micro_panels = ceil(panelRows / Mr)
//
// The K-first layout within micro-panels optimizes for the inner loop
// which iterates over K and needs contiguous A values for each k.
//
// Parameters:
//   - a: Input matrix A in row-major order
//   - packed: Output buffer, must have size >= ceil(panelRows/Mr) * panelK * Mr
//   - m, k: Dimensions of the full A matrix
//   - rowStart: Starting row of the panel to pack
//   - colStart: Starting column of the panel to pack (K-dimension offset)
//   - panelRows: Number of rows to pack
//   - panelK: Number of columns to pack (K dimension)
//   - mr: Micro-tile row dimension
//
// Returns the number of active rows in the last micro-panel (may be < Mr).
//
// This function dispatches to the appropriate SIMD implementation at runtime.
func PackLHS[T hwy.Floats](a []T, packed []T, m int, k int, rowStart int, colStart int, panelRows int, panelK int, mr int) int {
	switch any(a).(type) {
	case []hwy.Float16:
		return PackLHSFloat16(any(a).([]hwy.Float16), any(packed).([]hwy.Float16), m, k, rowStart, colStart, panelRows, panelK, mr)
	case []hwy.BFloat16:
		return PackLHSBFloat16(any(a).([]hwy.BFloat16), any(packed).([]hwy.BFloat16), m, k, rowStart, colStart, panelRows, panelK, mr)
	case []float32:
		return PackLHSFloat32(any(a).([]float32), any(packed).([]float32), m, k, rowStart, colStart, panelRows, panelK, mr)
	case []float64:
		return PackLHSFloat64(any(a).([]float64), any(packed).([]float64), m, k, rowStart, colStart, panelRows, panelK, mr)
	}
	panic("unreachable")
}

// PackRHS packs a panel of the RHS matrix (B) into a cache-friendly layout.
//
// Input B is K x N in row-major order. This function packs a panel of rows
// [rowStart, rowStart+panelK) and columns [colStart, colStart+panelCols).
//
// The packed layout is organized as micro-panels of Nr columns each:
//   - For each micro-panel j (cols j*Nr to (j+1)*Nr):
//   - For each k in [0, panelK):
//   - Store B[rowStart+k, colStart+j*Nr+0], ..., B[rowStart+k, colStart+j*Nr+Nr-1]
//
// This gives memory layout: [num_micro_panels, panelK, Nr]
// where num_micro_panels = ceil(panelCols / Nr)
//
// The K-first layout within micro-panels ensures sequential access
// when iterating over K in the inner loop.
//
// Parameters:
//   - b: Input matrix B in row-major order
//   - packed: Output buffer, must have size >= ceil(panelCols/Nr) * panelK * Nr
//   - k, n: Dimensions of the full B matrix
//   - rowStart: Starting row of the panel to pack (K-dimension offset)
//   - colStart: Starting column of the panel to pack
//   - panelK: Number of rows to pack (K dimension)
//   - panelCols: Number of columns to pack
//   - nr: Micro-tile column dimension
//
// Returns the number of active columns in the last micro-panel (may be < Nr).
//
// This function dispatches to the appropriate SIMD implementation at runtime.
func PackRHS[T hwy.Floats](b []T, packed []T, k int, n int, rowStart int, colStart int, panelK int, panelCols int, nr int) int {
	switch any(b).(type) {
	case []hwy.Float16:
		return PackRHSFloat16(any(b).([]hwy.Float16), any(packed).([]hwy.Float16), k, n, rowStart, colStart, panelK, panelCols, nr)
	case []hwy.BFloat16:
		return PackRHSBFloat16(any(b).([]hwy.BFloat16), any(packed).([]hwy.BFloat16), k, n, rowStart, colStart, panelK, panelCols, nr)
	case []float32:
		return PackRHSFloat32(any(b).([]float32), any(packed).([]float32), k, n, rowStart, colStart, panelK, panelCols, nr)
	case []float64:
		return PackRHSFloat64(any(b).([]float64), any(packed).([]float64), k, n, rowStart, colStart, panelK, panelCols, nr)
	}
	panic("unreachable")
}

// PackLHSVec packs LHS using SIMD when Mr aligns with vector width.
// This is a vectorized version of BasePackLHS for better performance.
//
// This function dispatches to the appropriate SIMD implementation at runtime.
func PackLHSVec[T hwy.Floats](a []T, packed []T, m int, k int, rowStart int, colStart int, panelRows int, panelK int, mr int) int {
	switch any(a).(type) {
	case []hwy.Float16:
		return PackLHSVecFloat16(any(a).([]hwy.Float16), any(packed).([]hwy.Float16), m, k, rowStart, colStart, panelRows, panelK, mr)
	case []hwy.BFloat16:
		return PackLHSVecBFloat16(any(a).([]hwy.BFloat16), any(packed).([]hwy.BFloat16), m, k, rowStart, colStart, panelRows, panelK, mr)
	case []float32:
		return PackLHSVecFloat32(any(a).([]float32), any(packed).([]float32), m, k, rowStart, colStart, panelRows, panelK, mr)
	case []float64:
		return PackLHSVecFloat64(any(a).([]float64), any(packed).([]float64), m, k, rowStart, colStart, panelRows, panelK, mr)
	}
	panic("unreachable")
}

// PackRHSVec packs RHS using SIMD loads for contiguous data.
// This is a vectorized version of BasePackRHS for better performance.
//
// This function dispatches to the appropriate SIMD implementation at runtime.
func PackRHSVec[T hwy.Floats](b []T, packed []T, k int, n int, rowStart int, colStart int, panelK int, panelCols int, nr int) int {
	switch any(b).(type) {
	case []hwy.Float16:
		return PackRHSVecFloat16(any(b).([]hwy.Float16), any(packed).([]hwy.Float16), k, n, rowStart, colStart, panelK, panelCols, nr)
	case []hwy.BFloat16:
		return PackRHSVecBFloat16(any(b).([]hwy.BFloat16), any(packed).([]hwy.BFloat16), k, n, rowStart, colStart, panelK, panelCols, nr)
	case []float32:
		return PackRHSVecFloat32(any(b).([]float32), any(packed).([]float32), k, n, rowStart, colStart, panelK, panelCols, nr)
	case []float64:
		return PackRHSVecFloat64(any(b).([]float64), any(packed).([]float64), k, n, rowStart, colStart, panelK, panelCols, nr)
	}
	panic("unreachable")
}

func init() {
	_ = hwy.NoSimdEnv // silence unused import
	initPackingFallback()
}

func initPackingFallback() {
	PackLHSFloat16 = BasePackLHS_fallback_Float16
	PackLHSBFloat16 = BasePackLHS_fallback_BFloat16
	PackLHSFloat32 = BasePackLHS_fallback
	PackLHSFloat64 = BasePackLHS_fallback_Float64
	PackRHSFloat16 = BasePackRHS_fallback_Float16
	PackRHSBFloat16 = BasePackRHS_fallback_BFloat16
	PackRHSFloat32 = BasePackRHS_fallback
	PackRHSFloat64 = BasePackRHS_fallback_Float64
	PackLHSVecFloat16 = BasePackLHSVec_fallback_Float16
	PackLHSVecBFloat16 = BasePackLHSVec_fallback_BFloat16
	PackLHSVecFloat32 = BasePackLHSVec_fallback
	PackLHSVecFloat64 = BasePackLHSVec_fallback_Float64
	PackRHSVecFloat16 = BasePackRHSVec_fallback_Float16
	PackRHSVecBFloat16 = BasePackRHSVec_fallback_BFloat16
	PackRHSVecFloat32 = BasePackRHSVec_fallback
	PackRHSVecFloat64 = BasePackRHSVec_fallback_Float64
}
