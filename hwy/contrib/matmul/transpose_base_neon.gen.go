// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

//go:build arm64

package matmul

import (
	"unsafe"

	"github.com/ajroetker/go-highway/hwy"
	"github.com/ajroetker/go-highway/hwy/asm"
)

func BaseTranspose2D_neon_Float16(src []hwy.Float16, m int, k int, dst []hwy.Float16) {
	if len(src) < m*k || len(dst) < k*m {
		return
	}
	lanes := 8
	i := 0
	for ; i <= m-lanes; i += lanes * 2 {
		for j := 0; j <= k-lanes; j += lanes {
			{
				rows_1 := [8]hwy.Vec[hwy.Float16]{}
				for r_1 := 0; r_1 < lanes; r_1++ {
					rows_1[r_1] = hwy.Load(src[(i+r_1)*k+j:])
				}
				for level_1 := 0; (1 << level_1) < lanes; level_1++ {
					stride_1 := 1 << level_1
					newRows_1 := [8]hwy.Vec[hwy.Float16]{}
					for i_1 := 0; i_1 < lanes; i_1 += 2 * stride_1 {
						for j_1 := 0; j_1 < stride_1; j_1++ {
							newRows_1[i_1+j_1] = hwy.InterleaveLower(rows_1[i_1+j_1], rows_1[i_1+j_1+stride_1])
							newRows_1[i_1+j_1+stride_1] = hwy.InterleaveUpper(rows_1[i_1+j_1], rows_1[i_1+j_1+stride_1])
						}
					}
					rows_1 = newRows_1
				}
				for c_1 := 0; c_1 < lanes; c_1++ {
					hwy.StoreFull(rows_1[c_1], dst[(j+c_1)*m+i:])
				}
			}
		}
		for j1 := 0; j1 <= k-lanes; j1 += lanes {
			{
				rows_11 := [8]hwy.Vec[hwy.Float16]{}
				for r_11 := 0; r_11 < lanes; r_11++ {
					rows_11[r_11] = hwy.Load(src[(i+r_11)*k+j1:])
				}
				for level_11 := 0; (1 << level_11) < lanes; level_11++ {
					stride_11 := 1 << level_11
					newRows_11 := [8]hwy.Vec[hwy.Float16]{}
					for i_11 := 0; i_11 < lanes; i_11 += 2 * stride_11 {
						for j_11 := 0; j_11 < stride_11; j_11++ {
							newRows_11[i_11+j_11] = hwy.InterleaveLower(rows_11[i_11+j_11], rows_11[i_11+j_11+stride_11])
							newRows_11[i_11+j_11+stride_11] = hwy.InterleaveUpper(rows_11[i_11+j_11], rows_11[i_11+j_11+stride_11])
						}
					}
					rows_11 = newRows_11
				}
				for c_11 := 0; c_11 < lanes; c_11++ {
					hwy.StoreFull(rows_11[c_11], dst[(j1+c_11)*m+i:])
				}
			}
		}
	}
	for ; i <= m-lanes; i += lanes {
		for j := 0; j <= k-lanes; j += lanes {
			{
				rows_1 := [8]hwy.Vec[hwy.Float16]{}
				for r_1 := 0; r_1 < lanes; r_1++ {
					rows_1[r_1] = hwy.Load(src[(i+r_1)*k+j:])
				}
				for level_1 := 0; (1 << level_1) < lanes; level_1++ {
					stride_1 := 1 << level_1
					newRows_1 := [8]hwy.Vec[hwy.Float16]{}
					for i_1 := 0; i_1 < lanes; i_1 += 2 * stride_1 {
						for j_1 := 0; j_1 < stride_1; j_1++ {
							newRows_1[i_1+j_1] = hwy.InterleaveLower(rows_1[i_1+j_1], rows_1[i_1+j_1+stride_1])
							newRows_1[i_1+j_1+stride_1] = hwy.InterleaveUpper(rows_1[i_1+j_1], rows_1[i_1+j_1+stride_1])
						}
					}
					rows_1 = newRows_1
				}
				for c_1 := 0; c_1 < lanes; c_1++ {
					hwy.StoreFull(rows_1[c_1], dst[(j+c_1)*m+i:])
				}
			}
		}
	}
	{
		blockM_2 := (m / lanes) * lanes
		blockK_2 := (k / lanes) * lanes
		for i_2 := 0; i_2 < m; i_2++ {
			for j_2 := blockK_2; j_2 < k; j_2++ {
				dst[j_2*m+i_2] = hwy.Float32ToFloat16(src[i_2*k+j_2].Float32())
			}
		}
		for i_2 := blockM_2; i_2 < m; i_2++ {
			for j_2 := 0; j_2 < blockK_2; j_2++ {
				dst[j_2*m+i_2] = hwy.Float32ToFloat16(src[i_2*k+j_2].Float32())
			}
		}
	}
}

func BaseTranspose2D_neon_BFloat16(src []hwy.BFloat16, m int, k int, dst []hwy.BFloat16) {
	if len(src) < m*k || len(dst) < k*m {
		return
	}
	lanes := 8
	i := 0
	for ; i <= m-lanes; i += lanes * 2 {
		for j := 0; j <= k-lanes; j += lanes {
			{
				rows_1 := [8]hwy.Vec[hwy.BFloat16]{}
				for r_1 := 0; r_1 < lanes; r_1++ {
					rows_1[r_1] = hwy.Load(src[(i+r_1)*k+j:])
				}
				for level_1 := 0; (1 << level_1) < lanes; level_1++ {
					stride_1 := 1 << level_1
					newRows_1 := [8]hwy.Vec[hwy.BFloat16]{}
					for i_1 := 0; i_1 < lanes; i_1 += 2 * stride_1 {
						for j_1 := 0; j_1 < stride_1; j_1++ {
							newRows_1[i_1+j_1] = hwy.InterleaveLower(rows_1[i_1+j_1], rows_1[i_1+j_1+stride_1])
							newRows_1[i_1+j_1+stride_1] = hwy.InterleaveUpper(rows_1[i_1+j_1], rows_1[i_1+j_1+stride_1])
						}
					}
					rows_1 = newRows_1
				}
				for c_1 := 0; c_1 < lanes; c_1++ {
					hwy.StoreFull(rows_1[c_1], dst[(j+c_1)*m+i:])
				}
			}
		}
		for j1 := 0; j1 <= k-lanes; j1 += lanes {
			{
				rows_11 := [8]hwy.Vec[hwy.BFloat16]{}
				for r_11 := 0; r_11 < lanes; r_11++ {
					rows_11[r_11] = hwy.Load(src[(i+r_11)*k+j1:])
				}
				for level_11 := 0; (1 << level_11) < lanes; level_11++ {
					stride_11 := 1 << level_11
					newRows_11 := [8]hwy.Vec[hwy.BFloat16]{}
					for i_11 := 0; i_11 < lanes; i_11 += 2 * stride_11 {
						for j_11 := 0; j_11 < stride_11; j_11++ {
							newRows_11[i_11+j_11] = hwy.InterleaveLower(rows_11[i_11+j_11], rows_11[i_11+j_11+stride_11])
							newRows_11[i_11+j_11+stride_11] = hwy.InterleaveUpper(rows_11[i_11+j_11], rows_11[i_11+j_11+stride_11])
						}
					}
					rows_11 = newRows_11
				}
				for c_11 := 0; c_11 < lanes; c_11++ {
					hwy.StoreFull(rows_11[c_11], dst[(j1+c_11)*m+i:])
				}
			}
		}
	}
	for ; i <= m-lanes; i += lanes {
		for j := 0; j <= k-lanes; j += lanes {
			{
				rows_1 := [8]hwy.Vec[hwy.BFloat16]{}
				for r_1 := 0; r_1 < lanes; r_1++ {
					rows_1[r_1] = hwy.Load(src[(i+r_1)*k+j:])
				}
				for level_1 := 0; (1 << level_1) < lanes; level_1++ {
					stride_1 := 1 << level_1
					newRows_1 := [8]hwy.Vec[hwy.BFloat16]{}
					for i_1 := 0; i_1 < lanes; i_1 += 2 * stride_1 {
						for j_1 := 0; j_1 < stride_1; j_1++ {
							newRows_1[i_1+j_1] = hwy.InterleaveLower(rows_1[i_1+j_1], rows_1[i_1+j_1+stride_1])
							newRows_1[i_1+j_1+stride_1] = hwy.InterleaveUpper(rows_1[i_1+j_1], rows_1[i_1+j_1+stride_1])
						}
					}
					rows_1 = newRows_1
				}
				for c_1 := 0; c_1 < lanes; c_1++ {
					hwy.StoreFull(rows_1[c_1], dst[(j+c_1)*m+i:])
				}
			}
		}
	}
	{
		blockM_2 := (m / lanes) * lanes
		blockK_2 := (k / lanes) * lanes
		for i_2 := 0; i_2 < m; i_2++ {
			for j_2 := blockK_2; j_2 < k; j_2++ {
				dst[j_2*m+i_2] = hwy.Float32ToBFloat16(src[i_2*k+j_2].Float32())
			}
		}
		for i_2 := blockM_2; i_2 < m; i_2++ {
			for j_2 := 0; j_2 < blockK_2; j_2++ {
				dst[j_2*m+i_2] = hwy.Float32ToBFloat16(src[i_2*k+j_2].Float32())
			}
		}
	}
}

func BaseTranspose2D_neon(src []float32, m int, k int, dst []float32) {
	if len(src) < m*k || len(dst) < k*m {
		return
	}
	lanes := 4
	i := 0
	for ; i <= m-lanes; i += lanes * 2 {
		for j := 0; j <= k-lanes; j += lanes {
			{
				rows_1 := [4]asm.Float32x4{}
				for r_1 := 0; r_1 < lanes; r_1++ {
					rows_1[r_1] = asm.LoadFloat32x4((*[4]float32)(unsafe.Pointer(&src[(i+r_1)*k+j])))
				}
				for level_1 := 0; (1 << level_1) < lanes; level_1++ {
					stride_1 := 1 << level_1
					newRows_1 := [4]asm.Float32x4{}
					for i_1 := 0; i_1 < lanes; i_1 += 2 * stride_1 {
						for j_1 := 0; j_1 < stride_1; j_1++ {
							newRows_1[i_1+j_1] = hwy.InterleaveLower_NEON_F32x4(rows_1[i_1+j_1], rows_1[i_1+j_1+stride_1])
							newRows_1[i_1+j_1+stride_1] = hwy.InterleaveUpper_NEON_F32x4(rows_1[i_1+j_1], rows_1[i_1+j_1+stride_1])
						}
					}
					rows_1 = newRows_1
				}
				for c_1 := 0; c_1 < lanes; c_1++ {
					rows_1[c_1].Store((*[4]float32)(unsafe.Pointer(&dst[(j+c_1)*m+i])))
				}
			}
		}
		for j1 := 0; j1 <= k-lanes; j1 += lanes {
			{
				rows_11 := [4]asm.Float32x4{}
				for r_11 := 0; r_11 < lanes; r_11++ {
					rows_11[r_11] = asm.LoadFloat32x4((*[4]float32)(unsafe.Pointer(&src[(i+r_11)*k+j1])))
				}
				for level_11 := 0; (1 << level_11) < lanes; level_11++ {
					stride_11 := 1 << level_11
					newRows_11 := [4]asm.Float32x4{}
					for i_11 := 0; i_11 < lanes; i_11 += 2 * stride_11 {
						for j_11 := 0; j_11 < stride_11; j_11++ {
							newRows_11[i_11+j_11] = hwy.InterleaveLower_NEON_F32x4(rows_11[i_11+j_11], rows_11[i_11+j_11+stride_11])
							newRows_11[i_11+j_11+stride_11] = hwy.InterleaveUpper_NEON_F32x4(rows_11[i_11+j_11], rows_11[i_11+j_11+stride_11])
						}
					}
					rows_11 = newRows_11
				}
				for c_11 := 0; c_11 < lanes; c_11++ {
					rows_11[c_11].Store((*[4]float32)(unsafe.Pointer(&dst[(j1+c_11)*m+i])))
				}
			}
		}
	}
	for ; i <= m-lanes; i += lanes {
		for j := 0; j <= k-lanes; j += lanes {
			{
				rows_1 := [4]asm.Float32x4{}
				for r_1 := 0; r_1 < lanes; r_1++ {
					rows_1[r_1] = asm.LoadFloat32x4((*[4]float32)(unsafe.Pointer(&src[(i+r_1)*k+j])))
				}
				for level_1 := 0; (1 << level_1) < lanes; level_1++ {
					stride_1 := 1 << level_1
					newRows_1 := [4]asm.Float32x4{}
					for i_1 := 0; i_1 < lanes; i_1 += 2 * stride_1 {
						for j_1 := 0; j_1 < stride_1; j_1++ {
							newRows_1[i_1+j_1] = hwy.InterleaveLower_NEON_F32x4(rows_1[i_1+j_1], rows_1[i_1+j_1+stride_1])
							newRows_1[i_1+j_1+stride_1] = hwy.InterleaveUpper_NEON_F32x4(rows_1[i_1+j_1], rows_1[i_1+j_1+stride_1])
						}
					}
					rows_1 = newRows_1
				}
				for c_1 := 0; c_1 < lanes; c_1++ {
					rows_1[c_1].Store((*[4]float32)(unsafe.Pointer(&dst[(j+c_1)*m+i])))
				}
			}
		}
	}
	{
		blockM_2 := (m / lanes) * lanes
		blockK_2 := (k / lanes) * lanes
		for i_2 := 0; i_2 < m; i_2++ {
			for j_2 := blockK_2; j_2 < k; j_2++ {
				dst[j_2*m+i_2] = src[i_2*k+j_2]
			}
		}
		for i_2 := blockM_2; i_2 < m; i_2++ {
			for j_2 := 0; j_2 < blockK_2; j_2++ {
				dst[j_2*m+i_2] = src[i_2*k+j_2]
			}
		}
	}
}

func BaseTranspose2D_neon_Float64(src []float64, m int, k int, dst []float64) {
	if len(src) < m*k || len(dst) < k*m {
		return
	}
	lanes := 2
	i := 0
	for ; i <= m-lanes; i += lanes * 2 {
		for j := 0; j <= k-lanes; j += lanes {
			{
				rows_1 := [2]asm.Float64x2{}
				for r_1 := 0; r_1 < lanes; r_1++ {
					rows_1[r_1] = asm.LoadFloat64x2((*[2]float64)(unsafe.Pointer(&src[(i+r_1)*k+j])))
				}
				for level_1 := 0; (1 << level_1) < lanes; level_1++ {
					stride_1 := 1 << level_1
					newRows_1 := [2]asm.Float64x2{}
					for i_1 := 0; i_1 < lanes; i_1 += 2 * stride_1 {
						for j_1 := 0; j_1 < stride_1; j_1++ {
							newRows_1[i_1+j_1] = hwy.InterleaveLower_NEON_F64x2(rows_1[i_1+j_1], rows_1[i_1+j_1+stride_1])
							newRows_1[i_1+j_1+stride_1] = hwy.InterleaveUpper_NEON_F64x2(rows_1[i_1+j_1], rows_1[i_1+j_1+stride_1])
						}
					}
					rows_1 = newRows_1
				}
				for c_1 := 0; c_1 < lanes; c_1++ {
					rows_1[c_1].Store((*[2]float64)(unsafe.Pointer(&dst[(j+c_1)*m+i])))
				}
			}
		}
		for j1 := 0; j1 <= k-lanes; j1 += lanes {
			{
				rows_11 := [2]asm.Float64x2{}
				for r_11 := 0; r_11 < lanes; r_11++ {
					rows_11[r_11] = asm.LoadFloat64x2((*[2]float64)(unsafe.Pointer(&src[(i+r_11)*k+j1])))
				}
				for level_11 := 0; (1 << level_11) < lanes; level_11++ {
					stride_11 := 1 << level_11
					newRows_11 := [2]asm.Float64x2{}
					for i_11 := 0; i_11 < lanes; i_11 += 2 * stride_11 {
						for j_11 := 0; j_11 < stride_11; j_11++ {
							newRows_11[i_11+j_11] = hwy.InterleaveLower_NEON_F64x2(rows_11[i_11+j_11], rows_11[i_11+j_11+stride_11])
							newRows_11[i_11+j_11+stride_11] = hwy.InterleaveUpper_NEON_F64x2(rows_11[i_11+j_11], rows_11[i_11+j_11+stride_11])
						}
					}
					rows_11 = newRows_11
				}
				for c_11 := 0; c_11 < lanes; c_11++ {
					rows_11[c_11].Store((*[2]float64)(unsafe.Pointer(&dst[(j1+c_11)*m+i])))
				}
			}
		}
	}
	for ; i <= m-lanes; i += lanes {
		for j := 0; j <= k-lanes; j += lanes {
			{
				rows_1 := [2]asm.Float64x2{}
				for r_1 := 0; r_1 < lanes; r_1++ {
					rows_1[r_1] = asm.LoadFloat64x2((*[2]float64)(unsafe.Pointer(&src[(i+r_1)*k+j])))
				}
				for level_1 := 0; (1 << level_1) < lanes; level_1++ {
					stride_1 := 1 << level_1
					newRows_1 := [2]asm.Float64x2{}
					for i_1 := 0; i_1 < lanes; i_1 += 2 * stride_1 {
						for j_1 := 0; j_1 < stride_1; j_1++ {
							newRows_1[i_1+j_1] = hwy.InterleaveLower_NEON_F64x2(rows_1[i_1+j_1], rows_1[i_1+j_1+stride_1])
							newRows_1[i_1+j_1+stride_1] = hwy.InterleaveUpper_NEON_F64x2(rows_1[i_1+j_1], rows_1[i_1+j_1+stride_1])
						}
					}
					rows_1 = newRows_1
				}
				for c_1 := 0; c_1 < lanes; c_1++ {
					rows_1[c_1].Store((*[2]float64)(unsafe.Pointer(&dst[(j+c_1)*m+i])))
				}
			}
		}
	}
	{
		blockM_2 := (m / lanes) * lanes
		blockK_2 := (k / lanes) * lanes
		for i_2 := 0; i_2 < m; i_2++ {
			for j_2 := blockK_2; j_2 < k; j_2++ {
				dst[j_2*m+i_2] = src[i_2*k+j_2]
			}
		}
		for i_2 := blockM_2; i_2 < m; i_2++ {
			for j_2 := 0; j_2 < blockK_2; j_2++ {
				dst[j_2*m+i_2] = src[i_2*k+j_2]
			}
		}
	}
}
