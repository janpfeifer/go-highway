// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

package matmul

import (
	"github.com/ajroetker/go-highway/hwy"
)

func BaseMatMulKLast_fallback_Float16(a []hwy.Float16, b []hwy.Float16, c []hwy.Float16, m int, n int, k int) {
	if len(a) < m*k {
		panic("matmul: A slice too short")
	}
	if len(b) < n*k {
		panic("matmul: B slice too short")
	}
	if len(c) < m*n {
		panic("matmul: C slice too short")
	}
	var i int
	for i = 0; i+3 < m; i += 4 {
		aRow0 := i * k
		aRow1 := (i + 1) * k
		aRow2 := (i + 2) * k
		aRow3 := (i + 3) * k
		cRow0 := i * n
		cRow1 := (i + 1) * n
		cRow2 := (i + 2) * n
		cRow3 := (i + 3) * n
		for j := 0; j < n; j++ {
			bRow := j * k
			acc0 := hwy.Float16(0)
			acc1 := hwy.Float16(0)
			acc2 := hwy.Float16(0)
			acc3 := hwy.Float16(0)
			var p int
			for p = 0; p < k; p++ {
				vB := b[bRow+p]
				vA0 := a[aRow0+p]
				vA1 := a[aRow1+p]
				vA2 := a[aRow2+p]
				vA3 := a[aRow3+p]
				acc0 = vA0*vB + acc0
				acc1 = vA1*vB + acc1
				acc2 = vA2*vB + acc2
				acc3 = vA3*vB + acc3
			}
			sum0 := acc0
			sum1 := acc1
			sum2 := acc2
			sum3 := acc3
			for ; p < k; p++ {
				sum0 += a[aRow0+p] * b[bRow+p]
				sum1 += a[aRow1+p] * b[bRow+p]
				sum2 += a[aRow2+p] * b[bRow+p]
				sum3 += a[aRow3+p] * b[bRow+p]
			}
			c[cRow0+j] = sum0
			c[cRow1+j] = sum1
			c[cRow2+j] = sum2
			c[cRow3+j] = sum3
		}
	}
	for ; i < m; i++ {
		aRow := i * k
		cRow := i * n
		for j := 0; j < n; j++ {
			bRow := j * k
			acc := hwy.Float16(0)
			var p int
			for p = 0; p < k; p++ {
				vA := a[aRow+p]
				vB := b[bRow+p]
				acc = vA*vB + acc
			}
			sum := acc
			for ; p < k; p++ {
				sum += a[aRow+p] * b[bRow+p]
			}
			c[cRow+j] = sum
		}
	}
}

func BaseMatMulKLast_fallback_BFloat16(a []hwy.BFloat16, b []hwy.BFloat16, c []hwy.BFloat16, m int, n int, k int) {
	if len(a) < m*k {
		panic("matmul: A slice too short")
	}
	if len(b) < n*k {
		panic("matmul: B slice too short")
	}
	if len(c) < m*n {
		panic("matmul: C slice too short")
	}
	var i int
	for i = 0; i+3 < m; i += 4 {
		aRow0 := i * k
		aRow1 := (i + 1) * k
		aRow2 := (i + 2) * k
		aRow3 := (i + 3) * k
		cRow0 := i * n
		cRow1 := (i + 1) * n
		cRow2 := (i + 2) * n
		cRow3 := (i + 3) * n
		for j := 0; j < n; j++ {
			bRow := j * k
			acc0 := hwy.BFloat16(0)
			acc1 := hwy.BFloat16(0)
			acc2 := hwy.BFloat16(0)
			acc3 := hwy.BFloat16(0)
			var p int
			for p = 0; p < k; p++ {
				vB := b[bRow+p]
				vA0 := a[aRow0+p]
				vA1 := a[aRow1+p]
				vA2 := a[aRow2+p]
				vA3 := a[aRow3+p]
				acc0 = vA0*vB + acc0
				acc1 = vA1*vB + acc1
				acc2 = vA2*vB + acc2
				acc3 = vA3*vB + acc3
			}
			sum0 := acc0
			sum1 := acc1
			sum2 := acc2
			sum3 := acc3
			for ; p < k; p++ {
				sum0 += a[aRow0+p] * b[bRow+p]
				sum1 += a[aRow1+p] * b[bRow+p]
				sum2 += a[aRow2+p] * b[bRow+p]
				sum3 += a[aRow3+p] * b[bRow+p]
			}
			c[cRow0+j] = sum0
			c[cRow1+j] = sum1
			c[cRow2+j] = sum2
			c[cRow3+j] = sum3
		}
	}
	for ; i < m; i++ {
		aRow := i * k
		cRow := i * n
		for j := 0; j < n; j++ {
			bRow := j * k
			acc := hwy.BFloat16(0)
			var p int
			for p = 0; p < k; p++ {
				vA := a[aRow+p]
				vB := b[bRow+p]
				acc = vA*vB + acc
			}
			sum := acc
			for ; p < k; p++ {
				sum += a[aRow+p] * b[bRow+p]
			}
			c[cRow+j] = sum
		}
	}
}

func BaseMatMulKLast_fallback(a []float32, b []float32, c []float32, m int, n int, k int) {
	if len(a) < m*k {
		panic("matmul: A slice too short")
	}
	if len(b) < n*k {
		panic("matmul: B slice too short")
	}
	if len(c) < m*n {
		panic("matmul: C slice too short")
	}
	var i int
	for i = 0; i+3 < m; i += 4 {
		aRow0 := i * k
		aRow1 := (i + 1) * k
		aRow2 := (i + 2) * k
		aRow3 := (i + 3) * k
		cRow0 := i * n
		cRow1 := (i + 1) * n
		cRow2 := (i + 2) * n
		cRow3 := (i + 3) * n
		for j := 0; j < n; j++ {
			bRow := j * k
			acc0 := float32(0)
			acc1 := float32(0)
			acc2 := float32(0)
			acc3 := float32(0)
			var p int
			for p = 0; p < k; p++ {
				vB := b[bRow+p]
				vA0 := a[aRow0+p]
				vA1 := a[aRow1+p]
				vA2 := a[aRow2+p]
				vA3 := a[aRow3+p]
				acc0 = vA0*vB + acc0
				acc1 = vA1*vB + acc1
				acc2 = vA2*vB + acc2
				acc3 = vA3*vB + acc3
			}
			sum0 := acc0
			sum1 := acc1
			sum2 := acc2
			sum3 := acc3
			for ; p < k; p++ {
				sum0 += a[aRow0+p] * b[bRow+p]
				sum1 += a[aRow1+p] * b[bRow+p]
				sum2 += a[aRow2+p] * b[bRow+p]
				sum3 += a[aRow3+p] * b[bRow+p]
			}
			c[cRow0+j] = sum0
			c[cRow1+j] = sum1
			c[cRow2+j] = sum2
			c[cRow3+j] = sum3
		}
	}
	for ; i < m; i++ {
		aRow := i * k
		cRow := i * n
		for j := 0; j < n; j++ {
			bRow := j * k
			acc := float32(0)
			var p int
			for p = 0; p < k; p++ {
				vA := a[aRow+p]
				vB := b[bRow+p]
				acc = vA*vB + acc
			}
			sum := acc
			for ; p < k; p++ {
				sum += a[aRow+p] * b[bRow+p]
			}
			c[cRow+j] = sum
		}
	}
}

func BaseMatMulKLast_fallback_Float64(a []float64, b []float64, c []float64, m int, n int, k int) {
	if len(a) < m*k {
		panic("matmul: A slice too short")
	}
	if len(b) < n*k {
		panic("matmul: B slice too short")
	}
	if len(c) < m*n {
		panic("matmul: C slice too short")
	}
	var i int
	for i = 0; i+3 < m; i += 4 {
		aRow0 := i * k
		aRow1 := (i + 1) * k
		aRow2 := (i + 2) * k
		aRow3 := (i + 3) * k
		cRow0 := i * n
		cRow1 := (i + 1) * n
		cRow2 := (i + 2) * n
		cRow3 := (i + 3) * n
		for j := 0; j < n; j++ {
			bRow := j * k
			acc0 := float64(0)
			acc1 := float64(0)
			acc2 := float64(0)
			acc3 := float64(0)
			var p int
			for p = 0; p < k; p++ {
				vB := b[bRow+p]
				vA0 := a[aRow0+p]
				vA1 := a[aRow1+p]
				vA2 := a[aRow2+p]
				vA3 := a[aRow3+p]
				acc0 = vA0*vB + acc0
				acc1 = vA1*vB + acc1
				acc2 = vA2*vB + acc2
				acc3 = vA3*vB + acc3
			}
			sum0 := acc0
			sum1 := acc1
			sum2 := acc2
			sum3 := acc3
			for ; p < k; p++ {
				sum0 += a[aRow0+p] * b[bRow+p]
				sum1 += a[aRow1+p] * b[bRow+p]
				sum2 += a[aRow2+p] * b[bRow+p]
				sum3 += a[aRow3+p] * b[bRow+p]
			}
			c[cRow0+j] = sum0
			c[cRow1+j] = sum1
			c[cRow2+j] = sum2
			c[cRow3+j] = sum3
		}
	}
	for ; i < m; i++ {
		aRow := i * k
		cRow := i * n
		for j := 0; j < n; j++ {
			bRow := j * k
			acc := float64(0)
			var p int
			for p = 0; p < k; p++ {
				vA := a[aRow+p]
				vB := b[bRow+p]
				acc = vA*vB + acc
			}
			sum := acc
			for ; p < k; p++ {
				sum += a[aRow+p] * b[bRow+p]
			}
			c[cRow+j] = sum
		}
	}
}

func BaseMatMulKLastBlocked_fallback_Float16(a []hwy.Float16, b []hwy.Float16, c []hwy.Float16, m int, n int, k int) {
	if len(a) < m*k {
		panic("matmul: A slice too short")
	}
	if len(b) < n*k {
		panic("matmul: B slice too short")
	}
	if len(c) < m*n {
		panic("matmul: C slice too short")
	}
	const blockM = 64
	const blockN = 64
	const blockK = 256
	for i := range c[:m*n] {
		c[i] = 0
	}
	for ii := 0; ii < m; ii += blockM {
		iEnd := min(ii+blockM, m)
		for jj := 0; jj < n; jj += blockN {
			jEnd := min(jj+blockN, n)
			for kk := 0; kk < k; kk += blockK {
				kEnd := min(kk+blockK, k)
				for i := ii; i < iEnd; i++ {
					aRow := i * k
					cRow := i * n
					for j := jj; j < jEnd; j++ {
						bRow := j * k
						acc := hwy.Float16(0)
						var p int
						for p = kk; p < kEnd; p++ {
							vA := a[aRow+p]
							vB := b[bRow+p]
							acc = vA*vB + acc
						}
						sum := acc
						for ; p < kEnd; p++ {
							sum += a[aRow+p] * b[bRow+p]
						}
						c[cRow+j] += sum
					}
				}
			}
		}
	}
}

func BaseMatMulKLastBlocked_fallback_BFloat16(a []hwy.BFloat16, b []hwy.BFloat16, c []hwy.BFloat16, m int, n int, k int) {
	if len(a) < m*k {
		panic("matmul: A slice too short")
	}
	if len(b) < n*k {
		panic("matmul: B slice too short")
	}
	if len(c) < m*n {
		panic("matmul: C slice too short")
	}
	const blockM = 64
	const blockN = 64
	const blockK = 256
	for i := range c[:m*n] {
		c[i] = 0
	}
	for ii := 0; ii < m; ii += blockM {
		iEnd := min(ii+blockM, m)
		for jj := 0; jj < n; jj += blockN {
			jEnd := min(jj+blockN, n)
			for kk := 0; kk < k; kk += blockK {
				kEnd := min(kk+blockK, k)
				for i := ii; i < iEnd; i++ {
					aRow := i * k
					cRow := i * n
					for j := jj; j < jEnd; j++ {
						bRow := j * k
						acc := hwy.BFloat16(0)
						var p int
						for p = kk; p < kEnd; p++ {
							vA := a[aRow+p]
							vB := b[bRow+p]
							acc = vA*vB + acc
						}
						sum := acc
						for ; p < kEnd; p++ {
							sum += a[aRow+p] * b[bRow+p]
						}
						c[cRow+j] += sum
					}
				}
			}
		}
	}
}

func BaseMatMulKLastBlocked_fallback(a []float32, b []float32, c []float32, m int, n int, k int) {
	if len(a) < m*k {
		panic("matmul: A slice too short")
	}
	if len(b) < n*k {
		panic("matmul: B slice too short")
	}
	if len(c) < m*n {
		panic("matmul: C slice too short")
	}
	const blockM = 64
	const blockN = 64
	const blockK = 256
	for i := range c[:m*n] {
		c[i] = 0
	}
	for ii := 0; ii < m; ii += blockM {
		iEnd := min(ii+blockM, m)
		for jj := 0; jj < n; jj += blockN {
			jEnd := min(jj+blockN, n)
			for kk := 0; kk < k; kk += blockK {
				kEnd := min(kk+blockK, k)
				for i := ii; i < iEnd; i++ {
					aRow := i * k
					cRow := i * n
					for j := jj; j < jEnd; j++ {
						bRow := j * k
						acc := float32(0)
						var p int
						for p = kk; p < kEnd; p++ {
							vA := a[aRow+p]
							vB := b[bRow+p]
							acc = vA*vB + acc
						}
						sum := acc
						for ; p < kEnd; p++ {
							sum += a[aRow+p] * b[bRow+p]
						}
						c[cRow+j] += sum
					}
				}
			}
		}
	}
}

func BaseMatMulKLastBlocked_fallback_Float64(a []float64, b []float64, c []float64, m int, n int, k int) {
	if len(a) < m*k {
		panic("matmul: A slice too short")
	}
	if len(b) < n*k {
		panic("matmul: B slice too short")
	}
	if len(c) < m*n {
		panic("matmul: C slice too short")
	}
	const blockM = 64
	const blockN = 64
	const blockK = 256
	for i := range c[:m*n] {
		c[i] = 0
	}
	for ii := 0; ii < m; ii += blockM {
		iEnd := min(ii+blockM, m)
		for jj := 0; jj < n; jj += blockN {
			jEnd := min(jj+blockN, n)
			for kk := 0; kk < k; kk += blockK {
				kEnd := min(kk+blockK, k)
				for i := ii; i < iEnd; i++ {
					aRow := i * k
					cRow := i * n
					for j := jj; j < jEnd; j++ {
						bRow := j * k
						acc := float64(0)
						var p int
						for p = kk; p < kEnd; p++ {
							vA := a[aRow+p]
							vB := b[bRow+p]
							acc = vA*vB + acc
						}
						sum := acc
						for ; p < kEnd; p++ {
							sum += a[aRow+p] * b[bRow+p]
						}
						c[cRow+j] += sum
					}
				}
			}
		}
	}
}
