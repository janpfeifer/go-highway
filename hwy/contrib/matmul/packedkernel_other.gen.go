// Code generated by hwygen. DO NOT EDIT.
//go:build !arm64 && !(amd64 && goexperiment.simd)

package matmul

import (
	"os"

	"github.com/ajroetker/go-highway/hwy"
)

var PackedMicroKernelFloat16 func(packedA []hwy.Float16, packedB []hwy.Float16, c []hwy.Float16, n int, ir int, jr int, kc int, mr int, nr int)
var PackedMicroKernelBFloat16 func(packedA []hwy.BFloat16, packedB []hwy.BFloat16, c []hwy.BFloat16, n int, ir int, jr int, kc int, mr int, nr int)
var PackedMicroKernelFloat32 func(packedA []float32, packedB []float32, c []float32, n int, ir int, jr int, kc int, mr int, nr int)
var PackedMicroKernelFloat64 func(packedA []float64, packedB []float64, c []float64, n int, ir int, jr int, kc int, mr int, nr int)
var PackedMicroKernelPartialFloat16 func(packedA []hwy.Float16, packedB []hwy.Float16, c []hwy.Float16, n int, ir int, jr int, kc int, mr int, nr int, activeRows int, activeCols int)
var PackedMicroKernelPartialBFloat16 func(packedA []hwy.BFloat16, packedB []hwy.BFloat16, c []hwy.BFloat16, n int, ir int, jr int, kc int, mr int, nr int, activeRows int, activeCols int)
var PackedMicroKernelPartialFloat32 func(packedA []float32, packedB []float32, c []float32, n int, ir int, jr int, kc int, mr int, nr int, activeRows int, activeCols int)
var PackedMicroKernelPartialFloat64 func(packedA []float64, packedB []float64, c []float64, n int, ir int, jr int, kc int, mr int, nr int, activeRows int, activeCols int)

// PackedMicroKernel is the generic API that dispatches to the appropriate SIMD implementation.
func PackedMicroKernel[T hwy.Floats](packedA []T, packedB []T, c []T, n int, ir int, jr int, kc int, mr int, nr int) {
	switch any(packedA).(type) {
	case []hwy.Float16:
		PackedMicroKernelFloat16(any(packedA).([]hwy.Float16), any(packedB).([]hwy.Float16), any(c).([]hwy.Float16), n, ir, jr, kc, mr, nr)
	case []hwy.BFloat16:
		PackedMicroKernelBFloat16(any(packedA).([]hwy.BFloat16), any(packedB).([]hwy.BFloat16), any(c).([]hwy.BFloat16), n, ir, jr, kc, mr, nr)
	case []float32:
		PackedMicroKernelFloat32(any(packedA).([]float32), any(packedB).([]float32), any(c).([]float32), n, ir, jr, kc, mr, nr)
	case []float64:
		PackedMicroKernelFloat64(any(packedA).([]float64), any(packedB).([]float64), any(c).([]float64), n, ir, jr, kc, mr, nr)
	}
}

// PackedMicroKernelPartial is the generic API that dispatches to the appropriate SIMD implementation.
func PackedMicroKernelPartial[T hwy.Floats](packedA []T, packedB []T, c []T, n int, ir int, jr int, kc int, mr int, nr int, activeRows int, activeCols int) {
	switch any(packedA).(type) {
	case []hwy.Float16:
		PackedMicroKernelPartialFloat16(any(packedA).([]hwy.Float16), any(packedB).([]hwy.Float16), any(c).([]hwy.Float16), n, ir, jr, kc, mr, nr, activeRows, activeCols)
	case []hwy.BFloat16:
		PackedMicroKernelPartialBFloat16(any(packedA).([]hwy.BFloat16), any(packedB).([]hwy.BFloat16), any(c).([]hwy.BFloat16), n, ir, jr, kc, mr, nr, activeRows, activeCols)
	case []float32:
		PackedMicroKernelPartialFloat32(any(packedA).([]float32), any(packedB).([]float32), any(c).([]float32), n, ir, jr, kc, mr, nr, activeRows, activeCols)
	case []float64:
		PackedMicroKernelPartialFloat64(any(packedA).([]float64), any(packedB).([]float64), any(c).([]float64), n, ir, jr, kc, mr, nr, activeRows, activeCols)
	}
}

func init() {
	_ = os.Getenv // silence unused import
	initPackedkernelFallback()
}

func initPackedkernelFallback() {
	PackedMicroKernelFloat16 = BasePackedMicroKernel_fallback_Float16
	PackedMicroKernelBFloat16 = BasePackedMicroKernel_fallback_BFloat16
	PackedMicroKernelFloat32 = BasePackedMicroKernel_fallback
	PackedMicroKernelFloat64 = BasePackedMicroKernel_fallback_Float64
	PackedMicroKernelPartialFloat16 = BasePackedMicroKernelPartial_fallback_Float16
	PackedMicroKernelPartialBFloat16 = BasePackedMicroKernelPartial_fallback_BFloat16
	PackedMicroKernelPartialFloat32 = BasePackedMicroKernelPartial_fallback
	PackedMicroKernelPartialFloat64 = BasePackedMicroKernelPartial_fallback_Float64
}
