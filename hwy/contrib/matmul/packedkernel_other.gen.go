// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

//go:build !arm64 && !(amd64 && goexperiment.simd)

package matmul

import (
	"github.com/ajroetker/go-highway/hwy"
)

var PackedMicroKernelFloat16 func(packedA []hwy.Float16, packedB []hwy.Float16, c []hwy.Float16, n int, ir int, jr int, kc int, mr int, nr int)
var PackedMicroKernelBFloat16 func(packedA []hwy.BFloat16, packedB []hwy.BFloat16, c []hwy.BFloat16, n int, ir int, jr int, kc int, mr int, nr int)
var PackedMicroKernelFloat32 func(packedA []float32, packedB []float32, c []float32, n int, ir int, jr int, kc int, mr int, nr int)
var PackedMicroKernelFloat64 func(packedA []float64, packedB []float64, c []float64, n int, ir int, jr int, kc int, mr int, nr int)
var packedMicroKernelGeneralFloat16 func(packedA []hwy.Float16, packedB []hwy.Float16, c []hwy.Float16, n int, ir int, jr int, kc int, mr int, nr int)
var packedMicroKernelGeneralBFloat16 func(packedA []hwy.BFloat16, packedB []hwy.BFloat16, c []hwy.BFloat16, n int, ir int, jr int, kc int, mr int, nr int)
var packedMicroKernelGeneralFloat32 func(packedA []float32, packedB []float32, c []float32, n int, ir int, jr int, kc int, mr int, nr int)
var packedMicroKernelGeneralFloat64 func(packedA []float64, packedB []float64, c []float64, n int, ir int, jr int, kc int, mr int, nr int)
var PackedMicroKernelPartialFloat16 func(packedA []hwy.Float16, packedB []hwy.Float16, c []hwy.Float16, n int, ir int, jr int, kc int, mr int, nr int, activeRows int, activeCols int)
var PackedMicroKernelPartialBFloat16 func(packedA []hwy.BFloat16, packedB []hwy.BFloat16, c []hwy.BFloat16, n int, ir int, jr int, kc int, mr int, nr int, activeRows int, activeCols int)
var PackedMicroKernelPartialFloat32 func(packedA []float32, packedB []float32, c []float32, n int, ir int, jr int, kc int, mr int, nr int, activeRows int, activeCols int)
var PackedMicroKernelPartialFloat64 func(packedA []float64, packedB []float64, c []float64, n int, ir int, jr int, kc int, mr int, nr int, activeRows int, activeCols int)

// PackedMicroKernel computes C[ir:ir+Mr, jr:jr+Nr] += packedA * packedB
// where packedA and packedB are in the packed layout from BasePackLHS/BasePackRHS.
//
// This is the innermost kernel of the GotoBLAS 5-loop algorithm. It operates on
// pre-packed data to achieve maximum memory bandwidth utilization:
//
//   - packedA: Kc values for Mr rows, laid out as [Kc, Mr] (K-first)
//   - packedB: Kc values for Nr cols, laid out as [Kc, Nr] (K-first)
//
// The kernel uses a 4×2-vector accumulator pattern:
//   - 4 rows (Mr=4) × 2 vector widths (Nr=2*lanes)
//   - 8 FMA operations per K iteration
//   - Accumulators held in registers across entire Kc loop
//
// Parameters:
//   - packedA: Packed A micro-panel, size Kc * Mr
//   - packedB: Packed B micro-panel, size Kc * Nr
//   - c: Output matrix C in row-major order
//   - n: Leading dimension of C (number of columns)
//   - ir: Starting row in C
//   - jr: Starting column in C
//   - kc: K-dimension of the packed panels
//   - mr: Number of rows (must be 4 for this kernel)
//   - nr: Number of columns (must be 2*lanes for this kernel)
//
// This function dispatches to the appropriate SIMD implementation at runtime.
func PackedMicroKernel[T hwy.Floats](packedA []T, packedB []T, c []T, n int, ir int, jr int, kc int, mr int, nr int) {
	switch any(packedA).(type) {
	case []hwy.Float16:
		PackedMicroKernelFloat16(any(packedA).([]hwy.Float16), any(packedB).([]hwy.Float16), any(c).([]hwy.Float16), n, ir, jr, kc, mr, nr)
	case []hwy.BFloat16:
		PackedMicroKernelBFloat16(any(packedA).([]hwy.BFloat16), any(packedB).([]hwy.BFloat16), any(c).([]hwy.BFloat16), n, ir, jr, kc, mr, nr)
	case []float32:
		PackedMicroKernelFloat32(any(packedA).([]float32), any(packedB).([]float32), any(c).([]float32), n, ir, jr, kc, mr, nr)
	case []float64:
		PackedMicroKernelFloat64(any(packedA).([]float64), any(packedB).([]float64), any(c).([]float64), n, ir, jr, kc, mr, nr)
	}
}

// packedMicroKernelGeneral handles arbitrary micro-tile sizes.
// Used as fallback when Mr != 4 or Nr != 2*lanes.
//
// This function dispatches to the appropriate SIMD implementation at runtime.
func packedMicroKernelGeneral[T hwy.Floats](packedA []T, packedB []T, c []T, n int, ir int, jr int, kc int, mr int, nr int) {
	switch any(packedA).(type) {
	case []hwy.Float16:
		packedMicroKernelGeneralFloat16(any(packedA).([]hwy.Float16), any(packedB).([]hwy.Float16), any(c).([]hwy.Float16), n, ir, jr, kc, mr, nr)
	case []hwy.BFloat16:
		packedMicroKernelGeneralBFloat16(any(packedA).([]hwy.BFloat16), any(packedB).([]hwy.BFloat16), any(c).([]hwy.BFloat16), n, ir, jr, kc, mr, nr)
	case []float32:
		packedMicroKernelGeneralFloat32(any(packedA).([]float32), any(packedB).([]float32), any(c).([]float32), n, ir, jr, kc, mr, nr)
	case []float64:
		packedMicroKernelGeneralFloat64(any(packedA).([]float64), any(packedB).([]float64), any(c).([]float64), n, ir, jr, kc, mr, nr)
	}
}

// PackedMicroKernelPartial handles edge cases where the micro-tile
// extends beyond the matrix bounds.
//
// Parameters:
//   - activeRows: Actual number of valid rows (may be < Mr)
//   - activeCols: Actual number of valid columns (may be < Nr)
//
// The packed data is still Mr × Nr with zero padding, but we only
// write back the active portion to C.
//
// This function dispatches to the appropriate SIMD implementation at runtime.
func PackedMicroKernelPartial[T hwy.Floats](packedA []T, packedB []T, c []T, n int, ir int, jr int, kc int, mr int, nr int, activeRows int, activeCols int) {
	switch any(packedA).(type) {
	case []hwy.Float16:
		PackedMicroKernelPartialFloat16(any(packedA).([]hwy.Float16), any(packedB).([]hwy.Float16), any(c).([]hwy.Float16), n, ir, jr, kc, mr, nr, activeRows, activeCols)
	case []hwy.BFloat16:
		PackedMicroKernelPartialBFloat16(any(packedA).([]hwy.BFloat16), any(packedB).([]hwy.BFloat16), any(c).([]hwy.BFloat16), n, ir, jr, kc, mr, nr, activeRows, activeCols)
	case []float32:
		PackedMicroKernelPartialFloat32(any(packedA).([]float32), any(packedB).([]float32), any(c).([]float32), n, ir, jr, kc, mr, nr, activeRows, activeCols)
	case []float64:
		PackedMicroKernelPartialFloat64(any(packedA).([]float64), any(packedB).([]float64), any(c).([]float64), n, ir, jr, kc, mr, nr, activeRows, activeCols)
	}
}

func init() {
	_ = hwy.NoSimdEnv // silence unused import
	initPackedkernelFallback()
}

func initPackedkernelFallback() {
	PackedMicroKernelFloat16 = BasePackedMicroKernel_fallback_Float16
	PackedMicroKernelBFloat16 = BasePackedMicroKernel_fallback_BFloat16
	PackedMicroKernelFloat32 = BasePackedMicroKernel_fallback
	PackedMicroKernelFloat64 = BasePackedMicroKernel_fallback_Float64
	packedMicroKernelGeneralFloat16 = basePackedMicroKernelGeneral_fallback_Float16
	packedMicroKernelGeneralBFloat16 = basePackedMicroKernelGeneral_fallback_BFloat16
	packedMicroKernelGeneralFloat32 = basePackedMicroKernelGeneral_fallback
	packedMicroKernelGeneralFloat64 = basePackedMicroKernelGeneral_fallback_Float64
	PackedMicroKernelPartialFloat16 = BasePackedMicroKernelPartial_fallback_Float16
	PackedMicroKernelPartialBFloat16 = BasePackedMicroKernelPartial_fallback_BFloat16
	PackedMicroKernelPartialFloat32 = BasePackedMicroKernelPartial_fallback
	PackedMicroKernelPartialFloat64 = BasePackedMicroKernelPartial_fallback_Float64
}
