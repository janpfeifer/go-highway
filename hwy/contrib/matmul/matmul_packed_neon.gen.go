// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

//go:build arm64

package matmul

import (
	"unsafe"

	"github.com/ajroetker/go-highway/hwy"
	"github.com/ajroetker/go-highway/hwy/asm"
)

func BasePackedMatMul_neon_Float16(a []hwy.Float16, b []hwy.Float16, c []hwy.Float16, m int, n int, k int) {
	if len(a) < m*k {
		panic("packedmatmul: A slice too short")
	}
	if len(b) < k*n {
		panic("packedmatmul: B slice too short")
	}
	if len(c) < m*n {
		panic("packedmatmul: C slice too short")
	}
	params := getCacheParams[hwy.Float16]()
	mr, nr := params.Mr, params.Nr
	kc, mc, nc := params.Kc, params.Mc, params.Nc
	packedASize := params.PackedASize()
	packedBSize := params.PackedBSize()
	packedA := make([]hwy.Float16, packedASize)
	packedB := make([]hwy.Float16, packedBSize)
	{
		vZero_1 := asm.ZeroFloat16x8()
		lanes_1 := 8
		var idx_1 int
		for idx_1 = 0; idx_1+lanes_1 <= m*n; idx_1 += lanes_1 {
			vZero_1.StorePtr(unsafe.Pointer(&c[idx_1:][0]))
		}
		for ; idx_1 < m*n; idx_1++ {
			c[idx_1] = hwy.Float32ToFloat16(0)
		}
	}
	for jc := 0; jc < n; jc += nc {
		jcEnd := min(jc+nc, n)
		panelCols := jcEnd - jc
		for pc := 0; pc < k; pc += kc {
			pcEnd := min(pc+kc, k)
			panelK := pcEnd - pc
			PackRHS(b, packedB, k, n, pc, jc, panelK, panelCols, nr)
			for ic := 0; ic < m; ic += mc {
				icEnd := min(ic+mc, m)
				panelRows := icEnd - ic
				activeRowsLast := PackLHS(a, packedA, m, k, ic, pc, panelRows, panelK, mr)
				{
					numMicroPanelsA_2 := (panelRows + mr - 1) / mr
					numMicroPanelsB_2 := (panelCols + nr - 1) / nr
					activeColsLast_2 := panelCols - (numMicroPanelsB_2-1)*nr
					if activeColsLast_2 <= 0 {
						activeColsLast_2 = nr
					}
					for jPanel_2 := 0; jPanel_2 < numMicroPanelsB_2; jPanel_2++ {
						jr_2 := jc + jPanel_2*nr
						bPanelOffset_2 := jPanel_2 * panelK * nr
						activeCols_2 := nr
						if jPanel_2 == numMicroPanelsB_2-1 {
							activeCols_2 = activeColsLast_2
						}
						for iPanel_2 := 0; iPanel_2 < numMicroPanelsA_2; iPanel_2++ {
							ir_2 := ic + iPanel_2*mr
							aPanelOffset_2 := iPanel_2 * panelK * mr
							activeRows_2 := mr
							if iPanel_2 == numMicroPanelsA_2-1 {
								activeRows_2 = activeRowsLast
							}
							if activeRows_2 == mr && activeCols_2 == nr {
								PackedMicroKernel(packedA[aPanelOffset_2:], packedB[bPanelOffset_2:], c, n, ir_2, jr_2, panelK, mr, nr)
							} else {
								PackedMicroKernelPartial(packedA[aPanelOffset_2:], packedB[bPanelOffset_2:], c, n, ir_2, jr_2, panelK, mr, nr, activeRows_2, activeCols_2)
							}
						}
					}
				}
			}
		}
	}
}

func BasePackedMatMul_neon_BFloat16(a []hwy.BFloat16, b []hwy.BFloat16, c []hwy.BFloat16, m int, n int, k int) {
	if len(a) < m*k {
		panic("packedmatmul: A slice too short")
	}
	if len(b) < k*n {
		panic("packedmatmul: B slice too short")
	}
	if len(c) < m*n {
		panic("packedmatmul: C slice too short")
	}
	params := getCacheParams[hwy.BFloat16]()
	mr, nr := params.Mr, params.Nr
	kc, mc, nc := params.Kc, params.Mc, params.Nc
	packedASize := params.PackedASize()
	packedBSize := params.PackedBSize()
	packedA := make([]hwy.BFloat16, packedASize)
	packedB := make([]hwy.BFloat16, packedBSize)
	{
		vZero_1 := asm.ZeroBFloat16x8()
		lanes_1 := 8
		var idx_1 int
		for idx_1 = 0; idx_1+lanes_1 <= m*n; idx_1 += lanes_1 {
			vZero_1.StorePtr(unsafe.Pointer(&c[idx_1:][0]))
		}
		for ; idx_1 < m*n; idx_1++ {
			c[idx_1] = hwy.Float32ToBFloat16(0)
		}
	}
	for jc := 0; jc < n; jc += nc {
		jcEnd := min(jc+nc, n)
		panelCols := jcEnd - jc
		for pc := 0; pc < k; pc += kc {
			pcEnd := min(pc+kc, k)
			panelK := pcEnd - pc
			PackRHS(b, packedB, k, n, pc, jc, panelK, panelCols, nr)
			for ic := 0; ic < m; ic += mc {
				icEnd := min(ic+mc, m)
				panelRows := icEnd - ic
				activeRowsLast := PackLHS(a, packedA, m, k, ic, pc, panelRows, panelK, mr)
				{
					numMicroPanelsA_2 := (panelRows + mr - 1) / mr
					numMicroPanelsB_2 := (panelCols + nr - 1) / nr
					activeColsLast_2 := panelCols - (numMicroPanelsB_2-1)*nr
					if activeColsLast_2 <= 0 {
						activeColsLast_2 = nr
					}
					for jPanel_2 := 0; jPanel_2 < numMicroPanelsB_2; jPanel_2++ {
						jr_2 := jc + jPanel_2*nr
						bPanelOffset_2 := jPanel_2 * panelK * nr
						activeCols_2 := nr
						if jPanel_2 == numMicroPanelsB_2-1 {
							activeCols_2 = activeColsLast_2
						}
						for iPanel_2 := 0; iPanel_2 < numMicroPanelsA_2; iPanel_2++ {
							ir_2 := ic + iPanel_2*mr
							aPanelOffset_2 := iPanel_2 * panelK * mr
							activeRows_2 := mr
							if iPanel_2 == numMicroPanelsA_2-1 {
								activeRows_2 = activeRowsLast
							}
							if activeRows_2 == mr && activeCols_2 == nr {
								PackedMicroKernel(packedA[aPanelOffset_2:], packedB[bPanelOffset_2:], c, n, ir_2, jr_2, panelK, mr, nr)
							} else {
								PackedMicroKernelPartial(packedA[aPanelOffset_2:], packedB[bPanelOffset_2:], c, n, ir_2, jr_2, panelK, mr, nr, activeRows_2, activeCols_2)
							}
						}
					}
				}
			}
		}
	}
}

func BasePackedMatMul_neon(a []float32, b []float32, c []float32, m int, n int, k int) {
	if len(a) < m*k {
		panic("packedmatmul: A slice too short")
	}
	if len(b) < k*n {
		panic("packedmatmul: B slice too short")
	}
	if len(c) < m*n {
		panic("packedmatmul: C slice too short")
	}
	params := getCacheParams[float32]()
	mr, nr := params.Mr, params.Nr
	kc, mc, nc := params.Kc, params.Mc, params.Nc
	packedASize := params.PackedASize()
	packedBSize := params.PackedBSize()
	packedA := make([]float32, packedASize)
	packedB := make([]float32, packedBSize)
	{
		vZero_1 := asm.ZeroFloat32x4()
		lanes_1 := 4
		var idx_1 int
		for idx_1 = 0; idx_1+lanes_1 <= m*n; idx_1 += lanes_1 {
			vZero_1.StoreSlice(c[idx_1:])
		}
		for ; idx_1 < m*n; idx_1++ {
			c[idx_1] = 0
		}
	}
	for jc := 0; jc < n; jc += nc {
		jcEnd := min(jc+nc, n)
		panelCols := jcEnd - jc
		for pc := 0; pc < k; pc += kc {
			pcEnd := min(pc+kc, k)
			panelK := pcEnd - pc
			PackRHS(b, packedB, k, n, pc, jc, panelK, panelCols, nr)
			for ic := 0; ic < m; ic += mc {
				icEnd := min(ic+mc, m)
				panelRows := icEnd - ic
				activeRowsLast := PackLHS(a, packedA, m, k, ic, pc, panelRows, panelK, mr)
				{
					numMicroPanelsA_2 := (panelRows + mr - 1) / mr
					numMicroPanelsB_2 := (panelCols + nr - 1) / nr
					activeColsLast_2 := panelCols - (numMicroPanelsB_2-1)*nr
					if activeColsLast_2 <= 0 {
						activeColsLast_2 = nr
					}
					for jPanel_2 := 0; jPanel_2 < numMicroPanelsB_2; jPanel_2++ {
						jr_2 := jc + jPanel_2*nr
						bPanelOffset_2 := jPanel_2 * panelK * nr
						activeCols_2 := nr
						if jPanel_2 == numMicroPanelsB_2-1 {
							activeCols_2 = activeColsLast_2
						}
						for iPanel_2 := 0; iPanel_2 < numMicroPanelsA_2; iPanel_2++ {
							ir_2 := ic + iPanel_2*mr
							aPanelOffset_2 := iPanel_2 * panelK * mr
							activeRows_2 := mr
							if iPanel_2 == numMicroPanelsA_2-1 {
								activeRows_2 = activeRowsLast
							}
							if activeRows_2 == mr && activeCols_2 == nr {
								PackedMicroKernel(packedA[aPanelOffset_2:], packedB[bPanelOffset_2:], c, n, ir_2, jr_2, panelK, mr, nr)
							} else {
								PackedMicroKernelPartial(packedA[aPanelOffset_2:], packedB[bPanelOffset_2:], c, n, ir_2, jr_2, panelK, mr, nr, activeRows_2, activeCols_2)
							}
						}
					}
				}
			}
		}
	}
}

func BasePackedMatMul_neon_Float64(a []float64, b []float64, c []float64, m int, n int, k int) {
	if len(a) < m*k {
		panic("packedmatmul: A slice too short")
	}
	if len(b) < k*n {
		panic("packedmatmul: B slice too short")
	}
	if len(c) < m*n {
		panic("packedmatmul: C slice too short")
	}
	params := getCacheParams[float64]()
	mr, nr := params.Mr, params.Nr
	kc, mc, nc := params.Kc, params.Mc, params.Nc
	packedASize := params.PackedASize()
	packedBSize := params.PackedBSize()
	packedA := make([]float64, packedASize)
	packedB := make([]float64, packedBSize)
	{
		vZero_1 := asm.ZeroFloat64x2()
		lanes_1 := 2
		var idx_1 int
		for idx_1 = 0; idx_1+lanes_1 <= m*n; idx_1 += lanes_1 {
			vZero_1.StoreSlice(c[idx_1:])
		}
		for ; idx_1 < m*n; idx_1++ {
			c[idx_1] = 0
		}
	}
	for jc := 0; jc < n; jc += nc {
		jcEnd := min(jc+nc, n)
		panelCols := jcEnd - jc
		for pc := 0; pc < k; pc += kc {
			pcEnd := min(pc+kc, k)
			panelK := pcEnd - pc
			PackRHS(b, packedB, k, n, pc, jc, panelK, panelCols, nr)
			for ic := 0; ic < m; ic += mc {
				icEnd := min(ic+mc, m)
				panelRows := icEnd - ic
				activeRowsLast := PackLHS(a, packedA, m, k, ic, pc, panelRows, panelK, mr)
				{
					numMicroPanelsA_2 := (panelRows + mr - 1) / mr
					numMicroPanelsB_2 := (panelCols + nr - 1) / nr
					activeColsLast_2 := panelCols - (numMicroPanelsB_2-1)*nr
					if activeColsLast_2 <= 0 {
						activeColsLast_2 = nr
					}
					for jPanel_2 := 0; jPanel_2 < numMicroPanelsB_2; jPanel_2++ {
						jr_2 := jc + jPanel_2*nr
						bPanelOffset_2 := jPanel_2 * panelK * nr
						activeCols_2 := nr
						if jPanel_2 == numMicroPanelsB_2-1 {
							activeCols_2 = activeColsLast_2
						}
						for iPanel_2 := 0; iPanel_2 < numMicroPanelsA_2; iPanel_2++ {
							ir_2 := ic + iPanel_2*mr
							aPanelOffset_2 := iPanel_2 * panelK * mr
							activeRows_2 := mr
							if iPanel_2 == numMicroPanelsA_2-1 {
								activeRows_2 = activeRowsLast
							}
							if activeRows_2 == mr && activeCols_2 == nr {
								PackedMicroKernel(packedA[aPanelOffset_2:], packedB[bPanelOffset_2:], c, n, ir_2, jr_2, panelK, mr, nr)
							} else {
								PackedMicroKernelPartial(packedA[aPanelOffset_2:], packedB[bPanelOffset_2:], c, n, ir_2, jr_2, panelK, mr, nr, activeRows_2, activeCols_2)
							}
						}
					}
				}
			}
		}
	}
}

func BasePackedMatMulWithBuffers_neon_Float16(a []hwy.Float16, b []hwy.Float16, c []hwy.Float16, m int, n int, k int, packedA []hwy.Float16, packedB []hwy.Float16, params CacheParams) {
	if len(a) < m*k {
		panic("packedmatmul: A slice too short")
	}
	if len(b) < k*n {
		panic("packedmatmul: B slice too short")
	}
	if len(c) < m*n {
		panic("packedmatmul: C slice too short")
	}
	mr, nr := params.Mr, params.Nr
	kc, mc, nc := params.Kc, params.Mc, params.Nc
	{
		vZero_1 := asm.ZeroFloat16x8()
		lanes_1 := 8
		var idx_1 int
		for idx_1 = 0; idx_1+lanes_1 <= m*n; idx_1 += lanes_1 {
			vZero_1.StorePtr(unsafe.Pointer(&c[idx_1:][0]))
		}
		for ; idx_1 < m*n; idx_1++ {
			c[idx_1] = hwy.Float32ToFloat16(0)
		}
	}
	for jc := 0; jc < n; jc += nc {
		jcEnd := min(jc+nc, n)
		panelCols := jcEnd - jc
		for pc := 0; pc < k; pc += kc {
			pcEnd := min(pc+kc, k)
			panelK := pcEnd - pc
			PackRHS(b, packedB, k, n, pc, jc, panelK, panelCols, nr)
			for ic := 0; ic < m; ic += mc {
				icEnd := min(ic+mc, m)
				panelRows := icEnd - ic
				activeRowsLast := PackLHS(a, packedA, m, k, ic, pc, panelRows, panelK, mr)
				{
					numMicroPanelsA_2 := (panelRows + mr - 1) / mr
					numMicroPanelsB_2 := (panelCols + nr - 1) / nr
					activeColsLast_2 := panelCols - (numMicroPanelsB_2-1)*nr
					if activeColsLast_2 <= 0 {
						activeColsLast_2 = nr
					}
					for jPanel_2 := 0; jPanel_2 < numMicroPanelsB_2; jPanel_2++ {
						jr_2 := jc + jPanel_2*nr
						bPanelOffset_2 := jPanel_2 * panelK * nr
						activeCols_2 := nr
						if jPanel_2 == numMicroPanelsB_2-1 {
							activeCols_2 = activeColsLast_2
						}
						for iPanel_2 := 0; iPanel_2 < numMicroPanelsA_2; iPanel_2++ {
							ir_2 := ic + iPanel_2*mr
							aPanelOffset_2 := iPanel_2 * panelK * mr
							activeRows_2 := mr
							if iPanel_2 == numMicroPanelsA_2-1 {
								activeRows_2 = activeRowsLast
							}
							if activeRows_2 == mr && activeCols_2 == nr {
								PackedMicroKernel(packedA[aPanelOffset_2:], packedB[bPanelOffset_2:], c, n, ir_2, jr_2, panelK, mr, nr)
							} else {
								PackedMicroKernelPartial(packedA[aPanelOffset_2:], packedB[bPanelOffset_2:], c, n, ir_2, jr_2, panelK, mr, nr, activeRows_2, activeCols_2)
							}
						}
					}
				}
			}
		}
	}
}

func BasePackedMatMulWithBuffers_neon_BFloat16(a []hwy.BFloat16, b []hwy.BFloat16, c []hwy.BFloat16, m int, n int, k int, packedA []hwy.BFloat16, packedB []hwy.BFloat16, params CacheParams) {
	if len(a) < m*k {
		panic("packedmatmul: A slice too short")
	}
	if len(b) < k*n {
		panic("packedmatmul: B slice too short")
	}
	if len(c) < m*n {
		panic("packedmatmul: C slice too short")
	}
	mr, nr := params.Mr, params.Nr
	kc, mc, nc := params.Kc, params.Mc, params.Nc
	{
		vZero_1 := asm.ZeroBFloat16x8()
		lanes_1 := 8
		var idx_1 int
		for idx_1 = 0; idx_1+lanes_1 <= m*n; idx_1 += lanes_1 {
			vZero_1.StorePtr(unsafe.Pointer(&c[idx_1:][0]))
		}
		for ; idx_1 < m*n; idx_1++ {
			c[idx_1] = hwy.Float32ToBFloat16(0)
		}
	}
	for jc := 0; jc < n; jc += nc {
		jcEnd := min(jc+nc, n)
		panelCols := jcEnd - jc
		for pc := 0; pc < k; pc += kc {
			pcEnd := min(pc+kc, k)
			panelK := pcEnd - pc
			PackRHS(b, packedB, k, n, pc, jc, panelK, panelCols, nr)
			for ic := 0; ic < m; ic += mc {
				icEnd := min(ic+mc, m)
				panelRows := icEnd - ic
				activeRowsLast := PackLHS(a, packedA, m, k, ic, pc, panelRows, panelK, mr)
				{
					numMicroPanelsA_2 := (panelRows + mr - 1) / mr
					numMicroPanelsB_2 := (panelCols + nr - 1) / nr
					activeColsLast_2 := panelCols - (numMicroPanelsB_2-1)*nr
					if activeColsLast_2 <= 0 {
						activeColsLast_2 = nr
					}
					for jPanel_2 := 0; jPanel_2 < numMicroPanelsB_2; jPanel_2++ {
						jr_2 := jc + jPanel_2*nr
						bPanelOffset_2 := jPanel_2 * panelK * nr
						activeCols_2 := nr
						if jPanel_2 == numMicroPanelsB_2-1 {
							activeCols_2 = activeColsLast_2
						}
						for iPanel_2 := 0; iPanel_2 < numMicroPanelsA_2; iPanel_2++ {
							ir_2 := ic + iPanel_2*mr
							aPanelOffset_2 := iPanel_2 * panelK * mr
							activeRows_2 := mr
							if iPanel_2 == numMicroPanelsA_2-1 {
								activeRows_2 = activeRowsLast
							}
							if activeRows_2 == mr && activeCols_2 == nr {
								PackedMicroKernel(packedA[aPanelOffset_2:], packedB[bPanelOffset_2:], c, n, ir_2, jr_2, panelK, mr, nr)
							} else {
								PackedMicroKernelPartial(packedA[aPanelOffset_2:], packedB[bPanelOffset_2:], c, n, ir_2, jr_2, panelK, mr, nr, activeRows_2, activeCols_2)
							}
						}
					}
				}
			}
		}
	}
}

func BasePackedMatMulWithBuffers_neon(a []float32, b []float32, c []float32, m int, n int, k int, packedA []float32, packedB []float32, params CacheParams) {
	if len(a) < m*k {
		panic("packedmatmul: A slice too short")
	}
	if len(b) < k*n {
		panic("packedmatmul: B slice too short")
	}
	if len(c) < m*n {
		panic("packedmatmul: C slice too short")
	}
	mr, nr := params.Mr, params.Nr
	kc, mc, nc := params.Kc, params.Mc, params.Nc
	{
		vZero_1 := asm.ZeroFloat32x4()
		lanes_1 := 4
		var idx_1 int
		for idx_1 = 0; idx_1+lanes_1 <= m*n; idx_1 += lanes_1 {
			vZero_1.StoreSlice(c[idx_1:])
		}
		for ; idx_1 < m*n; idx_1++ {
			c[idx_1] = 0
		}
	}
	for jc := 0; jc < n; jc += nc {
		jcEnd := min(jc+nc, n)
		panelCols := jcEnd - jc
		for pc := 0; pc < k; pc += kc {
			pcEnd := min(pc+kc, k)
			panelK := pcEnd - pc
			PackRHS(b, packedB, k, n, pc, jc, panelK, panelCols, nr)
			for ic := 0; ic < m; ic += mc {
				icEnd := min(ic+mc, m)
				panelRows := icEnd - ic
				activeRowsLast := PackLHS(a, packedA, m, k, ic, pc, panelRows, panelK, mr)
				{
					numMicroPanelsA_2 := (panelRows + mr - 1) / mr
					numMicroPanelsB_2 := (panelCols + nr - 1) / nr
					activeColsLast_2 := panelCols - (numMicroPanelsB_2-1)*nr
					if activeColsLast_2 <= 0 {
						activeColsLast_2 = nr
					}
					for jPanel_2 := 0; jPanel_2 < numMicroPanelsB_2; jPanel_2++ {
						jr_2 := jc + jPanel_2*nr
						bPanelOffset_2 := jPanel_2 * panelK * nr
						activeCols_2 := nr
						if jPanel_2 == numMicroPanelsB_2-1 {
							activeCols_2 = activeColsLast_2
						}
						for iPanel_2 := 0; iPanel_2 < numMicroPanelsA_2; iPanel_2++ {
							ir_2 := ic + iPanel_2*mr
							aPanelOffset_2 := iPanel_2 * panelK * mr
							activeRows_2 := mr
							if iPanel_2 == numMicroPanelsA_2-1 {
								activeRows_2 = activeRowsLast
							}
							if activeRows_2 == mr && activeCols_2 == nr {
								PackedMicroKernel(packedA[aPanelOffset_2:], packedB[bPanelOffset_2:], c, n, ir_2, jr_2, panelK, mr, nr)
							} else {
								PackedMicroKernelPartial(packedA[aPanelOffset_2:], packedB[bPanelOffset_2:], c, n, ir_2, jr_2, panelK, mr, nr, activeRows_2, activeCols_2)
							}
						}
					}
				}
			}
		}
	}
}

func BasePackedMatMulWithBuffers_neon_Float64(a []float64, b []float64, c []float64, m int, n int, k int, packedA []float64, packedB []float64, params CacheParams) {
	if len(a) < m*k {
		panic("packedmatmul: A slice too short")
	}
	if len(b) < k*n {
		panic("packedmatmul: B slice too short")
	}
	if len(c) < m*n {
		panic("packedmatmul: C slice too short")
	}
	mr, nr := params.Mr, params.Nr
	kc, mc, nc := params.Kc, params.Mc, params.Nc
	{
		vZero_1 := asm.ZeroFloat64x2()
		lanes_1 := 2
		var idx_1 int
		for idx_1 = 0; idx_1+lanes_1 <= m*n; idx_1 += lanes_1 {
			vZero_1.StoreSlice(c[idx_1:])
		}
		for ; idx_1 < m*n; idx_1++ {
			c[idx_1] = 0
		}
	}
	for jc := 0; jc < n; jc += nc {
		jcEnd := min(jc+nc, n)
		panelCols := jcEnd - jc
		for pc := 0; pc < k; pc += kc {
			pcEnd := min(pc+kc, k)
			panelK := pcEnd - pc
			PackRHS(b, packedB, k, n, pc, jc, panelK, panelCols, nr)
			for ic := 0; ic < m; ic += mc {
				icEnd := min(ic+mc, m)
				panelRows := icEnd - ic
				activeRowsLast := PackLHS(a, packedA, m, k, ic, pc, panelRows, panelK, mr)
				{
					numMicroPanelsA_2 := (panelRows + mr - 1) / mr
					numMicroPanelsB_2 := (panelCols + nr - 1) / nr
					activeColsLast_2 := panelCols - (numMicroPanelsB_2-1)*nr
					if activeColsLast_2 <= 0 {
						activeColsLast_2 = nr
					}
					for jPanel_2 := 0; jPanel_2 < numMicroPanelsB_2; jPanel_2++ {
						jr_2 := jc + jPanel_2*nr
						bPanelOffset_2 := jPanel_2 * panelK * nr
						activeCols_2 := nr
						if jPanel_2 == numMicroPanelsB_2-1 {
							activeCols_2 = activeColsLast_2
						}
						for iPanel_2 := 0; iPanel_2 < numMicroPanelsA_2; iPanel_2++ {
							ir_2 := ic + iPanel_2*mr
							aPanelOffset_2 := iPanel_2 * panelK * mr
							activeRows_2 := mr
							if iPanel_2 == numMicroPanelsA_2-1 {
								activeRows_2 = activeRowsLast
							}
							if activeRows_2 == mr && activeCols_2 == nr {
								PackedMicroKernel(packedA[aPanelOffset_2:], packedB[bPanelOffset_2:], c, n, ir_2, jr_2, panelK, mr, nr)
							} else {
								PackedMicroKernelPartial(packedA[aPanelOffset_2:], packedB[bPanelOffset_2:], c, n, ir_2, jr_2, panelK, mr, nr, activeRows_2, activeCols_2)
							}
						}
					}
				}
			}
		}
	}
}

func BasePackedMatMulStrip_neon_Float16(a []hwy.Float16, b []hwy.Float16, c []hwy.Float16, m int, n int, k int, rowStart int, rowEnd int, packedA []hwy.Float16, packedB []hwy.Float16, params CacheParams) {
	mr, nr := params.Mr, params.Nr
	kc, mc, nc := params.Kc, params.Mc, params.Nc
	stripM := rowEnd - rowStart
	{
		vZero_1 := asm.ZeroFloat16x8()
		lanes_1 := 8
		var idx_1 int
		for idx_1 = 0; idx_1+lanes_1 <= stripM*n; idx_1 += lanes_1 {
			vZero_1.StorePtr(unsafe.Pointer(&c[rowStart*n : rowEnd*n][idx_1:][0]))
		}
		for ; idx_1 < stripM*n; idx_1++ {
			c[rowStart*n : rowEnd*n][idx_1] = 0
		}
	}
	for jc := 0; jc < n; jc += nc {
		jcEnd := min(jc+nc, n)
		panelCols := jcEnd - jc
		for pc := 0; pc < k; pc += kc {
			pcEnd := min(pc+kc, k)
			panelK := pcEnd - pc
			PackRHS(b, packedB, k, n, pc, jc, panelK, panelCols, nr)
			for ic := rowStart; ic < rowEnd; ic += mc {
				icEnd := min(ic+mc, rowEnd)
				panelRows := icEnd - ic
				activeRowsLast := PackLHS(a, packedA, m, k, ic, pc, panelRows, panelK, mr)
				{
					numMicroPanelsA_2 := (panelRows + mr - 1) / mr
					numMicroPanelsB_2 := (panelCols + nr - 1) / nr
					activeColsLast_2 := panelCols - (numMicroPanelsB_2-1)*nr
					if activeColsLast_2 <= 0 {
						activeColsLast_2 = nr
					}
					for jPanel_2 := 0; jPanel_2 < numMicroPanelsB_2; jPanel_2++ {
						jr_2 := jc + jPanel_2*nr
						bPanelOffset_2 := jPanel_2 * panelK * nr
						activeCols_2 := nr
						if jPanel_2 == numMicroPanelsB_2-1 {
							activeCols_2 = activeColsLast_2
						}
						for iPanel_2 := 0; iPanel_2 < numMicroPanelsA_2; iPanel_2++ {
							ir_2 := ic + iPanel_2*mr
							aPanelOffset_2 := iPanel_2 * panelK * mr
							activeRows_2 := mr
							if iPanel_2 == numMicroPanelsA_2-1 {
								activeRows_2 = activeRowsLast
							}
							if activeRows_2 == mr && activeCols_2 == nr {
								PackedMicroKernel(packedA[aPanelOffset_2:], packedB[bPanelOffset_2:], c, n, ir_2, jr_2, panelK, mr, nr)
							} else {
								PackedMicroKernelPartial(packedA[aPanelOffset_2:], packedB[bPanelOffset_2:], c, n, ir_2, jr_2, panelK, mr, nr, activeRows_2, activeCols_2)
							}
						}
					}
				}
			}
		}
	}
}

func BasePackedMatMulStrip_neon_BFloat16(a []hwy.BFloat16, b []hwy.BFloat16, c []hwy.BFloat16, m int, n int, k int, rowStart int, rowEnd int, packedA []hwy.BFloat16, packedB []hwy.BFloat16, params CacheParams) {
	mr, nr := params.Mr, params.Nr
	kc, mc, nc := params.Kc, params.Mc, params.Nc
	stripM := rowEnd - rowStart
	{
		vZero_1 := asm.ZeroBFloat16x8()
		lanes_1 := 8
		var idx_1 int
		for idx_1 = 0; idx_1+lanes_1 <= stripM*n; idx_1 += lanes_1 {
			vZero_1.StorePtr(unsafe.Pointer(&c[rowStart*n : rowEnd*n][idx_1:][0]))
		}
		for ; idx_1 < stripM*n; idx_1++ {
			c[rowStart*n : rowEnd*n][idx_1] = 0
		}
	}
	for jc := 0; jc < n; jc += nc {
		jcEnd := min(jc+nc, n)
		panelCols := jcEnd - jc
		for pc := 0; pc < k; pc += kc {
			pcEnd := min(pc+kc, k)
			panelK := pcEnd - pc
			PackRHS(b, packedB, k, n, pc, jc, panelK, panelCols, nr)
			for ic := rowStart; ic < rowEnd; ic += mc {
				icEnd := min(ic+mc, rowEnd)
				panelRows := icEnd - ic
				activeRowsLast := PackLHS(a, packedA, m, k, ic, pc, panelRows, panelK, mr)
				{
					numMicroPanelsA_2 := (panelRows + mr - 1) / mr
					numMicroPanelsB_2 := (panelCols + nr - 1) / nr
					activeColsLast_2 := panelCols - (numMicroPanelsB_2-1)*nr
					if activeColsLast_2 <= 0 {
						activeColsLast_2 = nr
					}
					for jPanel_2 := 0; jPanel_2 < numMicroPanelsB_2; jPanel_2++ {
						jr_2 := jc + jPanel_2*nr
						bPanelOffset_2 := jPanel_2 * panelK * nr
						activeCols_2 := nr
						if jPanel_2 == numMicroPanelsB_2-1 {
							activeCols_2 = activeColsLast_2
						}
						for iPanel_2 := 0; iPanel_2 < numMicroPanelsA_2; iPanel_2++ {
							ir_2 := ic + iPanel_2*mr
							aPanelOffset_2 := iPanel_2 * panelK * mr
							activeRows_2 := mr
							if iPanel_2 == numMicroPanelsA_2-1 {
								activeRows_2 = activeRowsLast
							}
							if activeRows_2 == mr && activeCols_2 == nr {
								PackedMicroKernel(packedA[aPanelOffset_2:], packedB[bPanelOffset_2:], c, n, ir_2, jr_2, panelK, mr, nr)
							} else {
								PackedMicroKernelPartial(packedA[aPanelOffset_2:], packedB[bPanelOffset_2:], c, n, ir_2, jr_2, panelK, mr, nr, activeRows_2, activeCols_2)
							}
						}
					}
				}
			}
		}
	}
}

func BasePackedMatMulStrip_neon(a []float32, b []float32, c []float32, m int, n int, k int, rowStart int, rowEnd int, packedA []float32, packedB []float32, params CacheParams) {
	mr, nr := params.Mr, params.Nr
	kc, mc, nc := params.Kc, params.Mc, params.Nc
	stripM := rowEnd - rowStart
	{
		vZero_1 := asm.ZeroFloat32x4()
		lanes_1 := 4
		var idx_1 int
		for idx_1 = 0; idx_1+lanes_1 <= stripM*n; idx_1 += lanes_1 {
			vZero_1.StoreSlice(c[rowStart*n : rowEnd*n][idx_1:])
		}
		for ; idx_1 < stripM*n; idx_1++ {
			c[rowStart*n : rowEnd*n][idx_1] = 0
		}
	}
	for jc := 0; jc < n; jc += nc {
		jcEnd := min(jc+nc, n)
		panelCols := jcEnd - jc
		for pc := 0; pc < k; pc += kc {
			pcEnd := min(pc+kc, k)
			panelK := pcEnd - pc
			PackRHS(b, packedB, k, n, pc, jc, panelK, panelCols, nr)
			for ic := rowStart; ic < rowEnd; ic += mc {
				icEnd := min(ic+mc, rowEnd)
				panelRows := icEnd - ic
				activeRowsLast := PackLHS(a, packedA, m, k, ic, pc, panelRows, panelK, mr)
				{
					numMicroPanelsA_2 := (panelRows + mr - 1) / mr
					numMicroPanelsB_2 := (panelCols + nr - 1) / nr
					activeColsLast_2 := panelCols - (numMicroPanelsB_2-1)*nr
					if activeColsLast_2 <= 0 {
						activeColsLast_2 = nr
					}
					for jPanel_2 := 0; jPanel_2 < numMicroPanelsB_2; jPanel_2++ {
						jr_2 := jc + jPanel_2*nr
						bPanelOffset_2 := jPanel_2 * panelK * nr
						activeCols_2 := nr
						if jPanel_2 == numMicroPanelsB_2-1 {
							activeCols_2 = activeColsLast_2
						}
						for iPanel_2 := 0; iPanel_2 < numMicroPanelsA_2; iPanel_2++ {
							ir_2 := ic + iPanel_2*mr
							aPanelOffset_2 := iPanel_2 * panelK * mr
							activeRows_2 := mr
							if iPanel_2 == numMicroPanelsA_2-1 {
								activeRows_2 = activeRowsLast
							}
							if activeRows_2 == mr && activeCols_2 == nr {
								PackedMicroKernel(packedA[aPanelOffset_2:], packedB[bPanelOffset_2:], c, n, ir_2, jr_2, panelK, mr, nr)
							} else {
								PackedMicroKernelPartial(packedA[aPanelOffset_2:], packedB[bPanelOffset_2:], c, n, ir_2, jr_2, panelK, mr, nr, activeRows_2, activeCols_2)
							}
						}
					}
				}
			}
		}
	}
}

func BasePackedMatMulStrip_neon_Float64(a []float64, b []float64, c []float64, m int, n int, k int, rowStart int, rowEnd int, packedA []float64, packedB []float64, params CacheParams) {
	mr, nr := params.Mr, params.Nr
	kc, mc, nc := params.Kc, params.Mc, params.Nc
	stripM := rowEnd - rowStart
	{
		vZero_1 := asm.ZeroFloat64x2()
		lanes_1 := 2
		var idx_1 int
		for idx_1 = 0; idx_1+lanes_1 <= stripM*n; idx_1 += lanes_1 {
			vZero_1.StoreSlice(c[rowStart*n : rowEnd*n][idx_1:])
		}
		for ; idx_1 < stripM*n; idx_1++ {
			c[rowStart*n : rowEnd*n][idx_1] = 0
		}
	}
	for jc := 0; jc < n; jc += nc {
		jcEnd := min(jc+nc, n)
		panelCols := jcEnd - jc
		for pc := 0; pc < k; pc += kc {
			pcEnd := min(pc+kc, k)
			panelK := pcEnd - pc
			PackRHS(b, packedB, k, n, pc, jc, panelK, panelCols, nr)
			for ic := rowStart; ic < rowEnd; ic += mc {
				icEnd := min(ic+mc, rowEnd)
				panelRows := icEnd - ic
				activeRowsLast := PackLHS(a, packedA, m, k, ic, pc, panelRows, panelK, mr)
				{
					numMicroPanelsA_2 := (panelRows + mr - 1) / mr
					numMicroPanelsB_2 := (panelCols + nr - 1) / nr
					activeColsLast_2 := panelCols - (numMicroPanelsB_2-1)*nr
					if activeColsLast_2 <= 0 {
						activeColsLast_2 = nr
					}
					for jPanel_2 := 0; jPanel_2 < numMicroPanelsB_2; jPanel_2++ {
						jr_2 := jc + jPanel_2*nr
						bPanelOffset_2 := jPanel_2 * panelK * nr
						activeCols_2 := nr
						if jPanel_2 == numMicroPanelsB_2-1 {
							activeCols_2 = activeColsLast_2
						}
						for iPanel_2 := 0; iPanel_2 < numMicroPanelsA_2; iPanel_2++ {
							ir_2 := ic + iPanel_2*mr
							aPanelOffset_2 := iPanel_2 * panelK * mr
							activeRows_2 := mr
							if iPanel_2 == numMicroPanelsA_2-1 {
								activeRows_2 = activeRowsLast
							}
							if activeRows_2 == mr && activeCols_2 == nr {
								PackedMicroKernel(packedA[aPanelOffset_2:], packedB[bPanelOffset_2:], c, n, ir_2, jr_2, panelK, mr, nr)
							} else {
								PackedMicroKernelPartial(packedA[aPanelOffset_2:], packedB[bPanelOffset_2:], c, n, ir_2, jr_2, panelK, mr, nr, activeRows_2, activeCols_2)
							}
						}
					}
				}
			}
		}
	}
}
