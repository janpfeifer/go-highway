// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

//go:build amd64 && goexperiment.simd

package matmul

import (
	"simd/archsimd"
	"unsafe"

	"github.com/ajroetker/go-highway/hwy"
	"github.com/ajroetker/go-highway/hwy/asm"
)

func BaseMatMul_avx512_Float16(a []hwy.Float16, b []hwy.Float16, c []hwy.Float16, m int, n int, k int) {
	if len(a) < m*k {
		panic("matmul: A slice too short")
	}
	if len(b) < k*n {
		panic("matmul: B slice too short")
	}
	if len(c) < m*n {
		panic("matmul: C slice too short")
	}
	for i := range m {
		cRow := c[i*n : (i+1)*n]
		vZero := asm.ZeroFloat16x16AVX512()
		lanes := 16
		var j int
		for j = 0; j+lanes <= n; j += lanes {
			vZero.StorePtr(unsafe.Pointer(&cRow[j:][0]))
		}
		for ; j < n; j++ {
			cRow[j] = hwy.Float32ToFloat16(0)
		}
		for p := range k {
			aip := a[i*k+p]
			vA := asm.BroadcastFloat16x16AVX512(uint16(aip))
			bRow := b[p*n : (p+1)*n]
			for j = 0; j+lanes <= n; j += lanes {
				vB := asm.LoadFloat16x16AVX512Ptr(unsafe.Pointer(&bRow[j:][0]))
				vC := asm.LoadFloat16x16AVX512Ptr(unsafe.Pointer(&cRow[j:][0]))
				vC = vA.MulAdd(vB, vC)
				vC.StorePtr(unsafe.Pointer(&cRow[j:][0]))
			}
			for ; j < n; j++ {
				cRow[j] = hwy.Float32ToFloat16(cRow[j].Float32() + aip.Float32()*bRow[j].Float32())
			}
		}
	}
}

func BaseMatMul_avx512_BFloat16(a []hwy.BFloat16, b []hwy.BFloat16, c []hwy.BFloat16, m int, n int, k int) {
	if len(a) < m*k {
		panic("matmul: A slice too short")
	}
	if len(b) < k*n {
		panic("matmul: B slice too short")
	}
	if len(c) < m*n {
		panic("matmul: C slice too short")
	}
	for i := range m {
		cRow := c[i*n : (i+1)*n]
		vZero := asm.ZeroBFloat16x16AVX512()
		lanes := 16
		var j int
		for j = 0; j+lanes <= n; j += lanes {
			vZero.StorePtr(unsafe.Pointer(&cRow[j:][0]))
		}
		for ; j < n; j++ {
			cRow[j] = hwy.Float32ToBFloat16(0)
		}
		for p := range k {
			aip := a[i*k+p]
			vA := asm.BroadcastBFloat16x16AVX512(uint16(aip))
			bRow := b[p*n : (p+1)*n]
			for j = 0; j+lanes <= n; j += lanes {
				vB := asm.LoadBFloat16x16AVX512Ptr(unsafe.Pointer(&bRow[j:][0]))
				vC := asm.LoadBFloat16x16AVX512Ptr(unsafe.Pointer(&cRow[j:][0]))
				vC = vA.MulAdd(vB, vC)
				vC.StorePtr(unsafe.Pointer(&cRow[j:][0]))
			}
			for ; j < n; j++ {
				cRow[j] = hwy.Float32ToBFloat16(cRow[j].Float32() + aip.Float32()*bRow[j].Float32())
			}
		}
	}
}

func BaseMatMul_avx512(a []float32, b []float32, c []float32, m int, n int, k int) {
	if len(a) < m*k {
		panic("matmul: A slice too short")
	}
	if len(b) < k*n {
		panic("matmul: B slice too short")
	}
	if len(c) < m*n {
		panic("matmul: C slice too short")
	}
	for i := range m {
		cRow := c[i*n : (i+1)*n]
		vZero := archsimd.BroadcastFloat32x16(0)
		lanes := 16
		var j int
		for j = 0; j+lanes <= n; j += lanes {
			vZero.Store((*[16]float32)(unsafe.Pointer(&cRow[j])))
		}
		for ; j < n; j++ {
			cRow[j] = 0
		}
		for p := range k {
			aip := a[i*k+p]
			vA := archsimd.BroadcastFloat32x16(aip)
			bRow := b[p*n : (p+1)*n]
			for j = 0; j+lanes <= n; j += lanes {
				vB := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&bRow[j])))
				vC := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&cRow[j])))
				vC = vA.MulAdd(vB, vC)
				vC.Store((*[16]float32)(unsafe.Pointer(&cRow[j])))
			}
			for ; j < n; j++ {
				cRow[j] += aip * bRow[j]
			}
		}
	}
}

func BaseMatMul_avx512_Float64(a []float64, b []float64, c []float64, m int, n int, k int) {
	if len(a) < m*k {
		panic("matmul: A slice too short")
	}
	if len(b) < k*n {
		panic("matmul: B slice too short")
	}
	if len(c) < m*n {
		panic("matmul: C slice too short")
	}
	for i := range m {
		cRow := c[i*n : (i+1)*n]
		vZero := archsimd.BroadcastFloat64x8(0)
		lanes := 8
		var j int
		for j = 0; j+lanes <= n; j += lanes {
			vZero.Store((*[8]float64)(unsafe.Pointer(&cRow[j])))
		}
		for ; j < n; j++ {
			cRow[j] = 0
		}
		for p := range k {
			aip := a[i*k+p]
			vA := archsimd.BroadcastFloat64x8(aip)
			bRow := b[p*n : (p+1)*n]
			for j = 0; j+lanes <= n; j += lanes {
				vB := archsimd.LoadFloat64x8((*[8]float64)(unsafe.Pointer(&bRow[j])))
				vC := archsimd.LoadFloat64x8((*[8]float64)(unsafe.Pointer(&cRow[j])))
				vC = vA.MulAdd(vB, vC)
				vC.Store((*[8]float64)(unsafe.Pointer(&cRow[j])))
			}
			for ; j < n; j++ {
				cRow[j] += aip * bRow[j]
			}
		}
	}
}
