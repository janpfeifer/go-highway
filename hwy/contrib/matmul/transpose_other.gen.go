// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

//go:build !arm64 && !(amd64 && goexperiment.simd)

package matmul

import (
	"github.com/ajroetker/go-highway/hwy"
)

var Transpose2DStridedFloat16 func(src []hwy.Float16, rowStart int, rowEnd int, k int, dstM int, dst []hwy.Float16)
var Transpose2DStridedBFloat16 func(src []hwy.BFloat16, rowStart int, rowEnd int, k int, dstM int, dst []hwy.BFloat16)
var Transpose2DStridedFloat32 func(src []float32, rowStart int, rowEnd int, k int, dstM int, dst []float32)
var Transpose2DStridedFloat64 func(src []float64, rowStart int, rowEnd int, k int, dstM int, dst []float64)
var Transpose2DFloat16 func(src []hwy.Float16, m int, k int, dst []hwy.Float16)
var Transpose2DBFloat16 func(src []hwy.BFloat16, m int, k int, dst []hwy.BFloat16)
var Transpose2DFloat32 func(src []float32, m int, k int, dst []float32)
var Transpose2DFloat64 func(src []float64, m int, k int, dst []float64)

// Transpose2DStrided transposes rows [rowStart, rowEnd) of an M×K matrix to K×M.
// dstM is the stride in the destination (typically the full M dimension).
// This enables parallel transpose by processing row strips independently.
//
// Source: rows [rowStart, rowEnd) of M×K matrix, accessed as src[i*k + j]
// Dest: columns [rowStart, rowEnd) of K×M matrix, accessed as dst[j*dstM + i]
//
// This function dispatches to the appropriate SIMD implementation at runtime.
func Transpose2DStrided[T hwy.Floats](src []T, rowStart int, rowEnd int, k int, dstM int, dst []T) {
	switch any(src).(type) {
	case []hwy.Float16:
		Transpose2DStridedFloat16(any(src).([]hwy.Float16), rowStart, rowEnd, k, dstM, any(dst).([]hwy.Float16))
	case []hwy.BFloat16:
		Transpose2DStridedBFloat16(any(src).([]hwy.BFloat16), rowStart, rowEnd, k, dstM, any(dst).([]hwy.BFloat16))
	case []float32:
		Transpose2DStridedFloat32(any(src).([]float32), rowStart, rowEnd, k, dstM, any(dst).([]float32))
	case []float64:
		Transpose2DStridedFloat64(any(src).([]float64), rowStart, rowEnd, k, dstM, any(dst).([]float64))
	}
}

// Transpose2D transposes an M×K row-major matrix to K×M.
// Uses block-based approach: load lanes×lanes block, transpose in-register, store.
//
// This function dispatches to the appropriate SIMD implementation at runtime.
func Transpose2D[T hwy.Floats](src []T, m int, k int, dst []T) {
	switch any(src).(type) {
	case []hwy.Float16:
		Transpose2DFloat16(any(src).([]hwy.Float16), m, k, any(dst).([]hwy.Float16))
	case []hwy.BFloat16:
		Transpose2DBFloat16(any(src).([]hwy.BFloat16), m, k, any(dst).([]hwy.BFloat16))
	case []float32:
		Transpose2DFloat32(any(src).([]float32), m, k, any(dst).([]float32))
	case []float64:
		Transpose2DFloat64(any(src).([]float64), m, k, any(dst).([]float64))
	}
}

func init() {
	_ = hwy.NoSimdEnv // silence unused import
	initTransposeFallback()
}

func initTransposeFallback() {
	Transpose2DStridedFloat16 = BaseTranspose2DStrided_fallback_Float16
	Transpose2DStridedBFloat16 = BaseTranspose2DStrided_fallback_BFloat16
	Transpose2DStridedFloat32 = BaseTranspose2DStrided_fallback
	Transpose2DStridedFloat64 = BaseTranspose2DStrided_fallback_Float64
	Transpose2DFloat16 = BaseTranspose2D_fallback_Float16
	Transpose2DBFloat16 = BaseTranspose2D_fallback_BFloat16
	Transpose2DFloat32 = BaseTranspose2D_fallback
	Transpose2DFloat64 = BaseTranspose2D_fallback_Float64
}
