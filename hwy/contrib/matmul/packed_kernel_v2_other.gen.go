// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

//go:build !arm64 && !(amd64 && goexperiment.simd)

package matmul

import (
	"github.com/ajroetker/go-highway/hwy"
)

var PackedMicroKernel4x2Float16 func(packedA []hwy.Float16, packedB []hwy.Float16, output []hwy.Float16, outputStride int, outRowStart int, outColStart int, panelK int, lanes int)
var PackedMicroKernel4x2BFloat16 func(packedA []hwy.BFloat16, packedB []hwy.BFloat16, output []hwy.BFloat16, outputStride int, outRowStart int, outColStart int, panelK int, lanes int)
var PackedMicroKernel4x2Float32 func(packedA []float32, packedB []float32, output []float32, outputStride int, outRowStart int, outColStart int, panelK int, lanes int)
var PackedMicroKernel4x2Float64 func(packedA []float64, packedB []float64, output []float64, outputStride int, outRowStart int, outColStart int, panelK int, lanes int)
var ZeroSliceFloat16 func(s []hwy.Float16, n int)
var ZeroSliceBFloat16 func(s []hwy.BFloat16, n int)
var ZeroSliceFloat32 func(s []float32, n int)
var ZeroSliceFloat64 func(s []float64, n int)

// PackedMicroKernel4x2 computes a 4-row × 2-vector micro-tile for the V2 GEBP.
//
// This is the optimized inner kernel for V2, targeting mr=4 and nr=2*lanes.
// It uses 8 accumulator vectors (4 rows × 2 column vectors) that stay in
// registers across the entire K loop.
//
// The V2 kernel writes to a packed output buffer rather than directly to C,
// which eliminates bounds checking in the hot path.
//
// Includes 4x K-loop unrolling for better instruction-level parallelism.
//
// Parameters:
//   - packedA: Packed A micro-panel, size panelK * mr (K-first layout)
//   - packedB: Packed B micro-panel, size panelK * nr (K-first layout)
//   - output: Packed output buffer (not final C matrix)
//   - outputStride: Row stride in output buffer
//   - outRowStart: Starting row in output buffer
//   - outColStart: Starting column in output buffer
//   - panelK: K-dimension of the packed panels
//   - lanes: Vector width in elements (e.g., 8 for AVX2 float32)
//
// This function dispatches to the appropriate SIMD implementation at runtime.
func PackedMicroKernel4x2[T hwy.Floats](packedA []T, packedB []T, output []T, outputStride int, outRowStart int, outColStart int, panelK int, lanes int) {
	switch any(packedA).(type) {
	case []hwy.Float16:
		PackedMicroKernel4x2Float16(any(packedA).([]hwy.Float16), any(packedB).([]hwy.Float16), any(output).([]hwy.Float16), outputStride, outRowStart, outColStart, panelK, lanes)
	case []hwy.BFloat16:
		PackedMicroKernel4x2BFloat16(any(packedA).([]hwy.BFloat16), any(packedB).([]hwy.BFloat16), any(output).([]hwy.BFloat16), outputStride, outRowStart, outColStart, panelK, lanes)
	case []float32:
		PackedMicroKernel4x2Float32(any(packedA).([]float32), any(packedB).([]float32), any(output).([]float32), outputStride, outRowStart, outColStart, panelK, lanes)
	case []float64:
		PackedMicroKernel4x2Float64(any(packedA).([]float64), any(packedB).([]float64), any(output).([]float64), outputStride, outRowStart, outColStart, panelK, lanes)
	}
}

// ZeroSlice zeros a slice using SIMD.
//
// This is used to clear the packed output buffer before accumulating
// micro-kernel results.
//
// This function dispatches to the appropriate SIMD implementation at runtime.
func ZeroSlice[T hwy.Floats](s []T, n int) {
	switch any(s).(type) {
	case []hwy.Float16:
		ZeroSliceFloat16(any(s).([]hwy.Float16), n)
	case []hwy.BFloat16:
		ZeroSliceBFloat16(any(s).([]hwy.BFloat16), n)
	case []float32:
		ZeroSliceFloat32(any(s).([]float32), n)
	case []float64:
		ZeroSliceFloat64(any(s).([]float64), n)
	}
}

func init() {
	_ = hwy.NoSimdEnv // silence unused import
	initPacked_kernel_v2Fallback()
}

func initPacked_kernel_v2Fallback() {
	PackedMicroKernel4x2Float16 = BasePackedMicroKernel4x2_fallback_Float16
	PackedMicroKernel4x2BFloat16 = BasePackedMicroKernel4x2_fallback_BFloat16
	PackedMicroKernel4x2Float32 = BasePackedMicroKernel4x2_fallback
	PackedMicroKernel4x2Float64 = BasePackedMicroKernel4x2_fallback_Float64
	ZeroSliceFloat16 = BaseZeroSlice_fallback_Float16
	ZeroSliceBFloat16 = BaseZeroSlice_fallback_BFloat16
	ZeroSliceFloat32 = BaseZeroSlice_fallback
	ZeroSliceFloat64 = BaseZeroSlice_fallback_Float64
}
