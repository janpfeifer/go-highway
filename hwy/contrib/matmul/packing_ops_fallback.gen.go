// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

package matmul

import (
	"github.com/ajroetker/go-highway/hwy"
)

func BasePackRHSFast_fallback_Float16(b []hwy.Float16, packed []hwy.Float16, n int, rowStart int, colStart int, panelK int, panelCols int, nr int) {
	lanes := hwy.Zero[hwy.Float16]().NumLanes()
	dstIdx := 0
	for stripColIdx := 0; stripColIdx < panelCols; stripColIdx += nr {
		validCols := min(nr, panelCols-stripColIdx)
		baseCol := colStart + stripColIdx
		if validCols == nr && nr >= lanes && nr%lanes == 0 {
			for kk := range panelK {
				srcIdx := (rowStart+kk)*n + baseCol
				for c := 0; c < nr; c += lanes {
					v := hwy.Load(b[srcIdx+c:])
					hwy.Store(v, packed[dstIdx+c:])
				}
				dstIdx += nr
			}
			continue
		}
		for kk := range panelK {
			srcIdx := (rowStart+kk)*n + baseCol
			for c := range validCols {
				packed[dstIdx] = hwy.Float32ToFloat16(b[srcIdx+c].Float32())
				dstIdx++
			}
			for c := validCols; c < nr; c++ {
				packed[dstIdx] = hwy.Float32ToFloat16(0)
				dstIdx++
			}
		}
	}
}

func BasePackRHSFast_fallback_BFloat16(b []hwy.BFloat16, packed []hwy.BFloat16, n int, rowStart int, colStart int, panelK int, panelCols int, nr int) {
	lanes := hwy.Zero[hwy.BFloat16]().NumLanes()
	dstIdx := 0
	for stripColIdx := 0; stripColIdx < panelCols; stripColIdx += nr {
		validCols := min(nr, panelCols-stripColIdx)
		baseCol := colStart + stripColIdx
		if validCols == nr && nr >= lanes && nr%lanes == 0 {
			for kk := range panelK {
				srcIdx := (rowStart+kk)*n + baseCol
				for c := 0; c < nr; c += lanes {
					v := hwy.Load(b[srcIdx+c:])
					hwy.Store(v, packed[dstIdx+c:])
				}
				dstIdx += nr
			}
			continue
		}
		for kk := range panelK {
			srcIdx := (rowStart+kk)*n + baseCol
			for c := range validCols {
				packed[dstIdx] = hwy.Float32ToBFloat16(b[srcIdx+c].Float32())
				dstIdx++
			}
			for c := validCols; c < nr; c++ {
				packed[dstIdx] = hwy.Float32ToBFloat16(0)
				dstIdx++
			}
		}
	}
}

func BasePackRHSFast_fallback(b []float32, packed []float32, n int, rowStart int, colStart int, panelK int, panelCols int, nr int) {
	dstIdx := 0
	for stripColIdx := 0; stripColIdx < panelCols; stripColIdx += nr {
		validCols := min(nr, panelCols-stripColIdx)
		baseCol := colStart + stripColIdx
		if validCols == nr && nr >= 1 && nr%1 == 0 {
			for kk := range panelK {
				srcIdx := (rowStart+kk)*n + baseCol
				for c := 0; c < nr; c++ {
					v := b[srcIdx+c]
					packed[dstIdx+c] = v
				}
				dstIdx += nr
			}
			continue
		}
		for kk := range panelK {
			srcIdx := (rowStart+kk)*n + baseCol
			for c := range validCols {
				packed[dstIdx] = b[srcIdx+c]
				dstIdx++
			}
			for c := validCols; c < nr; c++ {
				packed[dstIdx] = 0
				dstIdx++
			}
		}
	}
}

func BasePackRHSFast_fallback_Float64(b []float64, packed []float64, n int, rowStart int, colStart int, panelK int, panelCols int, nr int) {
	dstIdx := 0
	for stripColIdx := 0; stripColIdx < panelCols; stripColIdx += nr {
		validCols := min(nr, panelCols-stripColIdx)
		baseCol := colStart + stripColIdx
		if validCols == nr && nr >= 1 && nr%1 == 0 {
			for kk := range panelK {
				srcIdx := (rowStart+kk)*n + baseCol
				for c := 0; c < nr; c++ {
					v := b[srcIdx+c]
					packed[dstIdx+c] = v
				}
				dstIdx += nr
			}
			continue
		}
		for kk := range panelK {
			srcIdx := (rowStart+kk)*n + baseCol
			for c := range validCols {
				packed[dstIdx] = b[srcIdx+c]
				dstIdx++
			}
			for c := validCols; c < nr; c++ {
				packed[dstIdx] = 0
				dstIdx++
			}
		}
	}
}

func BaseApplyPackedOutput_fallback_Float16(packedOutput []hwy.Float16, output []hwy.Float16, alpha hwy.Float16, beta hwy.Float16, packedStride int, outputRowOffset int, outputColOffset int, outputStride int, height int, width int) {
	lanes := hwy.Zero[hwy.Float16]().NumLanes()
	alphaVec := hwy.Set(alpha)
	betaVec := hwy.Set(beta)
	for r := range height {
		packedIdx := r * packedStride
		outputIdx := (outputRowOffset+r)*outputStride + outputColOffset
		c := 0
		for ; c+lanes <= width; c += lanes {
			packedVal := hwy.Load(packedOutput[packedIdx+c:])
			outputVal := hwy.Load(output[outputIdx+c:])
			scaledOutput := hwy.Mul(outputVal, betaVec)
			newVal := hwy.MulAdd(packedVal, alphaVec, scaledOutput)
			hwy.Store(newVal, output[outputIdx+c:])
		}
		for ; c < width; c++ {
			val := packedOutput[packedIdx+c]
			output[outputIdx+c] = hwy.Float32ToFloat16(beta.Float32()*output[outputIdx+c].Float32() + alpha.Float32()*val.Float32())
		}
	}
}

func BaseApplyPackedOutput_fallback_BFloat16(packedOutput []hwy.BFloat16, output []hwy.BFloat16, alpha hwy.BFloat16, beta hwy.BFloat16, packedStride int, outputRowOffset int, outputColOffset int, outputStride int, height int, width int) {
	lanes := hwy.Zero[hwy.BFloat16]().NumLanes()
	alphaVec := hwy.Set(alpha)
	betaVec := hwy.Set(beta)
	for r := range height {
		packedIdx := r * packedStride
		outputIdx := (outputRowOffset+r)*outputStride + outputColOffset
		c := 0
		for ; c+lanes <= width; c += lanes {
			packedVal := hwy.Load(packedOutput[packedIdx+c:])
			outputVal := hwy.Load(output[outputIdx+c:])
			scaledOutput := hwy.Mul(outputVal, betaVec)
			newVal := hwy.MulAdd(packedVal, alphaVec, scaledOutput)
			hwy.Store(newVal, output[outputIdx+c:])
		}
		for ; c < width; c++ {
			val := packedOutput[packedIdx+c]
			output[outputIdx+c] = hwy.Float32ToBFloat16(beta.Float32()*output[outputIdx+c].Float32() + alpha.Float32()*val.Float32())
		}
	}
}

func BaseApplyPackedOutput_fallback(packedOutput []float32, output []float32, alpha float32, beta float32, packedStride int, outputRowOffset int, outputColOffset int, outputStride int, height int, width int) {
	alphaVec := float32(alpha)
	betaVec := float32(beta)
	for r := range height {
		packedIdx := r * packedStride
		outputIdx := (outputRowOffset+r)*outputStride + outputColOffset
		c := 0
		for ; c < width; c++ {
			packedVal := packedOutput[packedIdx+c]
			outputVal := output[outputIdx+c]
			scaledOutput := outputVal * betaVec
			newVal := packedVal*alphaVec + scaledOutput
			output[outputIdx+c] = newVal
		}
		for ; c < width; c++ {
			val := packedOutput[packedIdx+c]
			output[outputIdx+c] = beta*output[outputIdx+c] + alpha*val
		}
	}
}

func BaseApplyPackedOutput_fallback_Float64(packedOutput []float64, output []float64, alpha float64, beta float64, packedStride int, outputRowOffset int, outputColOffset int, outputStride int, height int, width int) {
	alphaVec := float64(alpha)
	betaVec := float64(beta)
	for r := range height {
		packedIdx := r * packedStride
		outputIdx := (outputRowOffset+r)*outputStride + outputColOffset
		c := 0
		for ; c < width; c++ {
			packedVal := packedOutput[packedIdx+c]
			outputVal := output[outputIdx+c]
			scaledOutput := outputVal * betaVec
			newVal := packedVal*alphaVec + scaledOutput
			output[outputIdx+c] = newVal
		}
		for ; c < width; c++ {
			val := packedOutput[packedIdx+c]
			output[outputIdx+c] = beta*output[outputIdx+c] + alpha*val
		}
	}
}

func BaseApplyPackedOutputSimple_fallback_Float16(packedOutput []hwy.Float16, output []hwy.Float16, packedStride int, outputRowOffset int, outputColOffset int, outputStride int, height int, width int) {
	lanes := hwy.Zero[hwy.Float16]().NumLanes()
	for r := range height {
		packedIdx := r * packedStride
		outputIdx := (outputRowOffset+r)*outputStride + outputColOffset
		c := 0
		for ; c+lanes <= width; c += lanes {
			v := hwy.Load(packedOutput[packedIdx+c:])
			hwy.Store(v, output[outputIdx+c:])
		}
		for ; c < width; c++ {
			output[outputIdx+c] = hwy.Float32ToFloat16(packedOutput[packedIdx+c].Float32())
		}
	}
}

func BaseApplyPackedOutputSimple_fallback_BFloat16(packedOutput []hwy.BFloat16, output []hwy.BFloat16, packedStride int, outputRowOffset int, outputColOffset int, outputStride int, height int, width int) {
	lanes := hwy.Zero[hwy.BFloat16]().NumLanes()
	for r := range height {
		packedIdx := r * packedStride
		outputIdx := (outputRowOffset+r)*outputStride + outputColOffset
		c := 0
		for ; c+lanes <= width; c += lanes {
			v := hwy.Load(packedOutput[packedIdx+c:])
			hwy.Store(v, output[outputIdx+c:])
		}
		for ; c < width; c++ {
			output[outputIdx+c] = hwy.Float32ToBFloat16(packedOutput[packedIdx+c].Float32())
		}
	}
}

func BaseApplyPackedOutputSimple_fallback(packedOutput []float32, output []float32, packedStride int, outputRowOffset int, outputColOffset int, outputStride int, height int, width int) {
	for r := range height {
		packedIdx := r * packedStride
		outputIdx := (outputRowOffset+r)*outputStride + outputColOffset
		c := 0
		for ; c < width; c++ {
			v := packedOutput[packedIdx+c]
			output[outputIdx+c] = v
		}
		for ; c < width; c++ {
			output[outputIdx+c] = packedOutput[packedIdx+c]
		}
	}
}

func BaseApplyPackedOutputSimple_fallback_Float64(packedOutput []float64, output []float64, packedStride int, outputRowOffset int, outputColOffset int, outputStride int, height int, width int) {
	for r := range height {
		packedIdx := r * packedStride
		outputIdx := (outputRowOffset+r)*outputStride + outputColOffset
		c := 0
		for ; c < width; c++ {
			v := packedOutput[packedIdx+c]
			output[outputIdx+c] = v
		}
		for ; c < width; c++ {
			output[outputIdx+c] = packedOutput[packedIdx+c]
		}
	}
}

func BaseApplyPackedOutputAccum_fallback_Float16(packedOutput []hwy.Float16, output []hwy.Float16, packedStride int, outputRowOffset int, outputColOffset int, outputStride int, height int, width int) {
	lanes := hwy.Zero[hwy.Float16]().NumLanes()
	for r := range height {
		packedIdx := r * packedStride
		outputIdx := (outputRowOffset+r)*outputStride + outputColOffset
		c := 0
		for ; c+lanes <= width; c += lanes {
			packedVal := hwy.Load(packedOutput[packedIdx+c:])
			outputVal := hwy.Load(output[outputIdx+c:])
			newVal := hwy.Add(outputVal, packedVal)
			hwy.Store(newVal, output[outputIdx+c:])
		}
		for ; c < width; c++ {
			output[outputIdx+c] = hwy.Float32ToFloat16(output[outputIdx+c].Float32() + packedOutput[packedIdx+c].Float32())
		}
	}
}

func BaseApplyPackedOutputAccum_fallback_BFloat16(packedOutput []hwy.BFloat16, output []hwy.BFloat16, packedStride int, outputRowOffset int, outputColOffset int, outputStride int, height int, width int) {
	lanes := hwy.Zero[hwy.BFloat16]().NumLanes()
	for r := range height {
		packedIdx := r * packedStride
		outputIdx := (outputRowOffset+r)*outputStride + outputColOffset
		c := 0
		for ; c+lanes <= width; c += lanes {
			packedVal := hwy.Load(packedOutput[packedIdx+c:])
			outputVal := hwy.Load(output[outputIdx+c:])
			newVal := hwy.Add(outputVal, packedVal)
			hwy.Store(newVal, output[outputIdx+c:])
		}
		for ; c < width; c++ {
			output[outputIdx+c] = hwy.Float32ToBFloat16(output[outputIdx+c].Float32() + packedOutput[packedIdx+c].Float32())
		}
	}
}

func BaseApplyPackedOutputAccum_fallback(packedOutput []float32, output []float32, packedStride int, outputRowOffset int, outputColOffset int, outputStride int, height int, width int) {
	for r := range height {
		packedIdx := r * packedStride
		outputIdx := (outputRowOffset+r)*outputStride + outputColOffset
		c := 0
		for ; c < width; c++ {
			packedVal := packedOutput[packedIdx+c]
			outputVal := output[outputIdx+c]
			newVal := outputVal + packedVal
			output[outputIdx+c] = newVal
		}
		for ; c < width; c++ {
			output[outputIdx+c] += packedOutput[packedIdx+c]
		}
	}
}

func BaseApplyPackedOutputAccum_fallback_Float64(packedOutput []float64, output []float64, packedStride int, outputRowOffset int, outputColOffset int, outputStride int, height int, width int) {
	for r := range height {
		packedIdx := r * packedStride
		outputIdx := (outputRowOffset+r)*outputStride + outputColOffset
		c := 0
		for ; c < width; c++ {
			packedVal := packedOutput[packedIdx+c]
			outputVal := output[outputIdx+c]
			newVal := outputVal + packedVal
			output[outputIdx+c] = newVal
		}
		for ; c < width; c++ {
			output[outputIdx+c] += packedOutput[packedIdx+c]
		}
	}
}
