// Code generated by hwygen. DO NOT EDIT.

package matmul

import (
	"github.com/ajroetker/go-highway/hwy"
)

func BasePackedMicroKernel4x2_fallback_Float16(packedA []hwy.Float16, packedB []hwy.Float16, output []hwy.Float16, outputStride int, outRowStart int, outColStart int, panelK int, lanes int) {
	acc00 := hwy.Zero[hwy.Float16]()
	acc01 := hwy.Zero[hwy.Float16]()
	acc10 := hwy.Zero[hwy.Float16]()
	acc11 := hwy.Zero[hwy.Float16]()
	acc20 := hwy.Zero[hwy.Float16]()
	acc21 := hwy.Zero[hwy.Float16]()
	acc30 := hwy.Zero[hwy.Float16]()
	acc31 := hwy.Zero[hwy.Float16]()
	nr := 2 * lanes
	mr := 4
	aIdx := 0
	bIdx := 0
	_ = packedA[panelK*mr-1].Float32()
	_ = packedB[panelK*nr-1].Float32()
	p := 0
	for ; p+3 < panelK; p += 4 {
		bVec0_0 := hwy.Load(packedB[bIdx:])
		bVec1_0 := hwy.Load(packedB[bIdx+lanes:])
		a0_0 := hwy.Set(packedA[aIdx])
		a1_0 := hwy.Set(packedA[aIdx+1])
		a2_0 := hwy.Set(packedA[aIdx+2])
		a3_0 := hwy.Set(packedA[aIdx+3])
		acc00 = hwy.MulAdd(a0_0, bVec0_0, acc00)
		acc01 = hwy.MulAdd(a0_0, bVec1_0, acc01)
		acc10 = hwy.MulAdd(a1_0, bVec0_0, acc10)
		acc11 = hwy.MulAdd(a1_0, bVec1_0, acc11)
		acc20 = hwy.MulAdd(a2_0, bVec0_0, acc20)
		acc21 = hwy.MulAdd(a2_0, bVec1_0, acc21)
		acc30 = hwy.MulAdd(a3_0, bVec0_0, acc30)
		acc31 = hwy.MulAdd(a3_0, bVec1_0, acc31)
		bVec0_1 := hwy.Load(packedB[bIdx+nr:])
		bVec1_1 := hwy.Load(packedB[bIdx+nr+lanes:])
		a0_1 := hwy.Set(packedA[aIdx+mr])
		a1_1 := hwy.Set(packedA[aIdx+mr+1])
		a2_1 := hwy.Set(packedA[aIdx+mr+2])
		a3_1 := hwy.Set(packedA[aIdx+mr+3])
		acc00 = hwy.MulAdd(a0_1, bVec0_1, acc00)
		acc01 = hwy.MulAdd(a0_1, bVec1_1, acc01)
		acc10 = hwy.MulAdd(a1_1, bVec0_1, acc10)
		acc11 = hwy.MulAdd(a1_1, bVec1_1, acc11)
		acc20 = hwy.MulAdd(a2_1, bVec0_1, acc20)
		acc21 = hwy.MulAdd(a2_1, bVec1_1, acc21)
		acc30 = hwy.MulAdd(a3_1, bVec0_1, acc30)
		acc31 = hwy.MulAdd(a3_1, bVec1_1, acc31)
		bVec0_2 := hwy.Load(packedB[bIdx+2*nr:])
		bVec1_2 := hwy.Load(packedB[bIdx+2*nr+lanes:])
		a0_2 := hwy.Set(packedA[aIdx+2*mr])
		a1_2 := hwy.Set(packedA[aIdx+2*mr+1])
		a2_2 := hwy.Set(packedA[aIdx+2*mr+2])
		a3_2 := hwy.Set(packedA[aIdx+2*mr+3])
		acc00 = hwy.MulAdd(a0_2, bVec0_2, acc00)
		acc01 = hwy.MulAdd(a0_2, bVec1_2, acc01)
		acc10 = hwy.MulAdd(a1_2, bVec0_2, acc10)
		acc11 = hwy.MulAdd(a1_2, bVec1_2, acc11)
		acc20 = hwy.MulAdd(a2_2, bVec0_2, acc20)
		acc21 = hwy.MulAdd(a2_2, bVec1_2, acc21)
		acc30 = hwy.MulAdd(a3_2, bVec0_2, acc30)
		acc31 = hwy.MulAdd(a3_2, bVec1_2, acc31)
		bVec0_3 := hwy.Load(packedB[bIdx+3*nr:])
		bVec1_3 := hwy.Load(packedB[bIdx+3*nr+lanes:])
		a0_3 := hwy.Set(packedA[aIdx+3*mr])
		a1_3 := hwy.Set(packedA[aIdx+3*mr+1])
		a2_3 := hwy.Set(packedA[aIdx+3*mr+2])
		a3_3 := hwy.Set(packedA[aIdx+3*mr+3])
		acc00 = hwy.MulAdd(a0_3, bVec0_3, acc00)
		acc01 = hwy.MulAdd(a0_3, bVec1_3, acc01)
		acc10 = hwy.MulAdd(a1_3, bVec0_3, acc10)
		acc11 = hwy.MulAdd(a1_3, bVec1_3, acc11)
		acc20 = hwy.MulAdd(a2_3, bVec0_3, acc20)
		acc21 = hwy.MulAdd(a2_3, bVec1_3, acc21)
		acc30 = hwy.MulAdd(a3_3, bVec0_3, acc30)
		acc31 = hwy.MulAdd(a3_3, bVec1_3, acc31)
		aIdx += 4 * mr
		bIdx += 4 * nr
	}
	for ; p < panelK; p++ {
		bVec0 := hwy.Load(packedB[bIdx:])
		bVec1 := hwy.Load(packedB[bIdx+lanes:])
		bIdx += nr
		a0 := hwy.Set(packedA[aIdx])
		a1 := hwy.Set(packedA[aIdx+1])
		a2 := hwy.Set(packedA[aIdx+2])
		a3 := hwy.Set(packedA[aIdx+3])
		aIdx += mr
		acc00 = hwy.MulAdd(a0, bVec0, acc00)
		acc01 = hwy.MulAdd(a0, bVec1, acc01)
		acc10 = hwy.MulAdd(a1, bVec0, acc10)
		acc11 = hwy.MulAdd(a1, bVec1, acc11)
		acc20 = hwy.MulAdd(a2, bVec0, acc20)
		acc21 = hwy.MulAdd(a2, bVec1, acc21)
		acc30 = hwy.MulAdd(a3, bVec0, acc30)
		acc31 = hwy.MulAdd(a3, bVec1, acc31)
	}
	outIdx0 := outRowStart*outputStride + outColStart
	outIdx1 := outIdx0 + outputStride
	outIdx2 := outIdx1 + outputStride
	outIdx3 := outIdx2 + outputStride
	hwy.Store(acc00, output[outIdx0:])
	hwy.Store(acc01, output[outIdx0+lanes:])
	hwy.Store(acc10, output[outIdx1:])
	hwy.Store(acc11, output[outIdx1+lanes:])
	hwy.Store(acc20, output[outIdx2:])
	hwy.Store(acc21, output[outIdx2+lanes:])
	hwy.Store(acc30, output[outIdx3:])
	hwy.Store(acc31, output[outIdx3+lanes:])
}

func BasePackedMicroKernel4x2_fallback_BFloat16(packedA []hwy.BFloat16, packedB []hwy.BFloat16, output []hwy.BFloat16, outputStride int, outRowStart int, outColStart int, panelK int, lanes int) {
	acc00 := hwy.Zero[hwy.BFloat16]()
	acc01 := hwy.Zero[hwy.BFloat16]()
	acc10 := hwy.Zero[hwy.BFloat16]()
	acc11 := hwy.Zero[hwy.BFloat16]()
	acc20 := hwy.Zero[hwy.BFloat16]()
	acc21 := hwy.Zero[hwy.BFloat16]()
	acc30 := hwy.Zero[hwy.BFloat16]()
	acc31 := hwy.Zero[hwy.BFloat16]()
	nr := 2 * lanes
	mr := 4
	aIdx := 0
	bIdx := 0
	_ = packedA[panelK*mr-1].Float32()
	_ = packedB[panelK*nr-1].Float32()
	p := 0
	for ; p+3 < panelK; p += 4 {
		bVec0_0 := hwy.Load(packedB[bIdx:])
		bVec1_0 := hwy.Load(packedB[bIdx+lanes:])
		a0_0 := hwy.Set(packedA[aIdx])
		a1_0 := hwy.Set(packedA[aIdx+1])
		a2_0 := hwy.Set(packedA[aIdx+2])
		a3_0 := hwy.Set(packedA[aIdx+3])
		acc00 = hwy.MulAdd(a0_0, bVec0_0, acc00)
		acc01 = hwy.MulAdd(a0_0, bVec1_0, acc01)
		acc10 = hwy.MulAdd(a1_0, bVec0_0, acc10)
		acc11 = hwy.MulAdd(a1_0, bVec1_0, acc11)
		acc20 = hwy.MulAdd(a2_0, bVec0_0, acc20)
		acc21 = hwy.MulAdd(a2_0, bVec1_0, acc21)
		acc30 = hwy.MulAdd(a3_0, bVec0_0, acc30)
		acc31 = hwy.MulAdd(a3_0, bVec1_0, acc31)
		bVec0_1 := hwy.Load(packedB[bIdx+nr:])
		bVec1_1 := hwy.Load(packedB[bIdx+nr+lanes:])
		a0_1 := hwy.Set(packedA[aIdx+mr])
		a1_1 := hwy.Set(packedA[aIdx+mr+1])
		a2_1 := hwy.Set(packedA[aIdx+mr+2])
		a3_1 := hwy.Set(packedA[aIdx+mr+3])
		acc00 = hwy.MulAdd(a0_1, bVec0_1, acc00)
		acc01 = hwy.MulAdd(a0_1, bVec1_1, acc01)
		acc10 = hwy.MulAdd(a1_1, bVec0_1, acc10)
		acc11 = hwy.MulAdd(a1_1, bVec1_1, acc11)
		acc20 = hwy.MulAdd(a2_1, bVec0_1, acc20)
		acc21 = hwy.MulAdd(a2_1, bVec1_1, acc21)
		acc30 = hwy.MulAdd(a3_1, bVec0_1, acc30)
		acc31 = hwy.MulAdd(a3_1, bVec1_1, acc31)
		bVec0_2 := hwy.Load(packedB[bIdx+2*nr:])
		bVec1_2 := hwy.Load(packedB[bIdx+2*nr+lanes:])
		a0_2 := hwy.Set(packedA[aIdx+2*mr])
		a1_2 := hwy.Set(packedA[aIdx+2*mr+1])
		a2_2 := hwy.Set(packedA[aIdx+2*mr+2])
		a3_2 := hwy.Set(packedA[aIdx+2*mr+3])
		acc00 = hwy.MulAdd(a0_2, bVec0_2, acc00)
		acc01 = hwy.MulAdd(a0_2, bVec1_2, acc01)
		acc10 = hwy.MulAdd(a1_2, bVec0_2, acc10)
		acc11 = hwy.MulAdd(a1_2, bVec1_2, acc11)
		acc20 = hwy.MulAdd(a2_2, bVec0_2, acc20)
		acc21 = hwy.MulAdd(a2_2, bVec1_2, acc21)
		acc30 = hwy.MulAdd(a3_2, bVec0_2, acc30)
		acc31 = hwy.MulAdd(a3_2, bVec1_2, acc31)
		bVec0_3 := hwy.Load(packedB[bIdx+3*nr:])
		bVec1_3 := hwy.Load(packedB[bIdx+3*nr+lanes:])
		a0_3 := hwy.Set(packedA[aIdx+3*mr])
		a1_3 := hwy.Set(packedA[aIdx+3*mr+1])
		a2_3 := hwy.Set(packedA[aIdx+3*mr+2])
		a3_3 := hwy.Set(packedA[aIdx+3*mr+3])
		acc00 = hwy.MulAdd(a0_3, bVec0_3, acc00)
		acc01 = hwy.MulAdd(a0_3, bVec1_3, acc01)
		acc10 = hwy.MulAdd(a1_3, bVec0_3, acc10)
		acc11 = hwy.MulAdd(a1_3, bVec1_3, acc11)
		acc20 = hwy.MulAdd(a2_3, bVec0_3, acc20)
		acc21 = hwy.MulAdd(a2_3, bVec1_3, acc21)
		acc30 = hwy.MulAdd(a3_3, bVec0_3, acc30)
		acc31 = hwy.MulAdd(a3_3, bVec1_3, acc31)
		aIdx += 4 * mr
		bIdx += 4 * nr
	}
	for ; p < panelK; p++ {
		bVec0 := hwy.Load(packedB[bIdx:])
		bVec1 := hwy.Load(packedB[bIdx+lanes:])
		bIdx += nr
		a0 := hwy.Set(packedA[aIdx])
		a1 := hwy.Set(packedA[aIdx+1])
		a2 := hwy.Set(packedA[aIdx+2])
		a3 := hwy.Set(packedA[aIdx+3])
		aIdx += mr
		acc00 = hwy.MulAdd(a0, bVec0, acc00)
		acc01 = hwy.MulAdd(a0, bVec1, acc01)
		acc10 = hwy.MulAdd(a1, bVec0, acc10)
		acc11 = hwy.MulAdd(a1, bVec1, acc11)
		acc20 = hwy.MulAdd(a2, bVec0, acc20)
		acc21 = hwy.MulAdd(a2, bVec1, acc21)
		acc30 = hwy.MulAdd(a3, bVec0, acc30)
		acc31 = hwy.MulAdd(a3, bVec1, acc31)
	}
	outIdx0 := outRowStart*outputStride + outColStart
	outIdx1 := outIdx0 + outputStride
	outIdx2 := outIdx1 + outputStride
	outIdx3 := outIdx2 + outputStride
	hwy.Store(acc00, output[outIdx0:])
	hwy.Store(acc01, output[outIdx0+lanes:])
	hwy.Store(acc10, output[outIdx1:])
	hwy.Store(acc11, output[outIdx1+lanes:])
	hwy.Store(acc20, output[outIdx2:])
	hwy.Store(acc21, output[outIdx2+lanes:])
	hwy.Store(acc30, output[outIdx3:])
	hwy.Store(acc31, output[outIdx3+lanes:])
}

func BasePackedMicroKernel4x2_fallback(packedA []float32, packedB []float32, output []float32, outputStride int, outRowStart int, outColStart int, panelK int, lanes int) {
	acc00 := hwy.Zero[float32]()
	acc01 := hwy.Zero[float32]()
	acc10 := hwy.Zero[float32]()
	acc11 := hwy.Zero[float32]()
	acc20 := hwy.Zero[float32]()
	acc21 := hwy.Zero[float32]()
	acc30 := hwy.Zero[float32]()
	acc31 := hwy.Zero[float32]()
	nr := 2 * lanes
	mr := 4
	aIdx := 0
	bIdx := 0
	_ = packedA[panelK*mr-1]
	_ = packedB[panelK*nr-1]
	p := 0
	for ; p+3 < panelK; p += 4 {
		bVec0_0 := hwy.Load(packedB[bIdx:])
		bVec1_0 := hwy.Load(packedB[bIdx+lanes:])
		a0_0 := hwy.Set(packedA[aIdx])
		a1_0 := hwy.Set(packedA[aIdx+1])
		a2_0 := hwy.Set(packedA[aIdx+2])
		a3_0 := hwy.Set(packedA[aIdx+3])
		acc00 = hwy.MulAdd(a0_0, bVec0_0, acc00)
		acc01 = hwy.MulAdd(a0_0, bVec1_0, acc01)
		acc10 = hwy.MulAdd(a1_0, bVec0_0, acc10)
		acc11 = hwy.MulAdd(a1_0, bVec1_0, acc11)
		acc20 = hwy.MulAdd(a2_0, bVec0_0, acc20)
		acc21 = hwy.MulAdd(a2_0, bVec1_0, acc21)
		acc30 = hwy.MulAdd(a3_0, bVec0_0, acc30)
		acc31 = hwy.MulAdd(a3_0, bVec1_0, acc31)
		bVec0_1 := hwy.Load(packedB[bIdx+nr:])
		bVec1_1 := hwy.Load(packedB[bIdx+nr+lanes:])
		a0_1 := hwy.Set(packedA[aIdx+mr])
		a1_1 := hwy.Set(packedA[aIdx+mr+1])
		a2_1 := hwy.Set(packedA[aIdx+mr+2])
		a3_1 := hwy.Set(packedA[aIdx+mr+3])
		acc00 = hwy.MulAdd(a0_1, bVec0_1, acc00)
		acc01 = hwy.MulAdd(a0_1, bVec1_1, acc01)
		acc10 = hwy.MulAdd(a1_1, bVec0_1, acc10)
		acc11 = hwy.MulAdd(a1_1, bVec1_1, acc11)
		acc20 = hwy.MulAdd(a2_1, bVec0_1, acc20)
		acc21 = hwy.MulAdd(a2_1, bVec1_1, acc21)
		acc30 = hwy.MulAdd(a3_1, bVec0_1, acc30)
		acc31 = hwy.MulAdd(a3_1, bVec1_1, acc31)
		bVec0_2 := hwy.Load(packedB[bIdx+2*nr:])
		bVec1_2 := hwy.Load(packedB[bIdx+2*nr+lanes:])
		a0_2 := hwy.Set(packedA[aIdx+2*mr])
		a1_2 := hwy.Set(packedA[aIdx+2*mr+1])
		a2_2 := hwy.Set(packedA[aIdx+2*mr+2])
		a3_2 := hwy.Set(packedA[aIdx+2*mr+3])
		acc00 = hwy.MulAdd(a0_2, bVec0_2, acc00)
		acc01 = hwy.MulAdd(a0_2, bVec1_2, acc01)
		acc10 = hwy.MulAdd(a1_2, bVec0_2, acc10)
		acc11 = hwy.MulAdd(a1_2, bVec1_2, acc11)
		acc20 = hwy.MulAdd(a2_2, bVec0_2, acc20)
		acc21 = hwy.MulAdd(a2_2, bVec1_2, acc21)
		acc30 = hwy.MulAdd(a3_2, bVec0_2, acc30)
		acc31 = hwy.MulAdd(a3_2, bVec1_2, acc31)
		bVec0_3 := hwy.Load(packedB[bIdx+3*nr:])
		bVec1_3 := hwy.Load(packedB[bIdx+3*nr+lanes:])
		a0_3 := hwy.Set(packedA[aIdx+3*mr])
		a1_3 := hwy.Set(packedA[aIdx+3*mr+1])
		a2_3 := hwy.Set(packedA[aIdx+3*mr+2])
		a3_3 := hwy.Set(packedA[aIdx+3*mr+3])
		acc00 = hwy.MulAdd(a0_3, bVec0_3, acc00)
		acc01 = hwy.MulAdd(a0_3, bVec1_3, acc01)
		acc10 = hwy.MulAdd(a1_3, bVec0_3, acc10)
		acc11 = hwy.MulAdd(a1_3, bVec1_3, acc11)
		acc20 = hwy.MulAdd(a2_3, bVec0_3, acc20)
		acc21 = hwy.MulAdd(a2_3, bVec1_3, acc21)
		acc30 = hwy.MulAdd(a3_3, bVec0_3, acc30)
		acc31 = hwy.MulAdd(a3_3, bVec1_3, acc31)
		aIdx += 4 * mr
		bIdx += 4 * nr
	}
	for ; p < panelK; p++ {
		bVec0 := hwy.Load(packedB[bIdx:])
		bVec1 := hwy.Load(packedB[bIdx+lanes:])
		bIdx += nr
		a0 := hwy.Set(packedA[aIdx])
		a1 := hwy.Set(packedA[aIdx+1])
		a2 := hwy.Set(packedA[aIdx+2])
		a3 := hwy.Set(packedA[aIdx+3])
		aIdx += mr
		acc00 = hwy.MulAdd(a0, bVec0, acc00)
		acc01 = hwy.MulAdd(a0, bVec1, acc01)
		acc10 = hwy.MulAdd(a1, bVec0, acc10)
		acc11 = hwy.MulAdd(a1, bVec1, acc11)
		acc20 = hwy.MulAdd(a2, bVec0, acc20)
		acc21 = hwy.MulAdd(a2, bVec1, acc21)
		acc30 = hwy.MulAdd(a3, bVec0, acc30)
		acc31 = hwy.MulAdd(a3, bVec1, acc31)
	}
	outIdx0 := outRowStart*outputStride + outColStart
	outIdx1 := outIdx0 + outputStride
	outIdx2 := outIdx1 + outputStride
	outIdx3 := outIdx2 + outputStride
	hwy.Store(acc00, output[outIdx0:])
	hwy.Store(acc01, output[outIdx0+lanes:])
	hwy.Store(acc10, output[outIdx1:])
	hwy.Store(acc11, output[outIdx1+lanes:])
	hwy.Store(acc20, output[outIdx2:])
	hwy.Store(acc21, output[outIdx2+lanes:])
	hwy.Store(acc30, output[outIdx3:])
	hwy.Store(acc31, output[outIdx3+lanes:])
}

func BasePackedMicroKernel4x2_fallback_Float64(packedA []float64, packedB []float64, output []float64, outputStride int, outRowStart int, outColStart int, panelK int, lanes int) {
	acc00 := hwy.Zero[float64]()
	acc01 := hwy.Zero[float64]()
	acc10 := hwy.Zero[float64]()
	acc11 := hwy.Zero[float64]()
	acc20 := hwy.Zero[float64]()
	acc21 := hwy.Zero[float64]()
	acc30 := hwy.Zero[float64]()
	acc31 := hwy.Zero[float64]()
	nr := 2 * lanes
	mr := 4
	aIdx := 0
	bIdx := 0
	_ = packedA[panelK*mr-1]
	_ = packedB[panelK*nr-1]
	p := 0
	for ; p+3 < panelK; p += 4 {
		bVec0_0 := hwy.Load(packedB[bIdx:])
		bVec1_0 := hwy.Load(packedB[bIdx+lanes:])
		a0_0 := hwy.Set(packedA[aIdx])
		a1_0 := hwy.Set(packedA[aIdx+1])
		a2_0 := hwy.Set(packedA[aIdx+2])
		a3_0 := hwy.Set(packedA[aIdx+3])
		acc00 = hwy.MulAdd(a0_0, bVec0_0, acc00)
		acc01 = hwy.MulAdd(a0_0, bVec1_0, acc01)
		acc10 = hwy.MulAdd(a1_0, bVec0_0, acc10)
		acc11 = hwy.MulAdd(a1_0, bVec1_0, acc11)
		acc20 = hwy.MulAdd(a2_0, bVec0_0, acc20)
		acc21 = hwy.MulAdd(a2_0, bVec1_0, acc21)
		acc30 = hwy.MulAdd(a3_0, bVec0_0, acc30)
		acc31 = hwy.MulAdd(a3_0, bVec1_0, acc31)
		bVec0_1 := hwy.Load(packedB[bIdx+nr:])
		bVec1_1 := hwy.Load(packedB[bIdx+nr+lanes:])
		a0_1 := hwy.Set(packedA[aIdx+mr])
		a1_1 := hwy.Set(packedA[aIdx+mr+1])
		a2_1 := hwy.Set(packedA[aIdx+mr+2])
		a3_1 := hwy.Set(packedA[aIdx+mr+3])
		acc00 = hwy.MulAdd(a0_1, bVec0_1, acc00)
		acc01 = hwy.MulAdd(a0_1, bVec1_1, acc01)
		acc10 = hwy.MulAdd(a1_1, bVec0_1, acc10)
		acc11 = hwy.MulAdd(a1_1, bVec1_1, acc11)
		acc20 = hwy.MulAdd(a2_1, bVec0_1, acc20)
		acc21 = hwy.MulAdd(a2_1, bVec1_1, acc21)
		acc30 = hwy.MulAdd(a3_1, bVec0_1, acc30)
		acc31 = hwy.MulAdd(a3_1, bVec1_1, acc31)
		bVec0_2 := hwy.Load(packedB[bIdx+2*nr:])
		bVec1_2 := hwy.Load(packedB[bIdx+2*nr+lanes:])
		a0_2 := hwy.Set(packedA[aIdx+2*mr])
		a1_2 := hwy.Set(packedA[aIdx+2*mr+1])
		a2_2 := hwy.Set(packedA[aIdx+2*mr+2])
		a3_2 := hwy.Set(packedA[aIdx+2*mr+3])
		acc00 = hwy.MulAdd(a0_2, bVec0_2, acc00)
		acc01 = hwy.MulAdd(a0_2, bVec1_2, acc01)
		acc10 = hwy.MulAdd(a1_2, bVec0_2, acc10)
		acc11 = hwy.MulAdd(a1_2, bVec1_2, acc11)
		acc20 = hwy.MulAdd(a2_2, bVec0_2, acc20)
		acc21 = hwy.MulAdd(a2_2, bVec1_2, acc21)
		acc30 = hwy.MulAdd(a3_2, bVec0_2, acc30)
		acc31 = hwy.MulAdd(a3_2, bVec1_2, acc31)
		bVec0_3 := hwy.Load(packedB[bIdx+3*nr:])
		bVec1_3 := hwy.Load(packedB[bIdx+3*nr+lanes:])
		a0_3 := hwy.Set(packedA[aIdx+3*mr])
		a1_3 := hwy.Set(packedA[aIdx+3*mr+1])
		a2_3 := hwy.Set(packedA[aIdx+3*mr+2])
		a3_3 := hwy.Set(packedA[aIdx+3*mr+3])
		acc00 = hwy.MulAdd(a0_3, bVec0_3, acc00)
		acc01 = hwy.MulAdd(a0_3, bVec1_3, acc01)
		acc10 = hwy.MulAdd(a1_3, bVec0_3, acc10)
		acc11 = hwy.MulAdd(a1_3, bVec1_3, acc11)
		acc20 = hwy.MulAdd(a2_3, bVec0_3, acc20)
		acc21 = hwy.MulAdd(a2_3, bVec1_3, acc21)
		acc30 = hwy.MulAdd(a3_3, bVec0_3, acc30)
		acc31 = hwy.MulAdd(a3_3, bVec1_3, acc31)
		aIdx += 4 * mr
		bIdx += 4 * nr
	}
	for ; p < panelK; p++ {
		bVec0 := hwy.Load(packedB[bIdx:])
		bVec1 := hwy.Load(packedB[bIdx+lanes:])
		bIdx += nr
		a0 := hwy.Set(packedA[aIdx])
		a1 := hwy.Set(packedA[aIdx+1])
		a2 := hwy.Set(packedA[aIdx+2])
		a3 := hwy.Set(packedA[aIdx+3])
		aIdx += mr
		acc00 = hwy.MulAdd(a0, bVec0, acc00)
		acc01 = hwy.MulAdd(a0, bVec1, acc01)
		acc10 = hwy.MulAdd(a1, bVec0, acc10)
		acc11 = hwy.MulAdd(a1, bVec1, acc11)
		acc20 = hwy.MulAdd(a2, bVec0, acc20)
		acc21 = hwy.MulAdd(a2, bVec1, acc21)
		acc30 = hwy.MulAdd(a3, bVec0, acc30)
		acc31 = hwy.MulAdd(a3, bVec1, acc31)
	}
	outIdx0 := outRowStart*outputStride + outColStart
	outIdx1 := outIdx0 + outputStride
	outIdx2 := outIdx1 + outputStride
	outIdx3 := outIdx2 + outputStride
	hwy.Store(acc00, output[outIdx0:])
	hwy.Store(acc01, output[outIdx0+lanes:])
	hwy.Store(acc10, output[outIdx1:])
	hwy.Store(acc11, output[outIdx1+lanes:])
	hwy.Store(acc20, output[outIdx2:])
	hwy.Store(acc21, output[outIdx2+lanes:])
	hwy.Store(acc30, output[outIdx3:])
	hwy.Store(acc31, output[outIdx3+lanes:])
}

func BaseZeroSlice_fallback_Float16(s []hwy.Float16, n int) {
	vZero := hwy.Zero[hwy.Float16]()
	lanes := vZero.NumLanes()
	var idx int
	for idx = 0; idx+lanes <= n; idx += lanes {
		hwy.Store(vZero, s[idx:])
	}
	for ; idx < n; idx++ {
		s[idx] = hwy.Float32ToFloat16(0)
	}
}

func BaseZeroSlice_fallback_BFloat16(s []hwy.BFloat16, n int) {
	vZero := hwy.Zero[hwy.BFloat16]()
	lanes := vZero.NumLanes()
	var idx int
	for idx = 0; idx+lanes <= n; idx += lanes {
		hwy.Store(vZero, s[idx:])
	}
	for ; idx < n; idx++ {
		s[idx] = hwy.Float32ToBFloat16(0)
	}
}

func BaseZeroSlice_fallback(s []float32, n int) {
	vZero := hwy.Zero[float32]()
	lanes := vZero.NumLanes()
	var idx int
	for idx = 0; idx+lanes <= n; idx += lanes {
		hwy.Store(vZero, s[idx:])
	}
	for ; idx < n; idx++ {
		s[idx] = 0
	}
}

func BaseZeroSlice_fallback_Float64(s []float64, n int) {
	vZero := hwy.Zero[float64]()
	lanes := vZero.NumLanes()
	var idx int
	for idx = 0; idx+lanes <= n; idx += lanes {
		hwy.Store(vZero, s[idx:])
	}
	for ; idx < n; idx++ {
		s[idx] = 0
	}
}
