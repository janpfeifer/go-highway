// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

//go:build amd64 && goexperiment.simd

package matmul

import (
	"github.com/ajroetker/go-highway/hwy"
)

func BaseTranspose2D_avx2_Float16(src []hwy.Float16, m int, k int, dst []hwy.Float16) {
	if len(src) < m*k || len(dst) < k*m {
		return
	}
	lanes := 16
	i := 0
	for ; i <= m-lanes; i += lanes * 4 {
		for j := 0; j <= k-lanes; j += lanes {
			transposeBlockSIMD(src, dst, i, j, m, k, lanes)
		}
		for j1 := 0; j1 <= k-lanes; j1 += lanes {
			transposeBlockSIMD(src, dst, i, j1, m, k, lanes)
		}
		for j2 := 0; j2 <= k-lanes; j2 += lanes {
			transposeBlockSIMD(src, dst, i, j2, m, k, lanes)
		}
		for j3 := 0; j3 <= k-lanes; j3 += lanes {
			transposeBlockSIMD(src, dst, i, j3, m, k, lanes)
		}
	}
	for ; i <= m-lanes; i += lanes {
		for j := 0; j <= k-lanes; j += lanes {
			transposeBlockSIMD(src, dst, i, j, m, k, lanes)
		}
	}
	transposeEdgesScalar(src, m, k, dst, lanes)
}

func BaseTranspose2D_avx2_BFloat16(src []hwy.BFloat16, m int, k int, dst []hwy.BFloat16) {
	if len(src) < m*k || len(dst) < k*m {
		return
	}
	lanes := 16
	i := 0
	for ; i <= m-lanes; i += lanes * 4 {
		for j := 0; j <= k-lanes; j += lanes {
			transposeBlockSIMD(src, dst, i, j, m, k, lanes)
		}
		for j1 := 0; j1 <= k-lanes; j1 += lanes {
			transposeBlockSIMD(src, dst, i, j1, m, k, lanes)
		}
		for j2 := 0; j2 <= k-lanes; j2 += lanes {
			transposeBlockSIMD(src, dst, i, j2, m, k, lanes)
		}
		for j3 := 0; j3 <= k-lanes; j3 += lanes {
			transposeBlockSIMD(src, dst, i, j3, m, k, lanes)
		}
	}
	for ; i <= m-lanes; i += lanes {
		for j := 0; j <= k-lanes; j += lanes {
			transposeBlockSIMD(src, dst, i, j, m, k, lanes)
		}
	}
	transposeEdgesScalar(src, m, k, dst, lanes)
}

func BaseTranspose2D_avx2(src []float32, m int, k int, dst []float32) {
	if len(src) < m*k || len(dst) < k*m {
		return
	}
	lanes := 8
	i := 0
	for ; i <= m-lanes; i += lanes * 4 {
		for j := 0; j <= k-lanes; j += lanes {
			transposeBlockSIMD(src, dst, i, j, m, k, lanes)
		}
		for j1 := 0; j1 <= k-lanes; j1 += lanes {
			transposeBlockSIMD(src, dst, i, j1, m, k, lanes)
		}
		for j2 := 0; j2 <= k-lanes; j2 += lanes {
			transposeBlockSIMD(src, dst, i, j2, m, k, lanes)
		}
		for j3 := 0; j3 <= k-lanes; j3 += lanes {
			transposeBlockSIMD(src, dst, i, j3, m, k, lanes)
		}
	}
	for ; i <= m-lanes; i += lanes {
		for j := 0; j <= k-lanes; j += lanes {
			transposeBlockSIMD(src, dst, i, j, m, k, lanes)
		}
	}
	transposeEdgesScalar(src, m, k, dst, lanes)
}

func BaseTranspose2D_avx2_Float64(src []float64, m int, k int, dst []float64) {
	if len(src) < m*k || len(dst) < k*m {
		return
	}
	lanes := 4
	i := 0
	for ; i <= m-lanes; i += lanes * 4 {
		for j := 0; j <= k-lanes; j += lanes {
			transposeBlockSIMD(src, dst, i, j, m, k, lanes)
		}
		for j1 := 0; j1 <= k-lanes; j1 += lanes {
			transposeBlockSIMD(src, dst, i, j1, m, k, lanes)
		}
		for j2 := 0; j2 <= k-lanes; j2 += lanes {
			transposeBlockSIMD(src, dst, i, j2, m, k, lanes)
		}
		for j3 := 0; j3 <= k-lanes; j3 += lanes {
			transposeBlockSIMD(src, dst, i, j3, m, k, lanes)
		}
	}
	for ; i <= m-lanes; i += lanes {
		for j := 0; j <= k-lanes; j += lanes {
			transposeBlockSIMD(src, dst, i, j, m, k, lanes)
		}
	}
	transposeEdgesScalar(src, m, k, dst, lanes)
}
