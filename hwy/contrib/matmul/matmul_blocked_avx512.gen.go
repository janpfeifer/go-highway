// Code generated by hwygen. DO NOT EDIT.
//go:build amd64 && goexperiment.simd

package matmul

import (
	"github.com/ajroetker/go-highway/hwy"
	"simd/archsimd"
)

func BaseBlockedMatMul_avx512_Float16(a []hwy.Float16, b []hwy.Float16, c []hwy.Float16, m int, n int, k int) {
	if len(a) < m*k {
		panic("matmul: A slice too short")
	}
	if len(b) < k*n {
		panic("matmul: B slice too short")
	}
	if len(c) < m*n {
		panic("matmul: C slice too short")
	}
	vZero := hwy.Zero[hwy.Float16]()
	lanes := 32
	total := m * n
	var idx int
	for idx = 0; idx+lanes <= total; idx += lanes {
		hwy.Store(vZero, c[idx:])
	}
	for ; idx < total; idx++ {
		c[idx] = hwy.Float32ToFloat16(0)
	}
	mr := 4
	nr := lanes * 2
	for i0 := 0; i0 < m; i0 += BlockSize {
		iEnd := min(i0+BlockSize, m)
		for j0 := 0; j0 < n; j0 += BlockSize {
			jEnd := min(j0+BlockSize, n)
			var i int
			for i = i0; i+mr <= iEnd; i += mr {
				var j int
				for j = j0; j+nr <= jEnd; j += nr {
					acc00 := hwy.Zero[hwy.Float16]()
					acc01 := hwy.Zero[hwy.Float16]()
					acc10 := hwy.Zero[hwy.Float16]()
					acc11 := hwy.Zero[hwy.Float16]()
					acc20 := hwy.Zero[hwy.Float16]()
					acc21 := hwy.Zero[hwy.Float16]()
					acc30 := hwy.Zero[hwy.Float16]()
					acc31 := hwy.Zero[hwy.Float16]()
					for p := 0; p < k; p++ {
						a0p := a[i*k+p]
						a1p := a[(i+1)*k+p]
						a2p := a[(i+2)*k+p]
						a3p := a[(i+3)*k+p]
						vA0 := hwy.Set(a0p)
						vA1 := hwy.Set(a1p)
						vA2 := hwy.Set(a2p)
						vA3 := hwy.Set(a3p)
						bRowStart := p * n
						vB0 := hwy.Load(b[bRowStart+j:])
						vB1 := hwy.Load(b[bRowStart+j+lanes:])
						acc00 = hwy.FMAF16(vA0, vB0, acc00)
						acc01 = hwy.FMAF16(vA0, vB1, acc01)
						acc10 = hwy.FMAF16(vA1, vB0, acc10)
						acc11 = hwy.FMAF16(vA1, vB1, acc11)
						acc20 = hwy.FMAF16(vA2, vB0, acc20)
						acc21 = hwy.FMAF16(vA2, vB1, acc21)
						acc30 = hwy.FMAF16(vA3, vB0, acc30)
						acc31 = hwy.FMAF16(vA3, vB1, acc31)
					}
					cRow0 := i * n
					cRow1 := (i + 1) * n
					cRow2 := (i + 2) * n
					cRow3 := (i + 3) * n
					hwy.Store(acc00, c[cRow0+j:])
					hwy.Store(acc01, c[cRow0+j+lanes:])
					hwy.Store(acc10, c[cRow1+j:])
					hwy.Store(acc11, c[cRow1+j+lanes:])
					hwy.Store(acc20, c[cRow2+j:])
					hwy.Store(acc21, c[cRow2+j+lanes:])
					hwy.Store(acc30, c[cRow3+j:])
					hwy.Store(acc31, c[cRow3+j+lanes:])
				}
				for ; j < jEnd; j += lanes {
					remaining := jEnd - j
					if remaining >= lanes {
						acc0 := hwy.Zero[hwy.Float16]()
						acc1 := hwy.Zero[hwy.Float16]()
						acc2 := hwy.Zero[hwy.Float16]()
						acc3 := hwy.Zero[hwy.Float16]()
						for p := 0; p < k; p++ {
							vA0 := hwy.Set(a[i*k+p])
							vA1 := hwy.Set(a[(i+1)*k+p])
							vA2 := hwy.Set(a[(i+2)*k+p])
							vA3 := hwy.Set(a[(i+3)*k+p])
							vB := hwy.Load(b[p*n+j:])
							acc0 = hwy.FMAF16(vA0, vB, acc0)
							acc1 = hwy.FMAF16(vA1, vB, acc1)
							acc2 = hwy.FMAF16(vA2, vB, acc2)
							acc3 = hwy.FMAF16(vA3, vB, acc3)
						}
						hwy.Store(acc0, c[i*n+j:])
						hwy.Store(acc1, c[(i+1)*n+j:])
						hwy.Store(acc2, c[(i+2)*n+j:])
						hwy.Store(acc3, c[(i+3)*n+j:])
					} else {
						for jj := j; jj < jEnd; jj++ {
							var sum0, sum1, sum2, sum3 float32
							for p := 0; p < k; p++ {
								bpj := b[p*n+jj]
								sum0 += a[i*k+p].Float32() * bpj.Float32()
								sum1 += a[(i+1)*k+p].Float32() * bpj.Float32()
								sum2 += a[(i+2)*k+p].Float32() * bpj.Float32()
								sum3 += a[(i+3)*k+p].Float32() * bpj.Float32()
							}
							c[i*n+jj] = hwy.Float32ToFloat16(sum0)
							c[(i+1)*n+jj] = hwy.Float32ToFloat16(sum1)
							c[(i+2)*n+jj] = hwy.Float32ToFloat16(sum2)
							c[(i+3)*n+jj] = hwy.Float32ToFloat16(sum3)
						}
						break
					}
				}
			}
			for ; i < iEnd; i++ {
				cRowStart := i * n
				var j int
				for j = j0; j+lanes <= jEnd; j += lanes {
					acc := hwy.Zero[hwy.Float16]()
					for p := 0; p < k; p++ {
						vA := hwy.Set(a[i*k+p])
						vB := hwy.Load(b[p*n+j:])
						acc = hwy.FMAF16(vA, vB, acc)
					}
					hwy.Store(acc, c[cRowStart+j:])
				}
				for ; j < jEnd; j++ {
					var sum float32
					for p := 0; p < k; p++ {
						sum += a[i*k+p].Float32() * b[p*n+j].Float32()
					}
					c[cRowStart+j] = hwy.Float32ToFloat16(sum)
				}
			}
		}
	}
}

func BaseBlockedMatMul_avx512_BFloat16(a []hwy.BFloat16, b []hwy.BFloat16, c []hwy.BFloat16, m int, n int, k int) {
	if len(a) < m*k {
		panic("matmul: A slice too short")
	}
	if len(b) < k*n {
		panic("matmul: B slice too short")
	}
	if len(c) < m*n {
		panic("matmul: C slice too short")
	}
	vZero := hwy.Zero[hwy.BFloat16]()
	lanes := 32
	total := m * n
	var idx int
	for idx = 0; idx+lanes <= total; idx += lanes {
		hwy.Store(vZero, c[idx:])
	}
	for ; idx < total; idx++ {
		c[idx] = hwy.Float32ToBFloat16(0)
	}
	mr := 4
	nr := lanes * 2
	for i0 := 0; i0 < m; i0 += BlockSize {
		iEnd := min(i0+BlockSize, m)
		for j0 := 0; j0 < n; j0 += BlockSize {
			jEnd := min(j0+BlockSize, n)
			var i int
			for i = i0; i+mr <= iEnd; i += mr {
				var j int
				for j = j0; j+nr <= jEnd; j += nr {
					acc00 := hwy.Zero[hwy.BFloat16]()
					acc01 := hwy.Zero[hwy.BFloat16]()
					acc10 := hwy.Zero[hwy.BFloat16]()
					acc11 := hwy.Zero[hwy.BFloat16]()
					acc20 := hwy.Zero[hwy.BFloat16]()
					acc21 := hwy.Zero[hwy.BFloat16]()
					acc30 := hwy.Zero[hwy.BFloat16]()
					acc31 := hwy.Zero[hwy.BFloat16]()
					for p := 0; p < k; p++ {
						a0p := a[i*k+p]
						a1p := a[(i+1)*k+p]
						a2p := a[(i+2)*k+p]
						a3p := a[(i+3)*k+p]
						vA0 := hwy.Set(a0p)
						vA1 := hwy.Set(a1p)
						vA2 := hwy.Set(a2p)
						vA3 := hwy.Set(a3p)
						bRowStart := p * n
						vB0 := hwy.Load(b[bRowStart+j:])
						vB1 := hwy.Load(b[bRowStart+j+lanes:])
						acc00 = hwy.FMABF16(vA0, vB0, acc00)
						acc01 = hwy.FMABF16(vA0, vB1, acc01)
						acc10 = hwy.FMABF16(vA1, vB0, acc10)
						acc11 = hwy.FMABF16(vA1, vB1, acc11)
						acc20 = hwy.FMABF16(vA2, vB0, acc20)
						acc21 = hwy.FMABF16(vA2, vB1, acc21)
						acc30 = hwy.FMABF16(vA3, vB0, acc30)
						acc31 = hwy.FMABF16(vA3, vB1, acc31)
					}
					cRow0 := i * n
					cRow1 := (i + 1) * n
					cRow2 := (i + 2) * n
					cRow3 := (i + 3) * n
					hwy.Store(acc00, c[cRow0+j:])
					hwy.Store(acc01, c[cRow0+j+lanes:])
					hwy.Store(acc10, c[cRow1+j:])
					hwy.Store(acc11, c[cRow1+j+lanes:])
					hwy.Store(acc20, c[cRow2+j:])
					hwy.Store(acc21, c[cRow2+j+lanes:])
					hwy.Store(acc30, c[cRow3+j:])
					hwy.Store(acc31, c[cRow3+j+lanes:])
				}
				for ; j < jEnd; j += lanes {
					remaining := jEnd - j
					if remaining >= lanes {
						acc0 := hwy.Zero[hwy.BFloat16]()
						acc1 := hwy.Zero[hwy.BFloat16]()
						acc2 := hwy.Zero[hwy.BFloat16]()
						acc3 := hwy.Zero[hwy.BFloat16]()
						for p := 0; p < k; p++ {
							vA0 := hwy.Set(a[i*k+p])
							vA1 := hwy.Set(a[(i+1)*k+p])
							vA2 := hwy.Set(a[(i+2)*k+p])
							vA3 := hwy.Set(a[(i+3)*k+p])
							vB := hwy.Load(b[p*n+j:])
							acc0 = hwy.FMABF16(vA0, vB, acc0)
							acc1 = hwy.FMABF16(vA1, vB, acc1)
							acc2 = hwy.FMABF16(vA2, vB, acc2)
							acc3 = hwy.FMABF16(vA3, vB, acc3)
						}
						hwy.Store(acc0, c[i*n+j:])
						hwy.Store(acc1, c[(i+1)*n+j:])
						hwy.Store(acc2, c[(i+2)*n+j:])
						hwy.Store(acc3, c[(i+3)*n+j:])
					} else {
						for jj := j; jj < jEnd; jj++ {
							var sum0, sum1, sum2, sum3 float32
							for p := 0; p < k; p++ {
								bpj := b[p*n+jj]
								sum0 += a[i*k+p].Float32() * bpj.Float32()
								sum1 += a[(i+1)*k+p].Float32() * bpj.Float32()
								sum2 += a[(i+2)*k+p].Float32() * bpj.Float32()
								sum3 += a[(i+3)*k+p].Float32() * bpj.Float32()
							}
							c[i*n+jj] = hwy.Float32ToBFloat16(sum0)
							c[(i+1)*n+jj] = hwy.Float32ToBFloat16(sum1)
							c[(i+2)*n+jj] = hwy.Float32ToBFloat16(sum2)
							c[(i+3)*n+jj] = hwy.Float32ToBFloat16(sum3)
						}
						break
					}
				}
			}
			for ; i < iEnd; i++ {
				cRowStart := i * n
				var j int
				for j = j0; j+lanes <= jEnd; j += lanes {
					acc := hwy.Zero[hwy.BFloat16]()
					for p := 0; p < k; p++ {
						vA := hwy.Set(a[i*k+p])
						vB := hwy.Load(b[p*n+j:])
						acc = hwy.FMABF16(vA, vB, acc)
					}
					hwy.Store(acc, c[cRowStart+j:])
				}
				for ; j < jEnd; j++ {
					var sum float32
					for p := 0; p < k; p++ {
						sum += a[i*k+p].Float32() * b[p*n+j].Float32()
					}
					c[cRowStart+j] = hwy.Float32ToBFloat16(sum)
				}
			}
		}
	}
}

func BaseBlockedMatMul_avx512(a []float32, b []float32, c []float32, m int, n int, k int) {
	if len(a) < m*k {
		panic("matmul: A slice too short")
	}
	if len(b) < k*n {
		panic("matmul: B slice too short")
	}
	if len(c) < m*n {
		panic("matmul: C slice too short")
	}
	vZero := archsimd.BroadcastFloat32x16(0)
	lanes := 16
	total := m * n
	var idx int
	for idx = 0; idx+lanes <= total; idx += lanes {
		vZero.StoreSlice(c[idx:])
	}
	for ; idx < total; idx++ {
		c[idx] = 0
	}
	mr := 4
	nr := lanes * 2
	for i0 := 0; i0 < m; i0 += BlockSize {
		iEnd := min(i0+BlockSize, m)
		for j0 := 0; j0 < n; j0 += BlockSize {
			jEnd := min(j0+BlockSize, n)
			var i int
			for i = i0; i+mr <= iEnd; i += mr {
				var j int
				for j = j0; j+nr <= jEnd; j += nr {
					acc00 := archsimd.BroadcastFloat32x16(0)
					acc01 := archsimd.BroadcastFloat32x16(0)
					acc10 := archsimd.BroadcastFloat32x16(0)
					acc11 := archsimd.BroadcastFloat32x16(0)
					acc20 := archsimd.BroadcastFloat32x16(0)
					acc21 := archsimd.BroadcastFloat32x16(0)
					acc30 := archsimd.BroadcastFloat32x16(0)
					acc31 := archsimd.BroadcastFloat32x16(0)
					for p := 0; p < k; p++ {
						a0p := a[i*k+p]
						a1p := a[(i+1)*k+p]
						a2p := a[(i+2)*k+p]
						a3p := a[(i+3)*k+p]
						vA0 := archsimd.BroadcastFloat32x16(a0p)
						vA1 := archsimd.BroadcastFloat32x16(a1p)
						vA2 := archsimd.BroadcastFloat32x16(a2p)
						vA3 := archsimd.BroadcastFloat32x16(a3p)
						bRowStart := p * n
						vB0 := archsimd.LoadFloat32x16Slice(b[bRowStart+j:])
						vB1 := archsimd.LoadFloat32x16Slice(b[bRowStart+j+lanes:])
						acc00 = vA0.MulAdd(vB0, acc00)
						acc01 = vA0.MulAdd(vB1, acc01)
						acc10 = vA1.MulAdd(vB0, acc10)
						acc11 = vA1.MulAdd(vB1, acc11)
						acc20 = vA2.MulAdd(vB0, acc20)
						acc21 = vA2.MulAdd(vB1, acc21)
						acc30 = vA3.MulAdd(vB0, acc30)
						acc31 = vA3.MulAdd(vB1, acc31)
					}
					cRow0 := i * n
					cRow1 := (i + 1) * n
					cRow2 := (i + 2) * n
					cRow3 := (i + 3) * n
					acc00.StoreSlice(c[cRow0+j:])
					acc01.StoreSlice(c[cRow0+j+lanes:])
					acc10.StoreSlice(c[cRow1+j:])
					acc11.StoreSlice(c[cRow1+j+lanes:])
					acc20.StoreSlice(c[cRow2+j:])
					acc21.StoreSlice(c[cRow2+j+lanes:])
					acc30.StoreSlice(c[cRow3+j:])
					acc31.StoreSlice(c[cRow3+j+lanes:])
				}
				for ; j < jEnd; j += lanes {
					remaining := jEnd - j
					if remaining >= lanes {
						acc0 := archsimd.BroadcastFloat32x16(0)
						acc1 := archsimd.BroadcastFloat32x16(0)
						acc2 := archsimd.BroadcastFloat32x16(0)
						acc3 := archsimd.BroadcastFloat32x16(0)
						for p := 0; p < k; p++ {
							vA0 := archsimd.BroadcastFloat32x16(a[i*k+p])
							vA1 := archsimd.BroadcastFloat32x16(a[(i+1)*k+p])
							vA2 := archsimd.BroadcastFloat32x16(a[(i+2)*k+p])
							vA3 := archsimd.BroadcastFloat32x16(a[(i+3)*k+p])
							vB := archsimd.LoadFloat32x16Slice(b[p*n+j:])
							acc0 = vA0.MulAdd(vB, acc0)
							acc1 = vA1.MulAdd(vB, acc1)
							acc2 = vA2.MulAdd(vB, acc2)
							acc3 = vA3.MulAdd(vB, acc3)
						}
						acc0.StoreSlice(c[i*n+j:])
						acc1.StoreSlice(c[(i+1)*n+j:])
						acc2.StoreSlice(c[(i+2)*n+j:])
						acc3.StoreSlice(c[(i+3)*n+j:])
					} else {
						for jj := j; jj < jEnd; jj++ {
							var sum0, sum1, sum2, sum3 float32
							for p := 0; p < k; p++ {
								bpj := b[p*n+jj]
								sum0 += a[i*k+p] * bpj
								sum1 += a[(i+1)*k+p] * bpj
								sum2 += a[(i+2)*k+p] * bpj
								sum3 += a[(i+3)*k+p] * bpj
							}
							c[i*n+jj] = sum0
							c[(i+1)*n+jj] = sum1
							c[(i+2)*n+jj] = sum2
							c[(i+3)*n+jj] = sum3
						}
						break
					}
				}
			}
			for ; i < iEnd; i++ {
				cRowStart := i * n
				var j int
				for j = j0; j+lanes <= jEnd; j += lanes {
					acc := archsimd.BroadcastFloat32x16(0)
					for p := 0; p < k; p++ {
						vA := archsimd.BroadcastFloat32x16(a[i*k+p])
						vB := archsimd.LoadFloat32x16Slice(b[p*n+j:])
						acc = vA.MulAdd(vB, acc)
					}
					acc.StoreSlice(c[cRowStart+j:])
				}
				for ; j < jEnd; j++ {
					var sum float32
					for p := 0; p < k; p++ {
						sum += a[i*k+p] * b[p*n+j]
					}
					c[cRowStart+j] = sum
				}
			}
		}
	}
}

func BaseBlockedMatMul_avx512_Float64(a []float64, b []float64, c []float64, m int, n int, k int) {
	if len(a) < m*k {
		panic("matmul: A slice too short")
	}
	if len(b) < k*n {
		panic("matmul: B slice too short")
	}
	if len(c) < m*n {
		panic("matmul: C slice too short")
	}
	vZero := archsimd.BroadcastFloat64x8(0)
	lanes := 8
	total := m * n
	var idx int
	for idx = 0; idx+lanes <= total; idx += lanes {
		vZero.StoreSlice(c[idx:])
	}
	for ; idx < total; idx++ {
		c[idx] = 0
	}
	mr := 4
	nr := lanes * 2
	for i0 := 0; i0 < m; i0 += BlockSize {
		iEnd := min(i0+BlockSize, m)
		for j0 := 0; j0 < n; j0 += BlockSize {
			jEnd := min(j0+BlockSize, n)
			var i int
			for i = i0; i+mr <= iEnd; i += mr {
				var j int
				for j = j0; j+nr <= jEnd; j += nr {
					acc00 := archsimd.BroadcastFloat64x8(0)
					acc01 := archsimd.BroadcastFloat64x8(0)
					acc10 := archsimd.BroadcastFloat64x8(0)
					acc11 := archsimd.BroadcastFloat64x8(0)
					acc20 := archsimd.BroadcastFloat64x8(0)
					acc21 := archsimd.BroadcastFloat64x8(0)
					acc30 := archsimd.BroadcastFloat64x8(0)
					acc31 := archsimd.BroadcastFloat64x8(0)
					for p := 0; p < k; p++ {
						a0p := a[i*k+p]
						a1p := a[(i+1)*k+p]
						a2p := a[(i+2)*k+p]
						a3p := a[(i+3)*k+p]
						vA0 := archsimd.BroadcastFloat64x8(a0p)
						vA1 := archsimd.BroadcastFloat64x8(a1p)
						vA2 := archsimd.BroadcastFloat64x8(a2p)
						vA3 := archsimd.BroadcastFloat64x8(a3p)
						bRowStart := p * n
						vB0 := archsimd.LoadFloat64x8Slice(b[bRowStart+j:])
						vB1 := archsimd.LoadFloat64x8Slice(b[bRowStart+j+lanes:])
						acc00 = vA0.MulAdd(vB0, acc00)
						acc01 = vA0.MulAdd(vB1, acc01)
						acc10 = vA1.MulAdd(vB0, acc10)
						acc11 = vA1.MulAdd(vB1, acc11)
						acc20 = vA2.MulAdd(vB0, acc20)
						acc21 = vA2.MulAdd(vB1, acc21)
						acc30 = vA3.MulAdd(vB0, acc30)
						acc31 = vA3.MulAdd(vB1, acc31)
					}
					cRow0 := i * n
					cRow1 := (i + 1) * n
					cRow2 := (i + 2) * n
					cRow3 := (i + 3) * n
					acc00.StoreSlice(c[cRow0+j:])
					acc01.StoreSlice(c[cRow0+j+lanes:])
					acc10.StoreSlice(c[cRow1+j:])
					acc11.StoreSlice(c[cRow1+j+lanes:])
					acc20.StoreSlice(c[cRow2+j:])
					acc21.StoreSlice(c[cRow2+j+lanes:])
					acc30.StoreSlice(c[cRow3+j:])
					acc31.StoreSlice(c[cRow3+j+lanes:])
				}
				for ; j < jEnd; j += lanes {
					remaining := jEnd - j
					if remaining >= lanes {
						acc0 := archsimd.BroadcastFloat64x8(0)
						acc1 := archsimd.BroadcastFloat64x8(0)
						acc2 := archsimd.BroadcastFloat64x8(0)
						acc3 := archsimd.BroadcastFloat64x8(0)
						for p := 0; p < k; p++ {
							vA0 := archsimd.BroadcastFloat64x8(a[i*k+p])
							vA1 := archsimd.BroadcastFloat64x8(a[(i+1)*k+p])
							vA2 := archsimd.BroadcastFloat64x8(a[(i+2)*k+p])
							vA3 := archsimd.BroadcastFloat64x8(a[(i+3)*k+p])
							vB := archsimd.LoadFloat64x8Slice(b[p*n+j:])
							acc0 = vA0.MulAdd(vB, acc0)
							acc1 = vA1.MulAdd(vB, acc1)
							acc2 = vA2.MulAdd(vB, acc2)
							acc3 = vA3.MulAdd(vB, acc3)
						}
						acc0.StoreSlice(c[i*n+j:])
						acc1.StoreSlice(c[(i+1)*n+j:])
						acc2.StoreSlice(c[(i+2)*n+j:])
						acc3.StoreSlice(c[(i+3)*n+j:])
					} else {
						for jj := j; jj < jEnd; jj++ {
							var sum0, sum1, sum2, sum3 float64
							for p := 0; p < k; p++ {
								bpj := b[p*n+jj]
								sum0 += a[i*k+p] * bpj
								sum1 += a[(i+1)*k+p] * bpj
								sum2 += a[(i+2)*k+p] * bpj
								sum3 += a[(i+3)*k+p] * bpj
							}
							c[i*n+jj] = sum0
							c[(i+1)*n+jj] = sum1
							c[(i+2)*n+jj] = sum2
							c[(i+3)*n+jj] = sum3
						}
						break
					}
				}
			}
			for ; i < iEnd; i++ {
				cRowStart := i * n
				var j int
				for j = j0; j+lanes <= jEnd; j += lanes {
					acc := archsimd.BroadcastFloat64x8(0)
					for p := 0; p < k; p++ {
						vA := archsimd.BroadcastFloat64x8(a[i*k+p])
						vB := archsimd.LoadFloat64x8Slice(b[p*n+j:])
						acc = vA.MulAdd(vB, acc)
					}
					acc.StoreSlice(c[cRowStart+j:])
				}
				for ; j < jEnd; j++ {
					var sum float64
					for p := 0; p < k; p++ {
						sum += a[i*k+p] * b[p*n+j]
					}
					c[cRowStart+j] = sum
				}
			}
		}
	}
}
