// Code generated by hwygen. DO NOT EDIT.
//go:build amd64 && goexperiment.simd

package matmul

import (
	"github.com/ajroetker/go-highway/hwy"
	"simd/archsimd"
)

func BaseBlockedMatMul_avx512_Float16(a []hwy.Float16, b []hwy.Float16, c []hwy.Float16, m int, n int, k int) {
	if len(a) < m*k {
		panic("matmul: A slice too short")
	}
	if len(b) < k*n {
		panic("matmul: B slice too short")
	}
	if len(c) < m*n {
		panic("matmul: C slice too short")
	}
	vZero := hwy.Zero[hwy.Float16]()
	lanes := 32
	total := m * n
	var idx int
	for idx = 0; idx+lanes <= total; idx += lanes {
		hwy.Store(vZero, c[idx:])
	}
	for ; idx < total; idx++ {
		c[idx] = hwy.Float32ToFloat16(0)
	}
	for i0 := 0; i0 < m; i0 += BlockSize {
		iEnd := min(i0+BlockSize, m)
		for j0 := 0; j0 < n; j0 += BlockSize {
			jEnd := min(j0+BlockSize, n)
			blockN := jEnd - j0
			for p0 := 0; p0 < k; p0 += BlockSize {
				pEnd := min(p0+BlockSize, k)
				for i := i0; i < iEnd; i++ {
					cRowStart := i*n + j0
					for p := p0; p < pEnd; p++ {
						aip := a[i*k+p]
						vA := hwy.Set(aip)
						bRowStart := p*n + j0
						var j int
						for j = 0; j+lanes <= blockN; j += lanes {
							vB := hwy.Load(b[bRowStart+j:])
							vC := hwy.Load(c[cRowStart+j:])
							vC = hwy.FMAF16(vA, vB, vC)
							hwy.Store(vC, c[cRowStart+j:])
						}
						for ; j < blockN; j++ {
							c[cRowStart+j] = hwy.Float32ToFloat16(c[cRowStart+j].Float32() + aip.Float32()*b[bRowStart+j].Float32())
						}
					}
				}
			}
		}
	}
}

func BaseBlockedMatMul_avx512_BFloat16(a []hwy.BFloat16, b []hwy.BFloat16, c []hwy.BFloat16, m int, n int, k int) {
	if len(a) < m*k {
		panic("matmul: A slice too short")
	}
	if len(b) < k*n {
		panic("matmul: B slice too short")
	}
	if len(c) < m*n {
		panic("matmul: C slice too short")
	}
	vZero := hwy.Zero[hwy.BFloat16]()
	lanes := 32
	total := m * n
	var idx int
	for idx = 0; idx+lanes <= total; idx += lanes {
		hwy.Store(vZero, c[idx:])
	}
	for ; idx < total; idx++ {
		c[idx] = hwy.Float32ToBFloat16(0)
	}
	for i0 := 0; i0 < m; i0 += BlockSize {
		iEnd := min(i0+BlockSize, m)
		for j0 := 0; j0 < n; j0 += BlockSize {
			jEnd := min(j0+BlockSize, n)
			blockN := jEnd - j0
			for p0 := 0; p0 < k; p0 += BlockSize {
				pEnd := min(p0+BlockSize, k)
				for i := i0; i < iEnd; i++ {
					cRowStart := i*n + j0
					for p := p0; p < pEnd; p++ {
						aip := a[i*k+p]
						vA := hwy.Set(aip)
						bRowStart := p*n + j0
						var j int
						for j = 0; j+lanes <= blockN; j += lanes {
							vB := hwy.Load(b[bRowStart+j:])
							vC := hwy.Load(c[cRowStart+j:])
							vC = hwy.FMABF16(vA, vB, vC)
							hwy.Store(vC, c[cRowStart+j:])
						}
						for ; j < blockN; j++ {
							c[cRowStart+j] = hwy.Float32ToBFloat16(c[cRowStart+j].Float32() + aip.Float32()*b[bRowStart+j].Float32())
						}
					}
				}
			}
		}
	}
}

func BaseBlockedMatMul_avx512(a []float32, b []float32, c []float32, m int, n int, k int) {
	if len(a) < m*k {
		panic("matmul: A slice too short")
	}
	if len(b) < k*n {
		panic("matmul: B slice too short")
	}
	if len(c) < m*n {
		panic("matmul: C slice too short")
	}
	vZero := archsimd.BroadcastFloat32x16(0)
	lanes := 16
	total := m * n
	var idx int
	for idx = 0; idx+lanes <= total; idx += lanes {
		vZero.StoreSlice(c[idx:])
	}
	for ; idx < total; idx++ {
		c[idx] = 0
	}
	for i0 := 0; i0 < m; i0 += BlockSize {
		iEnd := min(i0+BlockSize, m)
		for j0 := 0; j0 < n; j0 += BlockSize {
			jEnd := min(j0+BlockSize, n)
			blockN := jEnd - j0
			for p0 := 0; p0 < k; p0 += BlockSize {
				pEnd := min(p0+BlockSize, k)
				for i := i0; i < iEnd; i++ {
					cRowStart := i*n + j0
					for p := p0; p < pEnd; p++ {
						aip := a[i*k+p]
						vA := archsimd.BroadcastFloat32x16(aip)
						bRowStart := p*n + j0
						var j int
						for j = 0; j+lanes <= blockN; j += lanes {
							vB := archsimd.LoadFloat32x16Slice(b[bRowStart+j:])
							vC := archsimd.LoadFloat32x16Slice(c[cRowStart+j:])
							vC = vA.MulAdd(vB, vC)
							vC.StoreSlice(c[cRowStart+j:])
						}
						for ; j < blockN; j++ {
							c[cRowStart+j] += aip * b[bRowStart+j]
						}
					}
				}
			}
		}
	}
}

func BaseBlockedMatMul_avx512_Float64(a []float64, b []float64, c []float64, m int, n int, k int) {
	if len(a) < m*k {
		panic("matmul: A slice too short")
	}
	if len(b) < k*n {
		panic("matmul: B slice too short")
	}
	if len(c) < m*n {
		panic("matmul: C slice too short")
	}
	vZero := archsimd.BroadcastFloat64x8(0)
	lanes := 8
	total := m * n
	var idx int
	for idx = 0; idx+lanes <= total; idx += lanes {
		vZero.StoreSlice(c[idx:])
	}
	for ; idx < total; idx++ {
		c[idx] = 0
	}
	for i0 := 0; i0 < m; i0 += BlockSize {
		iEnd := min(i0+BlockSize, m)
		for j0 := 0; j0 < n; j0 += BlockSize {
			jEnd := min(j0+BlockSize, n)
			blockN := jEnd - j0
			for p0 := 0; p0 < k; p0 += BlockSize {
				pEnd := min(p0+BlockSize, k)
				for i := i0; i < iEnd; i++ {
					cRowStart := i*n + j0
					for p := p0; p < pEnd; p++ {
						aip := a[i*k+p]
						vA := archsimd.BroadcastFloat64x8(aip)
						bRowStart := p*n + j0
						var j int
						for j = 0; j+lanes <= blockN; j += lanes {
							vB := archsimd.LoadFloat64x8Slice(b[bRowStart+j:])
							vC := archsimd.LoadFloat64x8Slice(c[cRowStart+j:])
							vC = vA.MulAdd(vB, vC)
							vC.StoreSlice(c[cRowStart+j:])
						}
						for ; j < blockN; j++ {
							c[cRowStart+j] += aip * b[bRowStart+j]
						}
					}
				}
			}
		}
	}
}
