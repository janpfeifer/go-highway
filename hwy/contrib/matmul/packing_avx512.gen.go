// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

//go:build amd64 && goexperiment.simd

package matmul

import (
	"simd/archsimd"
	"unsafe"

	"github.com/ajroetker/go-highway/hwy"
	"github.com/ajroetker/go-highway/hwy/asm"
)

func BasePackLHS_avx512_Float16(a []hwy.Float16, packed []hwy.Float16, m int, k int, rowStart int, colStart int, panelRows int, panelK int, mr int) int {
	numMicroPanels := (panelRows + mr - 1) / mr
	activeRowsLast := panelRows - (numMicroPanels-1)*mr
	fullPanels := numMicroPanels
	if activeRowsLast < mr {
		fullPanels--
	}
	packIdx := 0
	for panel := 0; panel < fullPanels; panel++ {
		baseRow := rowStart + panel*mr
		for kk := 0; kk < panelK; kk++ {
			for r := 0; r < mr; r++ {
				packed[packIdx] = hwy.Float32ToFloat16(a[(baseRow+r)*k+colStart+kk].Float32())
				packIdx++
			}
		}
	}
	if activeRowsLast < mr && activeRowsLast > 0 {
		baseRow := rowStart + fullPanels*mr
		for kk := 0; kk < panelK; kk++ {
			for r := 0; r < activeRowsLast; r++ {
				packed[packIdx] = hwy.Float32ToFloat16(a[(baseRow+r)*k+colStart+kk].Float32())
				packIdx++
			}
			for r := activeRowsLast; r < mr; r++ {
				packed[packIdx] = hwy.Float32ToFloat16(0)
				packIdx++
			}
		}
	}
	return activeRowsLast
}

func BasePackLHS_avx512_BFloat16(a []hwy.BFloat16, packed []hwy.BFloat16, m int, k int, rowStart int, colStart int, panelRows int, panelK int, mr int) int {
	numMicroPanels := (panelRows + mr - 1) / mr
	activeRowsLast := panelRows - (numMicroPanels-1)*mr
	fullPanels := numMicroPanels
	if activeRowsLast < mr {
		fullPanels--
	}
	packIdx := 0
	for panel := 0; panel < fullPanels; panel++ {
		baseRow := rowStart + panel*mr
		for kk := 0; kk < panelK; kk++ {
			for r := 0; r < mr; r++ {
				packed[packIdx] = hwy.Float32ToBFloat16(a[(baseRow+r)*k+colStart+kk].Float32())
				packIdx++
			}
		}
	}
	if activeRowsLast < mr && activeRowsLast > 0 {
		baseRow := rowStart + fullPanels*mr
		for kk := 0; kk < panelK; kk++ {
			for r := 0; r < activeRowsLast; r++ {
				packed[packIdx] = hwy.Float32ToBFloat16(a[(baseRow+r)*k+colStart+kk].Float32())
				packIdx++
			}
			for r := activeRowsLast; r < mr; r++ {
				packed[packIdx] = hwy.Float32ToBFloat16(0)
				packIdx++
			}
		}
	}
	return activeRowsLast
}

func BasePackLHS_avx512(a []float32, packed []float32, m int, k int, rowStart int, colStart int, panelRows int, panelK int, mr int) int {
	numMicroPanels := (panelRows + mr - 1) / mr
	activeRowsLast := panelRows - (numMicroPanels-1)*mr
	fullPanels := numMicroPanels
	if activeRowsLast < mr {
		fullPanels--
	}
	packIdx := 0
	for panel := 0; panel < fullPanels; panel++ {
		baseRow := rowStart + panel*mr
		for kk := 0; kk < panelK; kk++ {
			for r := 0; r < mr; r++ {
				packed[packIdx] = a[(baseRow+r)*k+colStart+kk]
				packIdx++
			}
		}
	}
	if activeRowsLast < mr && activeRowsLast > 0 {
		baseRow := rowStart + fullPanels*mr
		for kk := 0; kk < panelK; kk++ {
			for r := 0; r < activeRowsLast; r++ {
				packed[packIdx] = a[(baseRow+r)*k+colStart+kk]
				packIdx++
			}
			for r := activeRowsLast; r < mr; r++ {
				packed[packIdx] = 0
				packIdx++
			}
		}
	}
	return activeRowsLast
}

func BasePackLHS_avx512_Float64(a []float64, packed []float64, m int, k int, rowStart int, colStart int, panelRows int, panelK int, mr int) int {
	numMicroPanels := (panelRows + mr - 1) / mr
	activeRowsLast := panelRows - (numMicroPanels-1)*mr
	fullPanels := numMicroPanels
	if activeRowsLast < mr {
		fullPanels--
	}
	packIdx := 0
	for panel := 0; panel < fullPanels; panel++ {
		baseRow := rowStart + panel*mr
		for kk := 0; kk < panelK; kk++ {
			for r := 0; r < mr; r++ {
				packed[packIdx] = a[(baseRow+r)*k+colStart+kk]
				packIdx++
			}
		}
	}
	if activeRowsLast < mr && activeRowsLast > 0 {
		baseRow := rowStart + fullPanels*mr
		for kk := 0; kk < panelK; kk++ {
			for r := 0; r < activeRowsLast; r++ {
				packed[packIdx] = a[(baseRow+r)*k+colStart+kk]
				packIdx++
			}
			for r := activeRowsLast; r < mr; r++ {
				packed[packIdx] = 0
				packIdx++
			}
		}
	}
	return activeRowsLast
}

func BasePackRHS_avx512_Float16(b []hwy.Float16, packed []hwy.Float16, k int, n int, rowStart int, colStart int, panelK int, panelCols int, nr int) int {
	numMicroPanels := (panelCols + nr - 1) / nr
	activeColsLast := panelCols - (numMicroPanels-1)*nr
	fullPanels := numMicroPanels
	if activeColsLast < nr {
		fullPanels--
	}
	packIdx := 0
	for panel := 0; panel < fullPanels; panel++ {
		baseCol := colStart + panel*nr
		for kk := 0; kk < panelK; kk++ {
			bRowStart := (rowStart + kk) * n
			for c := 0; c < nr; c++ {
				packed[packIdx] = hwy.Float32ToFloat16(b[bRowStart+baseCol+c].Float32())
				packIdx++
			}
		}
	}
	if activeColsLast < nr && activeColsLast > 0 {
		baseCol := colStart + fullPanels*nr
		for kk := 0; kk < panelK; kk++ {
			bRowStart := (rowStart + kk) * n
			for c := 0; c < activeColsLast; c++ {
				packed[packIdx] = hwy.Float32ToFloat16(b[bRowStart+baseCol+c].Float32())
				packIdx++
			}
			for c := activeColsLast; c < nr; c++ {
				packed[packIdx] = hwy.Float32ToFloat16(0)
				packIdx++
			}
		}
	}
	return activeColsLast
}

func BasePackRHS_avx512_BFloat16(b []hwy.BFloat16, packed []hwy.BFloat16, k int, n int, rowStart int, colStart int, panelK int, panelCols int, nr int) int {
	numMicroPanels := (panelCols + nr - 1) / nr
	activeColsLast := panelCols - (numMicroPanels-1)*nr
	fullPanels := numMicroPanels
	if activeColsLast < nr {
		fullPanels--
	}
	packIdx := 0
	for panel := 0; panel < fullPanels; panel++ {
		baseCol := colStart + panel*nr
		for kk := 0; kk < panelK; kk++ {
			bRowStart := (rowStart + kk) * n
			for c := 0; c < nr; c++ {
				packed[packIdx] = hwy.Float32ToBFloat16(b[bRowStart+baseCol+c].Float32())
				packIdx++
			}
		}
	}
	if activeColsLast < nr && activeColsLast > 0 {
		baseCol := colStart + fullPanels*nr
		for kk := 0; kk < panelK; kk++ {
			bRowStart := (rowStart + kk) * n
			for c := 0; c < activeColsLast; c++ {
				packed[packIdx] = hwy.Float32ToBFloat16(b[bRowStart+baseCol+c].Float32())
				packIdx++
			}
			for c := activeColsLast; c < nr; c++ {
				packed[packIdx] = hwy.Float32ToBFloat16(0)
				packIdx++
			}
		}
	}
	return activeColsLast
}

func BasePackRHS_avx512(b []float32, packed []float32, k int, n int, rowStart int, colStart int, panelK int, panelCols int, nr int) int {
	numMicroPanels := (panelCols + nr - 1) / nr
	activeColsLast := panelCols - (numMicroPanels-1)*nr
	fullPanels := numMicroPanels
	if activeColsLast < nr {
		fullPanels--
	}
	packIdx := 0
	for panel := 0; panel < fullPanels; panel++ {
		baseCol := colStart + panel*nr
		for kk := 0; kk < panelK; kk++ {
			bRowStart := (rowStart + kk) * n
			for c := 0; c < nr; c++ {
				packed[packIdx] = b[bRowStart+baseCol+c]
				packIdx++
			}
		}
	}
	if activeColsLast < nr && activeColsLast > 0 {
		baseCol := colStart + fullPanels*nr
		for kk := 0; kk < panelK; kk++ {
			bRowStart := (rowStart + kk) * n
			for c := 0; c < activeColsLast; c++ {
				packed[packIdx] = b[bRowStart+baseCol+c]
				packIdx++
			}
			for c := activeColsLast; c < nr; c++ {
				packed[packIdx] = 0
				packIdx++
			}
		}
	}
	return activeColsLast
}

func BasePackRHS_avx512_Float64(b []float64, packed []float64, k int, n int, rowStart int, colStart int, panelK int, panelCols int, nr int) int {
	numMicroPanels := (panelCols + nr - 1) / nr
	activeColsLast := panelCols - (numMicroPanels-1)*nr
	fullPanels := numMicroPanels
	if activeColsLast < nr {
		fullPanels--
	}
	packIdx := 0
	for panel := 0; panel < fullPanels; panel++ {
		baseCol := colStart + panel*nr
		for kk := 0; kk < panelK; kk++ {
			bRowStart := (rowStart + kk) * n
			for c := 0; c < nr; c++ {
				packed[packIdx] = b[bRowStart+baseCol+c]
				packIdx++
			}
		}
	}
	if activeColsLast < nr && activeColsLast > 0 {
		baseCol := colStart + fullPanels*nr
		for kk := 0; kk < panelK; kk++ {
			bRowStart := (rowStart + kk) * n
			for c := 0; c < activeColsLast; c++ {
				packed[packIdx] = b[bRowStart+baseCol+c]
				packIdx++
			}
			for c := activeColsLast; c < nr; c++ {
				packed[packIdx] = 0
				packIdx++
			}
		}
	}
	return activeColsLast
}

func BasePackLHSVec_avx512_Float16(a []hwy.Float16, packed []hwy.Float16, m int, k int, rowStart int, colStart int, panelRows int, panelK int, mr int) int {
	return BasePackLHS_avx512_Float16(a, packed, m, k, rowStart, colStart, panelRows, panelK, mr)
}

func BasePackLHSVec_avx512_BFloat16(a []hwy.BFloat16, packed []hwy.BFloat16, m int, k int, rowStart int, colStart int, panelRows int, panelK int, mr int) int {
	return BasePackLHS_avx512_BFloat16(a, packed, m, k, rowStart, colStart, panelRows, panelK, mr)
}

func BasePackLHSVec_avx512(a []float32, packed []float32, m int, k int, rowStart int, colStart int, panelRows int, panelK int, mr int) int {
	return BasePackLHS_avx512(a, packed, m, k, rowStart, colStart, panelRows, panelK, mr)
}

func BasePackLHSVec_avx512_Float64(a []float64, packed []float64, m int, k int, rowStart int, colStart int, panelRows int, panelK int, mr int) int {
	return BasePackLHS_avx512_Float64(a, packed, m, k, rowStart, colStart, panelRows, panelK, mr)
}

func BasePackRHSVec_avx512_Float16(b []hwy.Float16, packed []hwy.Float16, k int, n int, rowStart int, colStart int, panelK int, panelCols int, nr int) int {
	lanes := 16
	if nr >= lanes && nr%lanes == 0 {
		numMicroPanels := (panelCols + nr - 1) / nr
		activeColsLast := panelCols - (numMicroPanels-1)*nr
		fullPanels := numMicroPanels
		if activeColsLast < nr {
			fullPanels--
		}
		packIdx := 0
		for panel := 0; panel < fullPanels; panel++ {
			baseCol := colStart + panel*nr
			for kk := 0; kk < panelK; kk++ {
				bRowStart := (rowStart + kk) * n
				for c := 0; c < nr; c += lanes {
					v := asm.LoadFloat16x16AVX512Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(b[bRowStart+baseCol+c:]))), len(b[bRowStart+baseCol+c:])))
					v.StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(packed[packIdx+c:]))), len(packed[packIdx+c:])))
				}
				packIdx += nr
			}
		}
		if activeColsLast < nr && activeColsLast > 0 {
			baseCol := colStart + fullPanels*nr
			for kk := 0; kk < panelK; kk++ {
				bRowStart := (rowStart + kk) * n
				for c := 0; c < activeColsLast; c++ {
					packed[packIdx] = hwy.Float32ToFloat16(b[bRowStart+baseCol+c].Float32())
					packIdx++
				}
				for c := activeColsLast; c < nr; c++ {
					packed[packIdx] = hwy.Float32ToFloat16(0)
					packIdx++
				}
			}
		}
		return activeColsLast
	}
	return BasePackRHS_avx512_Float16(b, packed, k, n, rowStart, colStart, panelK, panelCols, nr)
}

func BasePackRHSVec_avx512_BFloat16(b []hwy.BFloat16, packed []hwy.BFloat16, k int, n int, rowStart int, colStart int, panelK int, panelCols int, nr int) int {
	lanes := 16
	if nr >= lanes && nr%lanes == 0 {
		numMicroPanels := (panelCols + nr - 1) / nr
		activeColsLast := panelCols - (numMicroPanels-1)*nr
		fullPanels := numMicroPanels
		if activeColsLast < nr {
			fullPanels--
		}
		packIdx := 0
		for panel := 0; panel < fullPanels; panel++ {
			baseCol := colStart + panel*nr
			for kk := 0; kk < panelK; kk++ {
				bRowStart := (rowStart + kk) * n
				for c := 0; c < nr; c += lanes {
					v := asm.LoadBFloat16x16AVX512Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(b[bRowStart+baseCol+c:]))), len(b[bRowStart+baseCol+c:])))
					v.StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(packed[packIdx+c:]))), len(packed[packIdx+c:])))
				}
				packIdx += nr
			}
		}
		if activeColsLast < nr && activeColsLast > 0 {
			baseCol := colStart + fullPanels*nr
			for kk := 0; kk < panelK; kk++ {
				bRowStart := (rowStart + kk) * n
				for c := 0; c < activeColsLast; c++ {
					packed[packIdx] = hwy.Float32ToBFloat16(b[bRowStart+baseCol+c].Float32())
					packIdx++
				}
				for c := activeColsLast; c < nr; c++ {
					packed[packIdx] = hwy.Float32ToBFloat16(0)
					packIdx++
				}
			}
		}
		return activeColsLast
	}
	return BasePackRHS_avx512_BFloat16(b, packed, k, n, rowStart, colStart, panelK, panelCols, nr)
}

func BasePackRHSVec_avx512(b []float32, packed []float32, k int, n int, rowStart int, colStart int, panelK int, panelCols int, nr int) int {
	lanes := 16
	if nr >= lanes && nr%lanes == 0 {
		numMicroPanels := (panelCols + nr - 1) / nr
		activeColsLast := panelCols - (numMicroPanels-1)*nr
		fullPanels := numMicroPanels
		if activeColsLast < nr {
			fullPanels--
		}
		packIdx := 0
		for panel := 0; panel < fullPanels; panel++ {
			baseCol := colStart + panel*nr
			for kk := 0; kk < panelK; kk++ {
				bRowStart := (rowStart + kk) * n
				for c := 0; c < nr; c += lanes {
					v := archsimd.LoadFloat32x16Slice(b[bRowStart+baseCol+c:])
					v.StoreSlice(packed[packIdx+c:])
				}
				packIdx += nr
			}
		}
		if activeColsLast < nr && activeColsLast > 0 {
			baseCol := colStart + fullPanels*nr
			for kk := 0; kk < panelK; kk++ {
				bRowStart := (rowStart + kk) * n
				for c := 0; c < activeColsLast; c++ {
					packed[packIdx] = b[bRowStart+baseCol+c]
					packIdx++
				}
				for c := activeColsLast; c < nr; c++ {
					packed[packIdx] = 0
					packIdx++
				}
			}
		}
		return activeColsLast
	}
	return BasePackRHS_avx512(b, packed, k, n, rowStart, colStart, panelK, panelCols, nr)
}

func BasePackRHSVec_avx512_Float64(b []float64, packed []float64, k int, n int, rowStart int, colStart int, panelK int, panelCols int, nr int) int {
	lanes := 8
	if nr >= lanes && nr%lanes == 0 {
		numMicroPanels := (panelCols + nr - 1) / nr
		activeColsLast := panelCols - (numMicroPanels-1)*nr
		fullPanels := numMicroPanels
		if activeColsLast < nr {
			fullPanels--
		}
		packIdx := 0
		for panel := 0; panel < fullPanels; panel++ {
			baseCol := colStart + panel*nr
			for kk := 0; kk < panelK; kk++ {
				bRowStart := (rowStart + kk) * n
				for c := 0; c < nr; c += lanes {
					v := archsimd.LoadFloat64x8Slice(b[bRowStart+baseCol+c:])
					v.StoreSlice(packed[packIdx+c:])
				}
				packIdx += nr
			}
		}
		if activeColsLast < nr && activeColsLast > 0 {
			baseCol := colStart + fullPanels*nr
			for kk := 0; kk < panelK; kk++ {
				bRowStart := (rowStart + kk) * n
				for c := 0; c < activeColsLast; c++ {
					packed[packIdx] = b[bRowStart+baseCol+c]
					packIdx++
				}
				for c := activeColsLast; c < nr; c++ {
					packed[packIdx] = 0
					packIdx++
				}
			}
		}
		return activeColsLast
	}
	return BasePackRHS_avx512_Float64(b, packed, k, n, rowStart, colStart, panelK, panelCols, nr)
}
