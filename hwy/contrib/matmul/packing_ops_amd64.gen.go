// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

//go:build amd64 && goexperiment.simd

package matmul

import (
	"simd/archsimd"

	"github.com/ajroetker/go-highway/hwy"
)

var PackRHSFastFloat16 func(b []hwy.Float16, packed []hwy.Float16, n int, rowStart int, colStart int, panelK int, panelCols int, nr int)
var PackRHSFastBFloat16 func(b []hwy.BFloat16, packed []hwy.BFloat16, n int, rowStart int, colStart int, panelK int, panelCols int, nr int)
var PackRHSFastFloat32 func(b []float32, packed []float32, n int, rowStart int, colStart int, panelK int, panelCols int, nr int)
var PackRHSFastFloat64 func(b []float64, packed []float64, n int, rowStart int, colStart int, panelK int, panelCols int, nr int)
var ApplyPackedOutputFloat16 func(packedOutput []hwy.Float16, output []hwy.Float16, alpha hwy.Float16, beta hwy.Float16, packedStride int, outputRowOffset int, outputColOffset int, outputStride int, height int, width int)
var ApplyPackedOutputBFloat16 func(packedOutput []hwy.BFloat16, output []hwy.BFloat16, alpha hwy.BFloat16, beta hwy.BFloat16, packedStride int, outputRowOffset int, outputColOffset int, outputStride int, height int, width int)
var ApplyPackedOutputFloat32 func(packedOutput []float32, output []float32, alpha float32, beta float32, packedStride int, outputRowOffset int, outputColOffset int, outputStride int, height int, width int)
var ApplyPackedOutputFloat64 func(packedOutput []float64, output []float64, alpha float64, beta float64, packedStride int, outputRowOffset int, outputColOffset int, outputStride int, height int, width int)
var ApplyPackedOutputSimpleFloat16 func(packedOutput []hwy.Float16, output []hwy.Float16, packedStride int, outputRowOffset int, outputColOffset int, outputStride int, height int, width int)
var ApplyPackedOutputSimpleBFloat16 func(packedOutput []hwy.BFloat16, output []hwy.BFloat16, packedStride int, outputRowOffset int, outputColOffset int, outputStride int, height int, width int)
var ApplyPackedOutputSimpleFloat32 func(packedOutput []float32, output []float32, packedStride int, outputRowOffset int, outputColOffset int, outputStride int, height int, width int)
var ApplyPackedOutputSimpleFloat64 func(packedOutput []float64, output []float64, packedStride int, outputRowOffset int, outputColOffset int, outputStride int, height int, width int)
var ApplyPackedOutputAccumFloat16 func(packedOutput []hwy.Float16, output []hwy.Float16, packedStride int, outputRowOffset int, outputColOffset int, outputStride int, height int, width int)
var ApplyPackedOutputAccumBFloat16 func(packedOutput []hwy.BFloat16, output []hwy.BFloat16, packedStride int, outputRowOffset int, outputColOffset int, outputStride int, height int, width int)
var ApplyPackedOutputAccumFloat32 func(packedOutput []float32, output []float32, packedStride int, outputRowOffset int, outputColOffset int, outputStride int, height int, width int)
var ApplyPackedOutputAccumFloat64 func(packedOutput []float64, output []float64, packedStride int, outputRowOffset int, outputColOffset int, outputStride int, height int, width int)

// PackRHSFast packs a panel of the RHS matrix (B) using SIMD when possible.
//
// This is an optimized version of BasePackRHS that uses vector loads/stores
// for full micro-panels where nr matches common SIMD widths.
//
// For AVX-512 with float32 (nr=32), this uses 2x ZMM loads/stores per row.
// For AVX2 with float32 (nr=16), this uses 2x YMM loads/stores per row.
// For NEON with float32 (nr=8), this uses 2x vector loads/stores per row.
//
// Parameters:
//   - b: Input matrix B in row-major order (K x N)
//   - packed: Output buffer for packed data
//   - n: Number of columns in B (row stride)
//   - rowStart: Starting row index in B (K-dimension offset)
//   - colStart: Starting column index in B
//   - panelK: Number of rows to pack (K dimension)
//   - panelCols: Number of columns to pack
//   - nr: Micro-tile column dimension (should match vector width * 2)
//
// This function dispatches to the appropriate SIMD implementation at runtime.
func PackRHSFast[T hwy.Floats](b []T, packed []T, n int, rowStart int, colStart int, panelK int, panelCols int, nr int) {
	switch any(b).(type) {
	case []hwy.Float16:
		PackRHSFastFloat16(any(b).([]hwy.Float16), any(packed).([]hwy.Float16), n, rowStart, colStart, panelK, panelCols, nr)
	case []hwy.BFloat16:
		PackRHSFastBFloat16(any(b).([]hwy.BFloat16), any(packed).([]hwy.BFloat16), n, rowStart, colStart, panelK, panelCols, nr)
	case []float32:
		PackRHSFastFloat32(any(b).([]float32), any(packed).([]float32), n, rowStart, colStart, panelK, panelCols, nr)
	case []float64:
		PackRHSFastFloat64(any(b).([]float64), any(packed).([]float64), n, rowStart, colStart, panelK, panelCols, nr)
	}
}

// ApplyPackedOutput applies the computed packed output to the final output matrix.
//
// This function transfers results from a temporary packed output buffer to the
// actual output matrix, applying alpha and beta scaling:
//
//	output = alpha * packedOutput + beta * output
//
// Using a packed output buffer allows the micro-kernel to write contiguously
// without bounds checking, improving performance. The alpha/beta application
// is then done efficiently with SIMD in this separate pass.
//
// Parameters:
//   - packedOutput: Temporary buffer with computed results [height, packedStride]
//   - output: Final output matrix in row-major order
//   - alpha, beta: Scaling factors (output = alpha*packed + beta*output)
//   - packedStride: Row stride in packedOutput (typically params.Nc)
//   - outputRowOffset: Starting row in output matrix
//   - outputColOffset: Starting column in output matrix
//   - outputStride: Row stride in output matrix (N dimension)
//   - height: Number of rows to apply
//   - width: Number of columns to apply
//
// This function dispatches to the appropriate SIMD implementation at runtime.
func ApplyPackedOutput[T hwy.Floats](packedOutput []T, output []T, alpha T, beta T, packedStride int, outputRowOffset int, outputColOffset int, outputStride int, height int, width int) {
	switch any(packedOutput).(type) {
	case []hwy.Float16:
		ApplyPackedOutputFloat16(any(packedOutput).([]hwy.Float16), any(output).([]hwy.Float16), any(alpha).(hwy.Float16), any(beta).(hwy.Float16), packedStride, outputRowOffset, outputColOffset, outputStride, height, width)
	case []hwy.BFloat16:
		ApplyPackedOutputBFloat16(any(packedOutput).([]hwy.BFloat16), any(output).([]hwy.BFloat16), any(alpha).(hwy.BFloat16), any(beta).(hwy.BFloat16), packedStride, outputRowOffset, outputColOffset, outputStride, height, width)
	case []float32:
		ApplyPackedOutputFloat32(any(packedOutput).([]float32), any(output).([]float32), any(alpha).(float32), any(beta).(float32), packedStride, outputRowOffset, outputColOffset, outputStride, height, width)
	case []float64:
		ApplyPackedOutputFloat64(any(packedOutput).([]float64), any(output).([]float64), any(alpha).(float64), any(beta).(float64), packedStride, outputRowOffset, outputColOffset, outputStride, height, width)
	}
}

// ApplyPackedOutputSimple is a simplified version for alpha=1, beta=0.
//
// When no scaling is needed, this directly copies from packed to output,
// which is faster than the general case.
//
// This function dispatches to the appropriate SIMD implementation at runtime.
func ApplyPackedOutputSimple[T hwy.Floats](packedOutput []T, output []T, packedStride int, outputRowOffset int, outputColOffset int, outputStride int, height int, width int) {
	switch any(packedOutput).(type) {
	case []hwy.Float16:
		ApplyPackedOutputSimpleFloat16(any(packedOutput).([]hwy.Float16), any(output).([]hwy.Float16), packedStride, outputRowOffset, outputColOffset, outputStride, height, width)
	case []hwy.BFloat16:
		ApplyPackedOutputSimpleBFloat16(any(packedOutput).([]hwy.BFloat16), any(output).([]hwy.BFloat16), packedStride, outputRowOffset, outputColOffset, outputStride, height, width)
	case []float32:
		ApplyPackedOutputSimpleFloat32(any(packedOutput).([]float32), any(output).([]float32), packedStride, outputRowOffset, outputColOffset, outputStride, height, width)
	case []float64:
		ApplyPackedOutputSimpleFloat64(any(packedOutput).([]float64), any(output).([]float64), packedStride, outputRowOffset, outputColOffset, outputStride, height, width)
	}
}

// ApplyPackedOutputAccum is for accumulation (alpha=1, beta=1).
//
// This is the common case when accumulating K-dimension blocks:
// output += packedOutput
//
// This function dispatches to the appropriate SIMD implementation at runtime.
func ApplyPackedOutputAccum[T hwy.Floats](packedOutput []T, output []T, packedStride int, outputRowOffset int, outputColOffset int, outputStride int, height int, width int) {
	switch any(packedOutput).(type) {
	case []hwy.Float16:
		ApplyPackedOutputAccumFloat16(any(packedOutput).([]hwy.Float16), any(output).([]hwy.Float16), packedStride, outputRowOffset, outputColOffset, outputStride, height, width)
	case []hwy.BFloat16:
		ApplyPackedOutputAccumBFloat16(any(packedOutput).([]hwy.BFloat16), any(output).([]hwy.BFloat16), packedStride, outputRowOffset, outputColOffset, outputStride, height, width)
	case []float32:
		ApplyPackedOutputAccumFloat32(any(packedOutput).([]float32), any(output).([]float32), packedStride, outputRowOffset, outputColOffset, outputStride, height, width)
	case []float64:
		ApplyPackedOutputAccumFloat64(any(packedOutput).([]float64), any(output).([]float64), packedStride, outputRowOffset, outputColOffset, outputStride, height, width)
	}
}

func init() {
	if hwy.NoSimdEnv() {
		initPacking_opsFallback()
		return
	}
	if archsimd.X86.AVX512() {
		initPacking_opsAVX512()
		return
	}
	if archsimd.X86.AVX2() {
		initPacking_opsAVX2()
		return
	}
	initPacking_opsFallback()
}

func initPacking_opsAVX2() {
	PackRHSFastFloat16 = BasePackRHSFast_avx2_Float16
	PackRHSFastBFloat16 = BasePackRHSFast_avx2_BFloat16
	PackRHSFastFloat32 = BasePackRHSFast_avx2
	PackRHSFastFloat64 = BasePackRHSFast_avx2_Float64
	ApplyPackedOutputFloat16 = BaseApplyPackedOutput_avx2_Float16
	ApplyPackedOutputBFloat16 = BaseApplyPackedOutput_avx2_BFloat16
	ApplyPackedOutputFloat32 = BaseApplyPackedOutput_avx2
	ApplyPackedOutputFloat64 = BaseApplyPackedOutput_avx2_Float64
	ApplyPackedOutputSimpleFloat16 = BaseApplyPackedOutputSimple_avx2_Float16
	ApplyPackedOutputSimpleBFloat16 = BaseApplyPackedOutputSimple_avx2_BFloat16
	ApplyPackedOutputSimpleFloat32 = BaseApplyPackedOutputSimple_avx2
	ApplyPackedOutputSimpleFloat64 = BaseApplyPackedOutputSimple_avx2_Float64
	ApplyPackedOutputAccumFloat16 = BaseApplyPackedOutputAccum_avx2_Float16
	ApplyPackedOutputAccumBFloat16 = BaseApplyPackedOutputAccum_avx2_BFloat16
	ApplyPackedOutputAccumFloat32 = BaseApplyPackedOutputAccum_avx2
	ApplyPackedOutputAccumFloat64 = BaseApplyPackedOutputAccum_avx2_Float64
}

func initPacking_opsAVX512() {
	PackRHSFastFloat16 = BasePackRHSFast_avx512_Float16
	PackRHSFastBFloat16 = BasePackRHSFast_avx512_BFloat16
	PackRHSFastFloat32 = BasePackRHSFast_avx512
	PackRHSFastFloat64 = BasePackRHSFast_avx512_Float64
	ApplyPackedOutputFloat16 = BaseApplyPackedOutput_avx512_Float16
	ApplyPackedOutputBFloat16 = BaseApplyPackedOutput_avx512_BFloat16
	ApplyPackedOutputFloat32 = BaseApplyPackedOutput_avx512
	ApplyPackedOutputFloat64 = BaseApplyPackedOutput_avx512_Float64
	ApplyPackedOutputSimpleFloat16 = BaseApplyPackedOutputSimple_avx512_Float16
	ApplyPackedOutputSimpleBFloat16 = BaseApplyPackedOutputSimple_avx512_BFloat16
	ApplyPackedOutputSimpleFloat32 = BaseApplyPackedOutputSimple_avx512
	ApplyPackedOutputSimpleFloat64 = BaseApplyPackedOutputSimple_avx512_Float64
	ApplyPackedOutputAccumFloat16 = BaseApplyPackedOutputAccum_avx512_Float16
	ApplyPackedOutputAccumBFloat16 = BaseApplyPackedOutputAccum_avx512_BFloat16
	ApplyPackedOutputAccumFloat32 = BaseApplyPackedOutputAccum_avx512
	ApplyPackedOutputAccumFloat64 = BaseApplyPackedOutputAccum_avx512_Float64
}

func initPacking_opsFallback() {
	PackRHSFastFloat16 = BasePackRHSFast_fallback_Float16
	PackRHSFastBFloat16 = BasePackRHSFast_fallback_BFloat16
	PackRHSFastFloat32 = BasePackRHSFast_fallback
	PackRHSFastFloat64 = BasePackRHSFast_fallback_Float64
	ApplyPackedOutputFloat16 = BaseApplyPackedOutput_fallback_Float16
	ApplyPackedOutputBFloat16 = BaseApplyPackedOutput_fallback_BFloat16
	ApplyPackedOutputFloat32 = BaseApplyPackedOutput_fallback
	ApplyPackedOutputFloat64 = BaseApplyPackedOutput_fallback_Float64
	ApplyPackedOutputSimpleFloat16 = BaseApplyPackedOutputSimple_fallback_Float16
	ApplyPackedOutputSimpleBFloat16 = BaseApplyPackedOutputSimple_fallback_BFloat16
	ApplyPackedOutputSimpleFloat32 = BaseApplyPackedOutputSimple_fallback
	ApplyPackedOutputSimpleFloat64 = BaseApplyPackedOutputSimple_fallback_Float64
	ApplyPackedOutputAccumFloat16 = BaseApplyPackedOutputAccum_fallback_Float16
	ApplyPackedOutputAccumBFloat16 = BaseApplyPackedOutputAccum_fallback_BFloat16
	ApplyPackedOutputAccumFloat32 = BaseApplyPackedOutputAccum_fallback
	ApplyPackedOutputAccumFloat64 = BaseApplyPackedOutputAccum_fallback_Float64
}
