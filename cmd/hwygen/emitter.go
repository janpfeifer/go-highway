package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/printer"
	"go/token"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

// ContribPackages tracks which contrib subpackages are needed for imports.
type ContribPackages struct {
	Math   bool // contrib/math (Exp, Log, Sin, etc.)
	Dot    bool // contrib/dot (Dot product)
	MatVec bool // contrib/matvec (Matrix-vector ops)
	Algo   bool // contrib/algo (Transform utilities)
}

// detectContribPackages analyzes parsed functions to determine which contrib subpackages are used.
func detectContribPackages(funcs []ParsedFunc, targets []Target) ContribPackages {
	pkgs := ContribPackages{}

	for _, pf := range funcs {
		for _, call := range pf.HwyCalls {
			// Check each target's OpMap for this function
			for _, target := range targets {
				if opInfo, ok := target.OpMap[call.FuncName]; ok {
					switch opInfo.SubPackage {
					case "math":
						pkgs.Math = true
					case "dot":
						pkgs.Dot = true
					case "matvec":
						pkgs.MatVec = true
					case "algo":
						pkgs.Algo = true
					}
				}
			}
		}
	}

	return pkgs
}

// EmitDispatcher generates the runtime dispatch file.
// This file contains:
// - Function variables (var Sigmoid func(...))
// - init() function with CPU detection
// - Target-specific initialization functions
func EmitDispatcher(funcs []ParsedFunc, targets []Target, pkgName, outPath string) error {
	var buf bytes.Buffer

	// Only import archsimd if we have non-fallback targets
	hasSimdTarget := false
	for _, target := range targets {
		if target.Name != "Fallback" {
			hasSimdTarget = true
			break
		}
	}

	// File header with build tag if using SIMD
	fmt.Fprintf(&buf, "// Code generated by hwygen. DO NOT EDIT.\n")
	if hasSimdTarget {
		fmt.Fprintf(&buf, "//go:build amd64 && goexperiment.simd\n")
	}
	fmt.Fprintf(&buf, "\npackage %s\n\n", pkgName)

	// Imports
	fmt.Fprintf(&buf, "import (\n")
	fmt.Fprintf(&buf, "\t\"os\"\n")

	if hasSimdTarget {
		fmt.Fprintf(&buf, "\t\"simd/archsimd\"\n")
	}

	fmt.Fprintf(&buf, ")\n\n")

	// Declare function variables
	for _, pf := range funcs {
		// Get concrete types to generate
		var concreteTypes []string
		if len(pf.TypeParams) > 0 {
			concreteTypes = GetConcreteTypes(pf.TypeParams[0].Constraint)
		} else {
			concreteTypes = []string{"float32"} // Default if not generic
		}

		for _, elemType := range concreteTypes {
			funcName := buildDispatchFuncName(pf.Name, elemType)
			signature := buildFuncSignature(pf, elemType)
			fmt.Fprintf(&buf, "var %s func%s\n", funcName, signature)
		}
	}
	fmt.Fprintf(&buf, "\n")

	// Generate init() function
	fmt.Fprintf(&buf, "func init() {\n")
	fmt.Fprintf(&buf, "\tif os.Getenv(\"HWY_NO_SIMD\") != \"\" {\n")
	fmt.Fprintf(&buf, "\t\tinitFallback()\n")
	fmt.Fprintf(&buf, "\t\treturn\n")
	fmt.Fprintf(&buf, "\t}\n")

	// Add CPU detection for each non-fallback target
	for _, target := range targets {
		if target.Name == "Fallback" {
			continue
		}

		switch target.Name {
		case "AVX512":
			fmt.Fprintf(&buf, "\tif archsimd.X86.AVX512() {\n")
			fmt.Fprintf(&buf, "\t\tinitAVX512()\n")
			fmt.Fprintf(&buf, "\t\treturn\n")
			fmt.Fprintf(&buf, "\t}\n")
		case "AVX2":
			fmt.Fprintf(&buf, "\tif archsimd.X86.AVX2() {\n")
			fmt.Fprintf(&buf, "\t\tinitAVX2()\n")
			fmt.Fprintf(&buf, "\t\treturn\n")
			fmt.Fprintf(&buf, "\t}\n")
		}
	}

	// Fallback to scalar
	fmt.Fprintf(&buf, "\tinitFallback()\n")
	fmt.Fprintf(&buf, "}\n\n")

	// Generate init functions for each target
	for _, target := range targets {
		initFuncName := "init" + target.Name
		fmt.Fprintf(&buf, "func %s() {\n", initFuncName)

		for _, pf := range funcs {
			var concreteTypes []string
			if len(pf.TypeParams) > 0 {
				concreteTypes = GetConcreteTypes(pf.TypeParams[0].Constraint)
			} else {
				concreteTypes = []string{"float32"}
			}

			for _, elemType := range concreteTypes {
				dispatchName := buildDispatchFuncName(pf.Name, elemType)
				implName := pf.Name + target.Suffix()
				if elemType != "float32" {
					implName = implName + "_" + strings.Title(elemType)
				}
				fmt.Fprintf(&buf, "\t%s = %s\n", dispatchName, implName)
			}
		}

		fmt.Fprintf(&buf, "}\n\n")
	}

	// Format the code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// If formatting fails, show the error but write unformatted code for debugging
		fmt.Fprintf(os.Stderr, "Warning: formatting failed: %v\n", err)
		formatted = buf.Bytes()
	}

	// Write to file
	filename := filepath.Join(outPath, "dispatch.gen.go")
	if err := os.WriteFile(filename, formatted, 0644); err != nil {
		return fmt.Errorf("write dispatcher: %w", err)
	}

	return nil
}

// EmitTarget generates a target-specific implementation file.
func EmitTarget(funcs []*ast.FuncDecl, target Target, pkgName, baseName, outPath string, contribPkgs ContribPackages) error {
	var buf bytes.Buffer

	// File header
	fmt.Fprintf(&buf, "// Code generated by hwygen. DO NOT EDIT.\n")
	if target.BuildTag != "" {
		fmt.Fprintf(&buf, "//go:build %s\n", target.BuildTag)
	}
	fmt.Fprintf(&buf, "\npackage %s\n\n", pkgName)

	// Build import list
	imports := []string{}

	if target.Name != "Fallback" {
		imports = append(imports, `"simd/archsimd"`)
		// Add contrib subpackage imports for SIMD targets
		if contribPkgs.Math {
			imports = append(imports, `"github.com/ajroetker/go-highway/hwy/contrib/math"`)
		}
		if contribPkgs.Dot {
			imports = append(imports, `"github.com/ajroetker/go-highway/hwy/contrib/dot"`)
		}
		if contribPkgs.MatVec {
			imports = append(imports, `"github.com/ajroetker/go-highway/hwy/contrib/matvec"`)
		}
		if contribPkgs.Algo {
			imports = append(imports, `"github.com/ajroetker/go-highway/hwy/contrib/algo"`)
		}
		// Also add stdmath for scalar tail code that may use math functions
		imports = append(imports, `stdmath "math"`)
	} else {
		// Fallback uses the hwy package directly for core ops
		imports = append(imports, `"github.com/ajroetker/go-highway/hwy"`)
		// Fallback also uses contrib subpackages for their portable generic implementations
		if contribPkgs.Math {
			imports = append(imports, `"github.com/ajroetker/go-highway/hwy/contrib/math"`)
		}
		if contribPkgs.Dot {
			imports = append(imports, `"github.com/ajroetker/go-highway/hwy/contrib/dot"`)
		}
		if contribPkgs.MatVec {
			imports = append(imports, `"github.com/ajroetker/go-highway/hwy/contrib/matvec"`)
		}
		if contribPkgs.Algo {
			imports = append(imports, `"github.com/ajroetker/go-highway/hwy/contrib/algo"`)
		}
		// Also add stdmath for scalar tail code that may use math functions
		imports = append(imports, `stdmath "math"`)
	}

	// Sort imports for consistency
	sort.Strings(imports)

	// Write imports
	fmt.Fprintf(&buf, "import (\n")
	for _, imp := range imports {
		fmt.Fprintf(&buf, "\t%s\n", imp)
	}
	fmt.Fprintf(&buf, ")\n\n")

	// Print each function
	fset := token.NewFileSet()
	for _, funcDecl := range funcs {
		if err := printer.Fprint(&buf, fset, funcDecl); err != nil {
			return fmt.Errorf("print function: %w", err)
		}
		fmt.Fprintf(&buf, "\n\n")
	}

	// Format the code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		fmt.Fprintf(os.Stderr, "Warning: formatting failed for %s: %v\n", target.Name, err)
		formatted = buf.Bytes()
	}

	// Determine output filename
	filename := filepath.Join(outPath, baseName+target.Suffix()+".gen.go")

	// Write to file
	if err := os.WriteFile(filename, formatted, 0644); err != nil {
		return fmt.Errorf("write target file: %w", err)
	}

	return nil
}

// buildDispatchFuncName creates the public function name for the dispatcher.
// BaseSigmoid[float32] -> Sigmoid
// BaseSigmoid[float64] -> SigmoidFloat64
func buildDispatchFuncName(baseName, elemType string) string {
	// Remove "Base" prefix
	name := strings.TrimPrefix(baseName, "Base")

	// Add type suffix for non-float32 types
	if elemType != "float32" {
		name = name + strings.Title(elemType)
	}

	return name
}

// buildFuncSignature builds a function signature string from ParsedFunc.
func buildFuncSignature(pf ParsedFunc, elemType string) string {
	var buf bytes.Buffer

	// Parameters
	buf.WriteString("(")
	for i, param := range pf.Params {
		if i > 0 {
			buf.WriteString(", ")
		}
		paramType := specializeType(param.Type, pf.TypeParams, elemType)
		buf.WriteString(param.Name)
		buf.WriteString(" ")
		buf.WriteString(paramType)
	}
	buf.WriteString(")")

	// Return values
	if len(pf.Returns) > 0 {
		buf.WriteString(" ")
		if len(pf.Returns) == 1 && pf.Returns[0].Name == "" {
			// Single unnamed return
			retType := specializeType(pf.Returns[0].Type, pf.TypeParams, elemType)
			buf.WriteString(retType)
		} else {
			// Multiple or named returns
			buf.WriteString("(")
			for i, ret := range pf.Returns {
				if i > 0 {
					buf.WriteString(", ")
				}
				if ret.Name != "" {
					buf.WriteString(ret.Name)
					buf.WriteString(" ")
				}
				retType := specializeType(ret.Type, pf.TypeParams, elemType)
				buf.WriteString(retType)
			}
			buf.WriteString(")")
		}
	}

	return buf.String()
}

// getBaseFilename extracts the base filename without extension.
func getBaseFilename(path string) string {
	base := filepath.Base(path)
	ext := filepath.Ext(base)
	return base[:len(base)-len(ext)]
}
