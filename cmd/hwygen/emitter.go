package main

import (
	"bytes"
	"fmt"
	"go/ast"
	"go/format"
	"go/printer"
	"go/token"
	"os"
	"path/filepath"
	"sort"
	"strings"
)

// ContribPackages tracks which contrib subpackages are needed for imports.
type ContribPackages struct {
	Math   bool // contrib/math (Exp, Log, Sin, etc.)
	Dot    bool // contrib/dot (Dot product)
	MatVec bool // contrib/matvec (Matrix-vector ops)
	Algo   bool // contrib/algo (Transform utilities)
}

// detectContribPackages analyzes parsed functions to determine which contrib subpackages are used.
func detectContribPackages(funcs []ParsedFunc, targets []Target) ContribPackages {
	pkgs := ContribPackages{}

	for _, pf := range funcs {
		for _, call := range pf.HwyCalls {
			// Check each target's OpMap for this function
			for _, target := range targets {
				if opInfo, ok := target.OpMap[call.FuncName]; ok {
					switch opInfo.SubPackage {
					case "math":
						pkgs.Math = true
					case "dot":
						pkgs.Dot = true
					case "matvec":
						pkgs.MatVec = true
					case "algo":
						pkgs.Algo = true
					}
				}
			}
		}
	}

	return pkgs
}

// EmitDispatcher generates the runtime dispatch file(s).
// This generates architecture-specific dispatch files:
// - dispatch_amd64.gen.go for AVX2/AVX512
// - dispatch_arm64.gen.go for NEON
// - dispatch.gen.go for fallback-only (no build tags)
func EmitDispatcher(funcs []ParsedFunc, targets []Target, pkgName, outPath string) error {
	// Group targets by architecture
	amd64Targets := []Target{}
	arm64Targets := []Target{}
	hasFallback := false

	for _, target := range targets {
		switch target.Arch() {
		case "amd64":
			amd64Targets = append(amd64Targets, target)
		case "arm64":
			arm64Targets = append(arm64Targets, target)
		default:
			if target.Name == "Fallback" {
				hasFallback = true
			}
		}
	}

	// Generate amd64 dispatch if we have amd64 targets
	if len(amd64Targets) > 0 {
		if err := emitArchDispatcher(funcs, amd64Targets, hasFallback, pkgName, outPath, "amd64"); err != nil {
			return err
		}
	}

	// Generate arm64 dispatch if we have arm64 targets
	if len(arm64Targets) > 0 {
		if err := emitArchDispatcher(funcs, arm64Targets, hasFallback, pkgName, outPath, "arm64"); err != nil {
			return err
		}
	}

	// Generate fallback-only dispatch if only fallback is requested
	if len(amd64Targets) == 0 && len(arm64Targets) == 0 && hasFallback {
		if err := emitFallbackOnlyDispatcher(funcs, pkgName, outPath); err != nil {
			return err
		}
	}

	return nil
}

// emitArchDispatcher generates an architecture-specific dispatch file.
func emitArchDispatcher(funcs []ParsedFunc, archTargets []Target, hasFallback bool, pkgName, outPath, arch string) error {
	var buf bytes.Buffer

	// Determine build tag based on architecture
	// amd64 requires goexperiment.simd for archsimd
	// arm64 uses our asm package which doesn't require the SIMD experiment
	var buildTag string
	if arch == "amd64" {
		buildTag = arch + " && goexperiment.simd"
	} else {
		buildTag = arch
	}

	// File header with build tag
	fmt.Fprintf(&buf, "// Code generated by hwygen. DO NOT EDIT.\n")
	fmt.Fprintf(&buf, "//go:build %s\n", buildTag)
	fmt.Fprintf(&buf, "\npackage %s\n\n", pkgName)

	// Imports - amd64 needs archsimd, arm64 doesn't
	fmt.Fprintf(&buf, "import (\n")
	fmt.Fprintf(&buf, "\t\"os\"\n")
	if arch == "amd64" {
		fmt.Fprintf(&buf, "\t\"simd/archsimd\"\n")
	}
	fmt.Fprintf(&buf, ")\n\n")

	// Declare function variables
	for _, pf := range funcs {
		var concreteTypes []string
		if len(pf.TypeParams) > 0 {
			concreteTypes = GetConcreteTypes(pf.TypeParams[0].Constraint)
		} else {
			concreteTypes = []string{"float32"}
		}

		for _, elemType := range concreteTypes {
			funcName := buildDispatchFuncName(pf.Name, elemType)
			signature := buildFuncSignature(pf, elemType)
			fmt.Fprintf(&buf, "var %s func%s\n", funcName, signature)
		}
	}
	fmt.Fprintf(&buf, "\n")

	// Generate init() function
	fmt.Fprintf(&buf, "func init() {\n")
	fmt.Fprintf(&buf, "\tif os.Getenv(\"HWY_NO_SIMD\") != \"\" {\n")
	fmt.Fprintf(&buf, "\t\tinitFallback()\n")
	fmt.Fprintf(&buf, "\t\treturn\n")
	fmt.Fprintf(&buf, "\t}\n")

	// Add CPU detection for each target
	for _, target := range archTargets {
		switch target.Name {
		case "AVX512":
			fmt.Fprintf(&buf, "\tif archsimd.X86.AVX512() {\n")
			fmt.Fprintf(&buf, "\t\tinitAVX512()\n")
			fmt.Fprintf(&buf, "\t\treturn\n")
			fmt.Fprintf(&buf, "\t}\n")
		case "AVX2":
			fmt.Fprintf(&buf, "\tif archsimd.X86.AVX2() {\n")
			fmt.Fprintf(&buf, "\t\tinitAVX2()\n")
			fmt.Fprintf(&buf, "\t\treturn\n")
			fmt.Fprintf(&buf, "\t}\n")
		case "NEON":
			// NEON is always available on arm64, so just init directly
			fmt.Fprintf(&buf, "\tinitNEON()\n")
			fmt.Fprintf(&buf, "\treturn\n")
		}
	}

	// Fallback to scalar (only if not NEON which always succeeds)
	if arch != "arm64" {
		fmt.Fprintf(&buf, "\tinitFallback()\n")
	}
	fmt.Fprintf(&buf, "}\n\n")

	// Generate init functions for each target
	for _, target := range archTargets {
		initFuncName := "init" + target.Name
		fmt.Fprintf(&buf, "func %s() {\n", initFuncName)

		for _, pf := range funcs {
			var concreteTypes []string
			if len(pf.TypeParams) > 0 {
				concreteTypes = GetConcreteTypes(pf.TypeParams[0].Constraint)
			} else {
				concreteTypes = []string{"float32"}
			}

			for _, elemType := range concreteTypes {
				dispatchName := buildDispatchFuncName(pf.Name, elemType)
				implName := pf.Name + target.Suffix()
				if elemType != "float32" {
					implName = implName + "_" + strings.Title(elemType)
				}
				fmt.Fprintf(&buf, "\t%s = %s\n", dispatchName, implName)
			}
		}

		fmt.Fprintf(&buf, "}\n\n")
	}

	// Generate fallback init function if needed
	if hasFallback {
		fmt.Fprintf(&buf, "func initFallback() {\n")
		for _, pf := range funcs {
			var concreteTypes []string
			if len(pf.TypeParams) > 0 {
				concreteTypes = GetConcreteTypes(pf.TypeParams[0].Constraint)
			} else {
				concreteTypes = []string{"float32"}
			}

			for _, elemType := range concreteTypes {
				dispatchName := buildDispatchFuncName(pf.Name, elemType)
				implName := pf.Name + "_fallback"
				if elemType != "float32" {
					implName = implName + "_" + strings.Title(elemType)
				}
				fmt.Fprintf(&buf, "\t%s = %s\n", dispatchName, implName)
			}
		}
		fmt.Fprintf(&buf, "}\n")
	}

	// Format the code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		fmt.Fprintf(os.Stderr, "Warning: formatting failed: %v\n", err)
		formatted = buf.Bytes()
	}

	// Write to file with architecture suffix
	filename := filepath.Join(outPath, fmt.Sprintf("dispatch_%s.gen.go", arch))
	if err := os.WriteFile(filename, formatted, 0644); err != nil {
		return fmt.Errorf("write dispatcher: %w", err)
	}

	return nil
}

// emitFallbackOnlyDispatcher generates a dispatch file with no build tags for fallback-only builds.
func emitFallbackOnlyDispatcher(funcs []ParsedFunc, pkgName, outPath string) error {
	var buf bytes.Buffer

	fmt.Fprintf(&buf, "// Code generated by hwygen. DO NOT EDIT.\n")
	fmt.Fprintf(&buf, "\npackage %s\n\n", pkgName)

	fmt.Fprintf(&buf, "import \"os\"\n\n")

	// Declare function variables
	for _, pf := range funcs {
		var concreteTypes []string
		if len(pf.TypeParams) > 0 {
			concreteTypes = GetConcreteTypes(pf.TypeParams[0].Constraint)
		} else {
			concreteTypes = []string{"float32"}
		}

		for _, elemType := range concreteTypes {
			funcName := buildDispatchFuncName(pf.Name, elemType)
			signature := buildFuncSignature(pf, elemType)
			fmt.Fprintf(&buf, "var %s func%s\n", funcName, signature)
		}
	}
	fmt.Fprintf(&buf, "\n")

	// Simple init that just uses fallback
	fmt.Fprintf(&buf, "func init() {\n")
	fmt.Fprintf(&buf, "\t_ = os.Getenv // silence unused import\n")
	fmt.Fprintf(&buf, "\tinitFallback()\n")
	fmt.Fprintf(&buf, "}\n\n")

	fmt.Fprintf(&buf, "func initFallback() {\n")
	for _, pf := range funcs {
		var concreteTypes []string
		if len(pf.TypeParams) > 0 {
			concreteTypes = GetConcreteTypes(pf.TypeParams[0].Constraint)
		} else {
			concreteTypes = []string{"float32"}
		}

		for _, elemType := range concreteTypes {
			dispatchName := buildDispatchFuncName(pf.Name, elemType)
			implName := pf.Name + "_fallback"
			if elemType != "float32" {
				implName = implName + "_" + strings.Title(elemType)
			}
			fmt.Fprintf(&buf, "\t%s = %s\n", dispatchName, implName)
		}
	}
	fmt.Fprintf(&buf, "}\n")

	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		fmt.Fprintf(os.Stderr, "Warning: formatting failed: %v\n", err)
		formatted = buf.Bytes()
	}

	filename := filepath.Join(outPath, "dispatch.gen.go")
	if err := os.WriteFile(filename, formatted, 0644); err != nil {
		return fmt.Errorf("write dispatcher: %w", err)
	}

	return nil
}

// EmitTarget generates a target-specific implementation file.
func EmitTarget(funcs []*ast.FuncDecl, target Target, pkgName, baseName, outPath string, contribPkgs ContribPackages) error {
	var buf bytes.Buffer

	// File header
	fmt.Fprintf(&buf, "// Code generated by hwygen. DO NOT EDIT.\n")
	if target.BuildTag != "" {
		fmt.Fprintf(&buf, "//go:build %s\n", target.BuildTag)
	}
	fmt.Fprintf(&buf, "\npackage %s\n\n", pkgName)

	// Build import list
	imports := []string{}

	if target.Name != "Fallback" {
		// Import the appropriate vector package
		switch target.VecPackage {
		case "archsimd":
			imports = append(imports, `"simd/archsimd"`)
		case "asm":
			imports = append(imports, `"github.com/ajroetker/go-highway/hwy/asm"`)
		}
		// Add contrib subpackage imports for SIMD targets
		if contribPkgs.Math {
			imports = append(imports, `"github.com/ajroetker/go-highway/hwy/contrib/math"`)
		}
		if contribPkgs.Dot {
			imports = append(imports, `"github.com/ajroetker/go-highway/hwy/contrib/dot"`)
		}
		if contribPkgs.MatVec {
			imports = append(imports, `"github.com/ajroetker/go-highway/hwy/contrib/matvec"`)
		}
		if contribPkgs.Algo {
			imports = append(imports, `"github.com/ajroetker/go-highway/hwy/contrib/algo"`)
		}
		// Also add stdmath for scalar tail code that may use math functions
		imports = append(imports, `stdmath "math"`)
	} else {
		// Fallback uses the hwy package directly for core ops
		imports = append(imports, `"github.com/ajroetker/go-highway/hwy"`)
		// Fallback also uses contrib subpackages for their portable generic implementations
		if contribPkgs.Math {
			imports = append(imports, `"github.com/ajroetker/go-highway/hwy/contrib/math"`)
		}
		if contribPkgs.Dot {
			imports = append(imports, `"github.com/ajroetker/go-highway/hwy/contrib/dot"`)
		}
		if contribPkgs.MatVec {
			imports = append(imports, `"github.com/ajroetker/go-highway/hwy/contrib/matvec"`)
		}
		if contribPkgs.Algo {
			imports = append(imports, `"github.com/ajroetker/go-highway/hwy/contrib/algo"`)
		}
		// Also add stdmath for scalar tail code that may use math functions
		imports = append(imports, `stdmath "math"`)
	}

	// Sort imports for consistency
	sort.Strings(imports)

	// Write imports
	fmt.Fprintf(&buf, "import (\n")
	for _, imp := range imports {
		fmt.Fprintf(&buf, "\t%s\n", imp)
	}
	fmt.Fprintf(&buf, ")\n\n")

	// Print each function
	fset := token.NewFileSet()
	for _, funcDecl := range funcs {
		if err := printer.Fprint(&buf, fset, funcDecl); err != nil {
			return fmt.Errorf("print function: %w", err)
		}
		fmt.Fprintf(&buf, "\n\n")
	}

	// Format the code
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		fmt.Fprintf(os.Stderr, "Warning: formatting failed for %s: %v\n", target.Name, err)
		formatted = buf.Bytes()
	}

	// Determine output filename
	filename := filepath.Join(outPath, baseName+target.Suffix()+".gen.go")

	// Write to file
	if err := os.WriteFile(filename, formatted, 0644); err != nil {
		return fmt.Errorf("write target file: %w", err)
	}

	return nil
}

// buildDispatchFuncName creates the public function name for the dispatcher.
// BaseSigmoid[float32] -> Sigmoid
// BaseSigmoid[float64] -> SigmoidFloat64
func buildDispatchFuncName(baseName, elemType string) string {
	// Remove "Base" prefix
	name := strings.TrimPrefix(baseName, "Base")

	// Add type suffix for non-float32 types
	if elemType != "float32" {
		name = name + strings.Title(elemType)
	}

	return name
}

// buildFuncSignature builds a function signature string from ParsedFunc.
func buildFuncSignature(pf ParsedFunc, elemType string) string {
	var buf bytes.Buffer

	// Parameters
	buf.WriteString("(")
	for i, param := range pf.Params {
		if i > 0 {
			buf.WriteString(", ")
		}
		paramType := specializeType(param.Type, pf.TypeParams, elemType)
		buf.WriteString(param.Name)
		buf.WriteString(" ")
		buf.WriteString(paramType)
	}
	buf.WriteString(")")

	// Return values
	if len(pf.Returns) > 0 {
		buf.WriteString(" ")
		if len(pf.Returns) == 1 && pf.Returns[0].Name == "" {
			// Single unnamed return
			retType := specializeType(pf.Returns[0].Type, pf.TypeParams, elemType)
			buf.WriteString(retType)
		} else {
			// Multiple or named returns
			buf.WriteString("(")
			for i, ret := range pf.Returns {
				if i > 0 {
					buf.WriteString(", ")
				}
				if ret.Name != "" {
					buf.WriteString(ret.Name)
					buf.WriteString(" ")
				}
				retType := specializeType(ret.Type, pf.TypeParams, elemType)
				buf.WriteString(retType)
			}
			buf.WriteString(")")
		}
	}

	return buf.String()
}

// getBaseFilename extracts the base filename without extension.
func getBaseFilename(path string) string {
	base := filepath.Base(path)
	ext := filepath.Ext(base)
	return base[:len(base)-len(ext)]
}
