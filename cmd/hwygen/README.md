# hwygen - Highway Code Generator

`hwygen` is a code generation tool that transforms portable `hwy.*` SIMD operations into architecture-specific implementations with runtime CPU dispatch.

## Overview

The generator takes Go source files containing `hwy.*` calls and produces:

1. **Dispatcher file** (`dispatch.gen.go`) - Runtime CPU detection and function dispatch
2. **Target-specific files** - Architecture-optimized implementations (AVX2, AVX512, fallback)

## Installation

```bash
cd cmd/hwygen
go build -o ../../bin/hwygen
```

## Usage

### Command Line

```bash
hwygen -input sigmoid.go -output . -targets avx2,fallback
```

### Flags

- `-input string` - Input Go source file (required)
- `-output string` - Output directory (default: ".")
- `-targets string` - Comma-separated targets: avx2,avx512,fallback (default: "avx2,fallback")
- `-pkg string` - Output package name (default: same as input)

### go:generate Integration

Add to your source file (using local source):

```go
//go:generate go run ../../../cmd/hwygen -input $GOFILE -output . -targets avx2,fallback

package mypackage

import "github.com/ajroetker/go-highway/hwy"

func BaseSigmoid[T hwy.Floats](in, out []T) {
    size := min(len(in), len(out))
    vOne := hwy.Set(T(1))
    for ii := 0; ii < size; ii += vOne.NumLanes() {
        x := hwy.Load(in[ii:])
        negX := hwy.Neg(x)
        y := hwy.Div(vOne, hwy.Add(vOne, negX))
        hwy.Store(y, out[ii:])
    }
}
```

Then run:

```bash
go generate
```

## Input Requirements

### Function Naming

Functions to be transformed must:
- Start with `Base` prefix (e.g., `BaseSigmoid`, `BaseAdd`)
- Use generic type parameters from `hwy.Floats`, `hwy.Integers`, etc.
- Use `hwy.*` operations for SIMD operations

### Supported Operations

**Load/Store:**
- `hwy.Load(src)` - Load vector from slice
- `hwy.Store(v, dst)` - Store vector to slice
- `hwy.Set(value)` - Broadcast scalar to all lanes
- `hwy.Zero()` - Create zero vector

**Arithmetic:**
- `hwy.Add(a, b)` - Element-wise addition
- `hwy.Sub(a, b)` - Element-wise subtraction
- `hwy.Mul(a, b)` - Element-wise multiplication
- `hwy.Div(a, b)` - Element-wise division
- `hwy.Neg(v)` - Negate all lanes
- `hwy.Abs(v)` - Absolute value

**Math:**
- `hwy.Sqrt(v)` - Square root
- `hwy.FMA(a, b, c)` - Fused multiply-add (a*b+c)
- `hwy.Min(a, b)` - Element-wise minimum
- `hwy.Max(a, b)` - Element-wise maximum

**Comparisons:**
- `hwy.Equal(a, b)` - Returns mask
- `hwy.LessThan(a, b)` - Returns mask
- `hwy.GreaterThan(a, b)` - Returns mask

**Conditional:**
- `hwy.IfThenElse(mask, a, b)` - Conditional selection

**Reductions:**
- `hwy.ReduceSum(v)` - Sum all lanes

## Output Files

### Dispatcher (`dispatch.gen.go`)

```go
// Code generated by hwygen. DO NOT EDIT.

package mypackage

import (
    "os"
    "simd/archsimd"
)

var Sigmoid func(in, out []float32)
var SigmoidFloat64 func(in, out []float64)

func init() {
    if os.Getenv("HWY_NO_SIMD") != "" {
        initFallback()
        return
    }
    if archsimd.HasAVX2() {
        initAVX2()
        return
    }
    initFallback()
}

func initAVX2() {
    Sigmoid = BaseSigmoid_avx2
    SigmoidFloat64 = BaseSigmoid_avx2_Float64
}

func initFallback() {
    Sigmoid = BaseSigmoid_fallback
    SigmoidFloat64 = BaseSigmoid_fallback_Float64
}
```

### AVX2 Target (`sigmoid_avx2.gen.go`)

```go
//go:build amd64 && simd

package mypackage

import "simd/archsimd"

func BaseSigmoid_avx2(in, out []float32) {
    size := min(len(in), len(out))
    const lanes = 8
    vOne := archsimd.BroadcastFloat32x8(1)

    ii := 0
    for ; ii+lanes <= size; ii += lanes {
        x := archsimd.LoadFloat32x8Slice(in[ii:])
        negX := x.Neg()
        y := vOne.Div(vOne.Add(negX))
        y.StoreSlice(out[ii:])
    }

    // Scalar tail
    for ; ii < size; ii++ {
        in[ii] = 1.0 / (1.0 + (-in[ii]))
    }
}
```

### Fallback Target (`sigmoid_fallback.gen.go`)

```go
package mypackage

import "github.com/ajroetker/go-highway/hwy"

func BaseSigmoid_fallback(in, out []float32) {
    size := min(len(in), len(out))
    vOne := hwy.Set[float32](1)
    for ii := 0; ii < size; ii += vOne.NumLanes() {
        x := hwy.Load(in[ii:])
        negX := hwy.Neg(x)
        y := hwy.Div(vOne, hwy.Add(vOne, negX))
        hwy.Store(y, out[ii:])
    }
}
```

## Target Architectures

### AVX2 (256-bit SIMD)

- **Build tag:** `amd64 && simd`
- **Vector width:** 32 bytes
- **Lanes:** 8x float32, 4x float64, 8x int32, 4x int64
- **Operations:** Transformed to `archsimd.*` method calls

### AVX-512 (512-bit SIMD)

- **Build tag:** `amd64 && simd && avx512`
- **Vector width:** 64 bytes
- **Lanes:** 16x float32, 8x float64, 16x int32, 8x int64
- **Operations:** Transformed to `archsimd.*` method calls

### Fallback (Scalar)

- **Build tag:** None (always available)
- **Vector width:** 16 bytes (minimal)
- **Operations:** Uses `hwy.*` package functions

## Transformation Rules

### Generic Type Specialization

Input:
```go
func BaseAdd[T hwy.Floats](a, b []T) { ... }
```

Output (for float32):
```go
func BaseAdd_avx2(a, b []float32) { ... }
```

Output (for float64):
```go
func BaseAdd_avx2_Float64(a, b []float64) { ... }
```

### Special `hwy.Float16` and `hwy.BFloat16` types

Since Go doesn't natively support `float16` and `bfloat16` types, `hwy` adds an implementation for them.

They required specialized handling though: if they are accessed normally, they are implicitly "promoted" to float32.
But when the promoted type is used, for instance, to be passed to another function, it needs to be explicity
converted back, usually using the generic type `T(myPromotedValue)`. This is a no-op for other float types,
but for `hwy.Float16` and `hwy.BFloat16` it will generate the correct conversion.

Example:

```go
func BaseOnePlus[T hwy.Floats](x T) {
    return T(x+1)
}
```

Generated code:

```go
func BaseOnePlus_fallback_float16(x hwy.Float16) {
    return hwy.Float32ToFloat16(x.Float32()+1)
}
```

### Operation Transformation

| Portable | AVX2 | Fallback |
|----------|------|----------|
| `hwy.Load(src)` | `archsimd.LoadFloat32x8Slice(src)` | `hwy.Load(src)` |
| `hwy.Add(a, b)` | `a.Add(b)` | `hwy.Add(a, b)` |
| `hwy.Store(v, dst)` | `v.StoreSlice(dst)` | `hwy.Store(v, dst)` |

### Loop Transformation

Input:
```go
for ii := 0; ii < size; ii += vOne.NumLanes() {
    // vector operations
}
```

AVX2 Output:
```go
const lanes = 8
ii := 0
for ; ii+lanes <= size; ii += lanes {
    // vector operations
}
// Scalar tail
for ; ii < size; ii++ {
    // scalar operations
}
```

## Environment Variables

- `HWY_NO_SIMD=1` - Force scalar fallback (useful for testing)

## Testing

```bash
cd cmd/hwygen
go test -v
```

Tests cover:
- Target configuration
- Type parsing
- Function transformation
- Code generation
- End-to-end pipeline

## Architecture

### Components

1. **parser.go** - Parses Go source files and extracts functions with `hwy.*` operations
2. **transformer.go** - Transforms AST for target architectures
3. **emitter.go** - Generates formatted Go code
4. **targets.go** - Target architecture definitions
5. **generator.go** - Orchestrates the pipeline
6. **main.go** - CLI entry point

### Pipeline

```
Input File
    ↓
Parser (AST)
    ↓
For Each Target:
    ↓
Transformer (Specialized AST)
    ↓
Emitter (Target File)
    ↓
Dispatcher Generator
    ↓
Output Files
```

## Known Limitations

1. **Type Inference:** Limited type inference for non-generic code
2. **Error Messages:** Line numbers in errors refer to generated code, not source
3. **Neg Operation:** Implemented as `Zero().Sub(x)` since archsimd lacks a Neg method

## Future Enhancements

- [ ] Better error messages with source line mapping
- [ ] ARM NEON and SVE target support
- [ ] AVX-512 target implementation
- [ ] Benchmark generation
- [ ] IDE integration
- [ ] Masked operations support

## Examples

See `examples/sigmoid/` for a complete working example.

## Contributing

When adding new operations:

1. Update `targets.go` with operation info for each target
2. Update `transformer.go` transformation logic if needed
3. Add tests in `hwygen_test.go`
4. Update this README

## License

Part of the go-highway project. See top-level LICENSE file.
