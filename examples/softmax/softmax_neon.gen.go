// Code generated by hwygen. DO NOT EDIT.
//go:build arm64

package softmax

import (
	"github.com/ajroetker/go-highway/hwy/contrib/algo"
	"github.com/ajroetker/go-highway/hwy/contrib/math"
	stdmath "math"
)

func BaseSoftmax_neon(input []float32, output []float32) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	maxVal := input[0]
	for i := 1; i < size; i++ {
		if input[i] > maxVal {
			maxVal = input[i]
		}
	}
	shifted := make([]float32, size)
	for i := 0; i < size; i++ {
		shifted[i] = input[i] - maxVal
	}
	algo.BaseApply_neon(shifted, output, math.BaseExpVec_neon)
	var expSum float32
	for i := 0; i < size; i++ {
		expSum += output[i]
	}
	invSum := float32(1.0) / expSum
	for i := 0; i < size; i++ {
		output[i] = output[i] * invSum
	}
}

func BaseSoftmax_neon_Float64(input []float64, output []float64) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	maxVal := input[0]
	for i := 1; i < size; i++ {
		if input[i] > maxVal {
			maxVal = input[i]
		}
	}
	shifted := make([]float64, size)
	for i := 0; i < size; i++ {
		shifted[i] = input[i] - maxVal
	}
	algo.BaseApply_neon_Float64(shifted, output, math.BaseExpVec_neon_Float64)
	var expSum float64
	for i := 0; i < size; i++ {
		expSum += output[i]
	}
	invSum := float64(1.0) / expSum
	for i := 0; i < size; i++ {
		output[i] = output[i] * invSum
	}
}

func BaseSoftmaxScalar_neon(input []float32, output []float32) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	maxVal := input[0]
	for i := 1; i < size; i++ {
		if input[i] > maxVal {
			maxVal = input[i]
		}
	}
	var expSum float32
	for i := 0; i < size; i++ {
		output[i] = float32(stdmath.Exp(float64(input[i] - maxVal)))
		expSum += output[i]
	}
	invSum := float32(1.0) / expSum
	for i := 0; i < size; i++ {
		output[i] = output[i] * invSum
	}
}

func BaseSoftmaxScalar_neon_Float64(input []float64, output []float64) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	maxVal := input[0]
	for i := 1; i < size; i++ {
		if input[i] > maxVal {
			maxVal = input[i]
		}
	}
	var expSum float64
	for i := 0; i < size; i++ {
		output[i] = float64(stdmath.Exp(float64(input[i] - maxVal)))
		expSum += output[i]
	}
	invSum := float64(1.0) / expSum
	for i := 0; i < size; i++ {
		output[i] = output[i] * invSum
	}
}
