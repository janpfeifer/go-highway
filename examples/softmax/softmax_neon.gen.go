// Code generated by hwygen. DO NOT EDIT.
//go:build arm64

package softmax

import (
	"github.com/ajroetker/go-highway/hwy/asm"
	"github.com/ajroetker/go-highway/hwy/contrib/math"
	stdmath "math"
)

func BaseSoftmax_neon(input []float32, output []float32) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	maxVal := input[0]
	i := 1
	for ; i+4 <= size; i++ {
		if input[i] > maxVal {
			maxVal = input[i]
		}
	}
	if i < size {
		BaseSoftmax_fallback(input[i:size], output[i:size])
	}
	vMax := asm.BroadcastFloat32x4(maxVal)
	var expSum float32
	for ii := 0; ii+4 <= size; ii += 4 {
		remaining := size - ii
		if remaining >= 4 {
			x := asm.LoadFloat32x4Slice(input[ii:])
			xShifted := x.Sub(vMax)
			expX := math.Exp_NEON_F32x4(xShifted)
			expX.StoreSlice(output[ii:])
			expSum += func() float32 {
				var _simd_temp [4]float32
				expX.StoreSlice(_simd_temp[:])
				return _simd_temp[0] + _simd_temp[1] + _simd_temp[2] + _simd_temp[3]
			}()
		} else {
			for i := ii; i+4 <= size; i++ {
				exp := float32(stdmath.Exp(float64(input[i] - maxVal)))
				output[i] = exp
				expSum += exp
			}
		}
	}
	vSum := asm.BroadcastFloat32x4(expSum)
	for ii := 0; ii+4 <= size; ii += 4 {
		remaining := size - ii
		if remaining >= 4 {
			expX := asm.LoadFloat32x4Slice(output[ii:])
			normalized := expX.Div(vSum)
			normalized.StoreSlice(output[ii:])
		} else {
			for i := ii; i+4 <= size; i++ {
				output[i] = output[i] / expSum
			}
		}
	}
}

func BaseSoftmax_neon_Float64(input []float64, output []float64) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	maxVal := input[0]
	i := 1
	for ; i+2 <= size; i++ {
		if input[i] > maxVal {
			maxVal = input[i]
		}
	}
	if i < size {
		BaseSoftmax_fallback_Float64(input[i:size], output[i:size])
	}
	vMax := asm.BroadcastFloat64x2(maxVal)
	var expSum float64
	for ii := 0; ii+2 <= size; ii += 2 {
		remaining := size - ii
		if remaining >= 2 {
			x := asm.LoadFloat64x2Slice(input[ii:])
			xShifted := x.Sub(vMax)
			expX := math.Exp_NEON_F64x2(xShifted)
			expX.StoreSlice(output[ii:])
			expSum += func() float64 {
				var _simd_temp [2]float64
				expX.StoreSlice(_simd_temp[:])
				return _simd_temp[0] + _simd_temp[1]
			}()
		} else {
			for i := ii; i+2 <= size; i++ {
				exp := float64(stdmath.Exp(float64(input[i] - maxVal)))
				output[i] = exp
				expSum += exp
			}
		}
	}
	vSum := asm.BroadcastFloat64x2(expSum)
	for ii := 0; ii+2 <= size; ii += 2 {
		remaining := size - ii
		if remaining >= 2 {
			expX := asm.LoadFloat64x2Slice(output[ii:])
			normalized := expX.Div(vSum)
			normalized.StoreSlice(output[ii:])
		} else {
			for i := ii; i+2 <= size; i++ {
				output[i] = output[i] / expSum
			}
		}
	}
}
