// Code generated by hwygen. DO NOT EDIT.
//go:build amd64 && goexperiment.simd

package softmax

import (
	"github.com/ajroetker/go-highway/hwy/contrib/math"
	"simd/archsimd"
)

func BaseSoftmax_avx512(input []float32, output []float32) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	maxVal := input[0]
	i := 1
	for ; i+16 <= size; i++ {
		if input[i] > maxVal {
			maxVal = input[i]
		}
	}
	if i < size {
		BaseSoftmax_fallback(input[i:size], output[i:size])
	}
	vMax := archsimd.BroadcastFloat32x16(maxVal)
	var expSum float32
	for ii := 0; ii+16 <= size; ii += 16 {
		remaining := size - ii
		if remaining >= vMax.NumLanes() {
			x := archsimd.LoadFloat32x16Slice(input[ii:])
			xShifted := x.Sub(vMax)
			expX := math.Exp(xShifted)
			expX.StoreSlice(output[ii:])
			expSum += expX.ReduceSum()
		} else {
			for i := ii; i+16 <= size; i++ {
				exp := float32(stdmath.Exp(float64(input[i] - maxVal)))
				output[i] = exp
				expSum += exp
			}
		}
	}
	vSum := archsimd.BroadcastFloat32x16(expSum)
	for ii := 0; ii+16 <= size; ii += 16 {
		remaining := size - ii
		if remaining >= vSum.NumLanes() {
			expX := archsimd.LoadFloat32x16Slice(output[ii:])
			normalized := expX.Div(vSum)
			normalized.StoreSlice(output[ii:])
		} else {
			for i := ii; i+16 <= size; i++ {
				output[i] = output[i] / expSum
			}
		}
	}
}

func BaseSoftmax_avx512_Float64(input []float64, output []float64) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	maxVal := input[0]
	i := 1
	for ; i+8 <= size; i++ {
		if input[i] > maxVal {
			maxVal = input[i]
		}
	}
	if i < size {
		BaseSoftmax_fallback_Float64(input[i:size], output[i:size])
	}
	vMax := archsimd.BroadcastFloat64x8(maxVal)
	var expSum float64
	for ii := 0; ii+8 <= size; ii += 8 {
		remaining := size - ii
		if remaining >= vMax.NumLanes() {
			x := archsimd.LoadFloat64x8Slice(input[ii:])
			xShifted := x.Sub(vMax)
			expX := math.Exp(xShifted)
			expX.StoreSlice(output[ii:])
			expSum += expX.ReduceSum()
		} else {
			for i := ii; i+8 <= size; i++ {
				exp := float64(stdmath.Exp(float64(input[i] - maxVal)))
				output[i] = exp
				expSum += exp
			}
		}
	}
	vSum := archsimd.BroadcastFloat64x8(expSum)
	for ii := 0; ii+8 <= size; ii += 8 {
		remaining := size - ii
		if remaining >= vSum.NumLanes() {
			expX := archsimd.LoadFloat64x8Slice(output[ii:])
			normalized := expX.Div(vSum)
			normalized.StoreSlice(output[ii:])
		} else {
			for i := ii; i+8 <= size; i++ {
				output[i] = output[i] / expSum
			}
		}
	}
}
