// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

//go:build amd64 && goexperiment.simd

package softmax

import (
	stdmath "math"

	"github.com/ajroetker/go-highway/hwy"
	"github.com/ajroetker/go-highway/hwy/contrib/algo"
	"github.com/ajroetker/go-highway/hwy/contrib/math"
)

func BaseSoftmax_avx512_Float16(input []hwy.Float16, output []hwy.Float16) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	maxVal := input[0]
	for i := 1; i < size; i++ {
		if input[i].Float32() > maxVal.Float32() {
			maxVal = input[i]
		}
	}
	shifted := make([]hwy.Float16, size)
	for i := range size {
		shifted[i] = hwy.Float32ToFloat16(input[i].Float32() - maxVal.Float32())
	}
	algo.BaseApply_avx512_Float16(shifted, output, math.BaseExpVec_avx512_Float16)
	var expSum float32
	for i := range size {
		expSum += output[i].Float32()
	}
	invSum := hwy.Float32ToFloat16(float32(1.0) / expSum)
	for i := range size {
		output[i] = hwy.Float32ToFloat16(output[i].Float32() * invSum.Float32())
	}
}

func BaseSoftmax_avx512_BFloat16(input []hwy.BFloat16, output []hwy.BFloat16) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	maxVal := input[0]
	for i := 1; i < size; i++ {
		if input[i].Float32() > maxVal.Float32() {
			maxVal = input[i]
		}
	}
	shifted := make([]hwy.BFloat16, size)
	for i := range size {
		shifted[i] = hwy.Float32ToBFloat16(input[i].Float32() - maxVal.Float32())
	}
	algo.BaseApply_avx512_BFloat16(shifted, output, math.BaseExpVec_avx512_BFloat16)
	var expSum float32
	for i := range size {
		expSum += output[i].Float32()
	}
	invSum := hwy.Float32ToBFloat16(float32(1.0) / expSum)
	for i := range size {
		output[i] = hwy.Float32ToBFloat16(output[i].Float32() * invSum.Float32())
	}
}

func BaseSoftmax_avx512(input []float32, output []float32) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	maxVal := input[0]
	for i := 1; i < size; i++ {
		if input[i] > maxVal {
			maxVal = input[i]
		}
	}
	shifted := make([]float32, size)
	for i := range size {
		shifted[i] = input[i] - maxVal
	}
	algo.BaseApply_avx512(shifted, output, math.BaseExpVec_avx512)
	var expSum float32
	for i := range size {
		expSum += output[i]
	}
	invSum := float32(1.0) / expSum
	for i := range size {
		output[i] = output[i] * invSum
	}
}

func BaseSoftmax_avx512_Float64(input []float64, output []float64) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	maxVal := input[0]
	for i := 1; i < size; i++ {
		if input[i] > maxVal {
			maxVal = input[i]
		}
	}
	shifted := make([]float64, size)
	for i := range size {
		shifted[i] = input[i] - maxVal
	}
	algo.BaseApply_avx512_Float64(shifted, output, math.BaseExpVec_avx512_Float64)
	var expSum float64
	for i := range size {
		expSum += output[i]
	}
	invSum := float64(1.0) / expSum
	for i := range size {
		output[i] = output[i] * invSum
	}
}

func BaseSoftmaxScalar_avx512_Float16(input []hwy.Float16, output []hwy.Float16) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	maxVal := input[0]
	for i := 1; i < size; i++ {
		if input[i].Float32() > maxVal.Float32() {
			maxVal = input[i]
		}
	}
	var expSum float32
	for i := range size {
		output[i] = hwy.Float32ToFloat16(float32(stdmath.Exp(float64(input[i].Float32() - maxVal.Float32()))))
		expSum += output[i].Float32()
	}
	invSum := hwy.Float32ToFloat16(float32(1.0) / expSum)
	for i := range size {
		output[i] = hwy.Float32ToFloat16(output[i].Float32() * invSum.Float32())
	}
}

func BaseSoftmaxScalar_avx512_BFloat16(input []hwy.BFloat16, output []hwy.BFloat16) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	maxVal := input[0]
	for i := 1; i < size; i++ {
		if input[i].Float32() > maxVal.Float32() {
			maxVal = input[i]
		}
	}
	var expSum float32
	for i := range size {
		output[i] = hwy.Float32ToBFloat16(float32(stdmath.Exp(float64(input[i].Float32() - maxVal.Float32()))))
		expSum += output[i].Float32()
	}
	invSum := hwy.Float32ToBFloat16(float32(1.0) / expSum)
	for i := range size {
		output[i] = hwy.Float32ToBFloat16(output[i].Float32() * invSum.Float32())
	}
}

func BaseSoftmaxScalar_avx512(input []float32, output []float32) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	maxVal := input[0]
	for i := 1; i < size; i++ {
		if input[i] > maxVal {
			maxVal = input[i]
		}
	}
	var expSum float32
	for i := range size {
		output[i] = float32(stdmath.Exp(float64(input[i] - maxVal)))
		expSum += output[i]
	}
	invSum := float32(1.0) / expSum
	for i := range size {
		output[i] = output[i] * invSum
	}
}

func BaseSoftmaxScalar_avx512_Float64(input []float64, output []float64) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	maxVal := input[0]
	for i := 1; i < size; i++ {
		if input[i] > maxVal {
			maxVal = input[i]
		}
	}
	var expSum float64
	for i := range size {
		output[i] = float64(stdmath.Exp(float64(input[i] - maxVal)))
		expSum += output[i]
	}
	invSum := float64(1.0) / expSum
	for i := range size {
		output[i] = output[i] * invSum
	}
}
