// Code generated by hwygen. DO NOT EDIT.

package softmax

import (
	"github.com/ajroetker/go-highway/hwy"
	"github.com/ajroetker/go-highway/hwy/contrib/math"
	stdmath "math"
)

func BaseSoftmax_fallback(input []float32, output []float32) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	maxVal := input[0]
	for i := 1; i < size; i++ {
		if input[i] > maxVal {
			maxVal = input[i]
		}
	}
	vMax := hwy.Set(maxVal)
	var expSum float32
	for ii := 0; ii < size; ii += vMax.NumLanes() {
		remaining := size - ii
		if remaining >= vMax.NumLanes() {
			x := hwy.Load(input[ii:])
			xShifted := hwy.Sub(x, vMax)
			expX := math.Exp(xShifted)
			hwy.Store(expX, output[ii:])
			expSum += hwy.ReduceSum(expX)
		} else {
			for i := ii; i < size; i++ {
				exp := float32(stdmath.Exp(float64(input[i] - maxVal)))
				output[i] = exp
				expSum += exp
			}
		}
	}
	vSum := hwy.Set(expSum)
	for ii := 0; ii < size; ii += vSum.NumLanes() {
		remaining := size - ii
		if remaining >= vSum.NumLanes() {
			expX := hwy.Load(output[ii:])
			normalized := hwy.Div(expX, vSum)
			hwy.Store(normalized, output[ii:])
		} else {
			for i := ii; i < size; i++ {
				output[i] = output[i] / expSum
			}
		}
	}
}

func BaseSoftmax_fallback_Float64(input []float64, output []float64) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	maxVal := input[0]
	for i := 1; i < size; i++ {
		if input[i] > maxVal {
			maxVal = input[i]
		}
	}
	vMax := hwy.Set(maxVal)
	var expSum float64
	for ii := 0; ii < size; ii += vMax.NumLanes() {
		remaining := size - ii
		if remaining >= vMax.NumLanes() {
			x := hwy.Load(input[ii:])
			xShifted := hwy.Sub(x, vMax)
			expX := math.Exp(xShifted)
			hwy.Store(expX, output[ii:])
			expSum += hwy.ReduceSum(expX)
		} else {
			for i := ii; i < size; i++ {
				exp := float64(stdmath.Exp(float64(input[i] - maxVal)))
				output[i] = exp
				expSum += exp
			}
		}
	}
	vSum := hwy.Set(expSum)
	for ii := 0; ii < size; ii += vSum.NumLanes() {
		remaining := size - ii
		if remaining >= vSum.NumLanes() {
			expX := hwy.Load(output[ii:])
			normalized := hwy.Div(expX, vSum)
			hwy.Store(normalized, output[ii:])
		} else {
			for i := ii; i < size; i++ {
				output[i] = output[i] / expSum
			}
		}
	}
}
