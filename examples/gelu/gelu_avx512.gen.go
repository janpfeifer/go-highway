// Code generated by github.com/ajroetker/go-highway/cmd/hwygen. DO NOT EDIT.

//go:build amd64 && goexperiment.simd

package gelu

import (
	stdmath "math"
	"simd/archsimd"
	"unsafe"

	"github.com/ajroetker/go-highway/hwy"
	"github.com/ajroetker/go-highway/hwy/asm"
	"github.com/ajroetker/go-highway/hwy/contrib/math"
)

func BaseGELU_avx512_Float16(input []hwy.Float16, output []hwy.Float16) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	vHalf := asm.BroadcastFloat16x16AVX512(uint16(hwy.Float32ToFloat16(float32(0.5))))
	vOne := asm.BroadcastFloat16x16AVX512(uint16(hwy.Float32ToFloat16(float32(1.0))))
	vInvSqrt2 := asm.BroadcastFloat16x16AVX512(uint16(hwy.Float32ToFloat16(float32(0.7071067811865476))))
	ii := 0
	for ; ii+32 <= size; ii += 32 {
		remaining := size - ii
		if remaining >= 16 {
			x := asm.LoadFloat16x16AVX512Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(input[ii:]))), len(input[ii:])))
			xScaled := x.Mul(vInvSqrt2)
			erfX := math.BaseErfVec_avx512_Float16(xScaled)
			onePlusErf := vOne.Add(erfX)
			halfOnePlusErf := vHalf.Mul(onePlusErf)
			result := x.Mul(halfOnePlusErf)
			result.StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(output[ii:]))), len(output[ii:])))
		} else {
			for i := ii; i < size; i++ {
				x := float64(input[i].Float32())
				output[i] = hwy.Float32ToFloat16(float32(x * 0.5 * (1.0 + stdmath.Erf(x*0.7071067811865476))))
			}
		}
		remaining1 := size - ii
		if remaining1 >= 16 {
			x1 := asm.LoadFloat16x16AVX512Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(input[ii+16:]))), len(input[ii+16:])))
			xScaled1 := x1.Mul(vInvSqrt2)
			erfX1 := math.BaseErfVec_avx512_Float16(xScaled1)
			onePlusErf1 := vOne.Add(erfX1)
			halfOnePlusErf1 := vHalf.Mul(onePlusErf1)
			result1 := x1.Mul(halfOnePlusErf1)
			result1.StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(output[ii+16:]))), len(output[ii+16:])))
		} else {
			for i1 := ii; i1 < size; i1++ {
				x1 := float64(input[i1].Float32())
				output[i1] = hwy.Float32ToFloat16(float32(x1 * 0.5 * (1.0 + stdmath.Erf(x1*0.7071067811865476))))
			}
		}
	}
	for ; ii+16 <= size; ii += 16 {
		remaining := size - ii
		if remaining >= 16 {
			x := asm.LoadFloat16x16AVX512Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(input[ii:]))), len(input[ii:])))
			xScaled := x.Mul(vInvSqrt2)
			erfX := math.BaseErfVec_avx512_Float16(xScaled)
			onePlusErf := vOne.Add(erfX)
			halfOnePlusErf := vHalf.Mul(onePlusErf)
			result := x.Mul(halfOnePlusErf)
			result.StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(output[ii:]))), len(output[ii:])))
		} else {
			for i := ii; i < size; i++ {
				x := float64(input[i].Float32())
				output[i] = hwy.Float32ToFloat16(float32(x * 0.5 * (1.0 + stdmath.Erf(x*0.7071067811865476))))
			}
		}
	}
}

func BaseGELU_avx512_BFloat16(input []hwy.BFloat16, output []hwy.BFloat16) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	vHalf := asm.BroadcastBFloat16x16AVX512(uint16(hwy.Float32ToBFloat16(float32(0.5))))
	vOne := asm.BroadcastBFloat16x16AVX512(uint16(hwy.Float32ToBFloat16(float32(1.0))))
	vInvSqrt2 := asm.BroadcastBFloat16x16AVX512(uint16(hwy.Float32ToBFloat16(float32(0.7071067811865476))))
	ii := 0
	for ; ii+32 <= size; ii += 32 {
		remaining := size - ii
		if remaining >= 16 {
			x := asm.LoadBFloat16x16AVX512Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(input[ii:]))), len(input[ii:])))
			xScaled := x.Mul(vInvSqrt2)
			erfX := math.BaseErfVec_avx512_BFloat16(xScaled)
			onePlusErf := vOne.Add(erfX)
			halfOnePlusErf := vHalf.Mul(onePlusErf)
			result := x.Mul(halfOnePlusErf)
			result.StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(output[ii:]))), len(output[ii:])))
		} else {
			for i := ii; i < size; i++ {
				x := float64(input[i].Float32())
				output[i] = hwy.Float32ToBFloat16(float32(x * 0.5 * (1.0 + stdmath.Erf(x*0.7071067811865476))))
			}
		}
		remaining1 := size - ii
		if remaining1 >= 16 {
			x1 := asm.LoadBFloat16x16AVX512Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(input[ii+16:]))), len(input[ii+16:])))
			xScaled1 := x1.Mul(vInvSqrt2)
			erfX1 := math.BaseErfVec_avx512_BFloat16(xScaled1)
			onePlusErf1 := vOne.Add(erfX1)
			halfOnePlusErf1 := vHalf.Mul(onePlusErf1)
			result1 := x1.Mul(halfOnePlusErf1)
			result1.StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(output[ii+16:]))), len(output[ii+16:])))
		} else {
			for i1 := ii; i1 < size; i1++ {
				x1 := float64(input[i1].Float32())
				output[i1] = hwy.Float32ToBFloat16(float32(x1 * 0.5 * (1.0 + stdmath.Erf(x1*0.7071067811865476))))
			}
		}
	}
	for ; ii+16 <= size; ii += 16 {
		remaining := size - ii
		if remaining >= 16 {
			x := asm.LoadBFloat16x16AVX512Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(input[ii:]))), len(input[ii:])))
			xScaled := x.Mul(vInvSqrt2)
			erfX := math.BaseErfVec_avx512_BFloat16(xScaled)
			onePlusErf := vOne.Add(erfX)
			halfOnePlusErf := vHalf.Mul(onePlusErf)
			result := x.Mul(halfOnePlusErf)
			result.StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(output[ii:]))), len(output[ii:])))
		} else {
			for i := ii; i < size; i++ {
				x := float64(input[i].Float32())
				output[i] = hwy.Float32ToBFloat16(float32(x * 0.5 * (1.0 + stdmath.Erf(x*0.7071067811865476))))
			}
		}
	}
}

func BaseGELU_avx512(input []float32, output []float32) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	vHalf := archsimd.BroadcastFloat32x16(0.5)
	vOne := archsimd.BroadcastFloat32x16(1.0)
	vInvSqrt2 := archsimd.BroadcastFloat32x16(0.7071067811865476)
	ii := 0
	for ; ii+32 <= size; ii += 32 {
		remaining := size - ii
		if remaining >= 16 {
			x := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&input[ii])))
			xScaled := x.Mul(vInvSqrt2)
			erfX := math.BaseErfVec_avx512(xScaled)
			onePlusErf := vOne.Add(erfX)
			halfOnePlusErf := vHalf.Mul(onePlusErf)
			result := x.Mul(halfOnePlusErf)
			result.Store((*[16]float32)(unsafe.Pointer(&output[ii])))
		} else {
			for i := ii; i < size; i++ {
				x := float64(input[i])
				output[i] = float32(x * 0.5 * (1.0 + stdmath.Erf(x*0.7071067811865476)))
			}
		}
		remaining1 := size - ii
		if remaining1 >= 16 {
			x1 := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&input[ii+16])))
			xScaled1 := x1.Mul(vInvSqrt2)
			erfX1 := math.BaseErfVec_avx512(xScaled1)
			onePlusErf1 := vOne.Add(erfX1)
			halfOnePlusErf1 := vHalf.Mul(onePlusErf1)
			result1 := x1.Mul(halfOnePlusErf1)
			result1.Store((*[16]float32)(unsafe.Pointer(&output[ii+16])))
		} else {
			for i1 := ii; i1 < size; i1++ {
				x1 := float64(input[i1])
				output[i1] = float32(x1 * 0.5 * (1.0 + stdmath.Erf(x1*0.7071067811865476)))
			}
		}
	}
	for ; ii+16 <= size; ii += 16 {
		remaining := size - ii
		if remaining >= 16 {
			x := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&input[ii])))
			xScaled := x.Mul(vInvSqrt2)
			erfX := math.BaseErfVec_avx512(xScaled)
			onePlusErf := vOne.Add(erfX)
			halfOnePlusErf := vHalf.Mul(onePlusErf)
			result := x.Mul(halfOnePlusErf)
			result.Store((*[16]float32)(unsafe.Pointer(&output[ii])))
		} else {
			for i := ii; i < size; i++ {
				x := float64(input[i])
				output[i] = float32(x * 0.5 * (1.0 + stdmath.Erf(x*0.7071067811865476)))
			}
		}
	}
}

func BaseGELU_avx512_Float64(input []float64, output []float64) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	vHalf := archsimd.BroadcastFloat64x8(0.5)
	vOne := archsimd.BroadcastFloat64x8(1.0)
	vInvSqrt2 := archsimd.BroadcastFloat64x8(0.7071067811865476)
	ii := 0
	for ; ii+16 <= size; ii += 16 {
		remaining := size - ii
		if remaining >= 8 {
			x := archsimd.LoadFloat64x8((*[8]float64)(unsafe.Pointer(&input[ii])))
			xScaled := x.Mul(vInvSqrt2)
			erfX := math.BaseErfVec_avx512_Float64(xScaled)
			onePlusErf := vOne.Add(erfX)
			halfOnePlusErf := vHalf.Mul(onePlusErf)
			result := x.Mul(halfOnePlusErf)
			result.Store((*[8]float64)(unsafe.Pointer(&output[ii])))
		} else {
			for i := ii; i < size; i++ {
				x := float64(input[i])
				output[i] = float64(x * 0.5 * (1.0 + stdmath.Erf(x*0.7071067811865476)))
			}
		}
		remaining1 := size - ii
		if remaining1 >= 8 {
			x1 := archsimd.LoadFloat64x8((*[8]float64)(unsafe.Pointer(&input[ii+8])))
			xScaled1 := x1.Mul(vInvSqrt2)
			erfX1 := math.BaseErfVec_avx512_Float64(xScaled1)
			onePlusErf1 := vOne.Add(erfX1)
			halfOnePlusErf1 := vHalf.Mul(onePlusErf1)
			result1 := x1.Mul(halfOnePlusErf1)
			result1.Store((*[8]float64)(unsafe.Pointer(&output[ii+8])))
		} else {
			for i1 := ii; i1 < size; i1++ {
				x1 := float64(input[i1])
				output[i1] = float64(x1 * 0.5 * (1.0 + stdmath.Erf(x1*0.7071067811865476)))
			}
		}
	}
	for ; ii+8 <= size; ii += 8 {
		remaining := size - ii
		if remaining >= 8 {
			x := archsimd.LoadFloat64x8((*[8]float64)(unsafe.Pointer(&input[ii])))
			xScaled := x.Mul(vInvSqrt2)
			erfX := math.BaseErfVec_avx512_Float64(xScaled)
			onePlusErf := vOne.Add(erfX)
			halfOnePlusErf := vHalf.Mul(onePlusErf)
			result := x.Mul(halfOnePlusErf)
			result.Store((*[8]float64)(unsafe.Pointer(&output[ii])))
		} else {
			for i := ii; i < size; i++ {
				x := float64(input[i])
				output[i] = float64(x * 0.5 * (1.0 + stdmath.Erf(x*0.7071067811865476)))
			}
		}
	}
}

func BaseGELUApprox_avx512_Float16(input []hwy.Float16, output []hwy.Float16) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	vCoeff := asm.BroadcastFloat16x16AVX512(uint16(hwy.Float32ToFloat16(float32(1.702))))
	ii := 0
	for ; ii+32 <= size; ii += 32 {
		remaining := size - ii
		if remaining >= 16 {
			x := asm.LoadFloat16x16AVX512Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(input[ii:]))), len(input[ii:])))
			xScaled := x.Mul(vCoeff)
			sigmoidX := math.BaseSigmoidVec_avx512_Float16(xScaled)
			result := x.Mul(sigmoidX)
			result.StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(output[ii:]))), len(output[ii:])))
		} else {
			for i := ii; i < size; i++ {
				x := float64(input[i].Float32())
				sigmoid := 1.0 / (1.0 + stdmath.Exp(-1.702*x))
				output[i] = hwy.Float32ToFloat16(float32(x * sigmoid))
			}
		}
		remaining1 := size - ii
		if remaining1 >= 16 {
			x1 := asm.LoadFloat16x16AVX512Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(input[ii+16:]))), len(input[ii+16:])))
			xScaled1 := x1.Mul(vCoeff)
			sigmoidX1 := math.BaseSigmoidVec_avx512_Float16(xScaled1)
			result1 := x1.Mul(sigmoidX1)
			result1.StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(output[ii+16:]))), len(output[ii+16:])))
		} else {
			for i1 := ii; i1 < size; i1++ {
				x1 := float64(input[i1].Float32())
				sigmoid1 := 1.0 / (1.0 + stdmath.Exp(-1.702*x1))
				output[i1] = hwy.Float32ToFloat16(float32(x1 * sigmoid1))
			}
		}
	}
	for ; ii+16 <= size; ii += 16 {
		remaining := size - ii
		if remaining >= 16 {
			x := asm.LoadFloat16x16AVX512Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(input[ii:]))), len(input[ii:])))
			xScaled := x.Mul(vCoeff)
			sigmoidX := math.BaseSigmoidVec_avx512_Float16(xScaled)
			result := x.Mul(sigmoidX)
			result.StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(output[ii:]))), len(output[ii:])))
		} else {
			for i := ii; i < size; i++ {
				x := float64(input[i].Float32())
				sigmoid := 1.0 / (1.0 + stdmath.Exp(-1.702*x))
				output[i] = hwy.Float32ToFloat16(float32(x * sigmoid))
			}
		}
	}
}

func BaseGELUApprox_avx512_BFloat16(input []hwy.BFloat16, output []hwy.BFloat16) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	vCoeff := asm.BroadcastBFloat16x16AVX512(uint16(hwy.Float32ToBFloat16(float32(1.702))))
	ii := 0
	for ; ii+32 <= size; ii += 32 {
		remaining := size - ii
		if remaining >= 16 {
			x := asm.LoadBFloat16x16AVX512Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(input[ii:]))), len(input[ii:])))
			xScaled := x.Mul(vCoeff)
			sigmoidX := math.BaseSigmoidVec_avx512_BFloat16(xScaled)
			result := x.Mul(sigmoidX)
			result.StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(output[ii:]))), len(output[ii:])))
		} else {
			for i := ii; i < size; i++ {
				x := float64(input[i].Float32())
				sigmoid := 1.0 / (1.0 + stdmath.Exp(-1.702*x))
				output[i] = hwy.Float32ToBFloat16(float32(x * sigmoid))
			}
		}
		remaining1 := size - ii
		if remaining1 >= 16 {
			x1 := asm.LoadBFloat16x16AVX512Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(input[ii+16:]))), len(input[ii+16:])))
			xScaled1 := x1.Mul(vCoeff)
			sigmoidX1 := math.BaseSigmoidVec_avx512_BFloat16(xScaled1)
			result1 := x1.Mul(sigmoidX1)
			result1.StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(output[ii+16:]))), len(output[ii+16:])))
		} else {
			for i1 := ii; i1 < size; i1++ {
				x1 := float64(input[i1].Float32())
				sigmoid1 := 1.0 / (1.0 + stdmath.Exp(-1.702*x1))
				output[i1] = hwy.Float32ToBFloat16(float32(x1 * sigmoid1))
			}
		}
	}
	for ; ii+16 <= size; ii += 16 {
		remaining := size - ii
		if remaining >= 16 {
			x := asm.LoadBFloat16x16AVX512Slice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(input[ii:]))), len(input[ii:])))
			xScaled := x.Mul(vCoeff)
			sigmoidX := math.BaseSigmoidVec_avx512_BFloat16(xScaled)
			result := x.Mul(sigmoidX)
			result.StoreSlice(unsafe.Slice((*uint16)(unsafe.Pointer(unsafe.SliceData(output[ii:]))), len(output[ii:])))
		} else {
			for i := ii; i < size; i++ {
				x := float64(input[i].Float32())
				sigmoid := 1.0 / (1.0 + stdmath.Exp(-1.702*x))
				output[i] = hwy.Float32ToBFloat16(float32(x * sigmoid))
			}
		}
	}
}

func BaseGELUApprox_avx512(input []float32, output []float32) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	vCoeff := archsimd.BroadcastFloat32x16(1.702)
	ii := 0
	for ; ii+32 <= size; ii += 32 {
		remaining := size - ii
		if remaining >= 16 {
			x := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&input[ii])))
			xScaled := x.Mul(vCoeff)
			sigmoidX := math.BaseSigmoidVec_avx512(xScaled)
			result := x.Mul(sigmoidX)
			result.Store((*[16]float32)(unsafe.Pointer(&output[ii])))
		} else {
			for i := ii; i < size; i++ {
				x := float64(input[i])
				sigmoid := 1.0 / (1.0 + stdmath.Exp(-1.702*x))
				output[i] = float32(x * sigmoid)
			}
		}
		remaining1 := size - ii
		if remaining1 >= 16 {
			x1 := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&input[ii+16])))
			xScaled1 := x1.Mul(vCoeff)
			sigmoidX1 := math.BaseSigmoidVec_avx512(xScaled1)
			result1 := x1.Mul(sigmoidX1)
			result1.Store((*[16]float32)(unsafe.Pointer(&output[ii+16])))
		} else {
			for i1 := ii; i1 < size; i1++ {
				x1 := float64(input[i1])
				sigmoid1 := 1.0 / (1.0 + stdmath.Exp(-1.702*x1))
				output[i1] = float32(x1 * sigmoid1)
			}
		}
	}
	for ; ii+16 <= size; ii += 16 {
		remaining := size - ii
		if remaining >= 16 {
			x := archsimd.LoadFloat32x16((*[16]float32)(unsafe.Pointer(&input[ii])))
			xScaled := x.Mul(vCoeff)
			sigmoidX := math.BaseSigmoidVec_avx512(xScaled)
			result := x.Mul(sigmoidX)
			result.Store((*[16]float32)(unsafe.Pointer(&output[ii])))
		} else {
			for i := ii; i < size; i++ {
				x := float64(input[i])
				sigmoid := 1.0 / (1.0 + stdmath.Exp(-1.702*x))
				output[i] = float32(x * sigmoid)
			}
		}
	}
}

func BaseGELUApprox_avx512_Float64(input []float64, output []float64) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	vCoeff := archsimd.BroadcastFloat64x8(1.702)
	ii := 0
	for ; ii+16 <= size; ii += 16 {
		remaining := size - ii
		if remaining >= 8 {
			x := archsimd.LoadFloat64x8((*[8]float64)(unsafe.Pointer(&input[ii])))
			xScaled := x.Mul(vCoeff)
			sigmoidX := math.BaseSigmoidVec_avx512_Float64(xScaled)
			result := x.Mul(sigmoidX)
			result.Store((*[8]float64)(unsafe.Pointer(&output[ii])))
		} else {
			for i := ii; i < size; i++ {
				x := float64(input[i])
				sigmoid := 1.0 / (1.0 + stdmath.Exp(-1.702*x))
				output[i] = float64(x * sigmoid)
			}
		}
		remaining1 := size - ii
		if remaining1 >= 8 {
			x1 := archsimd.LoadFloat64x8((*[8]float64)(unsafe.Pointer(&input[ii+8])))
			xScaled1 := x1.Mul(vCoeff)
			sigmoidX1 := math.BaseSigmoidVec_avx512_Float64(xScaled1)
			result1 := x1.Mul(sigmoidX1)
			result1.Store((*[8]float64)(unsafe.Pointer(&output[ii+8])))
		} else {
			for i1 := ii; i1 < size; i1++ {
				x1 := float64(input[i1])
				sigmoid1 := 1.0 / (1.0 + stdmath.Exp(-1.702*x1))
				output[i1] = float64(x1 * sigmoid1)
			}
		}
	}
	for ; ii+8 <= size; ii += 8 {
		remaining := size - ii
		if remaining >= 8 {
			x := archsimd.LoadFloat64x8((*[8]float64)(unsafe.Pointer(&input[ii])))
			xScaled := x.Mul(vCoeff)
			sigmoidX := math.BaseSigmoidVec_avx512_Float64(xScaled)
			result := x.Mul(sigmoidX)
			result.Store((*[8]float64)(unsafe.Pointer(&output[ii])))
		} else {
			for i := ii; i < size; i++ {
				x := float64(input[i])
				sigmoid := 1.0 / (1.0 + stdmath.Exp(-1.702*x))
				output[i] = float64(x * sigmoid)
			}
		}
	}
}
