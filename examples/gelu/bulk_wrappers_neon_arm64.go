//go:build !noasm && arm64
// Code generated by hwygen -bulk. DO NOT EDIT.

package gelu

import "unsafe"

// Public wrapper functions
// GELUBulkF32 computes BaseGELU for entire arrays using NEON SIMD.
func GELUBulkF32(input, output []float32) {
	if len(input) == 0 {
		return
	}
	n := int64(len(input))
	gelu_bulk_f32_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&output[0]), unsafe.Pointer(&n))
}

// GELUBulkF64 computes BaseGELU for entire arrays using NEON SIMD.
func GELUBulkF64(input, output []float64) {
	if len(input) == 0 {
		return
	}
	n := int64(len(input))
	gelu_bulk_f64_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&output[0]), unsafe.Pointer(&n))
}

// GELUApproxBulkF32 computes BaseGELUApprox for entire arrays using NEON SIMD.
func GELUApproxBulkF32(input, output []float32) {
	if len(input) == 0 {
		return
	}
	n := int64(len(input))
	geluapprox_bulk_f32_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&output[0]), unsafe.Pointer(&n))
}

// GELUApproxBulkF64 computes BaseGELUApprox for entire arrays using NEON SIMD.
func GELUApproxBulkF64(input, output []float64) {
	if len(input) == 0 {
		return
	}
	n := int64(len(input))
	geluapprox_bulk_f64_neon(unsafe.Pointer(&input[0]), unsafe.Pointer(&output[0]), unsafe.Pointer(&n))
}

