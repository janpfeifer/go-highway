// Code generated by hwygen. DO NOT EDIT.
//go:build amd64 && goexperiment.simd

package gelu

import (
	"github.com/ajroetker/go-highway/hwy/contrib/math"
	stdmath "math"
	"simd/archsimd"
)

// Hoisted constants - pre-broadcasted at package init time
var (
	BaseGELUApprox_AVX2_vCoeff_f64 = archsimd.BroadcastFloat64x4(float64(1.702))
	BaseGELU_AVX2_vInvSqrt2_f32    = archsimd.BroadcastFloat32x8(float32(0.7071067811865476))
	BaseGELU_AVX2_vHalf_f32        = archsimd.BroadcastFloat32x8(float32(0.5))
	BaseGELU_AVX2_vOne_f32         = archsimd.BroadcastFloat32x8(float32(1.0))
	BaseGELU_AVX2_vHalf_f64        = archsimd.BroadcastFloat64x4(float64(0.5))
	BaseGELU_AVX2_vOne_f64         = archsimd.BroadcastFloat64x4(float64(1.0))
	BaseGELU_AVX2_vInvSqrt2_f64    = archsimd.BroadcastFloat64x4(float64(0.7071067811865476))
	BaseGELUApprox_AVX2_vCoeff_f32 = archsimd.BroadcastFloat32x8(float32(1.702))
)

func BaseGELU_avx2(input []float32, output []float32) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	vHalf := BaseGELU_AVX2_vHalf_f32
	vOne := BaseGELU_AVX2_vOne_f32
	vInvSqrt2 := BaseGELU_AVX2_vInvSqrt2_f32
	ii := 0
	for ; ii+8 <= size; ii += 8 {
		remaining := size - ii
		if remaining >= 8 {
			x := archsimd.LoadFloat32x8Slice(input[ii:])
			xScaled := x.Mul(vInvSqrt2)
			erfX := math.BaseErfVec_avx2(xScaled)
			onePlusErf := vOne.Add(erfX)
			halfOnePlusErf := vHalf.Mul(onePlusErf)
			result := x.Mul(halfOnePlusErf)
			result.StoreSlice(output[ii:])
		} else {
			for i := ii; i < size; i++ {
				x := float64(input[i])
				output[i] = float32(x * 0.5 * (1.0 + stdmath.Erf(x*0.7071067811865476)))
			}
		}
	}
	if ii < size {
		BaseGELU_fallback(input[ii:size], output[ii:size])
	}
}

func BaseGELU_avx2_Float64(input []float64, output []float64) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	vHalf := BaseGELU_AVX2_vHalf_f64
	vOne := BaseGELU_AVX2_vOne_f64
	vInvSqrt2 := BaseGELU_AVX2_vInvSqrt2_f64
	ii := 0
	for ; ii+4 <= size; ii += 4 {
		remaining := size - ii
		if remaining >= 4 {
			x := archsimd.LoadFloat64x4Slice(input[ii:])
			xScaled := x.Mul(vInvSqrt2)
			erfX := math.BaseErfVec_avx2_Float64(xScaled)
			onePlusErf := vOne.Add(erfX)
			halfOnePlusErf := vHalf.Mul(onePlusErf)
			result := x.Mul(halfOnePlusErf)
			result.StoreSlice(output[ii:])
		} else {
			for i := ii; i < size; i++ {
				x := float64(input[i])
				output[i] = float64(x * 0.5 * (1.0 + stdmath.Erf(x*0.7071067811865476)))
			}
		}
	}
	if ii < size {
		BaseGELU_fallback_Float64(input[ii:size], output[ii:size])
	}
}

func BaseGELUApprox_avx2(input []float32, output []float32) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	vCoeff := BaseGELUApprox_AVX2_vCoeff_f32
	ii := 0
	for ; ii+8 <= size; ii += 8 {
		remaining := size - ii
		if remaining >= 8 {
			x := archsimd.LoadFloat32x8Slice(input[ii:])
			xScaled := x.Mul(vCoeff)
			sigmoidX := math.BaseSigmoidVec_avx2(xScaled)
			result := x.Mul(sigmoidX)
			result.StoreSlice(output[ii:])
		} else {
			for i := ii; i < size; i++ {
				x := float64(input[i])
				sigmoid := 1.0 / (1.0 + stdmath.Exp(-1.702*x))
				output[i] = float32(x * sigmoid)
			}
		}
	}
	if ii < size {
		BaseGELUApprox_fallback(input[ii:size], output[ii:size])
	}
}

func BaseGELUApprox_avx2_Float64(input []float64, output []float64) {
	size := min(len(input), len(output))
	if size == 0 {
		return
	}
	vCoeff := BaseGELUApprox_AVX2_vCoeff_f64
	ii := 0
	for ; ii+4 <= size; ii += 4 {
		remaining := size - ii
		if remaining >= 4 {
			x := archsimd.LoadFloat64x4Slice(input[ii:])
			xScaled := x.Mul(vCoeff)
			sigmoidX := math.BaseSigmoidVec_avx2_Float64(xScaled)
			result := x.Mul(sigmoidX)
			result.StoreSlice(output[ii:])
		} else {
			for i := ii; i < size; i++ {
				x := float64(input[i])
				sigmoid := 1.0 / (1.0 + stdmath.Exp(-1.702*x))
				output[i] = float64(x * sigmoid)
			}
		}
	}
	if ii < size {
		BaseGELUApprox_fallback_Float64(input[ii:size], output[ii:size])
	}
}
